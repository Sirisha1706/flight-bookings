/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/page"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fsirishasadhu%2FDesktop%2Fprojects%2FFull-stack-projects%2Fflight-bookings%2FFrontend%2Fcomponents%2Fheader%2Fheader-10%2Findex.jsx&modules=%2FUsers%2Fsirishasadhu%2FDesktop%2Fprojects%2FFull-stack-projects%2Fflight-bookings%2FFrontend%2Fcomponents%2Fhero%2FFilterSelect.jsx&modules=%2FUsers%2Fsirishasadhu%2FDesktop%2Fprojects%2FFull-stack-projects%2Fflight-bookings%2FFrontend%2Fcomponents%2Fhero%2FMainFilterSearchBox.jsx&modules=%2FUsers%2Fsirishasadhu%2FDesktop%2Fprojects%2FFull-stack-projects%2Fflight-bookings%2FFrontend%2Fnode_modules%2Fnext%2Fdist%2Fshared%2Flib%2Flazy-dynamic%2Fdynamic-bailout-to-csr.js&server=false!":
/*!*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fsirishasadhu%2FDesktop%2Fprojects%2FFull-stack-projects%2Fflight-bookings%2FFrontend%2Fcomponents%2Fheader%2Fheader-10%2Findex.jsx&modules=%2FUsers%2Fsirishasadhu%2FDesktop%2Fprojects%2FFull-stack-projects%2Fflight-bookings%2FFrontend%2Fcomponents%2Fhero%2FFilterSelect.jsx&modules=%2FUsers%2Fsirishasadhu%2FDesktop%2Fprojects%2FFull-stack-projects%2Fflight-bookings%2FFrontend%2Fcomponents%2Fhero%2FMainFilterSearchBox.jsx&modules=%2FUsers%2Fsirishasadhu%2FDesktop%2Fprojects%2FFull-stack-projects%2Fflight-bookings%2FFrontend%2Fnode_modules%2Fnext%2Fdist%2Fshared%2Flib%2Flazy-dynamic%2Fdynamic-bailout-to-csr.js&server=false! ***!
  \*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./components/header/header-10/index.jsx */ \"(app-pages-browser)/./components/header/header-10/index.jsx\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./components/hero/FilterSelect.jsx */ \"(app-pages-browser)/./components/hero/FilterSelect.jsx\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./components/hero/MainFilterSearchBox.jsx */ \"(app-pages-browser)/./components/hero/MainFilterSearchBox.jsx\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./node_modules/next/dist/shared/lib/lazy-dynamic/dynamic-bailout-to-csr.js */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/lazy-dynamic/dynamic-bailout-to-csr.js\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lMkZVc2VycyUyRnNpcmlzaGFzYWRodSUyRkRlc2t0b3AlMkZwcm9qZWN0cyUyRkZ1bGwtc3RhY2stcHJvamVjdHMlMkZmbGlnaHQtYm9va2luZ3MlMkZGcm9udGVuZCUyRmNvbXBvbmVudHMlMkZoZWFkZXIlMkZoZWFkZXItMTAlMkZpbmRleC5qc3gmbW9kdWxlcz0lMkZVc2VycyUyRnNpcmlzaGFzYWRodSUyRkRlc2t0b3AlMkZwcm9qZWN0cyUyRkZ1bGwtc3RhY2stcHJvamVjdHMlMkZmbGlnaHQtYm9va2luZ3MlMkZGcm9udGVuZCUyRmNvbXBvbmVudHMlMkZoZXJvJTJGRmlsdGVyU2VsZWN0LmpzeCZtb2R1bGVzPSUyRlVzZXJzJTJGc2lyaXNoYXNhZGh1JTJGRGVza3RvcCUyRnByb2plY3RzJTJGRnVsbC1zdGFjay1wcm9qZWN0cyUyRmZsaWdodC1ib29raW5ncyUyRkZyb250ZW5kJTJGY29tcG9uZW50cyUyRmhlcm8lMkZNYWluRmlsdGVyU2VhcmNoQm94LmpzeCZtb2R1bGVzPSUyRlVzZXJzJTJGc2lyaXNoYXNhZGh1JTJGRGVza3RvcCUyRnByb2plY3RzJTJGRnVsbC1zdGFjay1wcm9qZWN0cyUyRmZsaWdodC1ib29raW5ncyUyRkZyb250ZW5kJTJGbm9kZV9tb2R1bGVzJTJGbmV4dCUyRmRpc3QlMkZzaGFyZWQlMkZsaWIlMkZsYXp5LWR5bmFtaWMlMkZkeW5hbWljLWJhaWxvdXQtdG8tY3NyLmpzJnNlcnZlcj1mYWxzZSEiLCJtYXBwaW5ncyI6IkFBQUEsd01BQTRKO0FBQzVKLDhMQUF1SjtBQUN2Siw0TUFBOEo7QUFDOUoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLz9kMzFhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1VzZXJzL3NpcmlzaGFzYWRodS9EZXNrdG9wL3Byb2plY3RzL0Z1bGwtc3RhY2stcHJvamVjdHMvZmxpZ2h0LWJvb2tpbmdzL0Zyb250ZW5kL2NvbXBvbmVudHMvaGVhZGVyL2hlYWRlci0xMC9pbmRleC5qc3hcIik7XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy9zaXJpc2hhc2FkaHUvRGVza3RvcC9wcm9qZWN0cy9GdWxsLXN0YWNrLXByb2plY3RzL2ZsaWdodC1ib29raW5ncy9Gcm9udGVuZC9jb21wb25lbnRzL2hlcm8vRmlsdGVyU2VsZWN0LmpzeFwiKTtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1VzZXJzL3NpcmlzaGFzYWRodS9EZXNrdG9wL3Byb2plY3RzL0Z1bGwtc3RhY2stcHJvamVjdHMvZmxpZ2h0LWJvb2tpbmdzL0Zyb250ZW5kL2NvbXBvbmVudHMvaGVyby9NYWluRmlsdGVyU2VhcmNoQm94LmpzeFwiKTtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1VzZXJzL3NpcmlzaGFzYWRodS9EZXNrdG9wL3Byb2plY3RzL0Z1bGwtc3RhY2stcHJvamVjdHMvZmxpZ2h0LWJvb2tpbmdzL0Zyb250ZW5kL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9sYXp5LWR5bmFtaWMvZHluYW1pYy1iYWlsb3V0LXRvLWNzci5qc1wiKSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fsirishasadhu%2FDesktop%2Fprojects%2FFull-stack-projects%2Fflight-bookings%2FFrontend%2Fcomponents%2Fheader%2Fheader-10%2Findex.jsx&modules=%2FUsers%2Fsirishasadhu%2FDesktop%2Fprojects%2FFull-stack-projects%2Fflight-bookings%2FFrontend%2Fcomponents%2Fhero%2FFilterSelect.jsx&modules=%2FUsers%2Fsirishasadhu%2FDesktop%2Fprojects%2FFull-stack-projects%2Fflight-bookings%2FFrontend%2Fcomponents%2Fhero%2FMainFilterSearchBox.jsx&modules=%2FUsers%2Fsirishasadhu%2FDesktop%2Fprojects%2FFull-stack-projects%2Fflight-bookings%2FFrontend%2Fnode_modules%2Fnext%2Fdist%2Fshared%2Flib%2Flazy-dynamic%2Fdynamic-bailout-to-csr.js&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EnhancerArray: function() { return /* binding */ EnhancerArray; },\n/* harmony export */   MiddlewareArray: function() { return /* binding */ MiddlewareArray; },\n/* harmony export */   SHOULD_AUTOBATCH: function() { return /* binding */ SHOULD_AUTOBATCH; },\n/* harmony export */   TaskAbortError: function() { return /* binding */ TaskAbortError; },\n/* harmony export */   __DO_NOT_USE__ActionTypes: function() { return /* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.__DO_NOT_USE__ActionTypes; },\n/* harmony export */   addListener: function() { return /* binding */ addListener; },\n/* harmony export */   applyMiddleware: function() { return /* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.applyMiddleware; },\n/* harmony export */   autoBatchEnhancer: function() { return /* binding */ autoBatchEnhancer; },\n/* harmony export */   bindActionCreators: function() { return /* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.bindActionCreators; },\n/* harmony export */   clearAllListeners: function() { return /* binding */ clearAllListeners; },\n/* harmony export */   combineReducers: function() { return /* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers; },\n/* harmony export */   compose: function() { return /* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.compose; },\n/* harmony export */   configureStore: function() { return /* binding */ configureStore; },\n/* harmony export */   createAction: function() { return /* binding */ createAction; },\n/* harmony export */   createActionCreatorInvariantMiddleware: function() { return /* binding */ createActionCreatorInvariantMiddleware; },\n/* harmony export */   createAsyncThunk: function() { return /* binding */ createAsyncThunk; },\n/* harmony export */   createDraftSafeSelector: function() { return /* binding */ createDraftSafeSelector; },\n/* harmony export */   createEntityAdapter: function() { return /* binding */ createEntityAdapter; },\n/* harmony export */   createImmutableStateInvariantMiddleware: function() { return /* binding */ createImmutableStateInvariantMiddleware; },\n/* harmony export */   createListenerMiddleware: function() { return /* binding */ createListenerMiddleware; },\n/* harmony export */   createNextState: function() { return /* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; },\n/* harmony export */   createReducer: function() { return /* binding */ createReducer; },\n/* harmony export */   createSelector: function() { return /* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.createSelector; },\n/* harmony export */   createSerializableStateInvariantMiddleware: function() { return /* binding */ createSerializableStateInvariantMiddleware; },\n/* harmony export */   createSlice: function() { return /* binding */ createSlice; },\n/* harmony export */   createStore: function() { return /* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.createStore; },\n/* harmony export */   current: function() { return /* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.current; },\n/* harmony export */   findNonSerializableValue: function() { return /* binding */ findNonSerializableValue; },\n/* harmony export */   freeze: function() { return /* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.freeze; },\n/* harmony export */   getDefaultMiddleware: function() { return /* binding */ getDefaultMiddleware; },\n/* harmony export */   getType: function() { return /* binding */ getType; },\n/* harmony export */   isAction: function() { return /* binding */ isAction; },\n/* harmony export */   isActionCreator: function() { return /* binding */ isActionCreator; },\n/* harmony export */   isAllOf: function() { return /* binding */ isAllOf; },\n/* harmony export */   isAnyOf: function() { return /* binding */ isAnyOf; },\n/* harmony export */   isAsyncThunkAction: function() { return /* binding */ isAsyncThunkAction; },\n/* harmony export */   isDraft: function() { return /* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.isDraft; },\n/* harmony export */   isFluxStandardAction: function() { return /* binding */ isFSA; },\n/* harmony export */   isFulfilled: function() { return /* binding */ isFulfilled; },\n/* harmony export */   isImmutableDefault: function() { return /* binding */ isImmutableDefault; },\n/* harmony export */   isPending: function() { return /* binding */ isPending; },\n/* harmony export */   isPlain: function() { return /* binding */ isPlain; },\n/* harmony export */   isPlainObject: function() { return /* binding */ isPlainObject; },\n/* harmony export */   isRejected: function() { return /* binding */ isRejected; },\n/* harmony export */   isRejectedWithValue: function() { return /* binding */ isRejectedWithValue; },\n/* harmony export */   legacy_createStore: function() { return /* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.legacy_createStore; },\n/* harmony export */   miniSerializeError: function() { return /* binding */ miniSerializeError; },\n/* harmony export */   nanoid: function() { return /* binding */ nanoid; },\n/* harmony export */   original: function() { return /* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.original; },\n/* harmony export */   prepareAutoBatched: function() { return /* binding */ prepareAutoBatched; },\n/* harmony export */   removeListener: function() { return /* binding */ removeListener; },\n/* harmony export */   unwrapResult: function() { return /* binding */ unwrapResult; }\n/* harmony export */ });\n/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! immer */ \"(app-pages-browser)/./node_modules/immer/dist/immer.esm.mjs\");\n/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! redux */ \"(app-pages-browser)/./node_modules/redux/es/redux.js\");\n/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! reselect */ \"(app-pages-browser)/./node_modules/reselect/es/index.js\");\n/* harmony import */ var redux_thunk__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! redux-thunk */ \"(app-pages-browser)/./node_modules/redux-thunk/es/index.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\nvar __extends = undefined && undefined.__extends || function() {\n    var extendStatics = function(d, b) {\n        extendStatics = Object.setPrototypeOf || ({\n            __proto__: []\n        }) instanceof Array && function(d, b) {\n            d.__proto__ = b;\n        } || function(d, b) {\n            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n        };\n        return extendStatics(d, b);\n    };\n    return function(d, b) {\n        if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() {\n            this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n}();\nvar __generator = undefined && undefined.__generator || function(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, f, y, t, g;\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(_)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n};\nvar __spreadArray = undefined && undefined.__spreadArray || function(to, from) {\n    for(var i = 0, il = from.length, j = to.length; i < il; i++, j++)to[j] = from[i];\n    return to;\n};\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = function(obj, key, value) {\n    return key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: value\n    }) : obj[key] = value;\n};\nvar __spreadValues = function(a, b) {\n    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    if (__getOwnPropSymbols) for(var _i = 0, _c = __getOwnPropSymbols(b); _i < _c.length; _i++){\n        var prop = _c[_i];\n        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    }\n    return a;\n};\nvar __spreadProps = function(a, b) {\n    return __defProps(a, __getOwnPropDescs(b));\n};\nvar __async = function(__this, __arguments, generator) {\n    return new Promise(function(resolve, reject) {\n        var fulfilled = function(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        };\n        var rejected = function(value) {\n            try {\n                step(generator.throw(value));\n            } catch (e) {\n                reject(e);\n            }\n        };\n        var step = function(x) {\n            return x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n        };\n        step((generator = generator.apply(__this, __arguments)).next());\n    });\n};\n// src/index.ts\n\n\n\n\n// src/createDraftSafeSelector.ts\n\n\nvar createDraftSafeSelector = function() {\n    var args = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        args[_i] = arguments[_i];\n    }\n    var selector = reselect__WEBPACK_IMPORTED_MODULE_1__.createSelector.apply(void 0, args);\n    var wrappedSelector = function(value) {\n        var rest = [];\n        for(var _i = 1; _i < arguments.length; _i++){\n            rest[_i - 1] = arguments[_i];\n        }\n        return selector.apply(void 0, __spreadArray([\n            (0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(value) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__.current)(value) : value\n        ], rest));\n    };\n    return wrappedSelector;\n};\n// src/configureStore.ts\n\n// src/devtoolsExtension.ts\n\nvar composeWithDevTools =  true && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {\n    if (arguments.length === 0) return void 0;\n    if (typeof arguments[0] === \"object\") return redux__WEBPACK_IMPORTED_MODULE_0__.compose;\n    return redux__WEBPACK_IMPORTED_MODULE_0__.compose.apply(null, arguments);\n};\nvar devToolsEnhancer =  true && window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__ : function() {\n    return function(noop2) {\n        return noop2;\n    };\n};\n// src/isPlainObject.ts\nfunction isPlainObject(value) {\n    if (typeof value !== \"object\" || value === null) return false;\n    var proto = Object.getPrototypeOf(value);\n    if (proto === null) return true;\n    var baseProto = proto;\n    while(Object.getPrototypeOf(baseProto) !== null){\n        baseProto = Object.getPrototypeOf(baseProto);\n    }\n    return proto === baseProto;\n}\n// src/getDefaultMiddleware.ts\n\n// src/tsHelpers.ts\nvar hasMatchFunction = function(v) {\n    return v && typeof v.match === \"function\";\n};\n// src/createAction.ts\nfunction createAction(type, prepareAction) {\n    function actionCreator() {\n        var args = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            args[_i] = arguments[_i];\n        }\n        if (prepareAction) {\n            var prepared = prepareAction.apply(void 0, args);\n            if (!prepared) {\n                throw new Error(\"prepareAction did not return an object\");\n            }\n            return __spreadValues(__spreadValues({\n                type: type,\n                payload: prepared.payload\n            }, \"meta\" in prepared && {\n                meta: prepared.meta\n            }), \"error\" in prepared && {\n                error: prepared.error\n            });\n        }\n        return {\n            type: type,\n            payload: args[0]\n        };\n    }\n    actionCreator.toString = function() {\n        return \"\" + type;\n    };\n    actionCreator.type = type;\n    actionCreator.match = function(action) {\n        return action.type === type;\n    };\n    return actionCreator;\n}\nfunction isAction(action) {\n    return isPlainObject(action) && \"type\" in action;\n}\nfunction isActionCreator(action) {\n    return typeof action === \"function\" && \"type\" in action && hasMatchFunction(action);\n}\nfunction isFSA(action) {\n    return isAction(action) && typeof action.type === \"string\" && Object.keys(action).every(isValidKey);\n}\nfunction isValidKey(key) {\n    return [\n        \"type\",\n        \"payload\",\n        \"error\",\n        \"meta\"\n    ].indexOf(key) > -1;\n}\nfunction getType(actionCreator) {\n    return \"\" + actionCreator;\n}\n// src/actionCreatorInvariantMiddleware.ts\nfunction getMessage(type) {\n    var splitType = type ? (\"\" + type).split(\"/\") : [];\n    var actionName = splitType[splitType.length - 1] || \"actionCreator\";\n    return 'Detected an action creator with type \"' + (type || \"unknown\") + \"\\\" being dispatched. \\nMake sure you're calling the action creator before dispatching, i.e. `dispatch(\" + actionName + \"())` instead of `dispatch(\" + actionName + \")`. This is necessary even if the action has no payload.\";\n}\nfunction createActionCreatorInvariantMiddleware(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    if (false) {}\n    var _c = options.isActionCreator, isActionCreator2 = _c === void 0 ? isActionCreator : _c;\n    return function() {\n        return function(next) {\n            return function(action) {\n                if (isActionCreator2(action)) {\n                    console.warn(getMessage(action.type));\n                }\n                return next(action);\n            };\n        };\n    };\n}\n// src/utils.ts\n\nfunction getTimeMeasureUtils(maxDelay, fnName) {\n    var elapsed = 0;\n    return {\n        measureTime: function(fn) {\n            var started = Date.now();\n            try {\n                return fn();\n            } finally{\n                var finished = Date.now();\n                elapsed += finished - started;\n            }\n        },\n        warnIfExceeded: function() {\n            if (elapsed > maxDelay) {\n                console.warn(fnName + \" took \" + elapsed + \"ms, which is more than the warning threshold of \" + maxDelay + \"ms. \\nIf your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.\\nIt is disabled in production builds, so you don't need to worry about that.\");\n            }\n        }\n    };\n}\nvar MiddlewareArray = /** @class */ function(_super) {\n    __extends(MiddlewareArray, _super);\n    function MiddlewareArray() {\n        var args = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            args[_i] = arguments[_i];\n        }\n        var _this = _super.apply(this, args) || this;\n        Object.setPrototypeOf(_this, MiddlewareArray.prototype);\n        return _this;\n    }\n    Object.defineProperty(MiddlewareArray, Symbol.species, {\n        get: function() {\n            return MiddlewareArray;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    MiddlewareArray.prototype.concat = function() {\n        var arr = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            arr[_i] = arguments[_i];\n        }\n        return _super.prototype.concat.apply(this, arr);\n    };\n    MiddlewareArray.prototype.prepend = function() {\n        var arr = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            arr[_i] = arguments[_i];\n        }\n        if (arr.length === 1 && Array.isArray(arr[0])) {\n            return new (MiddlewareArray.bind.apply(MiddlewareArray, __spreadArray([\n                void 0\n            ], arr[0].concat(this))))();\n        }\n        return new (MiddlewareArray.bind.apply(MiddlewareArray, __spreadArray([\n            void 0\n        ], arr.concat(this))))();\n    };\n    return MiddlewareArray;\n}(Array);\nvar EnhancerArray = /** @class */ function(_super) {\n    __extends(EnhancerArray, _super);\n    function EnhancerArray() {\n        var args = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            args[_i] = arguments[_i];\n        }\n        var _this = _super.apply(this, args) || this;\n        Object.setPrototypeOf(_this, EnhancerArray.prototype);\n        return _this;\n    }\n    Object.defineProperty(EnhancerArray, Symbol.species, {\n        get: function() {\n            return EnhancerArray;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    EnhancerArray.prototype.concat = function() {\n        var arr = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            arr[_i] = arguments[_i];\n        }\n        return _super.prototype.concat.apply(this, arr);\n    };\n    EnhancerArray.prototype.prepend = function() {\n        var arr = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            arr[_i] = arguments[_i];\n        }\n        if (arr.length === 1 && Array.isArray(arr[0])) {\n            return new (EnhancerArray.bind.apply(EnhancerArray, __spreadArray([\n                void 0\n            ], arr[0].concat(this))))();\n        }\n        return new (EnhancerArray.bind.apply(EnhancerArray, __spreadArray([\n            void 0\n        ], arr.concat(this))))();\n    };\n    return EnhancerArray;\n}(Array);\nfunction freezeDraftable(val) {\n    return (0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraftable)(val) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(val, function() {}) : val;\n}\n// src/immutableStateInvariantMiddleware.ts\nvar isProduction = \"development\" === \"production\";\nvar prefix = \"Invariant failed\";\nfunction invariant(condition, message) {\n    if (condition) {\n        return;\n    }\n    if (isProduction) {\n        throw new Error(prefix);\n    }\n    throw new Error(prefix + \": \" + (message || \"\"));\n}\nfunction stringify(obj, serializer, indent, decycler) {\n    return JSON.stringify(obj, getSerialize(serializer, decycler), indent);\n}\nfunction getSerialize(serializer, decycler) {\n    var stack = [], keys = [];\n    if (!decycler) decycler = function(_, value) {\n        if (stack[0] === value) return \"[Circular ~]\";\n        return \"[Circular ~.\" + keys.slice(0, stack.indexOf(value)).join(\".\") + \"]\";\n    };\n    return function(key, value) {\n        if (stack.length > 0) {\n            var thisPos = stack.indexOf(this);\n            ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);\n            ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);\n            if (~stack.indexOf(value)) value = decycler.call(this, key, value);\n        } else stack.push(value);\n        return serializer == null ? value : serializer.call(this, key, value);\n    };\n}\nfunction isImmutableDefault(value) {\n    return typeof value !== \"object\" || value == null || Object.isFrozen(value);\n}\nfunction trackForMutations(isImmutable, ignorePaths, obj) {\n    var trackedProperties = trackProperties(isImmutable, ignorePaths, obj);\n    return {\n        detectMutations: function() {\n            return detectMutations(isImmutable, ignorePaths, trackedProperties, obj);\n        }\n    };\n}\nfunction trackProperties(isImmutable, ignorePaths, obj, path, checkedObjects) {\n    if (ignorePaths === void 0) {\n        ignorePaths = [];\n    }\n    if (path === void 0) {\n        path = \"\";\n    }\n    if (checkedObjects === void 0) {\n        checkedObjects = new Set();\n    }\n    var tracked = {\n        value: obj\n    };\n    if (!isImmutable(obj) && !checkedObjects.has(obj)) {\n        checkedObjects.add(obj);\n        tracked.children = {};\n        for(var key in obj){\n            var childPath = path ? path + \".\" + key : key;\n            if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {\n                continue;\n            }\n            tracked.children[key] = trackProperties(isImmutable, ignorePaths, obj[key], childPath);\n        }\n    }\n    return tracked;\n}\nfunction detectMutations(isImmutable, ignoredPaths, trackedProperty, obj, sameParentRef, path) {\n    if (ignoredPaths === void 0) {\n        ignoredPaths = [];\n    }\n    if (sameParentRef === void 0) {\n        sameParentRef = false;\n    }\n    if (path === void 0) {\n        path = \"\";\n    }\n    var prevObj = trackedProperty ? trackedProperty.value : void 0;\n    var sameRef = prevObj === obj;\n    if (sameParentRef && !sameRef && !Number.isNaN(obj)) {\n        return {\n            wasMutated: true,\n            path: path\n        };\n    }\n    if (isImmutable(prevObj) || isImmutable(obj)) {\n        return {\n            wasMutated: false\n        };\n    }\n    var keysToDetect = {};\n    for(var key in trackedProperty.children){\n        keysToDetect[key] = true;\n    }\n    for(var key in obj){\n        keysToDetect[key] = true;\n    }\n    var hasIgnoredPaths = ignoredPaths.length > 0;\n    var _loop_1 = function(key) {\n        var nestedPath = path ? path + \".\" + key : key;\n        if (hasIgnoredPaths) {\n            var hasMatches = ignoredPaths.some(function(ignored) {\n                if (ignored instanceof RegExp) {\n                    return ignored.test(nestedPath);\n                }\n                return nestedPath === ignored;\n            });\n            if (hasMatches) {\n                return \"continue\";\n            }\n        }\n        var result = detectMutations(isImmutable, ignoredPaths, trackedProperty.children[key], obj[key], sameRef, nestedPath);\n        if (result.wasMutated) {\n            return {\n                value: result\n            };\n        }\n    };\n    for(var key in keysToDetect){\n        var state_1 = _loop_1(key);\n        if (typeof state_1 === \"object\") return state_1.value;\n    }\n    return {\n        wasMutated: false\n    };\n}\nfunction createImmutableStateInvariantMiddleware(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    if (false) {}\n    var _c = options.isImmutable, isImmutable = _c === void 0 ? isImmutableDefault : _c, ignoredPaths = options.ignoredPaths, _d = options.warnAfter, warnAfter = _d === void 0 ? 32 : _d, ignore = options.ignore;\n    ignoredPaths = ignoredPaths || ignore;\n    var track = trackForMutations.bind(null, isImmutable, ignoredPaths);\n    return function(_c) {\n        var getState = _c.getState;\n        var state = getState();\n        var tracker = track(state);\n        var result;\n        return function(next) {\n            return function(action) {\n                var measureUtils = getTimeMeasureUtils(warnAfter, \"ImmutableStateInvariantMiddleware\");\n                measureUtils.measureTime(function() {\n                    state = getState();\n                    result = tracker.detectMutations();\n                    tracker = track(state);\n                    invariant(!result.wasMutated, \"A state mutation was detected between dispatches, in the path '\" + (result.path || \"\") + \"'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)\");\n                });\n                var dispatchedAction = next(action);\n                measureUtils.measureTime(function() {\n                    state = getState();\n                    result = tracker.detectMutations();\n                    tracker = track(state);\n                    result.wasMutated && invariant(!result.wasMutated, \"A state mutation was detected inside a dispatch, in the path: \" + (result.path || \"\") + \". Take a look at the reducer(s) handling the action \" + stringify(action) + \". (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)\");\n                });\n                measureUtils.warnIfExceeded();\n                return dispatchedAction;\n            };\n        };\n    };\n}\n// src/serializableStateInvariantMiddleware.ts\nfunction isPlain(val) {\n    var type = typeof val;\n    return val == null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(val) || isPlainObject(val);\n}\nfunction findNonSerializableValue(value, path, isSerializable, getEntries, ignoredPaths, cache) {\n    if (path === void 0) {\n        path = \"\";\n    }\n    if (isSerializable === void 0) {\n        isSerializable = isPlain;\n    }\n    if (ignoredPaths === void 0) {\n        ignoredPaths = [];\n    }\n    var foundNestedSerializable;\n    if (!isSerializable(value)) {\n        return {\n            keyPath: path || \"<root>\",\n            value: value\n        };\n    }\n    if (typeof value !== \"object\" || value === null) {\n        return false;\n    }\n    if (cache == null ? void 0 : cache.has(value)) return false;\n    var entries = getEntries != null ? getEntries(value) : Object.entries(value);\n    var hasIgnoredPaths = ignoredPaths.length > 0;\n    var _loop_2 = function(key, nestedValue) {\n        var nestedPath = path ? path + \".\" + key : key;\n        if (hasIgnoredPaths) {\n            var hasMatches = ignoredPaths.some(function(ignored) {\n                if (ignored instanceof RegExp) {\n                    return ignored.test(nestedPath);\n                }\n                return nestedPath === ignored;\n            });\n            if (hasMatches) {\n                return \"continue\";\n            }\n        }\n        if (!isSerializable(nestedValue)) {\n            return {\n                value: {\n                    keyPath: nestedPath,\n                    value: nestedValue\n                }\n            };\n        }\n        if (typeof nestedValue === \"object\") {\n            foundNestedSerializable = findNonSerializableValue(nestedValue, nestedPath, isSerializable, getEntries, ignoredPaths, cache);\n            if (foundNestedSerializable) {\n                return {\n                    value: foundNestedSerializable\n                };\n            }\n        }\n    };\n    for(var _i = 0, entries_1 = entries; _i < entries_1.length; _i++){\n        var _c = entries_1[_i], key = _c[0], nestedValue = _c[1];\n        var state_2 = _loop_2(key, nestedValue);\n        if (typeof state_2 === \"object\") return state_2.value;\n    }\n    if (cache && isNestedFrozen(value)) cache.add(value);\n    return false;\n}\nfunction isNestedFrozen(value) {\n    if (!Object.isFrozen(value)) return false;\n    for(var _i = 0, _c = Object.values(value); _i < _c.length; _i++){\n        var nestedValue = _c[_i];\n        if (typeof nestedValue !== \"object\" || nestedValue === null) continue;\n        if (!isNestedFrozen(nestedValue)) return false;\n    }\n    return true;\n}\nfunction createSerializableStateInvariantMiddleware(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    if (false) {}\n    var _c = options.isSerializable, isSerializable = _c === void 0 ? isPlain : _c, getEntries = options.getEntries, _d = options.ignoredActions, ignoredActions = _d === void 0 ? [] : _d, _e = options.ignoredActionPaths, ignoredActionPaths = _e === void 0 ? [\n        \"meta.arg\",\n        \"meta.baseQueryMeta\"\n    ] : _e, _f = options.ignoredPaths, ignoredPaths = _f === void 0 ? [] : _f, _g = options.warnAfter, warnAfter = _g === void 0 ? 32 : _g, _h = options.ignoreState, ignoreState = _h === void 0 ? false : _h, _j = options.ignoreActions, ignoreActions = _j === void 0 ? false : _j, _k = options.disableCache, disableCache = _k === void 0 ? false : _k;\n    var cache = !disableCache && WeakSet ? new WeakSet() : void 0;\n    return function(storeAPI) {\n        return function(next) {\n            return function(action) {\n                var result = next(action);\n                var measureUtils = getTimeMeasureUtils(warnAfter, \"SerializableStateInvariantMiddleware\");\n                if (!ignoreActions && !(ignoredActions.length && ignoredActions.indexOf(action.type) !== -1)) {\n                    measureUtils.measureTime(function() {\n                        var foundActionNonSerializableValue = findNonSerializableValue(action, \"\", isSerializable, getEntries, ignoredActionPaths, cache);\n                        if (foundActionNonSerializableValue) {\n                            var keyPath = foundActionNonSerializableValue.keyPath, value = foundActionNonSerializableValue.value;\n                            console.error(\"A non-serializable value was detected in an action, in the path: `\" + keyPath + \"`. Value:\", value, \"\\nTake a look at the logic that dispatched this action: \", action, \"\\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)\", \"\\n(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)\");\n                        }\n                    });\n                }\n                if (!ignoreState) {\n                    measureUtils.measureTime(function() {\n                        var state = storeAPI.getState();\n                        var foundStateNonSerializableValue = findNonSerializableValue(state, \"\", isSerializable, getEntries, ignoredPaths, cache);\n                        if (foundStateNonSerializableValue) {\n                            var keyPath = foundStateNonSerializableValue.keyPath, value = foundStateNonSerializableValue.value;\n                            console.error(\"A non-serializable value was detected in the state, in the path: `\" + keyPath + \"`. Value:\", value, \"\\nTake a look at the reducer(s) handling this action type: \" + action.type + \".\\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)\");\n                        }\n                    });\n                    measureUtils.warnIfExceeded();\n                }\n                return result;\n            };\n        };\n    };\n}\n// src/getDefaultMiddleware.ts\nfunction isBoolean(x) {\n    return typeof x === \"boolean\";\n}\nfunction curryGetDefaultMiddleware() {\n    return function curriedGetDefaultMiddleware(options) {\n        return getDefaultMiddleware(options);\n    };\n}\nfunction getDefaultMiddleware(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var _c = options.thunk, thunk = _c === void 0 ? true : _c, _d = options.immutableCheck, immutableCheck = _d === void 0 ? true : _d, _e = options.serializableCheck, serializableCheck = _e === void 0 ? true : _e, _f = options.actionCreatorCheck, actionCreatorCheck = _f === void 0 ? true : _f;\n    var middlewareArray = new MiddlewareArray();\n    if (thunk) {\n        if (isBoolean(thunk)) {\n            middlewareArray.push(redux_thunk__WEBPACK_IMPORTED_MODULE_3__[\"default\"]);\n        } else {\n            middlewareArray.push(redux_thunk__WEBPACK_IMPORTED_MODULE_3__[\"default\"].withExtraArgument(thunk.extraArgument));\n        }\n    }\n    if (true) {\n        if (immutableCheck) {\n            var immutableOptions = {};\n            if (!isBoolean(immutableCheck)) {\n                immutableOptions = immutableCheck;\n            }\n            middlewareArray.unshift(createImmutableStateInvariantMiddleware(immutableOptions));\n        }\n        if (serializableCheck) {\n            var serializableOptions = {};\n            if (!isBoolean(serializableCheck)) {\n                serializableOptions = serializableCheck;\n            }\n            middlewareArray.push(createSerializableStateInvariantMiddleware(serializableOptions));\n        }\n        if (actionCreatorCheck) {\n            var actionCreatorOptions = {};\n            if (!isBoolean(actionCreatorCheck)) {\n                actionCreatorOptions = actionCreatorCheck;\n            }\n            middlewareArray.unshift(createActionCreatorInvariantMiddleware(actionCreatorOptions));\n        }\n    }\n    return middlewareArray;\n}\n// src/configureStore.ts\nvar IS_PRODUCTION = \"development\" === \"production\";\nfunction configureStore(options) {\n    var curriedGetDefaultMiddleware = curryGetDefaultMiddleware();\n    var _c = options || {}, _d = _c.reducer, reducer = _d === void 0 ? void 0 : _d, _e = _c.middleware, middleware = _e === void 0 ? curriedGetDefaultMiddleware() : _e, _f = _c.devTools, devTools = _f === void 0 ? true : _f, _g = _c.preloadedState, preloadedState = _g === void 0 ? void 0 : _g, _h = _c.enhancers, enhancers = _h === void 0 ? void 0 : _h;\n    var rootReducer;\n    if (typeof reducer === \"function\") {\n        rootReducer = reducer;\n    } else if (isPlainObject(reducer)) {\n        rootReducer = (0,redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers)(reducer);\n    } else {\n        throw new Error('\"reducer\" is a required argument, and must be a function or an object of functions that can be passed to combineReducers');\n    }\n    var finalMiddleware = middleware;\n    if (typeof finalMiddleware === \"function\") {\n        finalMiddleware = finalMiddleware(curriedGetDefaultMiddleware);\n        if (!IS_PRODUCTION && !Array.isArray(finalMiddleware)) {\n            throw new Error(\"when using a middleware builder function, an array of middleware must be returned\");\n        }\n    }\n    if (!IS_PRODUCTION && finalMiddleware.some(function(item) {\n        return typeof item !== \"function\";\n    })) {\n        throw new Error(\"each middleware provided to configureStore must be a function\");\n    }\n    var middlewareEnhancer = redux__WEBPACK_IMPORTED_MODULE_0__.applyMiddleware.apply(void 0, finalMiddleware);\n    var finalCompose = redux__WEBPACK_IMPORTED_MODULE_0__.compose;\n    if (devTools) {\n        finalCompose = composeWithDevTools(__spreadValues({\n            trace: !IS_PRODUCTION\n        }, typeof devTools === \"object\" && devTools));\n    }\n    var defaultEnhancers = new EnhancerArray(middlewareEnhancer);\n    var storeEnhancers = defaultEnhancers;\n    if (Array.isArray(enhancers)) {\n        storeEnhancers = __spreadArray([\n            middlewareEnhancer\n        ], enhancers);\n    } else if (typeof enhancers === \"function\") {\n        storeEnhancers = enhancers(defaultEnhancers);\n    }\n    var composedEnhancer = finalCompose.apply(void 0, storeEnhancers);\n    return (0,redux__WEBPACK_IMPORTED_MODULE_0__.createStore)(rootReducer, preloadedState, composedEnhancer);\n}\n// src/createReducer.ts\n\n// src/mapBuilders.ts\nfunction executeReducerBuilderCallback(builderCallback) {\n    var actionsMap = {};\n    var actionMatchers = [];\n    var defaultCaseReducer;\n    var builder = {\n        addCase: function(typeOrActionCreator, reducer) {\n            if (true) {\n                if (actionMatchers.length > 0) {\n                    throw new Error(\"`builder.addCase` should only be called before calling `builder.addMatcher`\");\n                }\n                if (defaultCaseReducer) {\n                    throw new Error(\"`builder.addCase` should only be called before calling `builder.addDefaultCase`\");\n                }\n            }\n            var type = typeof typeOrActionCreator === \"string\" ? typeOrActionCreator : typeOrActionCreator.type;\n            if (!type) {\n                throw new Error(\"`builder.addCase` cannot be called with an empty action type\");\n            }\n            if (type in actionsMap) {\n                throw new Error(\"`builder.addCase` cannot be called with two reducers for the same action type\");\n            }\n            actionsMap[type] = reducer;\n            return builder;\n        },\n        addMatcher: function(matcher, reducer) {\n            if (true) {\n                if (defaultCaseReducer) {\n                    throw new Error(\"`builder.addMatcher` should only be called before calling `builder.addDefaultCase`\");\n                }\n            }\n            actionMatchers.push({\n                matcher: matcher,\n                reducer: reducer\n            });\n            return builder;\n        },\n        addDefaultCase: function(reducer) {\n            if (true) {\n                if (defaultCaseReducer) {\n                    throw new Error(\"`builder.addDefaultCase` can only be called once\");\n                }\n            }\n            defaultCaseReducer = reducer;\n            return builder;\n        }\n    };\n    builderCallback(builder);\n    return [\n        actionsMap,\n        actionMatchers,\n        defaultCaseReducer\n    ];\n}\n// src/createReducer.ts\nfunction isStateFunction(x) {\n    return typeof x === \"function\";\n}\nvar hasWarnedAboutObjectNotation = false;\nfunction createReducer(initialState, mapOrBuilderCallback, actionMatchers, defaultCaseReducer) {\n    if (actionMatchers === void 0) {\n        actionMatchers = [];\n    }\n    if (true) {\n        if (typeof mapOrBuilderCallback === \"object\") {\n            if (!hasWarnedAboutObjectNotation) {\n                hasWarnedAboutObjectNotation = true;\n                console.warn(\"The object notation for `createReducer` is deprecated, and will be removed in RTK 2.0. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createReducer\");\n            }\n        }\n    }\n    var _c = typeof mapOrBuilderCallback === \"function\" ? executeReducerBuilderCallback(mapOrBuilderCallback) : [\n        mapOrBuilderCallback,\n        actionMatchers,\n        defaultCaseReducer\n    ], actionsMap = _c[0], finalActionMatchers = _c[1], finalDefaultCaseReducer = _c[2];\n    var getInitialState;\n    if (isStateFunction(initialState)) {\n        getInitialState = function() {\n            return freezeDraftable(initialState());\n        };\n    } else {\n        var frozenInitialState_1 = freezeDraftable(initialState);\n        getInitialState = function() {\n            return frozenInitialState_1;\n        };\n    }\n    function reducer(state, action) {\n        if (state === void 0) {\n            state = getInitialState();\n        }\n        var caseReducers = __spreadArray([\n            actionsMap[action.type]\n        ], finalActionMatchers.filter(function(_c) {\n            var matcher = _c.matcher;\n            return matcher(action);\n        }).map(function(_c) {\n            var reducer2 = _c.reducer;\n            return reducer2;\n        }));\n        if (caseReducers.filter(function(cr) {\n            return !!cr;\n        }).length === 0) {\n            caseReducers = [\n                finalDefaultCaseReducer\n            ];\n        }\n        return caseReducers.reduce(function(previousState, caseReducer) {\n            if (caseReducer) {\n                if ((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(previousState)) {\n                    var draft = previousState;\n                    var result = caseReducer(draft, action);\n                    if (result === void 0) {\n                        return previousState;\n                    }\n                    return result;\n                } else if (!(0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraftable)(previousState)) {\n                    var result = caseReducer(previousState, action);\n                    if (result === void 0) {\n                        if (previousState === null) {\n                            return previousState;\n                        }\n                        throw Error(\"A case reducer on a non-draftable value must not return undefined\");\n                    }\n                    return result;\n                } else {\n                    return (0,immer__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(previousState, function(draft) {\n                        return caseReducer(draft, action);\n                    });\n                }\n            }\n            return previousState;\n        }, state);\n    }\n    reducer.getInitialState = getInitialState;\n    return reducer;\n}\n// src/createSlice.ts\nvar hasWarnedAboutObjectNotation2 = false;\nfunction getType2(slice, actionKey) {\n    return slice + \"/\" + actionKey;\n}\nfunction createSlice(options) {\n    var name = options.name;\n    if (!name) {\n        throw new Error(\"`name` is a required option for createSlice\");\n    }\n    if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n        if (options.initialState === void 0) {\n            console.error(\"You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`\");\n        }\n    }\n    var initialState = typeof options.initialState == \"function\" ? options.initialState : freezeDraftable(options.initialState);\n    var reducers = options.reducers || {};\n    var reducerNames = Object.keys(reducers);\n    var sliceCaseReducersByName = {};\n    var sliceCaseReducersByType = {};\n    var actionCreators = {};\n    reducerNames.forEach(function(reducerName) {\n        var maybeReducerWithPrepare = reducers[reducerName];\n        var type = getType2(name, reducerName);\n        var caseReducer;\n        var prepareCallback;\n        if (\"reducer\" in maybeReducerWithPrepare) {\n            caseReducer = maybeReducerWithPrepare.reducer;\n            prepareCallback = maybeReducerWithPrepare.prepare;\n        } else {\n            caseReducer = maybeReducerWithPrepare;\n        }\n        sliceCaseReducersByName[reducerName] = caseReducer;\n        sliceCaseReducersByType[type] = caseReducer;\n        actionCreators[reducerName] = prepareCallback ? createAction(type, prepareCallback) : createAction(type);\n    });\n    function buildReducer() {\n        if (true) {\n            if (typeof options.extraReducers === \"object\") {\n                if (!hasWarnedAboutObjectNotation2) {\n                    hasWarnedAboutObjectNotation2 = true;\n                    console.warn(\"The object notation for `createSlice.extraReducers` is deprecated, and will be removed in RTK 2.0. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createSlice\");\n                }\n            }\n        }\n        var _c = typeof options.extraReducers === \"function\" ? executeReducerBuilderCallback(options.extraReducers) : [\n            options.extraReducers\n        ], _d = _c[0], extraReducers = _d === void 0 ? {} : _d, _e = _c[1], actionMatchers = _e === void 0 ? [] : _e, _f = _c[2], defaultCaseReducer = _f === void 0 ? void 0 : _f;\n        var finalCaseReducers = __spreadValues(__spreadValues({}, extraReducers), sliceCaseReducersByType);\n        return createReducer(initialState, function(builder) {\n            for(var key in finalCaseReducers){\n                builder.addCase(key, finalCaseReducers[key]);\n            }\n            for(var _i = 0, actionMatchers_1 = actionMatchers; _i < actionMatchers_1.length; _i++){\n                var m = actionMatchers_1[_i];\n                builder.addMatcher(m.matcher, m.reducer);\n            }\n            if (defaultCaseReducer) {\n                builder.addDefaultCase(defaultCaseReducer);\n            }\n        });\n    }\n    var _reducer;\n    return {\n        name: name,\n        reducer: function(state, action) {\n            if (!_reducer) _reducer = buildReducer();\n            return _reducer(state, action);\n        },\n        actions: actionCreators,\n        caseReducers: sliceCaseReducersByName,\n        getInitialState: function() {\n            if (!_reducer) _reducer = buildReducer();\n            return _reducer.getInitialState();\n        }\n    };\n}\n// src/entities/entity_state.ts\nfunction getInitialEntityState() {\n    return {\n        ids: [],\n        entities: {}\n    };\n}\nfunction createInitialStateFactory() {\n    function getInitialState(additionalState) {\n        if (additionalState === void 0) {\n            additionalState = {};\n        }\n        return Object.assign(getInitialEntityState(), additionalState);\n    }\n    return {\n        getInitialState: getInitialState\n    };\n}\n// src/entities/state_selectors.ts\nfunction createSelectorsFactory() {\n    function getSelectors(selectState) {\n        var selectIds = function(state) {\n            return state.ids;\n        };\n        var selectEntities = function(state) {\n            return state.entities;\n        };\n        var selectAll = createDraftSafeSelector(selectIds, selectEntities, function(ids, entities) {\n            return ids.map(function(id) {\n                return entities[id];\n            });\n        });\n        var selectId = function(_, id) {\n            return id;\n        };\n        var selectById = function(entities, id) {\n            return entities[id];\n        };\n        var selectTotal = createDraftSafeSelector(selectIds, function(ids) {\n            return ids.length;\n        });\n        if (!selectState) {\n            return {\n                selectIds: selectIds,\n                selectEntities: selectEntities,\n                selectAll: selectAll,\n                selectTotal: selectTotal,\n                selectById: createDraftSafeSelector(selectEntities, selectId, selectById)\n            };\n        }\n        var selectGlobalizedEntities = createDraftSafeSelector(selectState, selectEntities);\n        return {\n            selectIds: createDraftSafeSelector(selectState, selectIds),\n            selectEntities: selectGlobalizedEntities,\n            selectAll: createDraftSafeSelector(selectState, selectAll),\n            selectTotal: createDraftSafeSelector(selectState, selectTotal),\n            selectById: createDraftSafeSelector(selectGlobalizedEntities, selectId, selectById)\n        };\n    }\n    return {\n        getSelectors: getSelectors\n    };\n}\n// src/entities/state_adapter.ts\n\nfunction createSingleArgumentStateOperator(mutator) {\n    var operator = createStateOperator(function(_, state) {\n        return mutator(state);\n    });\n    return function operation(state) {\n        return operator(state, void 0);\n    };\n}\nfunction createStateOperator(mutator) {\n    return function operation(state, arg) {\n        function isPayloadActionArgument(arg2) {\n            return isFSA(arg2);\n        }\n        var runMutator = function(draft) {\n            if (isPayloadActionArgument(arg)) {\n                mutator(arg.payload, draft);\n            } else {\n                mutator(arg, draft);\n            }\n        };\n        if ((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(state)) {\n            runMutator(state);\n            return state;\n        } else {\n            return (0,immer__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state, runMutator);\n        }\n    };\n}\n// src/entities/utils.ts\nfunction selectIdValue(entity, selectId) {\n    var key = selectId(entity);\n    if ( true && key === void 0) {\n        console.warn(\"The entity passed to the `selectId` implementation returned undefined.\", \"You should probably provide your own `selectId` implementation.\", \"The entity that was passed:\", entity, \"The `selectId` implementation:\", selectId.toString());\n    }\n    return key;\n}\nfunction ensureEntitiesArray(entities) {\n    if (!Array.isArray(entities)) {\n        entities = Object.values(entities);\n    }\n    return entities;\n}\nfunction splitAddedUpdatedEntities(newEntities, selectId, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n    var added = [];\n    var updated = [];\n    for(var _i = 0, newEntities_1 = newEntities; _i < newEntities_1.length; _i++){\n        var entity = newEntities_1[_i];\n        var id = selectIdValue(entity, selectId);\n        if (id in state.entities) {\n            updated.push({\n                id: id,\n                changes: entity\n            });\n        } else {\n            added.push(entity);\n        }\n    }\n    return [\n        added,\n        updated\n    ];\n}\n// src/entities/unsorted_state_adapter.ts\nfunction createUnsortedStateAdapter(selectId) {\n    function addOneMutably(entity, state) {\n        var key = selectIdValue(entity, selectId);\n        if (key in state.entities) {\n            return;\n        }\n        state.ids.push(key);\n        state.entities[key] = entity;\n    }\n    function addManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        for(var _i = 0, newEntities_2 = newEntities; _i < newEntities_2.length; _i++){\n            var entity = newEntities_2[_i];\n            addOneMutably(entity, state);\n        }\n    }\n    function setOneMutably(entity, state) {\n        var key = selectIdValue(entity, selectId);\n        if (!(key in state.entities)) {\n            state.ids.push(key);\n        }\n        state.entities[key] = entity;\n    }\n    function setManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        for(var _i = 0, newEntities_3 = newEntities; _i < newEntities_3.length; _i++){\n            var entity = newEntities_3[_i];\n            setOneMutably(entity, state);\n        }\n    }\n    function setAllMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        state.ids = [];\n        state.entities = {};\n        addManyMutably(newEntities, state);\n    }\n    function removeOneMutably(key, state) {\n        return removeManyMutably([\n            key\n        ], state);\n    }\n    function removeManyMutably(keys, state) {\n        var didMutate = false;\n        keys.forEach(function(key) {\n            if (key in state.entities) {\n                delete state.entities[key];\n                didMutate = true;\n            }\n        });\n        if (didMutate) {\n            state.ids = state.ids.filter(function(id) {\n                return id in state.entities;\n            });\n        }\n    }\n    function removeAllMutably(state) {\n        Object.assign(state, {\n            ids: [],\n            entities: {}\n        });\n    }\n    function takeNewKey(keys, update, state) {\n        var original2 = state.entities[update.id];\n        var updated = Object.assign({}, original2, update.changes);\n        var newKey = selectIdValue(updated, selectId);\n        var hasNewKey = newKey !== update.id;\n        if (hasNewKey) {\n            keys[update.id] = newKey;\n            delete state.entities[update.id];\n        }\n        state.entities[newKey] = updated;\n        return hasNewKey;\n    }\n    function updateOneMutably(update, state) {\n        return updateManyMutably([\n            update\n        ], state);\n    }\n    function updateManyMutably(updates, state) {\n        var newKeys = {};\n        var updatesPerEntity = {};\n        updates.forEach(function(update) {\n            if (update.id in state.entities) {\n                updatesPerEntity[update.id] = {\n                    id: update.id,\n                    changes: __spreadValues(__spreadValues({}, updatesPerEntity[update.id] ? updatesPerEntity[update.id].changes : null), update.changes)\n                };\n            }\n        });\n        updates = Object.values(updatesPerEntity);\n        var didMutateEntities = updates.length > 0;\n        if (didMutateEntities) {\n            var didMutateIds = updates.filter(function(update) {\n                return takeNewKey(newKeys, update, state);\n            }).length > 0;\n            if (didMutateIds) {\n                state.ids = Object.keys(state.entities);\n            }\n        }\n    }\n    function upsertOneMutably(entity, state) {\n        return upsertManyMutably([\n            entity\n        ], state);\n    }\n    function upsertManyMutably(newEntities, state) {\n        var _c = splitAddedUpdatedEntities(newEntities, selectId, state), added = _c[0], updated = _c[1];\n        updateManyMutably(updated, state);\n        addManyMutably(added, state);\n    }\n    return {\n        removeAll: createSingleArgumentStateOperator(removeAllMutably),\n        addOne: createStateOperator(addOneMutably),\n        addMany: createStateOperator(addManyMutably),\n        setOne: createStateOperator(setOneMutably),\n        setMany: createStateOperator(setManyMutably),\n        setAll: createStateOperator(setAllMutably),\n        updateOne: createStateOperator(updateOneMutably),\n        updateMany: createStateOperator(updateManyMutably),\n        upsertOne: createStateOperator(upsertOneMutably),\n        upsertMany: createStateOperator(upsertManyMutably),\n        removeOne: createStateOperator(removeOneMutably),\n        removeMany: createStateOperator(removeManyMutably)\n    };\n}\n// src/entities/sorted_state_adapter.ts\nfunction createSortedStateAdapter(selectId, sort) {\n    var _c = createUnsortedStateAdapter(selectId), removeOne = _c.removeOne, removeMany = _c.removeMany, removeAll = _c.removeAll;\n    function addOneMutably(entity, state) {\n        return addManyMutably([\n            entity\n        ], state);\n    }\n    function addManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        var models = newEntities.filter(function(model) {\n            return !(selectIdValue(model, selectId) in state.entities);\n        });\n        if (models.length !== 0) {\n            merge(models, state);\n        }\n    }\n    function setOneMutably(entity, state) {\n        return setManyMutably([\n            entity\n        ], state);\n    }\n    function setManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        if (newEntities.length !== 0) {\n            merge(newEntities, state);\n        }\n    }\n    function setAllMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        state.entities = {};\n        state.ids = [];\n        addManyMutably(newEntities, state);\n    }\n    function updateOneMutably(update, state) {\n        return updateManyMutably([\n            update\n        ], state);\n    }\n    function updateManyMutably(updates, state) {\n        var appliedUpdates = false;\n        for(var _i = 0, updates_1 = updates; _i < updates_1.length; _i++){\n            var update = updates_1[_i];\n            var entity = state.entities[update.id];\n            if (!entity) {\n                continue;\n            }\n            appliedUpdates = true;\n            Object.assign(entity, update.changes);\n            var newId = selectId(entity);\n            if (update.id !== newId) {\n                delete state.entities[update.id];\n                state.entities[newId] = entity;\n            }\n        }\n        if (appliedUpdates) {\n            resortEntities(state);\n        }\n    }\n    function upsertOneMutably(entity, state) {\n        return upsertManyMutably([\n            entity\n        ], state);\n    }\n    function upsertManyMutably(newEntities, state) {\n        var _c = splitAddedUpdatedEntities(newEntities, selectId, state), added = _c[0], updated = _c[1];\n        updateManyMutably(updated, state);\n        addManyMutably(added, state);\n    }\n    function areArraysEqual(a, b) {\n        if (a.length !== b.length) {\n            return false;\n        }\n        for(var i = 0; i < a.length && i < b.length; i++){\n            if (a[i] === b[i]) {\n                continue;\n            }\n            return false;\n        }\n        return true;\n    }\n    function merge(models, state) {\n        models.forEach(function(model) {\n            state.entities[selectId(model)] = model;\n        });\n        resortEntities(state);\n    }\n    function resortEntities(state) {\n        var allEntities = Object.values(state.entities);\n        allEntities.sort(sort);\n        var newSortedIds = allEntities.map(selectId);\n        var ids = state.ids;\n        if (!areArraysEqual(ids, newSortedIds)) {\n            state.ids = newSortedIds;\n        }\n    }\n    return {\n        removeOne: removeOne,\n        removeMany: removeMany,\n        removeAll: removeAll,\n        addOne: createStateOperator(addOneMutably),\n        updateOne: createStateOperator(updateOneMutably),\n        upsertOne: createStateOperator(upsertOneMutably),\n        setOne: createStateOperator(setOneMutably),\n        setMany: createStateOperator(setManyMutably),\n        setAll: createStateOperator(setAllMutably),\n        addMany: createStateOperator(addManyMutably),\n        updateMany: createStateOperator(updateManyMutably),\n        upsertMany: createStateOperator(upsertManyMutably)\n    };\n}\n// src/entities/create_adapter.ts\nfunction createEntityAdapter(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var _c = __spreadValues({\n        sortComparer: false,\n        selectId: function(instance) {\n            return instance.id;\n        }\n    }, options), selectId = _c.selectId, sortComparer = _c.sortComparer;\n    var stateFactory = createInitialStateFactory();\n    var selectorsFactory = createSelectorsFactory();\n    var stateAdapter = sortComparer ? createSortedStateAdapter(selectId, sortComparer) : createUnsortedStateAdapter(selectId);\n    return __spreadValues(__spreadValues(__spreadValues({\n        selectId: selectId,\n        sortComparer: sortComparer\n    }, stateFactory), selectorsFactory), stateAdapter);\n}\n// src/nanoid.ts\nvar urlAlphabet = \"ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW\";\nvar nanoid = function(size) {\n    if (size === void 0) {\n        size = 21;\n    }\n    var id = \"\";\n    var i = size;\n    while(i--){\n        id += urlAlphabet[Math.random() * 64 | 0];\n    }\n    return id;\n};\n// src/createAsyncThunk.ts\nvar commonProperties = [\n    \"name\",\n    \"message\",\n    \"stack\",\n    \"code\"\n];\nvar RejectWithValue = /** @class */ function() {\n    function RejectWithValue(payload, meta) {\n        this.payload = payload;\n        this.meta = meta;\n    }\n    return RejectWithValue;\n}();\nvar FulfillWithMeta = /** @class */ function() {\n    function FulfillWithMeta(payload, meta) {\n        this.payload = payload;\n        this.meta = meta;\n    }\n    return FulfillWithMeta;\n}();\nvar miniSerializeError = function(value) {\n    if (typeof value === \"object\" && value !== null) {\n        var simpleError = {};\n        for(var _i = 0, commonProperties_1 = commonProperties; _i < commonProperties_1.length; _i++){\n            var property = commonProperties_1[_i];\n            if (typeof value[property] === \"string\") {\n                simpleError[property] = value[property];\n            }\n        }\n        return simpleError;\n    }\n    return {\n        message: String(value)\n    };\n};\nvar createAsyncThunk = function() {\n    function createAsyncThunk2(typePrefix, payloadCreator, options) {\n        var fulfilled = createAction(typePrefix + \"/fulfilled\", function(payload, requestId, arg, meta) {\n            return {\n                payload: payload,\n                meta: __spreadProps(__spreadValues({}, meta || {}), {\n                    arg: arg,\n                    requestId: requestId,\n                    requestStatus: \"fulfilled\"\n                })\n            };\n        });\n        var pending = createAction(typePrefix + \"/pending\", function(requestId, arg, meta) {\n            return {\n                payload: void 0,\n                meta: __spreadProps(__spreadValues({}, meta || {}), {\n                    arg: arg,\n                    requestId: requestId,\n                    requestStatus: \"pending\"\n                })\n            };\n        });\n        var rejected = createAction(typePrefix + \"/rejected\", function(error, requestId, arg, payload, meta) {\n            return {\n                payload: payload,\n                error: (options && options.serializeError || miniSerializeError)(error || \"Rejected\"),\n                meta: __spreadProps(__spreadValues({}, meta || {}), {\n                    arg: arg,\n                    requestId: requestId,\n                    rejectedWithValue: !!payload,\n                    requestStatus: \"rejected\",\n                    aborted: (error == null ? void 0 : error.name) === \"AbortError\",\n                    condition: (error == null ? void 0 : error.name) === \"ConditionError\"\n                })\n            };\n        });\n        var displayedWarning = false;\n        var AC = typeof AbortController !== \"undefined\" ? AbortController : /** @class */ function() {\n            function class_1() {\n                this.signal = {\n                    aborted: false,\n                    addEventListener: function() {},\n                    dispatchEvent: function() {\n                        return false;\n                    },\n                    onabort: function() {},\n                    removeEventListener: function() {},\n                    reason: void 0,\n                    throwIfAborted: function() {}\n                };\n            }\n            class_1.prototype.abort = function() {\n                if (true) {\n                    if (!displayedWarning) {\n                        displayedWarning = true;\n                        console.info(\"This platform does not implement AbortController. \\nIf you want to use the AbortController to react to `abort` events, please consider importing a polyfill like 'abortcontroller-polyfill/dist/abortcontroller-polyfill-only'.\");\n                    }\n                }\n            };\n            return class_1;\n        }();\n        function actionCreator(arg) {\n            return function(dispatch, getState, extra) {\n                var requestId = (options == null ? void 0 : options.idGenerator) ? options.idGenerator(arg) : nanoid();\n                var abortController = new AC();\n                var abortReason;\n                var started = false;\n                function abort(reason) {\n                    abortReason = reason;\n                    abortController.abort();\n                }\n                var promise2 = function() {\n                    return __async(this, null, function() {\n                        var _a, _b, finalAction, conditionResult, abortedPromise, err_1, skipDispatch;\n                        return __generator(this, function(_c) {\n                            switch(_c.label){\n                                case 0:\n                                    _c.trys.push([\n                                        0,\n                                        4,\n                                        ,\n                                        5\n                                    ]);\n                                    conditionResult = (_a = options == null ? void 0 : options.condition) == null ? void 0 : _a.call(options, arg, {\n                                        getState: getState,\n                                        extra: extra\n                                    });\n                                    if (!isThenable(conditionResult)) return [\n                                        3 /*break*/ ,\n                                        2\n                                    ];\n                                    return [\n                                        4 /*yield*/ ,\n                                        conditionResult\n                                    ];\n                                case 1:\n                                    conditionResult = _c.sent();\n                                    _c.label = 2;\n                                case 2:\n                                    if (conditionResult === false || abortController.signal.aborted) {\n                                        throw {\n                                            name: \"ConditionError\",\n                                            message: \"Aborted due to condition callback returning false.\"\n                                        };\n                                    }\n                                    started = true;\n                                    abortedPromise = new Promise(function(_, reject) {\n                                        return abortController.signal.addEventListener(\"abort\", function() {\n                                            return reject({\n                                                name: \"AbortError\",\n                                                message: abortReason || \"Aborted\"\n                                            });\n                                        });\n                                    });\n                                    dispatch(pending(requestId, arg, (_b = options == null ? void 0 : options.getPendingMeta) == null ? void 0 : _b.call(options, {\n                                        requestId: requestId,\n                                        arg: arg\n                                    }, {\n                                        getState: getState,\n                                        extra: extra\n                                    })));\n                                    return [\n                                        4 /*yield*/ ,\n                                        Promise.race([\n                                            abortedPromise,\n                                            Promise.resolve(payloadCreator(arg, {\n                                                dispatch: dispatch,\n                                                getState: getState,\n                                                extra: extra,\n                                                requestId: requestId,\n                                                signal: abortController.signal,\n                                                abort: abort,\n                                                rejectWithValue: function(value, meta) {\n                                                    return new RejectWithValue(value, meta);\n                                                },\n                                                fulfillWithValue: function(value, meta) {\n                                                    return new FulfillWithMeta(value, meta);\n                                                }\n                                            })).then(function(result) {\n                                                if (result instanceof RejectWithValue) {\n                                                    throw result;\n                                                }\n                                                if (result instanceof FulfillWithMeta) {\n                                                    return fulfilled(result.payload, requestId, arg, result.meta);\n                                                }\n                                                return fulfilled(result, requestId, arg);\n                                            })\n                                        ])\n                                    ];\n                                case 3:\n                                    finalAction = _c.sent();\n                                    return [\n                                        3 /*break*/ ,\n                                        5\n                                    ];\n                                case 4:\n                                    err_1 = _c.sent();\n                                    finalAction = err_1 instanceof RejectWithValue ? rejected(null, requestId, arg, err_1.payload, err_1.meta) : rejected(err_1, requestId, arg);\n                                    return [\n                                        3 /*break*/ ,\n                                        5\n                                    ];\n                                case 5:\n                                    skipDispatch = options && !options.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;\n                                    if (!skipDispatch) {\n                                        dispatch(finalAction);\n                                    }\n                                    return [\n                                        2 /*return*/ ,\n                                        finalAction\n                                    ];\n                            }\n                        });\n                    });\n                }();\n                return Object.assign(promise2, {\n                    abort: abort,\n                    requestId: requestId,\n                    arg: arg,\n                    unwrap: function() {\n                        return promise2.then(unwrapResult);\n                    }\n                });\n            };\n        }\n        return Object.assign(actionCreator, {\n            pending: pending,\n            rejected: rejected,\n            fulfilled: fulfilled,\n            typePrefix: typePrefix\n        });\n    }\n    createAsyncThunk2.withTypes = function() {\n        return createAsyncThunk2;\n    };\n    return createAsyncThunk2;\n}();\nfunction unwrapResult(action) {\n    if (action.meta && action.meta.rejectedWithValue) {\n        throw action.payload;\n    }\n    if (action.error) {\n        throw action.error;\n    }\n    return action.payload;\n}\nfunction isThenable(value) {\n    return value !== null && typeof value === \"object\" && typeof value.then === \"function\";\n}\n// src/matchers.ts\nvar matches = function(matcher, action) {\n    if (hasMatchFunction(matcher)) {\n        return matcher.match(action);\n    } else {\n        return matcher(action);\n    }\n};\nfunction isAnyOf() {\n    var matchers = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        matchers[_i] = arguments[_i];\n    }\n    return function(action) {\n        return matchers.some(function(matcher) {\n            return matches(matcher, action);\n        });\n    };\n}\nfunction isAllOf() {\n    var matchers = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        matchers[_i] = arguments[_i];\n    }\n    return function(action) {\n        return matchers.every(function(matcher) {\n            return matches(matcher, action);\n        });\n    };\n}\nfunction hasExpectedRequestMetadata(action, validStatus) {\n    if (!action || !action.meta) return false;\n    var hasValidRequestId = typeof action.meta.requestId === \"string\";\n    var hasValidRequestStatus = validStatus.indexOf(action.meta.requestStatus) > -1;\n    return hasValidRequestId && hasValidRequestStatus;\n}\nfunction isAsyncThunkArray(a) {\n    return typeof a[0] === \"function\" && \"pending\" in a[0] && \"fulfilled\" in a[0] && \"rejected\" in a[0];\n}\nfunction isPending() {\n    var asyncThunks = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        asyncThunks[_i] = arguments[_i];\n    }\n    if (asyncThunks.length === 0) {\n        return function(action) {\n            return hasExpectedRequestMetadata(action, [\n                \"pending\"\n            ]);\n        };\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isPending()(asyncThunks[0]);\n    }\n    return function(action) {\n        var matchers = asyncThunks.map(function(asyncThunk) {\n            return asyncThunk.pending;\n        });\n        var combinedMatcher = isAnyOf.apply(void 0, matchers);\n        return combinedMatcher(action);\n    };\n}\nfunction isRejected() {\n    var asyncThunks = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        asyncThunks[_i] = arguments[_i];\n    }\n    if (asyncThunks.length === 0) {\n        return function(action) {\n            return hasExpectedRequestMetadata(action, [\n                \"rejected\"\n            ]);\n        };\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isRejected()(asyncThunks[0]);\n    }\n    return function(action) {\n        var matchers = asyncThunks.map(function(asyncThunk) {\n            return asyncThunk.rejected;\n        });\n        var combinedMatcher = isAnyOf.apply(void 0, matchers);\n        return combinedMatcher(action);\n    };\n}\nfunction isRejectedWithValue() {\n    var asyncThunks = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        asyncThunks[_i] = arguments[_i];\n    }\n    var hasFlag = function(action) {\n        return action && action.meta && action.meta.rejectedWithValue;\n    };\n    if (asyncThunks.length === 0) {\n        return function(action) {\n            var combinedMatcher = isAllOf(isRejected.apply(void 0, asyncThunks), hasFlag);\n            return combinedMatcher(action);\n        };\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isRejectedWithValue()(asyncThunks[0]);\n    }\n    return function(action) {\n        var combinedMatcher = isAllOf(isRejected.apply(void 0, asyncThunks), hasFlag);\n        return combinedMatcher(action);\n    };\n}\nfunction isFulfilled() {\n    var asyncThunks = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        asyncThunks[_i] = arguments[_i];\n    }\n    if (asyncThunks.length === 0) {\n        return function(action) {\n            return hasExpectedRequestMetadata(action, [\n                \"fulfilled\"\n            ]);\n        };\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isFulfilled()(asyncThunks[0]);\n    }\n    return function(action) {\n        var matchers = asyncThunks.map(function(asyncThunk) {\n            return asyncThunk.fulfilled;\n        });\n        var combinedMatcher = isAnyOf.apply(void 0, matchers);\n        return combinedMatcher(action);\n    };\n}\nfunction isAsyncThunkAction() {\n    var asyncThunks = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        asyncThunks[_i] = arguments[_i];\n    }\n    if (asyncThunks.length === 0) {\n        return function(action) {\n            return hasExpectedRequestMetadata(action, [\n                \"pending\",\n                \"fulfilled\",\n                \"rejected\"\n            ]);\n        };\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isAsyncThunkAction()(asyncThunks[0]);\n    }\n    return function(action) {\n        var matchers = [];\n        for(var _i = 0, asyncThunks_1 = asyncThunks; _i < asyncThunks_1.length; _i++){\n            var asyncThunk = asyncThunks_1[_i];\n            matchers.push(asyncThunk.pending, asyncThunk.rejected, asyncThunk.fulfilled);\n        }\n        var combinedMatcher = isAnyOf.apply(void 0, matchers);\n        return combinedMatcher(action);\n    };\n}\n// src/listenerMiddleware/utils.ts\nvar assertFunction = function(func, expected) {\n    if (typeof func !== \"function\") {\n        throw new TypeError(expected + \" is not a function\");\n    }\n};\nvar noop = function() {};\nvar catchRejection = function(promise2, onError) {\n    if (onError === void 0) {\n        onError = noop;\n    }\n    promise2.catch(onError);\n    return promise2;\n};\nvar addAbortSignalListener = function(abortSignal, callback) {\n    abortSignal.addEventListener(\"abort\", callback, {\n        once: true\n    });\n    return function() {\n        return abortSignal.removeEventListener(\"abort\", callback);\n    };\n};\nvar abortControllerWithReason = function(abortController, reason) {\n    var signal = abortController.signal;\n    if (signal.aborted) {\n        return;\n    }\n    if (!(\"reason\" in signal)) {\n        Object.defineProperty(signal, \"reason\", {\n            enumerable: true,\n            value: reason,\n            configurable: true,\n            writable: true\n        });\n    }\n    ;\n    abortController.abort(reason);\n};\n// src/listenerMiddleware/exceptions.ts\nvar task = \"task\";\nvar listener = \"listener\";\nvar completed = \"completed\";\nvar cancelled = \"cancelled\";\nvar taskCancelled = \"task-\" + cancelled;\nvar taskCompleted = \"task-\" + completed;\nvar listenerCancelled = listener + \"-\" + cancelled;\nvar listenerCompleted = listener + \"-\" + completed;\nvar TaskAbortError = /** @class */ function() {\n    function TaskAbortError(code) {\n        this.code = code;\n        this.name = \"TaskAbortError\";\n        this.message = task + \" \" + cancelled + \" (reason: \" + code + \")\";\n    }\n    return TaskAbortError;\n}();\n// src/listenerMiddleware/task.ts\nvar validateActive = function(signal) {\n    if (signal.aborted) {\n        throw new TaskAbortError(signal.reason);\n    }\n};\nfunction raceWithSignal(signal, promise2) {\n    var cleanup = noop;\n    return new Promise(function(resolve, reject) {\n        var notifyRejection = function() {\n            return reject(new TaskAbortError(signal.reason));\n        };\n        if (signal.aborted) {\n            notifyRejection();\n            return;\n        }\n        cleanup = addAbortSignalListener(signal, notifyRejection);\n        promise2.finally(function() {\n            return cleanup();\n        }).then(resolve, reject);\n    }).finally(function() {\n        cleanup = noop;\n    });\n}\nvar runTask = function(task2, cleanUp) {\n    return __async(void 0, null, function() {\n        var value, error_1;\n        return __generator(this, function(_c) {\n            switch(_c.label){\n                case 0:\n                    _c.trys.push([\n                        0,\n                        3,\n                        4,\n                        5\n                    ]);\n                    return [\n                        4 /*yield*/ ,\n                        Promise.resolve()\n                    ];\n                case 1:\n                    _c.sent();\n                    return [\n                        4 /*yield*/ ,\n                        task2()\n                    ];\n                case 2:\n                    value = _c.sent();\n                    return [\n                        2 /*return*/ ,\n                        {\n                            status: \"ok\",\n                            value: value\n                        }\n                    ];\n                case 3:\n                    error_1 = _c.sent();\n                    return [\n                        2 /*return*/ ,\n                        {\n                            status: error_1 instanceof TaskAbortError ? \"cancelled\" : \"rejected\",\n                            error: error_1\n                        }\n                    ];\n                case 4:\n                    cleanUp == null ? void 0 : cleanUp();\n                    return [\n                        7 /*endfinally*/ \n                    ];\n                case 5:\n                    return [\n                        2 /*return*/ \n                    ];\n            }\n        });\n    });\n};\nvar createPause = function(signal) {\n    return function(promise2) {\n        return catchRejection(raceWithSignal(signal, promise2).then(function(output) {\n            validateActive(signal);\n            return output;\n        }));\n    };\n};\nvar createDelay = function(signal) {\n    var pause = createPause(signal);\n    return function(timeoutMs) {\n        return pause(new Promise(function(resolve) {\n            return setTimeout(resolve, timeoutMs);\n        }));\n    };\n};\n// src/listenerMiddleware/index.ts\nvar assign = Object.assign;\nvar INTERNAL_NIL_TOKEN = {};\nvar alm = \"listenerMiddleware\";\nvar createFork = function(parentAbortSignal, parentBlockingPromises) {\n    var linkControllers = function(controller) {\n        return addAbortSignalListener(parentAbortSignal, function() {\n            return abortControllerWithReason(controller, parentAbortSignal.reason);\n        });\n    };\n    return function(taskExecutor, opts) {\n        assertFunction(taskExecutor, \"taskExecutor\");\n        var childAbortController = new AbortController();\n        linkControllers(childAbortController);\n        var result = runTask(function() {\n            return __async(void 0, null, function() {\n                var result2;\n                return __generator(this, function(_c) {\n                    switch(_c.label){\n                        case 0:\n                            validateActive(parentAbortSignal);\n                            validateActive(childAbortController.signal);\n                            return [\n                                4 /*yield*/ ,\n                                taskExecutor({\n                                    pause: createPause(childAbortController.signal),\n                                    delay: createDelay(childAbortController.signal),\n                                    signal: childAbortController.signal\n                                })\n                            ];\n                        case 1:\n                            result2 = _c.sent();\n                            validateActive(childAbortController.signal);\n                            return [\n                                2 /*return*/ ,\n                                result2\n                            ];\n                    }\n                });\n            });\n        }, function() {\n            return abortControllerWithReason(childAbortController, taskCompleted);\n        });\n        if (opts == null ? void 0 : opts.autoJoin) {\n            parentBlockingPromises.push(result);\n        }\n        return {\n            result: createPause(parentAbortSignal)(result),\n            cancel: function() {\n                abortControllerWithReason(childAbortController, taskCancelled);\n            }\n        };\n    };\n};\nvar createTakePattern = function(startListening, signal) {\n    var take = function(predicate, timeout) {\n        return __async(void 0, null, function() {\n            var unsubscribe, tuplePromise, promises, output;\n            return __generator(this, function(_c) {\n                switch(_c.label){\n                    case 0:\n                        validateActive(signal);\n                        unsubscribe = function() {};\n                        tuplePromise = new Promise(function(resolve, reject) {\n                            var stopListening = startListening({\n                                predicate: predicate,\n                                effect: function(action, listenerApi) {\n                                    listenerApi.unsubscribe();\n                                    resolve([\n                                        action,\n                                        listenerApi.getState(),\n                                        listenerApi.getOriginalState()\n                                    ]);\n                                }\n                            });\n                            unsubscribe = function() {\n                                stopListening();\n                                reject();\n                            };\n                        });\n                        promises = [\n                            tuplePromise\n                        ];\n                        if (timeout != null) {\n                            promises.push(new Promise(function(resolve) {\n                                return setTimeout(resolve, timeout, null);\n                            }));\n                        }\n                        _c.label = 1;\n                    case 1:\n                        _c.trys.push([\n                            1,\n                            ,\n                            3,\n                            4\n                        ]);\n                        return [\n                            4 /*yield*/ ,\n                            raceWithSignal(signal, Promise.race(promises))\n                        ];\n                    case 2:\n                        output = _c.sent();\n                        validateActive(signal);\n                        return [\n                            2 /*return*/ ,\n                            output\n                        ];\n                    case 3:\n                        unsubscribe();\n                        return [\n                            7 /*endfinally*/ \n                        ];\n                    case 4:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    return function(predicate, timeout) {\n        return catchRejection(take(predicate, timeout));\n    };\n};\nvar getListenerEntryPropsFrom = function(options) {\n    var type = options.type, actionCreator = options.actionCreator, matcher = options.matcher, predicate = options.predicate, effect = options.effect;\n    if (type) {\n        predicate = createAction(type).match;\n    } else if (actionCreator) {\n        type = actionCreator.type;\n        predicate = actionCreator.match;\n    } else if (matcher) {\n        predicate = matcher;\n    } else if (predicate) {} else {\n        throw new Error(\"Creating or removing a listener requires one of the known fields for matching an action\");\n    }\n    assertFunction(effect, \"options.listener\");\n    return {\n        predicate: predicate,\n        type: type,\n        effect: effect\n    };\n};\nvar createListenerEntry = function(options) {\n    var _c = getListenerEntryPropsFrom(options), type = _c.type, predicate = _c.predicate, effect = _c.effect;\n    var id = nanoid();\n    var entry = {\n        id: id,\n        effect: effect,\n        type: type,\n        predicate: predicate,\n        pending: new Set(),\n        unsubscribe: function() {\n            throw new Error(\"Unsubscribe not initialized\");\n        }\n    };\n    return entry;\n};\nvar cancelActiveListeners = function(entry) {\n    entry.pending.forEach(function(controller) {\n        abortControllerWithReason(controller, listenerCancelled);\n    });\n};\nvar createClearListenerMiddleware = function(listenerMap) {\n    return function() {\n        listenerMap.forEach(cancelActiveListeners);\n        listenerMap.clear();\n    };\n};\nvar safelyNotifyError = function(errorHandler, errorToNotify, errorInfo) {\n    try {\n        errorHandler(errorToNotify, errorInfo);\n    } catch (errorHandlerError) {\n        setTimeout(function() {\n            throw errorHandlerError;\n        }, 0);\n    }\n};\nvar addListener = createAction(alm + \"/add\");\nvar clearAllListeners = createAction(alm + \"/removeAll\");\nvar removeListener = createAction(alm + \"/remove\");\nvar defaultErrorHandler = function() {\n    var args = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        args[_i] = arguments[_i];\n    }\n    console.error.apply(console, __spreadArray([\n        alm + \"/error\"\n    ], args));\n};\nfunction createListenerMiddleware(middlewareOptions) {\n    var _this = this;\n    if (middlewareOptions === void 0) {\n        middlewareOptions = {};\n    }\n    var listenerMap = new Map();\n    var extra = middlewareOptions.extra, _c = middlewareOptions.onError, onError = _c === void 0 ? defaultErrorHandler : _c;\n    assertFunction(onError, \"onError\");\n    var insertEntry = function(entry) {\n        entry.unsubscribe = function() {\n            return listenerMap.delete(entry.id);\n        };\n        listenerMap.set(entry.id, entry);\n        return function(cancelOptions) {\n            entry.unsubscribe();\n            if (cancelOptions == null ? void 0 : cancelOptions.cancelActive) {\n                cancelActiveListeners(entry);\n            }\n        };\n    };\n    var findListenerEntry = function(comparator) {\n        for(var _i = 0, _c = Array.from(listenerMap.values()); _i < _c.length; _i++){\n            var entry = _c[_i];\n            if (comparator(entry)) {\n                return entry;\n            }\n        }\n        return void 0;\n    };\n    var startListening = function(options) {\n        var entry = findListenerEntry(function(existingEntry) {\n            return existingEntry.effect === options.effect;\n        });\n        if (!entry) {\n            entry = createListenerEntry(options);\n        }\n        return insertEntry(entry);\n    };\n    var stopListening = function(options) {\n        var _c = getListenerEntryPropsFrom(options), type = _c.type, effect = _c.effect, predicate = _c.predicate;\n        var entry = findListenerEntry(function(entry2) {\n            var matchPredicateOrType = typeof type === \"string\" ? entry2.type === type : entry2.predicate === predicate;\n            return matchPredicateOrType && entry2.effect === effect;\n        });\n        if (entry) {\n            entry.unsubscribe();\n            if (options.cancelActive) {\n                cancelActiveListeners(entry);\n            }\n        }\n        return !!entry;\n    };\n    var notifyListener = function(entry, action, api, getOriginalState) {\n        return __async(_this, null, function() {\n            var internalTaskController, take, autoJoinPromises, listenerError_1;\n            return __generator(this, function(_c) {\n                switch(_c.label){\n                    case 0:\n                        internalTaskController = new AbortController();\n                        take = createTakePattern(startListening, internalTaskController.signal);\n                        autoJoinPromises = [];\n                        _c.label = 1;\n                    case 1:\n                        _c.trys.push([\n                            1,\n                            3,\n                            4,\n                            6\n                        ]);\n                        entry.pending.add(internalTaskController);\n                        return [\n                            4 /*yield*/ ,\n                            Promise.resolve(entry.effect(action, assign({}, api, {\n                                getOriginalState: getOriginalState,\n                                condition: function(predicate, timeout) {\n                                    return take(predicate, timeout).then(Boolean);\n                                },\n                                take: take,\n                                delay: createDelay(internalTaskController.signal),\n                                pause: createPause(internalTaskController.signal),\n                                extra: extra,\n                                signal: internalTaskController.signal,\n                                fork: createFork(internalTaskController.signal, autoJoinPromises),\n                                unsubscribe: entry.unsubscribe,\n                                subscribe: function() {\n                                    listenerMap.set(entry.id, entry);\n                                },\n                                cancelActiveListeners: function() {\n                                    entry.pending.forEach(function(controller, _, set) {\n                                        if (controller !== internalTaskController) {\n                                            abortControllerWithReason(controller, listenerCancelled);\n                                            set.delete(controller);\n                                        }\n                                    });\n                                }\n                            })))\n                        ];\n                    case 2:\n                        _c.sent();\n                        return [\n                            3 /*break*/ ,\n                            6\n                        ];\n                    case 3:\n                        listenerError_1 = _c.sent();\n                        if (!(listenerError_1 instanceof TaskAbortError)) {\n                            safelyNotifyError(onError, listenerError_1, {\n                                raisedBy: \"effect\"\n                            });\n                        }\n                        return [\n                            3 /*break*/ ,\n                            6\n                        ];\n                    case 4:\n                        return [\n                            4 /*yield*/ ,\n                            Promise.allSettled(autoJoinPromises)\n                        ];\n                    case 5:\n                        _c.sent();\n                        abortControllerWithReason(internalTaskController, listenerCompleted);\n                        entry.pending.delete(internalTaskController);\n                        return [\n                            7 /*endfinally*/ \n                        ];\n                    case 6:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    var clearListenerMiddleware = createClearListenerMiddleware(listenerMap);\n    var middleware = function(api) {\n        return function(next) {\n            return function(action) {\n                if (!isAction(action)) {\n                    return next(action);\n                }\n                if (addListener.match(action)) {\n                    return startListening(action.payload);\n                }\n                if (clearAllListeners.match(action)) {\n                    clearListenerMiddleware();\n                    return;\n                }\n                if (removeListener.match(action)) {\n                    return stopListening(action.payload);\n                }\n                var originalState = api.getState();\n                var getOriginalState = function() {\n                    if (originalState === INTERNAL_NIL_TOKEN) {\n                        throw new Error(alm + \": getOriginalState can only be called synchronously\");\n                    }\n                    return originalState;\n                };\n                var result;\n                try {\n                    result = next(action);\n                    if (listenerMap.size > 0) {\n                        var currentState = api.getState();\n                        var listenerEntries = Array.from(listenerMap.values());\n                        for(var _i = 0, listenerEntries_1 = listenerEntries; _i < listenerEntries_1.length; _i++){\n                            var entry = listenerEntries_1[_i];\n                            var runListener = false;\n                            try {\n                                runListener = entry.predicate(action, currentState, originalState);\n                            } catch (predicateError) {\n                                runListener = false;\n                                safelyNotifyError(onError, predicateError, {\n                                    raisedBy: \"predicate\"\n                                });\n                            }\n                            if (!runListener) {\n                                continue;\n                            }\n                            notifyListener(entry, action, api, getOriginalState);\n                        }\n                    }\n                } finally{\n                    originalState = INTERNAL_NIL_TOKEN;\n                }\n                return result;\n            };\n        };\n    };\n    return {\n        middleware: middleware,\n        startListening: startListening,\n        stopListening: stopListening,\n        clearListeners: clearListenerMiddleware\n    };\n}\n// src/autoBatchEnhancer.ts\nvar SHOULD_AUTOBATCH = \"RTK_autoBatch\";\nvar prepareAutoBatched = function() {\n    return function(payload) {\n        var _c;\n        return {\n            payload: payload,\n            meta: (_c = {}, _c[SHOULD_AUTOBATCH] = true, _c)\n        };\n    };\n};\nvar promise;\nvar queueMicrotaskShim = typeof queueMicrotask === \"function\" ? queueMicrotask.bind( true ? window : 0) : function(cb) {\n    return (promise || (promise = Promise.resolve())).then(cb).catch(function(err) {\n        return setTimeout(function() {\n            throw err;\n        }, 0);\n    });\n};\nvar createQueueWithTimer = function(timeout) {\n    return function(notify) {\n        setTimeout(notify, timeout);\n    };\n};\nvar rAF =  true && window.requestAnimationFrame ? window.requestAnimationFrame : createQueueWithTimer(10);\nvar autoBatchEnhancer = function(options) {\n    if (options === void 0) {\n        options = {\n            type: \"raf\"\n        };\n    }\n    return function(next) {\n        return function() {\n            var args = [];\n            for(var _i = 0; _i < arguments.length; _i++){\n                args[_i] = arguments[_i];\n            }\n            var store = next.apply(void 0, args);\n            var notifying = true;\n            var shouldNotifyAtEndOfTick = false;\n            var notificationQueued = false;\n            var listeners = new Set();\n            var queueCallback = options.type === \"tick\" ? queueMicrotaskShim : options.type === \"raf\" ? rAF : options.type === \"callback\" ? options.queueNotification : createQueueWithTimer(options.timeout);\n            var notifyListeners = function() {\n                notificationQueued = false;\n                if (shouldNotifyAtEndOfTick) {\n                    shouldNotifyAtEndOfTick = false;\n                    listeners.forEach(function(l) {\n                        return l();\n                    });\n                }\n            };\n            return Object.assign({}, store, {\n                subscribe: function(listener2) {\n                    var wrappedListener = function() {\n                        return notifying && listener2();\n                    };\n                    var unsubscribe = store.subscribe(wrappedListener);\n                    listeners.add(listener2);\n                    return function() {\n                        unsubscribe();\n                        listeners.delete(listener2);\n                    };\n                },\n                dispatch: function(action) {\n                    var _a;\n                    try {\n                        notifying = !((_a = action == null ? void 0 : action.meta) == null ? void 0 : _a[SHOULD_AUTOBATCH]);\n                        shouldNotifyAtEndOfTick = !notifying;\n                        if (shouldNotifyAtEndOfTick) {\n                            if (!notificationQueued) {\n                                notificationQueued = true;\n                                queueCallback(notifyListeners);\n                            }\n                        }\n                        return store.dispatch(action);\n                    } finally{\n                        notifying = true;\n                    }\n                }\n            });\n        };\n    };\n};\n// src/index.ts\n(0,immer__WEBPACK_IMPORTED_MODULE_2__.enableES5)();\n //# sourceMappingURL=redux-toolkit.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVkdXhqcy90b29sa2l0L2Rpc3QvcmVkdXgtdG9vbGtpdC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUEsWUFBWSxTQUFLLElBQUksU0FBSSxDQUFDQSxTQUFTLElBQUs7SUFDeEMsSUFBSUMsZ0JBQWdCLFNBQVVDLENBQUMsRUFBRUMsQ0FBQztRQUM5QkYsZ0JBQWdCRyxPQUFPQyxjQUFjLElBQ2hDO1lBQUVDLFdBQVcsRUFBRTtRQUFDLGNBQWFDLFNBQVMsU0FBVUwsQ0FBQyxFQUFFQyxDQUFDO1lBQUlELEVBQUVJLFNBQVMsR0FBR0g7UUFBRyxLQUMxRSxTQUFVRCxDQUFDLEVBQUVDLENBQUM7WUFBSSxJQUFLLElBQUlLLEtBQUtMLEVBQUcsSUFBSUMsT0FBT0ssU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ1IsR0FBR0ssSUFBSU4sQ0FBQyxDQUFDTSxFQUFFLEdBQUdMLENBQUMsQ0FBQ0ssRUFBRTtRQUFFO1FBQ3BHLE9BQU9QLGNBQWNDLEdBQUdDO0lBQzVCO0lBQ0EsT0FBTyxTQUFVRCxDQUFDLEVBQUVDLENBQUM7UUFDakIsSUFBSSxPQUFPQSxNQUFNLGNBQWNBLE1BQU0sTUFDakMsTUFBTSxJQUFJUyxVQUFVLHlCQUF5QkMsT0FBT1YsS0FBSztRQUM3REYsY0FBY0MsR0FBR0M7UUFDakIsU0FBU1c7WUFBTyxJQUFJLENBQUNDLFdBQVcsR0FBR2I7UUFBRztRQUN0Q0EsRUFBRU8sU0FBUyxHQUFHTixNQUFNLE9BQU9DLE9BQU9ZLE1BQU0sQ0FBQ2IsS0FBTVcsQ0FBQUEsR0FBR0wsU0FBUyxHQUFHTixFQUFFTSxTQUFTLEVBQUUsSUFBSUssSUFBRztJQUN0RjtBQUNKO0FBQ0EsSUFBSUcsY0FBYyxTQUFLLElBQUksU0FBSSxDQUFDQSxXQUFXLElBQUssU0FBVUMs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QTtvQkFBSztnQkFDakQ7WUFDSjtZQUNBLE9BQU8xb0IsT0FBT2lXLE1BQU0sQ0FBQyxDQUFDLEdBQUdpUyxPQUFPO2dCQUM1QnpCLFdBQVcsU0FBVWtDLFNBQVM7b0JBQzFCLElBQUlDLGtCQUFrQjt3QkFBYyxPQUFPVCxhQUFhUTtvQkFBYTtvQkFDckUsSUFBSTdFLGNBQWNvRSxNQUFNekIsU0FBUyxDQUFDbUM7b0JBQ2xDTixVQUFVN2IsR0FBRyxDQUFDa2M7b0JBQ2QsT0FBTzt3QkFDSDdFO3dCQUNBd0UsVUFBVTdDLE1BQU0sQ0FBQ2tEO29CQUNyQjtnQkFDSjtnQkFDQS9LLFVBQVUsU0FBVTlWLE1BQU07b0JBQ3RCLElBQUlvVztvQkFDSixJQUFJO3dCQUNBaUssWUFBWSxDQUFFLEVBQUNqSyxLQUFLcFcsVUFBVSxPQUFPLEtBQUssSUFBSUEsT0FBT0gsSUFBSSxLQUFLLE9BQU8sS0FBSyxJQUFJdVcsRUFBRSxDQUFDa0osaUJBQWlCO3dCQUNsR2dCLDBCQUEwQixDQUFDRDt3QkFDM0IsSUFBSUMseUJBQXlCOzRCQUN6QixJQUFJLENBQUNDLG9CQUFvQjtnQ0FDckJBLHFCQUFxQjtnQ0FDckJFLGNBQWNFOzRCQUNsQjt3QkFDSjt3QkFDQSxPQUFPUCxNQUFNdEssUUFBUSxDQUFDOVY7b0JBQzFCLFNBQ1E7d0JBQ0pxZ0IsWUFBWTtvQkFDaEI7Z0JBQ0o7WUFDSjtRQUNKO0lBQUc7QUFDUDtBQUNBLGVBQWU7QUFDZmxqQixnREFBU0E7QUFDKzBCLENBQ3gxQiw2Q0FBNkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0ByZWR1eGpzL3Rvb2xraXQvZGlzdC9yZWR1eC10b29sa2l0LmVzbS5qcz84Y2NjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20pIHtcclxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGZyb20ubGVuZ3RoLCBqID0gdG8ubGVuZ3RoOyBpIDwgaWw7IGkrKywgaisrKVxyXG4gICAgICAgIHRvW2pdID0gZnJvbVtpXTtcclxuICAgIHJldHVybiB0bztcclxufTtcclxudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcclxudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcclxudmFyIF9fZ2V0T3duUHJvcERlc2NzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XHJcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcclxudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XHJcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xyXG52YXIgX19kZWZOb3JtYWxQcm9wID0gZnVuY3Rpb24gKG9iaiwga2V5LCB2YWx1ZSkgeyByZXR1cm4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlOyB9O1xyXG52YXIgX19zcHJlYWRWYWx1ZXMgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxyXG4gICAgICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcclxuICAgICAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xyXG4gICAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYyA9IF9fZ2V0T3duUHJvcFN5bWJvbHMoYik7IF9pIDwgX2MubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwcm9wID0gX2NbX2ldO1xyXG4gICAgICAgICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXHJcbiAgICAgICAgICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIGE7XHJcbn07XHJcbnZhciBfX3NwcmVhZFByb3BzID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpOyB9O1xyXG52YXIgX19hc3luYyA9IGZ1bmN0aW9uIChfX3RoaXMsIF9fYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgdmFyIGZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciByZWplY3RlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgc3RlcChnZW5lcmF0b3IudGhyb3codmFsdWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgc3RlcCA9IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmRvbmUgPyByZXNvbHZlKHgudmFsdWUpIDogUHJvbWlzZS5yZXNvbHZlKHgudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH07XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KF9fdGhpcywgX19hcmd1bWVudHMpKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn07XHJcbi8vIHNyYy9pbmRleC50c1xyXG5pbXBvcnQgeyBlbmFibGVFUzUgfSBmcm9tIFwiaW1tZXJcIjtcclxuZXhwb3J0ICogZnJvbSBcInJlZHV4XCI7XHJcbmltcG9ydCB7IGRlZmF1bHQgYXMgZGVmYXVsdDIsIGN1cnJlbnQgYXMgY3VycmVudDIsIGZyZWV6ZSwgb3JpZ2luYWwsIGlzRHJhZnQgYXMgaXNEcmFmdDQgfSBmcm9tIFwiaW1tZXJcIjtcclxuaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3IgYXMgY3JlYXRlU2VsZWN0b3IyIH0gZnJvbSBcInJlc2VsZWN0XCI7XHJcbi8vIHNyYy9jcmVhdGVEcmFmdFNhZmVTZWxlY3Rvci50c1xyXG5pbXBvcnQgeyBjdXJyZW50LCBpc0RyYWZ0IH0gZnJvbSBcImltbWVyXCI7XHJcbmltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yIH0gZnJvbSBcInJlc2VsZWN0XCI7XHJcbnZhciBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBhcmdzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHZhciBzZWxlY3RvciA9IGNyZWF0ZVNlbGVjdG9yLmFwcGx5KHZvaWQgMCwgYXJncyk7XHJcbiAgICB2YXIgd3JhcHBlZFNlbGVjdG9yID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIHJlc3QgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICByZXN0W19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VsZWN0b3IuYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFtpc0RyYWZ0KHZhbHVlKSA/IGN1cnJlbnQodmFsdWUpIDogdmFsdWVdLCByZXN0KSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHdyYXBwZWRTZWxlY3RvcjtcclxufTtcclxuLy8gc3JjL2NvbmZpZ3VyZVN0b3JlLnRzXHJcbmltcG9ydCB7IGNyZWF0ZVN0b3JlLCBjb21wb3NlIGFzIGNvbXBvc2UyLCBhcHBseU1pZGRsZXdhcmUsIGNvbWJpbmVSZWR1Y2VycyB9IGZyb20gXCJyZWR1eFwiO1xyXG4vLyBzcmMvZGV2dG9vbHNFeHRlbnNpb24udHNcclxuaW1wb3J0IHsgY29tcG9zZSB9IGZyb20gXCJyZWR1eFwiO1xyXG52YXIgY29tcG9zZVdpdGhEZXZUb29scyA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX0NPTVBPU0VfXyA/IHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9DT01QT1NFX18gOiBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcclxuICAgICAgICByZXR1cm4gdm9pZCAwO1xyXG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09IFwib2JqZWN0XCIpXHJcbiAgICAgICAgcmV0dXJuIGNvbXBvc2U7XHJcbiAgICByZXR1cm4gY29tcG9zZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG59O1xyXG52YXIgZGV2VG9vbHNFbmhhbmNlciA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18gPyB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fXyA6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAobm9vcDIpIHtcclxuICAgICAgICByZXR1cm4gbm9vcDI7XHJcbiAgICB9O1xyXG59O1xyXG4vLyBzcmMvaXNQbGFpbk9iamVjdC50c1xyXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09PSBudWxsKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSk7XHJcbiAgICBpZiAocHJvdG8gPT09IG51bGwpXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB2YXIgYmFzZVByb3RvID0gcHJvdG87XHJcbiAgICB3aGlsZSAoT2JqZWN0LmdldFByb3RvdHlwZU9mKGJhc2VQcm90bykgIT09IG51bGwpIHtcclxuICAgICAgICBiYXNlUHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYmFzZVByb3RvKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwcm90byA9PT0gYmFzZVByb3RvO1xyXG59XHJcbi8vIHNyYy9nZXREZWZhdWx0TWlkZGxld2FyZS50c1xyXG5pbXBvcnQgdGh1bmtNaWRkbGV3YXJlIGZyb20gXCJyZWR1eC10aHVua1wiO1xyXG4vLyBzcmMvdHNIZWxwZXJzLnRzXHJcbnZhciBoYXNNYXRjaEZ1bmN0aW9uID0gZnVuY3Rpb24gKHYpIHtcclxuICAgIHJldHVybiB2ICYmIHR5cGVvZiB2Lm1hdGNoID09PSBcImZ1bmN0aW9uXCI7XHJcbn07XHJcbi8vIHNyYy9jcmVhdGVBY3Rpb24udHNcclxuZnVuY3Rpb24gY3JlYXRlQWN0aW9uKHR5cGUsIHByZXBhcmVBY3Rpb24pIHtcclxuICAgIGZ1bmN0aW9uIGFjdGlvbkNyZWF0b3IoKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcmVwYXJlQWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBwcmVwYXJlZCA9IHByZXBhcmVBY3Rpb24uYXBwbHkodm9pZCAwLCBhcmdzKTtcclxuICAgICAgICAgICAgaWYgKCFwcmVwYXJlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHJlcGFyZUFjdGlvbiBkaWQgbm90IHJldHVybiBhbiBvYmplY3RcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXHJcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiBwcmVwYXJlZC5wYXlsb2FkXHJcbiAgICAgICAgICAgIH0sIFwibWV0YVwiIGluIHByZXBhcmVkICYmIHsgbWV0YTogcHJlcGFyZWQubWV0YSB9KSwgXCJlcnJvclwiIGluIHByZXBhcmVkICYmIHsgZXJyb3I6IHByZXBhcmVkLmVycm9yIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyB0eXBlOiB0eXBlLCBwYXlsb2FkOiBhcmdzWzBdIH07XHJcbiAgICB9XHJcbiAgICBhY3Rpb25DcmVhdG9yLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJcIiArIHR5cGU7IH07XHJcbiAgICBhY3Rpb25DcmVhdG9yLnR5cGUgPSB0eXBlO1xyXG4gICAgYWN0aW9uQ3JlYXRvci5tYXRjaCA9IGZ1bmN0aW9uIChhY3Rpb24pIHsgcmV0dXJuIGFjdGlvbi50eXBlID09PSB0eXBlOyB9O1xyXG4gICAgcmV0dXJuIGFjdGlvbkNyZWF0b3I7XHJcbn1cclxuZnVuY3Rpb24gaXNBY3Rpb24oYWN0aW9uKSB7XHJcbiAgICByZXR1cm4gaXNQbGFpbk9iamVjdChhY3Rpb24pICYmIFwidHlwZVwiIGluIGFjdGlvbjtcclxufVxyXG5mdW5jdGlvbiBpc0FjdGlvbkNyZWF0b3IoYWN0aW9uKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIGFjdGlvbiA9PT0gXCJmdW5jdGlvblwiICYmIFwidHlwZVwiIGluIGFjdGlvbiAmJiBoYXNNYXRjaEZ1bmN0aW9uKGFjdGlvbik7XHJcbn1cclxuZnVuY3Rpb24gaXNGU0EoYWN0aW9uKSB7XHJcbiAgICByZXR1cm4gaXNBY3Rpb24oYWN0aW9uKSAmJiB0eXBlb2YgYWN0aW9uLnR5cGUgPT09IFwic3RyaW5nXCIgJiYgT2JqZWN0LmtleXMoYWN0aW9uKS5ldmVyeShpc1ZhbGlkS2V5KTtcclxufVxyXG5mdW5jdGlvbiBpc1ZhbGlkS2V5KGtleSkge1xyXG4gICAgcmV0dXJuIFtcInR5cGVcIiwgXCJwYXlsb2FkXCIsIFwiZXJyb3JcIiwgXCJtZXRhXCJdLmluZGV4T2Yoa2V5KSA+IC0xO1xyXG59XHJcbmZ1bmN0aW9uIGdldFR5cGUoYWN0aW9uQ3JlYXRvcikge1xyXG4gICAgcmV0dXJuIFwiXCIgKyBhY3Rpb25DcmVhdG9yO1xyXG59XHJcbi8vIHNyYy9hY3Rpb25DcmVhdG9ySW52YXJpYW50TWlkZGxld2FyZS50c1xyXG5mdW5jdGlvbiBnZXRNZXNzYWdlKHR5cGUpIHtcclxuICAgIHZhciBzcGxpdFR5cGUgPSB0eXBlID8gKFwiXCIgKyB0eXBlKS5zcGxpdChcIi9cIikgOiBbXTtcclxuICAgIHZhciBhY3Rpb25OYW1lID0gc3BsaXRUeXBlW3NwbGl0VHlwZS5sZW5ndGggLSAxXSB8fCBcImFjdGlvbkNyZWF0b3JcIjtcclxuICAgIHJldHVybiBcIkRldGVjdGVkIGFuIGFjdGlvbiBjcmVhdG9yIHdpdGggdHlwZSBcXFwiXCIgKyAodHlwZSB8fCBcInVua25vd25cIikgKyBcIlxcXCIgYmVpbmcgZGlzcGF0Y2hlZC4gXFxuTWFrZSBzdXJlIHlvdSdyZSBjYWxsaW5nIHRoZSBhY3Rpb24gY3JlYXRvciBiZWZvcmUgZGlzcGF0Y2hpbmcsIGkuZS4gYGRpc3BhdGNoKFwiICsgYWN0aW9uTmFtZSArIFwiKCkpYCBpbnN0ZWFkIG9mIGBkaXNwYXRjaChcIiArIGFjdGlvbk5hbWUgKyBcIilgLiBUaGlzIGlzIG5lY2Vzc2FyeSBldmVuIGlmIHRoZSBhY3Rpb24gaGFzIG5vIHBheWxvYWQuXCI7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQWN0aW9uQ3JlYXRvckludmFyaWFudE1pZGRsZXdhcmUob3B0aW9ucykge1xyXG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHsgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHsgcmV0dXJuIG5leHQoYWN0aW9uKTsgfTsgfTsgfTtcclxuICAgIH1cclxuICAgIHZhciBfYyA9IG9wdGlvbnMuaXNBY3Rpb25DcmVhdG9yLCBpc0FjdGlvbkNyZWF0b3IyID0gX2MgPT09IHZvaWQgMCA/IGlzQWN0aW9uQ3JlYXRvciA6IF9jO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7IHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKGlzQWN0aW9uQ3JlYXRvcjIoYWN0aW9uKSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oZ2V0TWVzc2FnZShhY3Rpb24udHlwZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xyXG4gICAgfTsgfTsgfTtcclxufVxyXG4vLyBzcmMvdXRpbHMudHNcclxuaW1wb3J0IGNyZWF0ZU5leHRTdGF0ZSwgeyBpc0RyYWZ0YWJsZSB9IGZyb20gXCJpbW1lclwiO1xyXG5mdW5jdGlvbiBnZXRUaW1lTWVhc3VyZVV0aWxzKG1heERlbGF5LCBmbk5hbWUpIHtcclxuICAgIHZhciBlbGFwc2VkID0gMDtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbWVhc3VyZVRpbWU6IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgICAgICB2YXIgc3RhcnRlZCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgIHZhciBmaW5pc2hlZCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICBlbGFwc2VkICs9IGZpbmlzaGVkIC0gc3RhcnRlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgd2FybklmRXhjZWVkZWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKGVsYXBzZWQgPiBtYXhEZWxheSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGZuTmFtZSArIFwiIHRvb2sgXCIgKyBlbGFwc2VkICsgXCJtcywgd2hpY2ggaXMgbW9yZSB0aGFuIHRoZSB3YXJuaW5nIHRocmVzaG9sZCBvZiBcIiArIG1heERlbGF5ICsgXCJtcy4gXFxuSWYgeW91ciBzdGF0ZSBvciBhY3Rpb25zIGFyZSB2ZXJ5IGxhcmdlLCB5b3UgbWF5IHdhbnQgdG8gZGlzYWJsZSB0aGUgbWlkZGxld2FyZSBhcyBpdCBtaWdodCBjYXVzZSB0b28gbXVjaCBvZiBhIHNsb3dkb3duIGluIGRldmVsb3BtZW50IG1vZGUuIFNlZSBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL2FwaS9nZXREZWZhdWx0TWlkZGxld2FyZSBmb3IgaW5zdHJ1Y3Rpb25zLlxcbkl0IGlzIGRpc2FibGVkIGluIHByb2R1Y3Rpb24gYnVpbGRzLCBzbyB5b3UgZG9uJ3QgbmVlZCB0byB3b3JyeSBhYm91dCB0aGF0LlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxudmFyIE1pZGRsZXdhcmVBcnJheSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNaWRkbGV3YXJlQXJyYXksIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNaWRkbGV3YXJlQXJyYXkoKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCBhcmdzKSB8fCB0aGlzO1xyXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgTWlkZGxld2FyZUFycmF5LnByb3RvdHlwZSk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1pZGRsZXdhcmVBcnJheSwgU3ltYm9sLnNwZWNpZXMsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1pZGRsZXdhcmVBcnJheTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBNaWRkbGV3YXJlQXJyYXkucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYXJyID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJyW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmNvbmNhdC5hcHBseSh0aGlzLCBhcnIpO1xyXG4gICAgfTtcclxuICAgIE1pZGRsZXdhcmVBcnJheS5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYXJyID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJyW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhcnIubGVuZ3RoID09PSAxICYmIEFycmF5LmlzQXJyYXkoYXJyWzBdKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IChNaWRkbGV3YXJlQXJyYXkuYmluZC5hcHBseShNaWRkbGV3YXJlQXJyYXksIF9fc3ByZWFkQXJyYXkoW3ZvaWQgMF0sIGFyclswXS5jb25jYXQodGhpcykpKSkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyAoTWlkZGxld2FyZUFycmF5LmJpbmQuYXBwbHkoTWlkZGxld2FyZUFycmF5LCBfX3NwcmVhZEFycmF5KFt2b2lkIDBdLCBhcnIuY29uY2F0KHRoaXMpKSkpKCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE1pZGRsZXdhcmVBcnJheTtcclxufShBcnJheSkpO1xyXG52YXIgRW5oYW5jZXJBcnJheSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhFbmhhbmNlckFycmF5LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRW5oYW5jZXJBcnJheSgpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3MpIHx8IHRoaXM7XHJcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBFbmhhbmNlckFycmF5LnByb3RvdHlwZSk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVuaGFuY2VyQXJyYXksIFN5bWJvbC5zcGVjaWVzLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBFbmhhbmNlckFycmF5O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIEVuaGFuY2VyQXJyYXkucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYXJyID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJyW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmNvbmNhdC5hcHBseSh0aGlzLCBhcnIpO1xyXG4gICAgfTtcclxuICAgIEVuaGFuY2VyQXJyYXkucHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGFyciA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFycltfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYXJyLmxlbmd0aCA9PT0gMSAmJiBBcnJheS5pc0FycmF5KGFyclswXSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyAoRW5oYW5jZXJBcnJheS5iaW5kLmFwcGx5KEVuaGFuY2VyQXJyYXksIF9fc3ByZWFkQXJyYXkoW3ZvaWQgMF0sIGFyclswXS5jb25jYXQodGhpcykpKSkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyAoRW5oYW5jZXJBcnJheS5iaW5kLmFwcGx5KEVuaGFuY2VyQXJyYXksIF9fc3ByZWFkQXJyYXkoW3ZvaWQgMF0sIGFyci5jb25jYXQodGhpcykpKSkoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRW5oYW5jZXJBcnJheTtcclxufShBcnJheSkpO1xyXG5mdW5jdGlvbiBmcmVlemVEcmFmdGFibGUodmFsKSB7XHJcbiAgICByZXR1cm4gaXNEcmFmdGFibGUodmFsKSA/IGNyZWF0ZU5leHRTdGF0ZSh2YWwsIGZ1bmN0aW9uICgpIHtcclxuICAgIH0pIDogdmFsO1xyXG59XHJcbi8vIHNyYy9pbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUudHNcclxudmFyIGlzUHJvZHVjdGlvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIjtcclxudmFyIHByZWZpeCA9IFwiSW52YXJpYW50IGZhaWxlZFwiO1xyXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XHJcbiAgICBpZiAoY29uZGl0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzUHJvZHVjdGlvbikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcmVmaXgpO1xyXG4gICAgfVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKHByZWZpeCArIFwiOiBcIiArIChtZXNzYWdlIHx8IFwiXCIpKTtcclxufVxyXG5mdW5jdGlvbiBzdHJpbmdpZnkob2JqLCBzZXJpYWxpemVyLCBpbmRlbnQsIGRlY3ljbGVyKSB7XHJcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqLCBnZXRTZXJpYWxpemUoc2VyaWFsaXplciwgZGVjeWNsZXIpLCBpbmRlbnQpO1xyXG59XHJcbmZ1bmN0aW9uIGdldFNlcmlhbGl6ZShzZXJpYWxpemVyLCBkZWN5Y2xlcikge1xyXG4gICAgdmFyIHN0YWNrID0gW10sIGtleXMgPSBbXTtcclxuICAgIGlmICghZGVjeWNsZXIpXHJcbiAgICAgICAgZGVjeWNsZXIgPSBmdW5jdGlvbiAoXywgdmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHN0YWNrWzBdID09PSB2YWx1ZSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIltDaXJjdWxhciB+XVwiO1xyXG4gICAgICAgICAgICByZXR1cm4gXCJbQ2lyY3VsYXIgfi5cIiArIGtleXMuc2xpY2UoMCwgc3RhY2suaW5kZXhPZih2YWx1ZSkpLmpvaW4oXCIuXCIpICsgXCJdXCI7XHJcbiAgICAgICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHZhciB0aGlzUG9zID0gc3RhY2suaW5kZXhPZih0aGlzKTtcclxuICAgICAgICAgICAgfnRoaXNQb3MgPyBzdGFjay5zcGxpY2UodGhpc1BvcyArIDEpIDogc3RhY2sucHVzaCh0aGlzKTtcclxuICAgICAgICAgICAgfnRoaXNQb3MgPyBrZXlzLnNwbGljZSh0aGlzUG9zLCBJbmZpbml0eSwga2V5KSA6IGtleXMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICBpZiAofnN0YWNrLmluZGV4T2YodmFsdWUpKVxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBkZWN5Y2xlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHN0YWNrLnB1c2godmFsdWUpO1xyXG4gICAgICAgIHJldHVybiBzZXJpYWxpemVyID09IG51bGwgPyB2YWx1ZSA6IHNlcmlhbGl6ZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaXNJbW11dGFibGVEZWZhdWx0KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09IG51bGwgfHwgT2JqZWN0LmlzRnJvemVuKHZhbHVlKTtcclxufVxyXG5mdW5jdGlvbiB0cmFja0Zvck11dGF0aW9ucyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMsIG9iaikge1xyXG4gICAgdmFyIHRyYWNrZWRQcm9wZXJ0aWVzID0gdHJhY2tQcm9wZXJ0aWVzKGlzSW1tdXRhYmxlLCBpZ25vcmVQYXRocywgb2JqKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZGV0ZWN0TXV0YXRpb25zOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkZXRlY3RNdXRhdGlvbnMoaXNJbW11dGFibGUsIGlnbm9yZVBhdGhzLCB0cmFja2VkUHJvcGVydGllcywgb2JqKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHRyYWNrUHJvcGVydGllcyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMsIG9iaiwgcGF0aCwgY2hlY2tlZE9iamVjdHMpIHtcclxuICAgIGlmIChpZ25vcmVQYXRocyA9PT0gdm9pZCAwKSB7IGlnbm9yZVBhdGhzID0gW107IH1cclxuICAgIGlmIChwYXRoID09PSB2b2lkIDApIHsgcGF0aCA9IFwiXCI7IH1cclxuICAgIGlmIChjaGVja2VkT2JqZWN0cyA9PT0gdm9pZCAwKSB7IGNoZWNrZWRPYmplY3RzID0gbmV3IFNldCgpOyB9XHJcbiAgICB2YXIgdHJhY2tlZCA9IHsgdmFsdWU6IG9iaiB9O1xyXG4gICAgaWYgKCFpc0ltbXV0YWJsZShvYmopICYmICFjaGVja2VkT2JqZWN0cy5oYXMob2JqKSkge1xyXG4gICAgICAgIGNoZWNrZWRPYmplY3RzLmFkZChvYmopO1xyXG4gICAgICAgIHRyYWNrZWQuY2hpbGRyZW4gPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZFBhdGggPSBwYXRoID8gcGF0aCArIFwiLlwiICsga2V5IDoga2V5O1xyXG4gICAgICAgICAgICBpZiAoaWdub3JlUGF0aHMubGVuZ3RoICYmIGlnbm9yZVBhdGhzLmluZGV4T2YoY2hpbGRQYXRoKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyYWNrZWQuY2hpbGRyZW5ba2V5XSA9IHRyYWNrUHJvcGVydGllcyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMsIG9ialtrZXldLCBjaGlsZFBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cmFja2VkO1xyXG59XHJcbmZ1bmN0aW9uIGRldGVjdE11dGF0aW9ucyhpc0ltbXV0YWJsZSwgaWdub3JlZFBhdGhzLCB0cmFja2VkUHJvcGVydHksIG9iaiwgc2FtZVBhcmVudFJlZiwgcGF0aCkge1xyXG4gICAgaWYgKGlnbm9yZWRQYXRocyA9PT0gdm9pZCAwKSB7IGlnbm9yZWRQYXRocyA9IFtdOyB9XHJcbiAgICBpZiAoc2FtZVBhcmVudFJlZiA9PT0gdm9pZCAwKSB7IHNhbWVQYXJlbnRSZWYgPSBmYWxzZTsgfVxyXG4gICAgaWYgKHBhdGggPT09IHZvaWQgMCkgeyBwYXRoID0gXCJcIjsgfVxyXG4gICAgdmFyIHByZXZPYmogPSB0cmFja2VkUHJvcGVydHkgPyB0cmFja2VkUHJvcGVydHkudmFsdWUgOiB2b2lkIDA7XHJcbiAgICB2YXIgc2FtZVJlZiA9IHByZXZPYmogPT09IG9iajtcclxuICAgIGlmIChzYW1lUGFyZW50UmVmICYmICFzYW1lUmVmICYmICFOdW1iZXIuaXNOYU4ob2JqKSkge1xyXG4gICAgICAgIHJldHVybiB7IHdhc011dGF0ZWQ6IHRydWUsIHBhdGg6IHBhdGggfTtcclxuICAgIH1cclxuICAgIGlmIChpc0ltbXV0YWJsZShwcmV2T2JqKSB8fCBpc0ltbXV0YWJsZShvYmopKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgd2FzTXV0YXRlZDogZmFsc2UgfTtcclxuICAgIH1cclxuICAgIHZhciBrZXlzVG9EZXRlY3QgPSB7fTtcclxuICAgIGZvciAodmFyIGtleSBpbiB0cmFja2VkUHJvcGVydHkuY2hpbGRyZW4pIHtcclxuICAgICAgICBrZXlzVG9EZXRlY3Rba2V5XSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAga2V5c1RvRGV0ZWN0W2tleV0gPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgdmFyIGhhc0lnbm9yZWRQYXRocyA9IGlnbm9yZWRQYXRocy5sZW5ndGggPiAwO1xyXG4gICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgdmFyIG5lc3RlZFBhdGggPSBwYXRoID8gcGF0aCArIFwiLlwiICsga2V5IDoga2V5O1xyXG4gICAgICAgIGlmIChoYXNJZ25vcmVkUGF0aHMpIHtcclxuICAgICAgICAgICAgdmFyIGhhc01hdGNoZXMgPSBpZ25vcmVkUGF0aHMuc29tZShmdW5jdGlvbiAoaWdub3JlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlnbm9yZWQgaW5zdGFuY2VvZiBSZWdFeHApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWdub3JlZC50ZXN0KG5lc3RlZFBhdGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5lc3RlZFBhdGggPT09IGlnbm9yZWQ7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoaGFzTWF0Y2hlcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVzdWx0ID0gZGV0ZWN0TXV0YXRpb25zKGlzSW1tdXRhYmxlLCBpZ25vcmVkUGF0aHMsIHRyYWNrZWRQcm9wZXJ0eS5jaGlsZHJlbltrZXldLCBvYmpba2V5XSwgc2FtZVJlZiwgbmVzdGVkUGF0aCk7XHJcbiAgICAgICAgaWYgKHJlc3VsdC53YXNNdXRhdGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiByZXN1bHQgfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZm9yICh2YXIga2V5IGluIGtleXNUb0RldGVjdCkge1xyXG4gICAgICAgIHZhciBzdGF0ZV8xID0gX2xvb3BfMShrZXkpO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdGVfMSA9PT0gXCJvYmplY3RcIilcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlXzEudmFsdWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyB3YXNNdXRhdGVkOiBmYWxzZSB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZShvcHRpb25zKSB7XHJcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAobmV4dCkgeyByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikgeyByZXR1cm4gbmV4dChhY3Rpb24pOyB9OyB9OyB9O1xyXG4gICAgfVxyXG4gICAgdmFyIF9jID0gb3B0aW9ucy5pc0ltbXV0YWJsZSwgaXNJbW11dGFibGUgPSBfYyA9PT0gdm9pZCAwID8gaXNJbW11dGFibGVEZWZhdWx0IDogX2MsIGlnbm9yZWRQYXRocyA9IG9wdGlvbnMuaWdub3JlZFBhdGhzLCBfZCA9IG9wdGlvbnMud2FybkFmdGVyLCB3YXJuQWZ0ZXIgPSBfZCA9PT0gdm9pZCAwID8gMzIgOiBfZCwgaWdub3JlID0gb3B0aW9ucy5pZ25vcmU7XHJcbiAgICBpZ25vcmVkUGF0aHMgPSBpZ25vcmVkUGF0aHMgfHwgaWdub3JlO1xyXG4gICAgdmFyIHRyYWNrID0gdHJhY2tGb3JNdXRhdGlvbnMuYmluZChudWxsLCBpc0ltbXV0YWJsZSwgaWdub3JlZFBhdGhzKTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoX2MpIHtcclxuICAgICAgICB2YXIgZ2V0U3RhdGUgPSBfYy5nZXRTdGF0ZTtcclxuICAgICAgICB2YXIgc3RhdGUgPSBnZXRTdGF0ZSgpO1xyXG4gICAgICAgIHZhciB0cmFja2VyID0gdHJhY2soc3RhdGUpO1xyXG4gICAgICAgIHZhciByZXN1bHQ7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7IHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBtZWFzdXJlVXRpbHMgPSBnZXRUaW1lTWVhc3VyZVV0aWxzKHdhcm5BZnRlciwgXCJJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmVcIik7XHJcbiAgICAgICAgICAgIG1lYXN1cmVVdGlscy5tZWFzdXJlVGltZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IGdldFN0YXRlKCk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0cmFja2VyLmRldGVjdE11dGF0aW9ucygpO1xyXG4gICAgICAgICAgICAgICAgdHJhY2tlciA9IHRyYWNrKHN0YXRlKTtcclxuICAgICAgICAgICAgICAgIGludmFyaWFudCghcmVzdWx0Lndhc011dGF0ZWQsIFwiQSBzdGF0ZSBtdXRhdGlvbiB3YXMgZGV0ZWN0ZWQgYmV0d2VlbiBkaXNwYXRjaGVzLCBpbiB0aGUgcGF0aCAnXCIgKyAocmVzdWx0LnBhdGggfHwgXCJcIikgKyBcIicuICBUaGlzIG1heSBjYXVzZSBpbmNvcnJlY3QgYmVoYXZpb3IuIChodHRwczovL3JlZHV4LmpzLm9yZy9zdHlsZS1ndWlkZS9zdHlsZS1ndWlkZSNkby1ub3QtbXV0YXRlLXN0YXRlKVwiKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHZhciBkaXNwYXRjaGVkQWN0aW9uID0gbmV4dChhY3Rpb24pO1xyXG4gICAgICAgICAgICBtZWFzdXJlVXRpbHMubWVhc3VyZVRpbWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgc3RhdGUgPSBnZXRTdGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJhY2tlci5kZXRlY3RNdXRhdGlvbnMoKTtcclxuICAgICAgICAgICAgICAgIHRyYWNrZXIgPSB0cmFjayhzdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQud2FzTXV0YXRlZCAmJiBpbnZhcmlhbnQoIXJlc3VsdC53YXNNdXRhdGVkLCBcIkEgc3RhdGUgbXV0YXRpb24gd2FzIGRldGVjdGVkIGluc2lkZSBhIGRpc3BhdGNoLCBpbiB0aGUgcGF0aDogXCIgKyAocmVzdWx0LnBhdGggfHwgXCJcIikgKyBcIi4gVGFrZSBhIGxvb2sgYXQgdGhlIHJlZHVjZXIocykgaGFuZGxpbmcgdGhlIGFjdGlvbiBcIiArIHN0cmluZ2lmeShhY3Rpb24pICsgXCIuIChodHRwczovL3JlZHV4LmpzLm9yZy9zdHlsZS1ndWlkZS9zdHlsZS1ndWlkZSNkby1ub3QtbXV0YXRlLXN0YXRlKVwiKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIG1lYXN1cmVVdGlscy53YXJuSWZFeGNlZWRlZCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gZGlzcGF0Y2hlZEFjdGlvbjtcclxuICAgICAgICB9OyB9O1xyXG4gICAgfTtcclxufVxyXG4vLyBzcmMvc2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlLnRzXHJcbmZ1bmN0aW9uIGlzUGxhaW4odmFsKSB7XHJcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XHJcbiAgICByZXR1cm4gdmFsID09IG51bGwgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlID09PSBcImJvb2xlYW5cIiB8fCB0eXBlID09PSBcIm51bWJlclwiIHx8IEFycmF5LmlzQXJyYXkodmFsKSB8fCBpc1BsYWluT2JqZWN0KHZhbCk7XHJcbn1cclxuZnVuY3Rpb24gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKHZhbHVlLCBwYXRoLCBpc1NlcmlhbGl6YWJsZSwgZ2V0RW50cmllcywgaWdub3JlZFBhdGhzLCBjYWNoZSkge1xyXG4gICAgaWYgKHBhdGggPT09IHZvaWQgMCkgeyBwYXRoID0gXCJcIjsgfVxyXG4gICAgaWYgKGlzU2VyaWFsaXphYmxlID09PSB2b2lkIDApIHsgaXNTZXJpYWxpemFibGUgPSBpc1BsYWluOyB9XHJcbiAgICBpZiAoaWdub3JlZFBhdGhzID09PSB2b2lkIDApIHsgaWdub3JlZFBhdGhzID0gW107IH1cclxuICAgIHZhciBmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZTtcclxuICAgIGlmICghaXNTZXJpYWxpemFibGUodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAga2V5UGF0aDogcGF0aCB8fCBcIjxyb290PlwiLFxyXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChjYWNoZSA9PSBudWxsID8gdm9pZCAwIDogY2FjaGUuaGFzKHZhbHVlKSlcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB2YXIgZW50cmllcyA9IGdldEVudHJpZXMgIT0gbnVsbCA/IGdldEVudHJpZXModmFsdWUpIDogT2JqZWN0LmVudHJpZXModmFsdWUpO1xyXG4gICAgdmFyIGhhc0lnbm9yZWRQYXRocyA9IGlnbm9yZWRQYXRocy5sZW5ndGggPiAwO1xyXG4gICAgdmFyIF9sb29wXzIgPSBmdW5jdGlvbiAoa2V5LCBuZXN0ZWRWYWx1ZSkge1xyXG4gICAgICAgIHZhciBuZXN0ZWRQYXRoID0gcGF0aCA/IHBhdGggKyBcIi5cIiArIGtleSA6IGtleTtcclxuICAgICAgICBpZiAoaGFzSWdub3JlZFBhdGhzKSB7XHJcbiAgICAgICAgICAgIHZhciBoYXNNYXRjaGVzID0gaWdub3JlZFBhdGhzLnNvbWUoZnVuY3Rpb24gKGlnbm9yZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpZ25vcmVkIGluc3RhbmNlb2YgUmVnRXhwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlnbm9yZWQudGVzdChuZXN0ZWRQYXRoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXN0ZWRQYXRoID09PSBpZ25vcmVkO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKGhhc01hdGNoZXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc1NlcmlhbGl6YWJsZShuZXN0ZWRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHtcclxuICAgICAgICAgICAgICAgICAgICBrZXlQYXRoOiBuZXN0ZWRQYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXN0ZWRWYWx1ZVxyXG4gICAgICAgICAgICAgICAgfSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIG5lc3RlZFZhbHVlID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgIGZvdW5kTmVzdGVkU2VyaWFsaXphYmxlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKG5lc3RlZFZhbHVlLCBuZXN0ZWRQYXRoLCBpc1NlcmlhbGl6YWJsZSwgZ2V0RW50cmllcywgaWdub3JlZFBhdGhzLCBjYWNoZSk7XHJcbiAgICAgICAgICAgIGlmIChmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGZvdW5kTmVzdGVkU2VyaWFsaXphYmxlIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZm9yICh2YXIgX2kgPSAwLCBlbnRyaWVzXzEgPSBlbnRyaWVzOyBfaSA8IGVudHJpZXNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICB2YXIgX2MgPSBlbnRyaWVzXzFbX2ldLCBrZXkgPSBfY1swXSwgbmVzdGVkVmFsdWUgPSBfY1sxXTtcclxuICAgICAgICB2YXIgc3RhdGVfMiA9IF9sb29wXzIoa2V5LCBuZXN0ZWRWYWx1ZSk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZV8yID09PSBcIm9iamVjdFwiKVxyXG4gICAgICAgICAgICByZXR1cm4gc3RhdGVfMi52YWx1ZTtcclxuICAgIH1cclxuICAgIGlmIChjYWNoZSAmJiBpc05lc3RlZEZyb3plbih2YWx1ZSkpXHJcbiAgICAgICAgY2FjaGUuYWRkKHZhbHVlKTtcclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBpc05lc3RlZEZyb3plbih2YWx1ZSkge1xyXG4gICAgaWYgKCFPYmplY3QuaXNGcm96ZW4odmFsdWUpKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIGZvciAodmFyIF9pID0gMCwgX2MgPSBPYmplY3QudmFsdWVzKHZhbHVlKTsgX2kgPCBfYy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICB2YXIgbmVzdGVkVmFsdWUgPSBfY1tfaV07XHJcbiAgICAgICAgaWYgKHR5cGVvZiBuZXN0ZWRWYWx1ZSAhPT0gXCJvYmplY3RcIiB8fCBuZXN0ZWRWYWx1ZSA9PT0gbnVsbClcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgaWYgKCFpc05lc3RlZEZyb3plbihuZXN0ZWRWYWx1ZSkpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZShvcHRpb25zKSB7XHJcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAobmV4dCkgeyByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikgeyByZXR1cm4gbmV4dChhY3Rpb24pOyB9OyB9OyB9O1xyXG4gICAgfVxyXG4gICAgdmFyIF9jID0gb3B0aW9ucy5pc1NlcmlhbGl6YWJsZSwgaXNTZXJpYWxpemFibGUgPSBfYyA9PT0gdm9pZCAwID8gaXNQbGFpbiA6IF9jLCBnZXRFbnRyaWVzID0gb3B0aW9ucy5nZXRFbnRyaWVzLCBfZCA9IG9wdGlvbnMuaWdub3JlZEFjdGlvbnMsIGlnbm9yZWRBY3Rpb25zID0gX2QgPT09IHZvaWQgMCA/IFtdIDogX2QsIF9lID0gb3B0aW9ucy5pZ25vcmVkQWN0aW9uUGF0aHMsIGlnbm9yZWRBY3Rpb25QYXRocyA9IF9lID09PSB2b2lkIDAgPyBbXCJtZXRhLmFyZ1wiLCBcIm1ldGEuYmFzZVF1ZXJ5TWV0YVwiXSA6IF9lLCBfZiA9IG9wdGlvbnMuaWdub3JlZFBhdGhzLCBpZ25vcmVkUGF0aHMgPSBfZiA9PT0gdm9pZCAwID8gW10gOiBfZiwgX2cgPSBvcHRpb25zLndhcm5BZnRlciwgd2FybkFmdGVyID0gX2cgPT09IHZvaWQgMCA/IDMyIDogX2csIF9oID0gb3B0aW9ucy5pZ25vcmVTdGF0ZSwgaWdub3JlU3RhdGUgPSBfaCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfaCwgX2ogPSBvcHRpb25zLmlnbm9yZUFjdGlvbnMsIGlnbm9yZUFjdGlvbnMgPSBfaiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfaiwgX2sgPSBvcHRpb25zLmRpc2FibGVDYWNoZSwgZGlzYWJsZUNhY2hlID0gX2sgPT09IHZvaWQgMCA/IGZhbHNlIDogX2s7XHJcbiAgICB2YXIgY2FjaGUgPSAhZGlzYWJsZUNhY2hlICYmIFdlYWtTZXQgPyBuZXcgV2Vha1NldCgpIDogdm9pZCAwO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdG9yZUFQSSkgeyByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHsgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV4dChhY3Rpb24pO1xyXG4gICAgICAgIHZhciBtZWFzdXJlVXRpbHMgPSBnZXRUaW1lTWVhc3VyZVV0aWxzKHdhcm5BZnRlciwgXCJTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmVcIik7XHJcbiAgICAgICAgaWYgKCFpZ25vcmVBY3Rpb25zICYmICEoaWdub3JlZEFjdGlvbnMubGVuZ3RoICYmIGlnbm9yZWRBY3Rpb25zLmluZGV4T2YoYWN0aW9uLnR5cGUpICE9PSAtMSkpIHtcclxuICAgICAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKGFjdGlvbiwgXCJcIiwgaXNTZXJpYWxpemFibGUsIGdldEVudHJpZXMsIGlnbm9yZWRBY3Rpb25QYXRocywgY2FjaGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kQWN0aW9uTm9uU2VyaWFsaXphYmxlVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIga2V5UGF0aCA9IGZvdW5kQWN0aW9uTm9uU2VyaWFsaXphYmxlVmFsdWUua2V5UGF0aCwgdmFsdWUgPSBmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJBIG5vbi1zZXJpYWxpemFibGUgdmFsdWUgd2FzIGRldGVjdGVkIGluIGFuIGFjdGlvbiwgaW4gdGhlIHBhdGg6IGBcIiArIGtleVBhdGggKyBcImAuIFZhbHVlOlwiLCB2YWx1ZSwgXCJcXG5UYWtlIGEgbG9vayBhdCB0aGUgbG9naWMgdGhhdCBkaXNwYXRjaGVkIHRoaXMgYWN0aW9uOiBcIiwgYWN0aW9uLCBcIlxcbihTZWUgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvZmFxL2FjdGlvbnMjd2h5LXNob3VsZC10eXBlLWJlLWEtc3RyaW5nLW9yLWF0LWxlYXN0LXNlcmlhbGl6YWJsZS13aHktc2hvdWxkLW15LWFjdGlvbi10eXBlcy1iZS1jb25zdGFudHMpXCIsIFwiXFxuKFRvIGFsbG93IG5vbi1zZXJpYWxpemFibGUgdmFsdWVzIHNlZTogaHR0cHM6Ly9yZWR1eC10b29sa2l0LmpzLm9yZy91c2FnZS91c2FnZS1ndWlkZSN3b3JraW5nLXdpdGgtbm9uLXNlcmlhbGl6YWJsZS1kYXRhKVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaWdub3JlU3RhdGUpIHtcclxuICAgICAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IHN0b3JlQVBJLmdldFN0YXRlKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZm91bmRTdGF0ZU5vblNlcmlhbGl6YWJsZVZhbHVlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKHN0YXRlLCBcIlwiLCBpc1NlcmlhbGl6YWJsZSwgZ2V0RW50cmllcywgaWdub3JlZFBhdGhzLCBjYWNoZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZm91bmRTdGF0ZU5vblNlcmlhbGl6YWJsZVZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleVBhdGggPSBmb3VuZFN0YXRlTm9uU2VyaWFsaXphYmxlVmFsdWUua2V5UGF0aCwgdmFsdWUgPSBmb3VuZFN0YXRlTm9uU2VyaWFsaXphYmxlVmFsdWUudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkEgbm9uLXNlcmlhbGl6YWJsZSB2YWx1ZSB3YXMgZGV0ZWN0ZWQgaW4gdGhlIHN0YXRlLCBpbiB0aGUgcGF0aDogYFwiICsga2V5UGF0aCArIFwiYC4gVmFsdWU6XCIsIHZhbHVlLCBcIlxcblRha2UgYSBsb29rIGF0IHRoZSByZWR1Y2VyKHMpIGhhbmRsaW5nIHRoaXMgYWN0aW9uIHR5cGU6IFwiICsgYWN0aW9uLnR5cGUgKyBcIi5cXG4oU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL2ZhcS9vcmdhbml6aW5nLXN0YXRlI2Nhbi1pLXB1dC1mdW5jdGlvbnMtcHJvbWlzZXMtb3Itb3RoZXItbm9uLXNlcmlhbGl6YWJsZS1pdGVtcy1pbi1teS1zdG9yZS1zdGF0ZSlcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBtZWFzdXJlVXRpbHMud2FybklmRXhjZWVkZWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07IH07IH07XHJcbn1cclxuLy8gc3JjL2dldERlZmF1bHRNaWRkbGV3YXJlLnRzXHJcbmZ1bmN0aW9uIGlzQm9vbGVhbih4KSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHggPT09IFwiYm9vbGVhblwiO1xyXG59XHJcbmZ1bmN0aW9uIGN1cnJ5R2V0RGVmYXVsdE1pZGRsZXdhcmUoKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gY3VycmllZEdldERlZmF1bHRNaWRkbGV3YXJlKG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gZ2V0RGVmYXVsdE1pZGRsZXdhcmUob3B0aW9ucyk7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGdldERlZmF1bHRNaWRkbGV3YXJlKG9wdGlvbnMpIHtcclxuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XHJcbiAgICB2YXIgX2MgPSBvcHRpb25zLnRodW5rLCB0aHVuayA9IF9jID09PSB2b2lkIDAgPyB0cnVlIDogX2MsIF9kID0gb3B0aW9ucy5pbW11dGFibGVDaGVjaywgaW1tdXRhYmxlQ2hlY2sgPSBfZCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9kLCBfZSA9IG9wdGlvbnMuc2VyaWFsaXphYmxlQ2hlY2ssIHNlcmlhbGl6YWJsZUNoZWNrID0gX2UgPT09IHZvaWQgMCA/IHRydWUgOiBfZSwgX2YgPSBvcHRpb25zLmFjdGlvbkNyZWF0b3JDaGVjaywgYWN0aW9uQ3JlYXRvckNoZWNrID0gX2YgPT09IHZvaWQgMCA/IHRydWUgOiBfZjtcclxuICAgIHZhciBtaWRkbGV3YXJlQXJyYXkgPSBuZXcgTWlkZGxld2FyZUFycmF5KCk7XHJcbiAgICBpZiAodGh1bmspIHtcclxuICAgICAgICBpZiAoaXNCb29sZWFuKHRodW5rKSkge1xyXG4gICAgICAgICAgICBtaWRkbGV3YXJlQXJyYXkucHVzaCh0aHVua01pZGRsZXdhcmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbWlkZGxld2FyZUFycmF5LnB1c2godGh1bmtNaWRkbGV3YXJlLndpdGhFeHRyYUFyZ3VtZW50KHRodW5rLmV4dHJhQXJndW1lbnQpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgICAgaWYgKGltbXV0YWJsZUNoZWNrKSB7XHJcbiAgICAgICAgICAgIHZhciBpbW11dGFibGVPcHRpb25zID0ge307XHJcbiAgICAgICAgICAgIGlmICghaXNCb29sZWFuKGltbXV0YWJsZUNoZWNrKSkge1xyXG4gICAgICAgICAgICAgICAgaW1tdXRhYmxlT3B0aW9ucyA9IGltbXV0YWJsZUNoZWNrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG1pZGRsZXdhcmVBcnJheS51bnNoaWZ0KGNyZWF0ZUltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZShpbW11dGFibGVPcHRpb25zKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzZXJpYWxpemFibGVDaGVjaykge1xyXG4gICAgICAgICAgICB2YXIgc2VyaWFsaXphYmxlT3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICBpZiAoIWlzQm9vbGVhbihzZXJpYWxpemFibGVDaGVjaykpIHtcclxuICAgICAgICAgICAgICAgIHNlcmlhbGl6YWJsZU9wdGlvbnMgPSBzZXJpYWxpemFibGVDaGVjaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtaWRkbGV3YXJlQXJyYXkucHVzaChjcmVhdGVTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUoc2VyaWFsaXphYmxlT3B0aW9ucykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYWN0aW9uQ3JlYXRvckNoZWNrKSB7XHJcbiAgICAgICAgICAgIHZhciBhY3Rpb25DcmVhdG9yT3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICBpZiAoIWlzQm9vbGVhbihhY3Rpb25DcmVhdG9yQ2hlY2spKSB7XHJcbiAgICAgICAgICAgICAgICBhY3Rpb25DcmVhdG9yT3B0aW9ucyA9IGFjdGlvbkNyZWF0b3JDaGVjaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtaWRkbGV3YXJlQXJyYXkudW5zaGlmdChjcmVhdGVBY3Rpb25DcmVhdG9ySW52YXJpYW50TWlkZGxld2FyZShhY3Rpb25DcmVhdG9yT3B0aW9ucykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBtaWRkbGV3YXJlQXJyYXk7XHJcbn1cclxuLy8gc3JjL2NvbmZpZ3VyZVN0b3JlLnRzXHJcbnZhciBJU19QUk9EVUNUSU9OID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiO1xyXG5mdW5jdGlvbiBjb25maWd1cmVTdG9yZShvcHRpb25zKSB7XHJcbiAgICB2YXIgY3VycmllZEdldERlZmF1bHRNaWRkbGV3YXJlID0gY3VycnlHZXREZWZhdWx0TWlkZGxld2FyZSgpO1xyXG4gICAgdmFyIF9jID0gb3B0aW9ucyB8fCB7fSwgX2QgPSBfYy5yZWR1Y2VyLCByZWR1Y2VyID0gX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLCBfZSA9IF9jLm1pZGRsZXdhcmUsIG1pZGRsZXdhcmUgPSBfZSA9PT0gdm9pZCAwID8gY3VycmllZEdldERlZmF1bHRNaWRkbGV3YXJlKCkgOiBfZSwgX2YgPSBfYy5kZXZUb29scywgZGV2VG9vbHMgPSBfZiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9mLCBfZyA9IF9jLnByZWxvYWRlZFN0YXRlLCBwcmVsb2FkZWRTdGF0ZSA9IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZywgX2ggPSBfYy5lbmhhbmNlcnMsIGVuaGFuY2VycyA9IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaDtcclxuICAgIHZhciByb290UmVkdWNlcjtcclxuICAgIGlmICh0eXBlb2YgcmVkdWNlciA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgcm9vdFJlZHVjZXIgPSByZWR1Y2VyO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChyZWR1Y2VyKSkge1xyXG4gICAgICAgIHJvb3RSZWR1Y2VyID0gY29tYmluZVJlZHVjZXJzKHJlZHVjZXIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcInJlZHVjZXJcIiBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50LCBhbmQgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCBvZiBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIGNvbWJpbmVSZWR1Y2VycycpO1xyXG4gICAgfVxyXG4gICAgdmFyIGZpbmFsTWlkZGxld2FyZSA9IG1pZGRsZXdhcmU7XHJcbiAgICBpZiAodHlwZW9mIGZpbmFsTWlkZGxld2FyZSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgZmluYWxNaWRkbGV3YXJlID0gZmluYWxNaWRkbGV3YXJlKGN1cnJpZWRHZXREZWZhdWx0TWlkZGxld2FyZSk7XHJcbiAgICAgICAgaWYgKCFJU19QUk9EVUNUSU9OICYmICFBcnJheS5pc0FycmF5KGZpbmFsTWlkZGxld2FyZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwid2hlbiB1c2luZyBhIG1pZGRsZXdhcmUgYnVpbGRlciBmdW5jdGlvbiwgYW4gYXJyYXkgb2YgbWlkZGxld2FyZSBtdXN0IGJlIHJldHVybmVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghSVNfUFJPRFVDVElPTiAmJiBmaW5hbE1pZGRsZXdhcmUuc29tZShmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gdHlwZW9mIGl0ZW0gIT09IFwiZnVuY3Rpb25cIjsgfSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlYWNoIG1pZGRsZXdhcmUgcHJvdmlkZWQgdG8gY29uZmlndXJlU3RvcmUgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xyXG4gICAgfVxyXG4gICAgdmFyIG1pZGRsZXdhcmVFbmhhbmNlciA9IGFwcGx5TWlkZGxld2FyZS5hcHBseSh2b2lkIDAsIGZpbmFsTWlkZGxld2FyZSk7XHJcbiAgICB2YXIgZmluYWxDb21wb3NlID0gY29tcG9zZTI7XHJcbiAgICBpZiAoZGV2VG9vbHMpIHtcclxuICAgICAgICBmaW5hbENvbXBvc2UgPSBjb21wb3NlV2l0aERldlRvb2xzKF9fc3ByZWFkVmFsdWVzKHtcclxuICAgICAgICAgICAgdHJhY2U6ICFJU19QUk9EVUNUSU9OXHJcbiAgICAgICAgfSwgdHlwZW9mIGRldlRvb2xzID09PSBcIm9iamVjdFwiICYmIGRldlRvb2xzKSk7XHJcbiAgICB9XHJcbiAgICB2YXIgZGVmYXVsdEVuaGFuY2VycyA9IG5ldyBFbmhhbmNlckFycmF5KG1pZGRsZXdhcmVFbmhhbmNlcik7XHJcbiAgICB2YXIgc3RvcmVFbmhhbmNlcnMgPSBkZWZhdWx0RW5oYW5jZXJzO1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZW5oYW5jZXJzKSkge1xyXG4gICAgICAgIHN0b3JlRW5oYW5jZXJzID0gX19zcHJlYWRBcnJheShbbWlkZGxld2FyZUVuaGFuY2VyXSwgZW5oYW5jZXJzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBlbmhhbmNlcnMgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgIHN0b3JlRW5oYW5jZXJzID0gZW5oYW5jZXJzKGRlZmF1bHRFbmhhbmNlcnMpO1xyXG4gICAgfVxyXG4gICAgdmFyIGNvbXBvc2VkRW5oYW5jZXIgPSBmaW5hbENvbXBvc2UuYXBwbHkodm9pZCAwLCBzdG9yZUVuaGFuY2Vycyk7XHJcbiAgICByZXR1cm4gY3JlYXRlU3RvcmUocm9vdFJlZHVjZXIsIHByZWxvYWRlZFN0YXRlLCBjb21wb3NlZEVuaGFuY2VyKTtcclxufVxyXG4vLyBzcmMvY3JlYXRlUmVkdWNlci50c1xyXG5pbXBvcnQgY3JlYXRlTmV4dFN0YXRlMiwgeyBpc0RyYWZ0IGFzIGlzRHJhZnQyLCBpc0RyYWZ0YWJsZSBhcyBpc0RyYWZ0YWJsZTIgfSBmcm9tIFwiaW1tZXJcIjtcclxuLy8gc3JjL21hcEJ1aWxkZXJzLnRzXHJcbmZ1bmN0aW9uIGV4ZWN1dGVSZWR1Y2VyQnVpbGRlckNhbGxiYWNrKGJ1aWxkZXJDYWxsYmFjaykge1xyXG4gICAgdmFyIGFjdGlvbnNNYXAgPSB7fTtcclxuICAgIHZhciBhY3Rpb25NYXRjaGVycyA9IFtdO1xyXG4gICAgdmFyIGRlZmF1bHRDYXNlUmVkdWNlcjtcclxuICAgIHZhciBidWlsZGVyID0ge1xyXG4gICAgICAgIGFkZENhc2U6IGZ1bmN0aW9uICh0eXBlT3JBY3Rpb25DcmVhdG9yLCByZWR1Y2VyKSB7XHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhY3Rpb25NYXRjaGVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYGJ1aWxkZXIuYWRkQ2FzZWAgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGJlZm9yZSBjYWxsaW5nIGBidWlsZGVyLmFkZE1hdGNoZXJgXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRDYXNlUmVkdWNlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImBidWlsZGVyLmFkZENhc2VgIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBiZWZvcmUgY2FsbGluZyBgYnVpbGRlci5hZGREZWZhdWx0Q2FzZWBcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdHlwZU9yQWN0aW9uQ3JlYXRvciA9PT0gXCJzdHJpbmdcIiA/IHR5cGVPckFjdGlvbkNyZWF0b3IgOiB0eXBlT3JBY3Rpb25DcmVhdG9yLnR5cGU7XHJcbiAgICAgICAgICAgIGlmICghdHlwZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYGJ1aWxkZXIuYWRkQ2FzZWAgY2Fubm90IGJlIGNhbGxlZCB3aXRoIGFuIGVtcHR5IGFjdGlvbiB0eXBlXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlIGluIGFjdGlvbnNNYXApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImBidWlsZGVyLmFkZENhc2VgIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCB0d28gcmVkdWNlcnMgZm9yIHRoZSBzYW1lIGFjdGlvbiB0eXBlXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFjdGlvbnNNYXBbdHlwZV0gPSByZWR1Y2VyO1xyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRlcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZE1hdGNoZXI6IGZ1bmN0aW9uIChtYXRjaGVyLCByZWR1Y2VyKSB7XHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0Q2FzZVJlZHVjZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgYnVpbGRlci5hZGRNYXRjaGVyYCBzaG91bGQgb25seSBiZSBjYWxsZWQgYmVmb3JlIGNhbGxpbmcgYGJ1aWxkZXIuYWRkRGVmYXVsdENhc2VgXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFjdGlvbk1hdGNoZXJzLnB1c2goeyBtYXRjaGVyOiBtYXRjaGVyLCByZWR1Y2VyOiByZWR1Y2VyIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRlcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZERlZmF1bHRDYXNlOiBmdW5jdGlvbiAocmVkdWNlcikge1xyXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVmYXVsdENhc2VSZWR1Y2VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYGJ1aWxkZXIuYWRkRGVmYXVsdENhc2VgIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlZmF1bHRDYXNlUmVkdWNlciA9IHJlZHVjZXI7XHJcbiAgICAgICAgICAgIHJldHVybiBidWlsZGVyO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBidWlsZGVyQ2FsbGJhY2soYnVpbGRlcik7XHJcbiAgICByZXR1cm4gW2FjdGlvbnNNYXAsIGFjdGlvbk1hdGNoZXJzLCBkZWZhdWx0Q2FzZVJlZHVjZXJdO1xyXG59XHJcbi8vIHNyYy9jcmVhdGVSZWR1Y2VyLnRzXHJcbmZ1bmN0aW9uIGlzU3RhdGVGdW5jdGlvbih4KSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIjtcclxufVxyXG52YXIgaGFzV2FybmVkQWJvdXRPYmplY3ROb3RhdGlvbiA9IGZhbHNlO1xyXG5mdW5jdGlvbiBjcmVhdGVSZWR1Y2VyKGluaXRpYWxTdGF0ZSwgbWFwT3JCdWlsZGVyQ2FsbGJhY2ssIGFjdGlvbk1hdGNoZXJzLCBkZWZhdWx0Q2FzZVJlZHVjZXIpIHtcclxuICAgIGlmIChhY3Rpb25NYXRjaGVycyA9PT0gdm9pZCAwKSB7IGFjdGlvbk1hdGNoZXJzID0gW107IH1cclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgICAgICBpZiAodHlwZW9mIG1hcE9yQnVpbGRlckNhbGxiYWNrID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRPYmplY3ROb3RhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgaGFzV2FybmVkQWJvdXRPYmplY3ROb3RhdGlvbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUaGUgb2JqZWN0IG5vdGF0aW9uIGZvciBgY3JlYXRlUmVkdWNlcmAgaXMgZGVwcmVjYXRlZCwgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBSVEsgMi4wLiBQbGVhc2UgdXNlIHRoZSAnYnVpbGRlciBjYWxsYmFjaycgbm90YXRpb24gaW5zdGVhZDogaHR0cHM6Ly9yZWR1eC10b29sa2l0LmpzLm9yZy9hcGkvY3JlYXRlUmVkdWNlclwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHZhciBfYyA9IHR5cGVvZiBtYXBPckJ1aWxkZXJDYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiID8gZXhlY3V0ZVJlZHVjZXJCdWlsZGVyQ2FsbGJhY2sobWFwT3JCdWlsZGVyQ2FsbGJhY2spIDogW21hcE9yQnVpbGRlckNhbGxiYWNrLCBhY3Rpb25NYXRjaGVycywgZGVmYXVsdENhc2VSZWR1Y2VyXSwgYWN0aW9uc01hcCA9IF9jWzBdLCBmaW5hbEFjdGlvbk1hdGNoZXJzID0gX2NbMV0sIGZpbmFsRGVmYXVsdENhc2VSZWR1Y2VyID0gX2NbMl07XHJcbiAgICB2YXIgZ2V0SW5pdGlhbFN0YXRlO1xyXG4gICAgaWYgKGlzU3RhdGVGdW5jdGlvbihpbml0aWFsU3RhdGUpKSB7XHJcbiAgICAgICAgZ2V0SW5pdGlhbFN0YXRlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnJlZXplRHJhZnRhYmxlKGluaXRpYWxTdGF0ZSgpKTsgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBmcm96ZW5Jbml0aWFsU3RhdGVfMSA9IGZyZWV6ZURyYWZ0YWJsZShpbml0aWFsU3RhdGUpO1xyXG4gICAgICAgIGdldEluaXRpYWxTdGF0ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZyb3plbkluaXRpYWxTdGF0ZV8xOyB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKHN0YXRlID09PSB2b2lkIDApIHsgc3RhdGUgPSBnZXRJbml0aWFsU3RhdGUoKTsgfVxyXG4gICAgICAgIHZhciBjYXNlUmVkdWNlcnMgPSBfX3NwcmVhZEFycmF5KFtcclxuICAgICAgICAgICAgYWN0aW9uc01hcFthY3Rpb24udHlwZV1cclxuICAgICAgICBdLCBmaW5hbEFjdGlvbk1hdGNoZXJzLmZpbHRlcihmdW5jdGlvbiAoX2MpIHtcclxuICAgICAgICAgICAgdmFyIG1hdGNoZXIgPSBfYy5tYXRjaGVyO1xyXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlcihhY3Rpb24pO1xyXG4gICAgICAgIH0pLm1hcChmdW5jdGlvbiAoX2MpIHtcclxuICAgICAgICAgICAgdmFyIHJlZHVjZXIyID0gX2MucmVkdWNlcjtcclxuICAgICAgICAgICAgcmV0dXJuIHJlZHVjZXIyO1xyXG4gICAgICAgIH0pKTtcclxuICAgICAgICBpZiAoY2FzZVJlZHVjZXJzLmZpbHRlcihmdW5jdGlvbiAoY3IpIHsgcmV0dXJuICEhY3I7IH0pLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBjYXNlUmVkdWNlcnMgPSBbZmluYWxEZWZhdWx0Q2FzZVJlZHVjZXJdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2FzZVJlZHVjZXJzLnJlZHVjZShmdW5jdGlvbiAocHJldmlvdXNTdGF0ZSwgY2FzZVJlZHVjZXIpIHtcclxuICAgICAgICAgICAgaWYgKGNhc2VSZWR1Y2VyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNEcmFmdDIocHJldmlvdXNTdGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZHJhZnQgPSBwcmV2aW91c1N0YXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBjYXNlUmVkdWNlcihkcmFmdCwgYWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzU3RhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNEcmFmdGFibGUyKHByZXZpb3VzU3RhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGNhc2VSZWR1Y2VyKHByZXZpb3VzU3RhdGUsIGFjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c1N0YXRlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJldmlvdXNTdGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIkEgY2FzZSByZWR1Y2VyIG9uIGEgbm9uLWRyYWZ0YWJsZSB2YWx1ZSBtdXN0IG5vdCByZXR1cm4gdW5kZWZpbmVkXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZU5leHRTdGF0ZTIocHJldmlvdXNTdGF0ZSwgZnVuY3Rpb24gKGRyYWZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYXNlUmVkdWNlcihkcmFmdCwgYWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcHJldmlvdXNTdGF0ZTtcclxuICAgICAgICB9LCBzdGF0ZSk7XHJcbiAgICB9XHJcbiAgICByZWR1Y2VyLmdldEluaXRpYWxTdGF0ZSA9IGdldEluaXRpYWxTdGF0ZTtcclxuICAgIHJldHVybiByZWR1Y2VyO1xyXG59XHJcbi8vIHNyYy9jcmVhdGVTbGljZS50c1xyXG52YXIgaGFzV2FybmVkQWJvdXRPYmplY3ROb3RhdGlvbjIgPSBmYWxzZTtcclxuZnVuY3Rpb24gZ2V0VHlwZTIoc2xpY2UsIGFjdGlvbktleSkge1xyXG4gICAgcmV0dXJuIHNsaWNlICsgXCIvXCIgKyBhY3Rpb25LZXk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlU2xpY2Uob3B0aW9ucykge1xyXG4gICAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWU7XHJcbiAgICBpZiAoIW5hbWUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgbmFtZWAgaXMgYSByZXF1aXJlZCBvcHRpb24gZm9yIGNyZWF0ZVNsaWNlXCIpO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcclxuICAgICAgICBpZiAob3B0aW9ucy5pbml0aWFsU3RhdGUgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiWW91IG11c3QgcHJvdmlkZSBhbiBgaW5pdGlhbFN0YXRlYCB2YWx1ZSB0aGF0IGlzIG5vdCBgdW5kZWZpbmVkYC4gWW91IG1heSBoYXZlIG1pc3NwZWxsZWQgYGluaXRpYWxTdGF0ZWBcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFyIGluaXRpYWxTdGF0ZSA9IHR5cGVvZiBvcHRpb25zLmluaXRpYWxTdGF0ZSA9PSBcImZ1bmN0aW9uXCIgPyBvcHRpb25zLmluaXRpYWxTdGF0ZSA6IGZyZWV6ZURyYWZ0YWJsZShvcHRpb25zLmluaXRpYWxTdGF0ZSk7XHJcbiAgICB2YXIgcmVkdWNlcnMgPSBvcHRpb25zLnJlZHVjZXJzIHx8IHt9O1xyXG4gICAgdmFyIHJlZHVjZXJOYW1lcyA9IE9iamVjdC5rZXlzKHJlZHVjZXJzKTtcclxuICAgIHZhciBzbGljZUNhc2VSZWR1Y2Vyc0J5TmFtZSA9IHt9O1xyXG4gICAgdmFyIHNsaWNlQ2FzZVJlZHVjZXJzQnlUeXBlID0ge307XHJcbiAgICB2YXIgYWN0aW9uQ3JlYXRvcnMgPSB7fTtcclxuICAgIHJlZHVjZXJOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWR1Y2VyTmFtZSkge1xyXG4gICAgICAgIHZhciBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZSA9IHJlZHVjZXJzW3JlZHVjZXJOYW1lXTtcclxuICAgICAgICB2YXIgdHlwZSA9IGdldFR5cGUyKG5hbWUsIHJlZHVjZXJOYW1lKTtcclxuICAgICAgICB2YXIgY2FzZVJlZHVjZXI7XHJcbiAgICAgICAgdmFyIHByZXBhcmVDYWxsYmFjaztcclxuICAgICAgICBpZiAoXCJyZWR1Y2VyXCIgaW4gbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUpIHtcclxuICAgICAgICAgICAgY2FzZVJlZHVjZXIgPSBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZS5yZWR1Y2VyO1xyXG4gICAgICAgICAgICBwcmVwYXJlQ2FsbGJhY2sgPSBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZS5wcmVwYXJlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY2FzZVJlZHVjZXIgPSBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2xpY2VDYXNlUmVkdWNlcnNCeU5hbWVbcmVkdWNlck5hbWVdID0gY2FzZVJlZHVjZXI7XHJcbiAgICAgICAgc2xpY2VDYXNlUmVkdWNlcnNCeVR5cGVbdHlwZV0gPSBjYXNlUmVkdWNlcjtcclxuICAgICAgICBhY3Rpb25DcmVhdG9yc1tyZWR1Y2VyTmFtZV0gPSBwcmVwYXJlQ2FsbGJhY2sgPyBjcmVhdGVBY3Rpb24odHlwZSwgcHJlcGFyZUNhbGxiYWNrKSA6IGNyZWF0ZUFjdGlvbih0eXBlKTtcclxuICAgIH0pO1xyXG4gICAgZnVuY3Rpb24gYnVpbGRSZWR1Y2VyKCkge1xyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmV4dHJhUmVkdWNlcnMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRPYmplY3ROb3RhdGlvbjIpIHtcclxuICAgICAgICAgICAgICAgICAgICBoYXNXYXJuZWRBYm91dE9iamVjdE5vdGF0aW9uMiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVGhlIG9iamVjdCBub3RhdGlvbiBmb3IgYGNyZWF0ZVNsaWNlLmV4dHJhUmVkdWNlcnNgIGlzIGRlcHJlY2F0ZWQsIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gUlRLIDIuMC4gUGxlYXNlIHVzZSB0aGUgJ2J1aWxkZXIgY2FsbGJhY2snIG5vdGF0aW9uIGluc3RlYWQ6IGh0dHBzOi8vcmVkdXgtdG9vbGtpdC5qcy5vcmcvYXBpL2NyZWF0ZVNsaWNlXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBfYyA9IHR5cGVvZiBvcHRpb25zLmV4dHJhUmVkdWNlcnMgPT09IFwiZnVuY3Rpb25cIiA/IGV4ZWN1dGVSZWR1Y2VyQnVpbGRlckNhbGxiYWNrKG9wdGlvbnMuZXh0cmFSZWR1Y2VycykgOiBbb3B0aW9ucy5leHRyYVJlZHVjZXJzXSwgX2QgPSBfY1swXSwgZXh0cmFSZWR1Y2VycyA9IF9kID09PSB2b2lkIDAgPyB7fSA6IF9kLCBfZSA9IF9jWzFdLCBhY3Rpb25NYXRjaGVycyA9IF9lID09PSB2b2lkIDAgPyBbXSA6IF9lLCBfZiA9IF9jWzJdLCBkZWZhdWx0Q2FzZVJlZHVjZXIgPSBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Y7XHJcbiAgICAgICAgdmFyIGZpbmFsQ2FzZVJlZHVjZXJzID0gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIGV4dHJhUmVkdWNlcnMpLCBzbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZSk7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlZHVjZXIoaW5pdGlhbFN0YXRlLCBmdW5jdGlvbiAoYnVpbGRlcikge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gZmluYWxDYXNlUmVkdWNlcnMpIHtcclxuICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkQ2FzZShrZXksIGZpbmFsQ2FzZVJlZHVjZXJzW2tleV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgYWN0aW9uTWF0Y2hlcnNfMSA9IGFjdGlvbk1hdGNoZXJzOyBfaSA8IGFjdGlvbk1hdGNoZXJzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbSA9IGFjdGlvbk1hdGNoZXJzXzFbX2ldO1xyXG4gICAgICAgICAgICAgICAgYnVpbGRlci5hZGRNYXRjaGVyKG0ubWF0Y2hlciwgbS5yZWR1Y2VyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGVmYXVsdENhc2VSZWR1Y2VyKSB7XHJcbiAgICAgICAgICAgICAgICBidWlsZGVyLmFkZERlZmF1bHRDYXNlKGRlZmF1bHRDYXNlUmVkdWNlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHZhciBfcmVkdWNlcjtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmFtZTogbmFtZSxcclxuICAgICAgICByZWR1Y2VyOiBmdW5jdGlvbiAoc3RhdGUsIGFjdGlvbikge1xyXG4gICAgICAgICAgICBpZiAoIV9yZWR1Y2VyKVxyXG4gICAgICAgICAgICAgICAgX3JlZHVjZXIgPSBidWlsZFJlZHVjZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIF9yZWR1Y2VyKHN0YXRlLCBhY3Rpb24pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWN0aW9uczogYWN0aW9uQ3JlYXRvcnMsXHJcbiAgICAgICAgY2FzZVJlZHVjZXJzOiBzbGljZUNhc2VSZWR1Y2Vyc0J5TmFtZSxcclxuICAgICAgICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCFfcmVkdWNlcilcclxuICAgICAgICAgICAgICAgIF9yZWR1Y2VyID0gYnVpbGRSZWR1Y2VyKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBfcmVkdWNlci5nZXRJbml0aWFsU3RhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbi8vIHNyYy9lbnRpdGllcy9lbnRpdHlfc3RhdGUudHNcclxuZnVuY3Rpb24gZ2V0SW5pdGlhbEVudGl0eVN0YXRlKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpZHM6IFtdLFxyXG4gICAgICAgIGVudGl0aWVzOiB7fVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVJbml0aWFsU3RhdGVGYWN0b3J5KCkge1xyXG4gICAgZnVuY3Rpb24gZ2V0SW5pdGlhbFN0YXRlKGFkZGl0aW9uYWxTdGF0ZSkge1xyXG4gICAgICAgIGlmIChhZGRpdGlvbmFsU3RhdGUgPT09IHZvaWQgMCkgeyBhZGRpdGlvbmFsU3RhdGUgPSB7fTsgfVxyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGdldEluaXRpYWxFbnRpdHlTdGF0ZSgpLCBhZGRpdGlvbmFsU3RhdGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgZ2V0SW5pdGlhbFN0YXRlOiBnZXRJbml0aWFsU3RhdGUgfTtcclxufVxyXG4vLyBzcmMvZW50aXRpZXMvc3RhdGVfc2VsZWN0b3JzLnRzXHJcbmZ1bmN0aW9uIGNyZWF0ZVNlbGVjdG9yc0ZhY3RvcnkoKSB7XHJcbiAgICBmdW5jdGlvbiBnZXRTZWxlY3RvcnMoc2VsZWN0U3RhdGUpIHtcclxuICAgICAgICB2YXIgc2VsZWN0SWRzID0gZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiBzdGF0ZS5pZHM7IH07XHJcbiAgICAgICAgdmFyIHNlbGVjdEVudGl0aWVzID0gZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiBzdGF0ZS5lbnRpdGllczsgfTtcclxuICAgICAgICB2YXIgc2VsZWN0QWxsID0gY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3Ioc2VsZWN0SWRzLCBzZWxlY3RFbnRpdGllcywgZnVuY3Rpb24gKGlkcywgZW50aXRpZXMpIHsgcmV0dXJuIGlkcy5tYXAoZnVuY3Rpb24gKGlkKSB7IHJldHVybiBlbnRpdGllc1tpZF07IH0pOyB9KTtcclxuICAgICAgICB2YXIgc2VsZWN0SWQgPSBmdW5jdGlvbiAoXywgaWQpIHsgcmV0dXJuIGlkOyB9O1xyXG4gICAgICAgIHZhciBzZWxlY3RCeUlkID0gZnVuY3Rpb24gKGVudGl0aWVzLCBpZCkgeyByZXR1cm4gZW50aXRpZXNbaWRdOyB9O1xyXG4gICAgICAgIHZhciBzZWxlY3RUb3RhbCA9IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yKHNlbGVjdElkcywgZnVuY3Rpb24gKGlkcykgeyByZXR1cm4gaWRzLmxlbmd0aDsgfSk7XHJcbiAgICAgICAgaWYgKCFzZWxlY3RTdGF0ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0SWRzOiBzZWxlY3RJZHMsXHJcbiAgICAgICAgICAgICAgICBzZWxlY3RFbnRpdGllczogc2VsZWN0RW50aXRpZXMsXHJcbiAgICAgICAgICAgICAgICBzZWxlY3RBbGw6IHNlbGVjdEFsbCxcclxuICAgICAgICAgICAgICAgIHNlbGVjdFRvdGFsOiBzZWxlY3RUb3RhbCxcclxuICAgICAgICAgICAgICAgIHNlbGVjdEJ5SWQ6IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yKHNlbGVjdEVudGl0aWVzLCBzZWxlY3RJZCwgc2VsZWN0QnlJZClcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNlbGVjdEdsb2JhbGl6ZWRFbnRpdGllcyA9IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yKHNlbGVjdFN0YXRlLCBzZWxlY3RFbnRpdGllcyk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc2VsZWN0SWRzOiBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvcihzZWxlY3RTdGF0ZSwgc2VsZWN0SWRzKSxcclxuICAgICAgICAgICAgc2VsZWN0RW50aXRpZXM6IHNlbGVjdEdsb2JhbGl6ZWRFbnRpdGllcyxcclxuICAgICAgICAgICAgc2VsZWN0QWxsOiBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvcihzZWxlY3RTdGF0ZSwgc2VsZWN0QWxsKSxcclxuICAgICAgICAgICAgc2VsZWN0VG90YWw6IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yKHNlbGVjdFN0YXRlLCBzZWxlY3RUb3RhbCksXHJcbiAgICAgICAgICAgIHNlbGVjdEJ5SWQ6IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yKHNlbGVjdEdsb2JhbGl6ZWRFbnRpdGllcywgc2VsZWN0SWQsIHNlbGVjdEJ5SWQpXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IGdldFNlbGVjdG9yczogZ2V0U2VsZWN0b3JzIH07XHJcbn1cclxuLy8gc3JjL2VudGl0aWVzL3N0YXRlX2FkYXB0ZXIudHNcclxuaW1wb3J0IGNyZWF0ZU5leHRTdGF0ZTMsIHsgaXNEcmFmdCBhcyBpc0RyYWZ0MyB9IGZyb20gXCJpbW1lclwiO1xyXG5mdW5jdGlvbiBjcmVhdGVTaW5nbGVBcmd1bWVudFN0YXRlT3BlcmF0b3IobXV0YXRvcikge1xyXG4gICAgdmFyIG9wZXJhdG9yID0gY3JlYXRlU3RhdGVPcGVyYXRvcihmdW5jdGlvbiAoXywgc3RhdGUpIHsgcmV0dXJuIG11dGF0b3Ioc3RhdGUpOyB9KTtcclxuICAgIHJldHVybiBmdW5jdGlvbiBvcGVyYXRpb24oc3RhdGUpIHtcclxuICAgICAgICByZXR1cm4gb3BlcmF0b3Ioc3RhdGUsIHZvaWQgMCk7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVN0YXRlT3BlcmF0b3IobXV0YXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG9wZXJhdGlvbihzdGF0ZSwgYXJnKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gaXNQYXlsb2FkQWN0aW9uQXJndW1lbnQoYXJnMikge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNGU0EoYXJnMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBydW5NdXRhdG9yID0gZnVuY3Rpb24gKGRyYWZ0KSB7XHJcbiAgICAgICAgICAgIGlmIChpc1BheWxvYWRBY3Rpb25Bcmd1bWVudChhcmcpKSB7XHJcbiAgICAgICAgICAgICAgICBtdXRhdG9yKGFyZy5wYXlsb2FkLCBkcmFmdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtdXRhdG9yKGFyZywgZHJhZnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoaXNEcmFmdDMoc3RhdGUpKSB7XHJcbiAgICAgICAgICAgIHJ1bk11dGF0b3Ioc3RhdGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTmV4dFN0YXRlMyhzdGF0ZSwgcnVuTXV0YXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG4vLyBzcmMvZW50aXRpZXMvdXRpbHMudHNcclxuZnVuY3Rpb24gc2VsZWN0SWRWYWx1ZShlbnRpdHksIHNlbGVjdElkKSB7XHJcbiAgICB2YXIga2V5ID0gc2VsZWN0SWQoZW50aXR5KTtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYga2V5ID09PSB2b2lkIDApIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oXCJUaGUgZW50aXR5IHBhc3NlZCB0byB0aGUgYHNlbGVjdElkYCBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCB1bmRlZmluZWQuXCIsIFwiWW91IHNob3VsZCBwcm9iYWJseSBwcm92aWRlIHlvdXIgb3duIGBzZWxlY3RJZGAgaW1wbGVtZW50YXRpb24uXCIsIFwiVGhlIGVudGl0eSB0aGF0IHdhcyBwYXNzZWQ6XCIsIGVudGl0eSwgXCJUaGUgYHNlbGVjdElkYCBpbXBsZW1lbnRhdGlvbjpcIiwgc2VsZWN0SWQudG9TdHJpbmcoKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ga2V5O1xyXG59XHJcbmZ1bmN0aW9uIGVuc3VyZUVudGl0aWVzQXJyYXkoZW50aXRpZXMpIHtcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShlbnRpdGllcykpIHtcclxuICAgICAgICBlbnRpdGllcyA9IE9iamVjdC52YWx1ZXMoZW50aXRpZXMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVudGl0aWVzO1xyXG59XHJcbmZ1bmN0aW9uIHNwbGl0QWRkZWRVcGRhdGVkRW50aXRpZXMobmV3RW50aXRpZXMsIHNlbGVjdElkLCBzdGF0ZSkge1xyXG4gICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcclxuICAgIHZhciBhZGRlZCA9IFtdO1xyXG4gICAgdmFyIHVwZGF0ZWQgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMCwgbmV3RW50aXRpZXNfMSA9IG5ld0VudGl0aWVzOyBfaSA8IG5ld0VudGl0aWVzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgdmFyIGVudGl0eSA9IG5ld0VudGl0aWVzXzFbX2ldO1xyXG4gICAgICAgIHZhciBpZCA9IHNlbGVjdElkVmFsdWUoZW50aXR5LCBzZWxlY3RJZCk7XHJcbiAgICAgICAgaWYgKGlkIGluIHN0YXRlLmVudGl0aWVzKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZWQucHVzaCh7IGlkOiBpZCwgY2hhbmdlczogZW50aXR5IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYWRkZWQucHVzaChlbnRpdHkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBbYWRkZWQsIHVwZGF0ZWRdO1xyXG59XHJcbi8vIHNyYy9lbnRpdGllcy91bnNvcnRlZF9zdGF0ZV9hZGFwdGVyLnRzXHJcbmZ1bmN0aW9uIGNyZWF0ZVVuc29ydGVkU3RhdGVBZGFwdGVyKHNlbGVjdElkKSB7XHJcbiAgICBmdW5jdGlvbiBhZGRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcclxuICAgICAgICB2YXIga2V5ID0gc2VsZWN0SWRWYWx1ZShlbnRpdHksIHNlbGVjdElkKTtcclxuICAgICAgICBpZiAoa2V5IGluIHN0YXRlLmVudGl0aWVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhdGUuaWRzLnB1c2goa2V5KTtcclxuICAgICAgICBzdGF0ZS5lbnRpdGllc1trZXldID0gZW50aXR5O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYWRkTWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XHJcbiAgICAgICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIG5ld0VudGl0aWVzXzIgPSBuZXdFbnRpdGllczsgX2kgPCBuZXdFbnRpdGllc18yLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgZW50aXR5ID0gbmV3RW50aXRpZXNfMltfaV07XHJcbiAgICAgICAgICAgIGFkZE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc2V0T25lTXV0YWJseShlbnRpdHksIHN0YXRlKSB7XHJcbiAgICAgICAgdmFyIGtleSA9IHNlbGVjdElkVmFsdWUoZW50aXR5LCBzZWxlY3RJZCk7XHJcbiAgICAgICAgaWYgKCEoa2V5IGluIHN0YXRlLmVudGl0aWVzKSkge1xyXG4gICAgICAgICAgICBzdGF0ZS5pZHMucHVzaChrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0ZS5lbnRpdGllc1trZXldID0gZW50aXR5O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc2V0TWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XHJcbiAgICAgICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIG5ld0VudGl0aWVzXzMgPSBuZXdFbnRpdGllczsgX2kgPCBuZXdFbnRpdGllc18zLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgZW50aXR5ID0gbmV3RW50aXRpZXNfM1tfaV07XHJcbiAgICAgICAgICAgIHNldE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc2V0QWxsTXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcclxuICAgICAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xyXG4gICAgICAgIHN0YXRlLmlkcyA9IFtdO1xyXG4gICAgICAgIHN0YXRlLmVudGl0aWVzID0ge307XHJcbiAgICAgICAgYWRkTWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlbW92ZU9uZU11dGFibHkoa2V5LCBzdGF0ZSkge1xyXG4gICAgICAgIHJldHVybiByZW1vdmVNYW55TXV0YWJseShba2V5XSwgc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVtb3ZlTWFueU11dGFibHkoa2V5cywgc3RhdGUpIHtcclxuICAgICAgICB2YXIgZGlkTXV0YXRlID0gZmFsc2U7XHJcbiAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgaWYgKGtleSBpbiBzdGF0ZS5lbnRpdGllcykge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHN0YXRlLmVudGl0aWVzW2tleV07XHJcbiAgICAgICAgICAgICAgICBkaWRNdXRhdGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGRpZE11dGF0ZSkge1xyXG4gICAgICAgICAgICBzdGF0ZS5pZHMgPSBzdGF0ZS5pZHMuZmlsdGVyKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gaWQgaW4gc3RhdGUuZW50aXRpZXM7IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbE11dGFibHkoc3RhdGUpIHtcclxuICAgICAgICBPYmplY3QuYXNzaWduKHN0YXRlLCB7XHJcbiAgICAgICAgICAgIGlkczogW10sXHJcbiAgICAgICAgICAgIGVudGl0aWVzOiB7fVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdGFrZU5ld0tleShrZXlzLCB1cGRhdGUsIHN0YXRlKSB7XHJcbiAgICAgICAgdmFyIG9yaWdpbmFsMiA9IHN0YXRlLmVudGl0aWVzW3VwZGF0ZS5pZF07XHJcbiAgICAgICAgdmFyIHVwZGF0ZWQgPSBPYmplY3QuYXNzaWduKHt9LCBvcmlnaW5hbDIsIHVwZGF0ZS5jaGFuZ2VzKTtcclxuICAgICAgICB2YXIgbmV3S2V5ID0gc2VsZWN0SWRWYWx1ZSh1cGRhdGVkLCBzZWxlY3RJZCk7XHJcbiAgICAgICAgdmFyIGhhc05ld0tleSA9IG5ld0tleSAhPT0gdXBkYXRlLmlkO1xyXG4gICAgICAgIGlmIChoYXNOZXdLZXkpIHtcclxuICAgICAgICAgICAga2V5c1t1cGRhdGUuaWRdID0gbmV3S2V5O1xyXG4gICAgICAgICAgICBkZWxldGUgc3RhdGUuZW50aXRpZXNbdXBkYXRlLmlkXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhdGUuZW50aXRpZXNbbmV3S2V5XSA9IHVwZGF0ZWQ7XHJcbiAgICAgICAgcmV0dXJuIGhhc05ld0tleTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZU9uZU11dGFibHkodXBkYXRlLCBzdGF0ZSkge1xyXG4gICAgICAgIHJldHVybiB1cGRhdGVNYW55TXV0YWJseShbdXBkYXRlXSwgc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdXBkYXRlTWFueU11dGFibHkodXBkYXRlcywgc3RhdGUpIHtcclxuICAgICAgICB2YXIgbmV3S2V5cyA9IHt9O1xyXG4gICAgICAgIHZhciB1cGRhdGVzUGVyRW50aXR5ID0ge307XHJcbiAgICAgICAgdXBkYXRlcy5mb3JFYWNoKGZ1bmN0aW9uICh1cGRhdGUpIHtcclxuICAgICAgICAgICAgaWYgKHVwZGF0ZS5pZCBpbiBzdGF0ZS5lbnRpdGllcykge1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlc1BlckVudGl0eVt1cGRhdGUuaWRdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlkOiB1cGRhdGUuaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlczogX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHVwZGF0ZXNQZXJFbnRpdHlbdXBkYXRlLmlkXSA/IHVwZGF0ZXNQZXJFbnRpdHlbdXBkYXRlLmlkXS5jaGFuZ2VzIDogbnVsbCksIHVwZGF0ZS5jaGFuZ2VzKVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHVwZGF0ZXMgPSBPYmplY3QudmFsdWVzKHVwZGF0ZXNQZXJFbnRpdHkpO1xyXG4gICAgICAgIHZhciBkaWRNdXRhdGVFbnRpdGllcyA9IHVwZGF0ZXMubGVuZ3RoID4gMDtcclxuICAgICAgICBpZiAoZGlkTXV0YXRlRW50aXRpZXMpIHtcclxuICAgICAgICAgICAgdmFyIGRpZE11dGF0ZUlkcyA9IHVwZGF0ZXMuZmlsdGVyKGZ1bmN0aW9uICh1cGRhdGUpIHsgcmV0dXJuIHRha2VOZXdLZXkobmV3S2V5cywgdXBkYXRlLCBzdGF0ZSk7IH0pLmxlbmd0aCA+IDA7XHJcbiAgICAgICAgICAgIGlmIChkaWRNdXRhdGVJZHMpIHtcclxuICAgICAgICAgICAgICAgIHN0YXRlLmlkcyA9IE9iamVjdC5rZXlzKHN0YXRlLmVudGl0aWVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHVwc2VydE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xyXG4gICAgICAgIHJldHVybiB1cHNlcnRNYW55TXV0YWJseShbZW50aXR5XSwgc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdXBzZXJ0TWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XHJcbiAgICAgICAgdmFyIF9jID0gc3BsaXRBZGRlZFVwZGF0ZWRFbnRpdGllcyhuZXdFbnRpdGllcywgc2VsZWN0SWQsIHN0YXRlKSwgYWRkZWQgPSBfY1swXSwgdXBkYXRlZCA9IF9jWzFdO1xyXG4gICAgICAgIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZWQsIHN0YXRlKTtcclxuICAgICAgICBhZGRNYW55TXV0YWJseShhZGRlZCwgc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZW1vdmVBbGw6IGNyZWF0ZVNpbmdsZUFyZ3VtZW50U3RhdGVPcGVyYXRvcihyZW1vdmVBbGxNdXRhYmx5KSxcclxuICAgICAgICBhZGRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IoYWRkT25lTXV0YWJseSksXHJcbiAgICAgICAgYWRkTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihhZGRNYW55TXV0YWJseSksXHJcbiAgICAgICAgc2V0T25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldE9uZU11dGFibHkpLFxyXG4gICAgICAgIHNldE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0TWFueU11dGFibHkpLFxyXG4gICAgICAgIHNldEFsbDogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRBbGxNdXRhYmx5KSxcclxuICAgICAgICB1cGRhdGVPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBkYXRlT25lTXV0YWJseSksXHJcbiAgICAgICAgdXBkYXRlTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cGRhdGVNYW55TXV0YWJseSksXHJcbiAgICAgICAgdXBzZXJ0T25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwc2VydE9uZU11dGFibHkpLFxyXG4gICAgICAgIHVwc2VydE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBzZXJ0TWFueU11dGFibHkpLFxyXG4gICAgICAgIHJlbW92ZU9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihyZW1vdmVPbmVNdXRhYmx5KSxcclxuICAgICAgICByZW1vdmVNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHJlbW92ZU1hbnlNdXRhYmx5KVxyXG4gICAgfTtcclxufVxyXG4vLyBzcmMvZW50aXRpZXMvc29ydGVkX3N0YXRlX2FkYXB0ZXIudHNcclxuZnVuY3Rpb24gY3JlYXRlU29ydGVkU3RhdGVBZGFwdGVyKHNlbGVjdElkLCBzb3J0KSB7XHJcbiAgICB2YXIgX2MgPSBjcmVhdGVVbnNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZCksIHJlbW92ZU9uZSA9IF9jLnJlbW92ZU9uZSwgcmVtb3ZlTWFueSA9IF9jLnJlbW92ZU1hbnksIHJlbW92ZUFsbCA9IF9jLnJlbW92ZUFsbDtcclxuICAgIGZ1bmN0aW9uIGFkZE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xyXG4gICAgICAgIHJldHVybiBhZGRNYW55TXV0YWJseShbZW50aXR5XSwgc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYWRkTWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XHJcbiAgICAgICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcclxuICAgICAgICB2YXIgbW9kZWxzID0gbmV3RW50aXRpZXMuZmlsdGVyKGZ1bmN0aW9uIChtb2RlbCkgeyByZXR1cm4gIShzZWxlY3RJZFZhbHVlKG1vZGVsLCBzZWxlY3RJZCkgaW4gc3RhdGUuZW50aXRpZXMpOyB9KTtcclxuICAgICAgICBpZiAobW9kZWxzLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgICAgICBtZXJnZShtb2RlbHMsIHN0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBzZXRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcclxuICAgICAgICByZXR1cm4gc2V0TWFueU11dGFibHkoW2VudGl0eV0sIHN0YXRlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHNldE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xyXG4gICAgICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XHJcbiAgICAgICAgaWYgKG5ld0VudGl0aWVzLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgICAgICBtZXJnZShuZXdFbnRpdGllcywgc3RhdGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHNldEFsbE11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XHJcbiAgICAgICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcclxuICAgICAgICBzdGF0ZS5lbnRpdGllcyA9IHt9O1xyXG4gICAgICAgIHN0YXRlLmlkcyA9IFtdO1xyXG4gICAgICAgIGFkZE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB1cGRhdGVPbmVNdXRhYmx5KHVwZGF0ZSwgc3RhdGUpIHtcclxuICAgICAgICByZXR1cm4gdXBkYXRlTWFueU11dGFibHkoW3VwZGF0ZV0sIHN0YXRlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZXMsIHN0YXRlKSB7XHJcbiAgICAgICAgdmFyIGFwcGxpZWRVcGRhdGVzID0gZmFsc2U7XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCB1cGRhdGVzXzEgPSB1cGRhdGVzOyBfaSA8IHVwZGF0ZXNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIHVwZGF0ZSA9IHVwZGF0ZXNfMVtfaV07XHJcbiAgICAgICAgICAgIHZhciBlbnRpdHkgPSBzdGF0ZS5lbnRpdGllc1t1cGRhdGUuaWRdO1xyXG4gICAgICAgICAgICBpZiAoIWVudGl0eSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXBwbGllZFVwZGF0ZXMgPSB0cnVlO1xyXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGVudGl0eSwgdXBkYXRlLmNoYW5nZXMpO1xyXG4gICAgICAgICAgICB2YXIgbmV3SWQgPSBzZWxlY3RJZChlbnRpdHkpO1xyXG4gICAgICAgICAgICBpZiAodXBkYXRlLmlkICE9PSBuZXdJZCkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHN0YXRlLmVudGl0aWVzW3VwZGF0ZS5pZF07XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5lbnRpdGllc1tuZXdJZF0gPSBlbnRpdHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFwcGxpZWRVcGRhdGVzKSB7XHJcbiAgICAgICAgICAgIHJlc29ydEVudGl0aWVzKHN0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB1cHNlcnRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcclxuICAgICAgICByZXR1cm4gdXBzZXJ0TWFueU11dGFibHkoW2VudGl0eV0sIHN0YXRlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHVwc2VydE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xyXG4gICAgICAgIHZhciBfYyA9IHNwbGl0QWRkZWRVcGRhdGVkRW50aXRpZXMobmV3RW50aXRpZXMsIHNlbGVjdElkLCBzdGF0ZSksIGFkZGVkID0gX2NbMF0sIHVwZGF0ZWQgPSBfY1sxXTtcclxuICAgICAgICB1cGRhdGVNYW55TXV0YWJseSh1cGRhdGVkLCBzdGF0ZSk7XHJcbiAgICAgICAgYWRkTWFueU11dGFibHkoYWRkZWQsIHN0YXRlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFyZUFycmF5c0VxdWFsKGEsIGIpIHtcclxuICAgICAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aCAmJiBpIDwgYi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoYVtpXSA9PT0gYltpXSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG1lcmdlKG1vZGVscywgc3RhdGUpIHtcclxuICAgICAgICBtb2RlbHMuZm9yRWFjaChmdW5jdGlvbiAobW9kZWwpIHtcclxuICAgICAgICAgICAgc3RhdGUuZW50aXRpZXNbc2VsZWN0SWQobW9kZWwpXSA9IG1vZGVsO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJlc29ydEVudGl0aWVzKHN0YXRlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlc29ydEVudGl0aWVzKHN0YXRlKSB7XHJcbiAgICAgICAgdmFyIGFsbEVudGl0aWVzID0gT2JqZWN0LnZhbHVlcyhzdGF0ZS5lbnRpdGllcyk7XHJcbiAgICAgICAgYWxsRW50aXRpZXMuc29ydChzb3J0KTtcclxuICAgICAgICB2YXIgbmV3U29ydGVkSWRzID0gYWxsRW50aXRpZXMubWFwKHNlbGVjdElkKTtcclxuICAgICAgICB2YXIgaWRzID0gc3RhdGUuaWRzO1xyXG4gICAgICAgIGlmICghYXJlQXJyYXlzRXF1YWwoaWRzLCBuZXdTb3J0ZWRJZHMpKSB7XHJcbiAgICAgICAgICAgIHN0YXRlLmlkcyA9IG5ld1NvcnRlZElkcztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlbW92ZU9uZTogcmVtb3ZlT25lLFxyXG4gICAgICAgIHJlbW92ZU1hbnk6IHJlbW92ZU1hbnksXHJcbiAgICAgICAgcmVtb3ZlQWxsOiByZW1vdmVBbGwsXHJcbiAgICAgICAgYWRkT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKGFkZE9uZU11dGFibHkpLFxyXG4gICAgICAgIHVwZGF0ZU9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cGRhdGVPbmVNdXRhYmx5KSxcclxuICAgICAgICB1cHNlcnRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBzZXJ0T25lTXV0YWJseSksXHJcbiAgICAgICAgc2V0T25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldE9uZU11dGFibHkpLFxyXG4gICAgICAgIHNldE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0TWFueU11dGFibHkpLFxyXG4gICAgICAgIHNldEFsbDogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRBbGxNdXRhYmx5KSxcclxuICAgICAgICBhZGRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKGFkZE1hbnlNdXRhYmx5KSxcclxuICAgICAgICB1cGRhdGVNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwZGF0ZU1hbnlNdXRhYmx5KSxcclxuICAgICAgICB1cHNlcnRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwc2VydE1hbnlNdXRhYmx5KVxyXG4gICAgfTtcclxufVxyXG4vLyBzcmMvZW50aXRpZXMvY3JlYXRlX2FkYXB0ZXIudHNcclxuZnVuY3Rpb24gY3JlYXRlRW50aXR5QWRhcHRlcihvcHRpb25zKSB7XHJcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxyXG4gICAgdmFyIF9jID0gX19zcHJlYWRWYWx1ZXMoe1xyXG4gICAgICAgIHNvcnRDb21wYXJlcjogZmFsc2UsXHJcbiAgICAgICAgc2VsZWN0SWQ6IGZ1bmN0aW9uIChpbnN0YW5jZSkgeyByZXR1cm4gaW5zdGFuY2UuaWQ7IH1cclxuICAgIH0sIG9wdGlvbnMpLCBzZWxlY3RJZCA9IF9jLnNlbGVjdElkLCBzb3J0Q29tcGFyZXIgPSBfYy5zb3J0Q29tcGFyZXI7XHJcbiAgICB2YXIgc3RhdGVGYWN0b3J5ID0gY3JlYXRlSW5pdGlhbFN0YXRlRmFjdG9yeSgpO1xyXG4gICAgdmFyIHNlbGVjdG9yc0ZhY3RvcnkgPSBjcmVhdGVTZWxlY3RvcnNGYWN0b3J5KCk7XHJcbiAgICB2YXIgc3RhdGVBZGFwdGVyID0gc29ydENvbXBhcmVyID8gY3JlYXRlU29ydGVkU3RhdGVBZGFwdGVyKHNlbGVjdElkLCBzb3J0Q29tcGFyZXIpIDogY3JlYXRlVW5zb3J0ZWRTdGF0ZUFkYXB0ZXIoc2VsZWN0SWQpO1xyXG4gICAgcmV0dXJuIF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHtcclxuICAgICAgICBzZWxlY3RJZDogc2VsZWN0SWQsXHJcbiAgICAgICAgc29ydENvbXBhcmVyOiBzb3J0Q29tcGFyZXJcclxuICAgIH0sIHN0YXRlRmFjdG9yeSksIHNlbGVjdG9yc0ZhY3RvcnkpLCBzdGF0ZUFkYXB0ZXIpO1xyXG59XHJcbi8vIHNyYy9uYW5vaWQudHNcclxudmFyIHVybEFscGhhYmV0ID0gXCJNb2R1bGVTeW1iaGFzT3duUHItMDEyMzQ1Njc4OUFCQ0RFRkdITlJWZmdjdGlVdnpfS3FZVEprTHhwWlhJalFXXCI7XHJcbnZhciBuYW5vaWQgPSBmdW5jdGlvbiAoc2l6ZSkge1xyXG4gICAgaWYgKHNpemUgPT09IHZvaWQgMCkgeyBzaXplID0gMjE7IH1cclxuICAgIHZhciBpZCA9IFwiXCI7XHJcbiAgICB2YXIgaSA9IHNpemU7XHJcbiAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgaWQgKz0gdXJsQWxwaGFiZXRbTWF0aC5yYW5kb20oKSAqIDY0IHwgMF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaWQ7XHJcbn07XHJcbi8vIHNyYy9jcmVhdGVBc3luY1RodW5rLnRzXHJcbnZhciBjb21tb25Qcm9wZXJ0aWVzID0gW1xyXG4gICAgXCJuYW1lXCIsXHJcbiAgICBcIm1lc3NhZ2VcIixcclxuICAgIFwic3RhY2tcIixcclxuICAgIFwiY29kZVwiXHJcbl07XHJcbnZhciBSZWplY3RXaXRoVmFsdWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBSZWplY3RXaXRoVmFsdWUocGF5bG9hZCwgbWV0YSkge1xyXG4gICAgICAgIHRoaXMucGF5bG9hZCA9IHBheWxvYWQ7XHJcbiAgICAgICAgdGhpcy5tZXRhID0gbWV0YTtcclxuICAgIH1cclxuICAgIHJldHVybiBSZWplY3RXaXRoVmFsdWU7XHJcbn0oKSk7XHJcbnZhciBGdWxmaWxsV2l0aE1ldGEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBGdWxmaWxsV2l0aE1ldGEocGF5bG9hZCwgbWV0YSkge1xyXG4gICAgICAgIHRoaXMucGF5bG9hZCA9IHBheWxvYWQ7XHJcbiAgICAgICAgdGhpcy5tZXRhID0gbWV0YTtcclxuICAgIH1cclxuICAgIHJldHVybiBGdWxmaWxsV2l0aE1ldGE7XHJcbn0oKSk7XHJcbnZhciBtaW5pU2VyaWFsaXplRXJyb3IgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgICB2YXIgc2ltcGxlRXJyb3IgPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGNvbW1vblByb3BlcnRpZXNfMSA9IGNvbW1vblByb3BlcnRpZXM7IF9pIDwgY29tbW9uUHJvcGVydGllc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgcHJvcGVydHkgPSBjb21tb25Qcm9wZXJ0aWVzXzFbX2ldO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlW3Byb3BlcnR5XSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgc2ltcGxlRXJyb3JbcHJvcGVydHldID0gdmFsdWVbcHJvcGVydHldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzaW1wbGVFcnJvcjtcclxuICAgIH1cclxuICAgIHJldHVybiB7IG1lc3NhZ2U6IFN0cmluZyh2YWx1ZSkgfTtcclxufTtcclxudmFyIGNyZWF0ZUFzeW5jVGh1bmsgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gY3JlYXRlQXN5bmNUaHVuazIodHlwZVByZWZpeCwgcGF5bG9hZENyZWF0b3IsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgZnVsZmlsbGVkID0gY3JlYXRlQWN0aW9uKHR5cGVQcmVmaXggKyBcIi9mdWxmaWxsZWRcIiwgZnVuY3Rpb24gKHBheWxvYWQsIHJlcXVlc3RJZCwgYXJnLCBtZXRhKSB7IHJldHVybiAoe1xyXG4gICAgICAgICAgICBwYXlsb2FkOiBwYXlsb2FkLFxyXG4gICAgICAgICAgICBtZXRhOiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBtZXRhIHx8IHt9KSwge1xyXG4gICAgICAgICAgICAgICAgYXJnOiBhcmcsXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IHJlcXVlc3RJZCxcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RTdGF0dXM6IFwiZnVsZmlsbGVkXCJcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9KTsgfSk7XHJcbiAgICAgICAgdmFyIHBlbmRpbmcgPSBjcmVhdGVBY3Rpb24odHlwZVByZWZpeCArIFwiL3BlbmRpbmdcIiwgZnVuY3Rpb24gKHJlcXVlc3RJZCwgYXJnLCBtZXRhKSB7IHJldHVybiAoe1xyXG4gICAgICAgICAgICBwYXlsb2FkOiB2b2lkIDAsXHJcbiAgICAgICAgICAgIG1ldGE6IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG1ldGEgfHwge30pLCB7XHJcbiAgICAgICAgICAgICAgICBhcmc6IGFyZyxcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RJZDogcmVxdWVzdElkLFxyXG4gICAgICAgICAgICAgICAgcmVxdWVzdFN0YXR1czogXCJwZW5kaW5nXCJcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9KTsgfSk7XHJcbiAgICAgICAgdmFyIHJlamVjdGVkID0gY3JlYXRlQWN0aW9uKHR5cGVQcmVmaXggKyBcIi9yZWplY3RlZFwiLCBmdW5jdGlvbiAoZXJyb3IsIHJlcXVlc3RJZCwgYXJnLCBwYXlsb2FkLCBtZXRhKSB7IHJldHVybiAoe1xyXG4gICAgICAgICAgICBwYXlsb2FkOiBwYXlsb2FkLFxyXG4gICAgICAgICAgICBlcnJvcjogKG9wdGlvbnMgJiYgb3B0aW9ucy5zZXJpYWxpemVFcnJvciB8fCBtaW5pU2VyaWFsaXplRXJyb3IpKGVycm9yIHx8IFwiUmVqZWN0ZWRcIiksXHJcbiAgICAgICAgICAgIG1ldGE6IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG1ldGEgfHwge30pLCB7XHJcbiAgICAgICAgICAgICAgICBhcmc6IGFyZyxcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RJZDogcmVxdWVzdElkLFxyXG4gICAgICAgICAgICAgICAgcmVqZWN0ZWRXaXRoVmFsdWU6ICEhcGF5bG9hZCxcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RTdGF0dXM6IFwicmVqZWN0ZWRcIixcclxuICAgICAgICAgICAgICAgIGFib3J0ZWQ6IChlcnJvciA9PSBudWxsID8gdm9pZCAwIDogZXJyb3IubmFtZSkgPT09IFwiQWJvcnRFcnJvclwiLFxyXG4gICAgICAgICAgICAgICAgY29uZGl0aW9uOiAoZXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IGVycm9yLm5hbWUpID09PSBcIkNvbmRpdGlvbkVycm9yXCJcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9KTsgfSk7XHJcbiAgICAgICAgdmFyIGRpc3BsYXllZFdhcm5pbmcgPSBmYWxzZTtcclxuICAgICAgICB2YXIgQUMgPSB0eXBlb2YgQWJvcnRDb250cm9sbGVyICE9PSBcInVuZGVmaW5lZFwiID8gQWJvcnRDb250cm9sbGVyIDogLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBjbGFzc18xKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaWduYWwgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWJvcnRlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBvbmFib3J0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICByZWFzb246IHZvaWQgMCxcclxuICAgICAgICAgICAgICAgICAgICB0aHJvd0lmQWJvcnRlZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkaXNwbGF5ZWRXYXJuaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXllZFdhcm5pbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oXCJUaGlzIHBsYXRmb3JtIGRvZXMgbm90IGltcGxlbWVudCBBYm9ydENvbnRyb2xsZXIuIFxcbklmIHlvdSB3YW50IHRvIHVzZSB0aGUgQWJvcnRDb250cm9sbGVyIHRvIHJlYWN0IHRvIGBhYm9ydGAgZXZlbnRzLCBwbGVhc2UgY29uc2lkZXIgaW1wb3J0aW5nIGEgcG9seWZpbGwgbGlrZSAnYWJvcnRjb250cm9sbGVyLXBvbHlmaWxsL2Rpc3QvYWJvcnRjb250cm9sbGVyLXBvbHlmaWxsLW9ubHknLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBjbGFzc18xO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgZnVuY3Rpb24gYWN0aW9uQ3JlYXRvcihhcmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkaXNwYXRjaCwgZ2V0U3RhdGUsIGV4dHJhKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdElkID0gKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuaWRHZW5lcmF0b3IpID8gb3B0aW9ucy5pZEdlbmVyYXRvcihhcmcpIDogbmFub2lkKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWJvcnRDb250cm9sbGVyID0gbmV3IEFDKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWJvcnRSZWFzb247XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYWJvcnQocmVhc29uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWJvcnRSZWFzb24gPSByZWFzb247XHJcbiAgICAgICAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZTIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBmaW5hbEFjdGlvbiwgY29uZGl0aW9uUmVzdWx0LCBhYm9ydGVkUHJvbWlzZSwgZXJyXzEsIHNraXBEaXNwYXRjaDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MudHJ5cy5wdXNoKFswLCA0LCAsIDVdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uUmVzdWx0ID0gKF9hID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5jb25kaXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKG9wdGlvbnMsIGFyZywgeyBnZXRTdGF0ZTogZ2V0U3RhdGUsIGV4dHJhOiBleHRyYSB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1RoZW5hYmxlKGNvbmRpdGlvblJlc3VsdCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBjb25kaXRpb25SZXN1bHRdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uUmVzdWx0ID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZGl0aW9uUmVzdWx0ID09PSBmYWxzZSB8fCBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkNvbmRpdGlvbkVycm9yXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJBYm9ydGVkIGR1ZSB0byBjb25kaXRpb24gY2FsbGJhY2sgcmV0dXJuaW5nIGZhbHNlLlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChfLCByZWplY3QpIHsgcmV0dXJuIGFib3J0Q29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlamVjdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkFib3J0RXJyb3JcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGFib3J0UmVhc29uIHx8IFwiQWJvcnRlZFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pOyB9KTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKHBlbmRpbmcocmVxdWVzdElkLCBhcmcsIChfYiA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZ2V0UGVuZGluZ01ldGEpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKG9wdGlvbnMsIHsgcmVxdWVzdElkOiByZXF1ZXN0SWQsIGFyZzogYXJnIH0sIHsgZ2V0U3RhdGU6IGdldFN0YXRlLCBleHRyYTogZXh0cmEgfSkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5yYWNlKFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydGVkUHJvbWlzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUocGF5bG9hZENyZWF0b3IoYXJnLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoOiBkaXNwYXRjaCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0U3RhdGU6IGdldFN0YXRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYTogZXh0cmEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RJZDogcmVxdWVzdElkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0OiBhYm9ydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0V2l0aFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIG1ldGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVqZWN0V2l0aFZhbHVlKHZhbHVlLCBtZXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsZmlsbFdpdGhWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBtZXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZ1bGZpbGxXaXRoTWV0YSh2YWx1ZSwgbWV0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBSZWplY3RXaXRoVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRnVsZmlsbFdpdGhNZXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVsZmlsbGVkKHJlc3VsdC5wYXlsb2FkLCByZXF1ZXN0SWQsIGFyZywgcmVzdWx0Lm1ldGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdWxmaWxsZWQocmVzdWx0LCByZXF1ZXN0SWQsIGFyZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsQWN0aW9uID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA1XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycl8xID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbEFjdGlvbiA9IGVycl8xIGluc3RhbmNlb2YgUmVqZWN0V2l0aFZhbHVlID8gcmVqZWN0ZWQobnVsbCwgcmVxdWVzdElkLCBhcmcsIGVycl8xLnBheWxvYWQsIGVycl8xLm1ldGEpIDogcmVqZWN0ZWQoZXJyXzEsIHJlcXVlc3RJZCwgYXJnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBza2lwRGlzcGF0Y2ggPSBvcHRpb25zICYmICFvcHRpb25zLmRpc3BhdGNoQ29uZGl0aW9uUmVqZWN0aW9uICYmIHJlamVjdGVkLm1hdGNoKGZpbmFsQWN0aW9uKSAmJiBmaW5hbEFjdGlvbi5tZXRhLmNvbmRpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFza2lwRGlzcGF0Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKGZpbmFsQWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZmluYWxBY3Rpb25dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0oKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHByb21pc2UyLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWJvcnQ6IGFib3J0LFxyXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RJZDogcmVxdWVzdElkLFxyXG4gICAgICAgICAgICAgICAgICAgIGFyZzogYXJnLFxyXG4gICAgICAgICAgICAgICAgICAgIHVud3JhcDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTIudGhlbih1bndyYXBSZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihhY3Rpb25DcmVhdG9yLCB7XHJcbiAgICAgICAgICAgIHBlbmRpbmc6IHBlbmRpbmcsXHJcbiAgICAgICAgICAgIHJlamVjdGVkOiByZWplY3RlZCxcclxuICAgICAgICAgICAgZnVsZmlsbGVkOiBmdWxmaWxsZWQsXHJcbiAgICAgICAgICAgIHR5cGVQcmVmaXg6IHR5cGVQcmVmaXhcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGNyZWF0ZUFzeW5jVGh1bmsyLndpdGhUeXBlcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNyZWF0ZUFzeW5jVGh1bmsyOyB9O1xyXG4gICAgcmV0dXJuIGNyZWF0ZUFzeW5jVGh1bmsyO1xyXG59KSgpO1xyXG5mdW5jdGlvbiB1bndyYXBSZXN1bHQoYWN0aW9uKSB7XHJcbiAgICBpZiAoYWN0aW9uLm1ldGEgJiYgYWN0aW9uLm1ldGEucmVqZWN0ZWRXaXRoVmFsdWUpIHtcclxuICAgICAgICB0aHJvdyBhY3Rpb24ucGF5bG9hZDtcclxuICAgIH1cclxuICAgIGlmIChhY3Rpb24uZXJyb3IpIHtcclxuICAgICAgICB0aHJvdyBhY3Rpb24uZXJyb3I7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYWN0aW9uLnBheWxvYWQ7XHJcbn1cclxuZnVuY3Rpb24gaXNUaGVuYWJsZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gXCJmdW5jdGlvblwiO1xyXG59XHJcbi8vIHNyYy9tYXRjaGVycy50c1xyXG52YXIgbWF0Y2hlcyA9IGZ1bmN0aW9uIChtYXRjaGVyLCBhY3Rpb24pIHtcclxuICAgIGlmIChoYXNNYXRjaEZ1bmN0aW9uKG1hdGNoZXIpKSB7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoZXIubWF0Y2goYWN0aW9uKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBtYXRjaGVyKGFjdGlvbik7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIGlzQW55T2YoKSB7XHJcbiAgICB2YXIgbWF0Y2hlcnMgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgbWF0Y2hlcnNbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoZXJzLnNvbWUoZnVuY3Rpb24gKG1hdGNoZXIpIHsgcmV0dXJuIG1hdGNoZXMobWF0Y2hlciwgYWN0aW9uKTsgfSk7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGlzQWxsT2YoKSB7XHJcbiAgICB2YXIgbWF0Y2hlcnMgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgbWF0Y2hlcnNbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoZXJzLmV2ZXJ5KGZ1bmN0aW9uIChtYXRjaGVyKSB7IHJldHVybiBtYXRjaGVzKG1hdGNoZXIsIGFjdGlvbik7IH0pO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIHZhbGlkU3RhdHVzKSB7XHJcbiAgICBpZiAoIWFjdGlvbiB8fCAhYWN0aW9uLm1ldGEpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgdmFyIGhhc1ZhbGlkUmVxdWVzdElkID0gdHlwZW9mIGFjdGlvbi5tZXRhLnJlcXVlc3RJZCA9PT0gXCJzdHJpbmdcIjtcclxuICAgIHZhciBoYXNWYWxpZFJlcXVlc3RTdGF0dXMgPSB2YWxpZFN0YXR1cy5pbmRleE9mKGFjdGlvbi5tZXRhLnJlcXVlc3RTdGF0dXMpID4gLTE7XHJcbiAgICByZXR1cm4gaGFzVmFsaWRSZXF1ZXN0SWQgJiYgaGFzVmFsaWRSZXF1ZXN0U3RhdHVzO1xyXG59XHJcbmZ1bmN0aW9uIGlzQXN5bmNUaHVua0FycmF5KGEpIHtcclxuICAgIHJldHVybiB0eXBlb2YgYVswXSA9PT0gXCJmdW5jdGlvblwiICYmIFwicGVuZGluZ1wiIGluIGFbMF0gJiYgXCJmdWxmaWxsZWRcIiBpbiBhWzBdICYmIFwicmVqZWN0ZWRcIiBpbiBhWzBdO1xyXG59XHJcbmZ1bmN0aW9uIGlzUGVuZGluZygpIHtcclxuICAgIHZhciBhc3luY1RodW5rcyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBhc3luY1RodW5rc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7IHJldHVybiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIFtcInBlbmRpbmdcIl0pOyB9O1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcclxuICAgICAgICByZXR1cm4gaXNQZW5kaW5nKCkoYXN5bmNUaHVua3NbMF0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICB2YXIgbWF0Y2hlcnMgPSBhc3luY1RodW5rcy5tYXAoZnVuY3Rpb24gKGFzeW5jVGh1bmspIHsgcmV0dXJuIGFzeW5jVGh1bmsucGVuZGluZzsgfSk7XHJcbiAgICAgICAgdmFyIGNvbWJpbmVkTWF0Y2hlciA9IGlzQW55T2YuYXBwbHkodm9pZCAwLCBtYXRjaGVycyk7XHJcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVkTWF0Y2hlcihhY3Rpb24pO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBpc1JlamVjdGVkKCkge1xyXG4gICAgdmFyIGFzeW5jVGh1bmtzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIGFzeW5jVGh1bmtzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHsgcmV0dXJuIGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgW1wicmVqZWN0ZWRcIl0pOyB9O1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcclxuICAgICAgICByZXR1cm4gaXNSZWplY3RlZCgpKGFzeW5jVGh1bmtzWzBdKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIG1hdGNoZXJzID0gYXN5bmNUaHVua3MubWFwKGZ1bmN0aW9uIChhc3luY1RodW5rKSB7IHJldHVybiBhc3luY1RodW5rLnJlamVjdGVkOyB9KTtcclxuICAgICAgICB2YXIgY29tYmluZWRNYXRjaGVyID0gaXNBbnlPZi5hcHBseSh2b2lkIDAsIG1hdGNoZXJzKTtcclxuICAgICAgICByZXR1cm4gY29tYmluZWRNYXRjaGVyKGFjdGlvbik7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGlzUmVqZWN0ZWRXaXRoVmFsdWUoKSB7XHJcbiAgICB2YXIgYXN5bmNUaHVua3MgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgYXN5bmNUaHVua3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHZhciBoYXNGbGFnID0gZnVuY3Rpb24gKGFjdGlvbikge1xyXG4gICAgICAgIHJldHVybiBhY3Rpb24gJiYgYWN0aW9uLm1ldGEgJiYgYWN0aW9uLm1ldGEucmVqZWN0ZWRXaXRoVmFsdWU7XHJcbiAgICB9O1xyXG4gICAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBjb21iaW5lZE1hdGNoZXIgPSBpc0FsbE9mKGlzUmVqZWN0ZWQuYXBwbHkodm9pZCAwLCBhc3luY1RodW5rcyksIGhhc0ZsYWcpO1xyXG4gICAgICAgICAgICByZXR1cm4gY29tYmluZWRNYXRjaGVyKGFjdGlvbik7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGlmICghaXNBc3luY1RodW5rQXJyYXkoYXN5bmNUaHVua3MpKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzUmVqZWN0ZWRXaXRoVmFsdWUoKShhc3luY1RodW5rc1swXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xyXG4gICAgICAgIHZhciBjb21iaW5lZE1hdGNoZXIgPSBpc0FsbE9mKGlzUmVqZWN0ZWQuYXBwbHkodm9pZCAwLCBhc3luY1RodW5rcyksIGhhc0ZsYWcpO1xyXG4gICAgICAgIHJldHVybiBjb21iaW5lZE1hdGNoZXIoYWN0aW9uKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaXNGdWxmaWxsZWQoKSB7XHJcbiAgICB2YXIgYXN5bmNUaHVua3MgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgYXN5bmNUaHVua3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIGlmIChhc3luY1RodW5rcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikgeyByZXR1cm4gaGFzRXhwZWN0ZWRSZXF1ZXN0TWV0YWRhdGEoYWN0aW9uLCBbXCJmdWxmaWxsZWRcIl0pOyB9O1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcclxuICAgICAgICByZXR1cm4gaXNGdWxmaWxsZWQoKShhc3luY1RodW5rc1swXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xyXG4gICAgICAgIHZhciBtYXRjaGVycyA9IGFzeW5jVGh1bmtzLm1hcChmdW5jdGlvbiAoYXN5bmNUaHVuaykgeyByZXR1cm4gYXN5bmNUaHVuay5mdWxmaWxsZWQ7IH0pO1xyXG4gICAgICAgIHZhciBjb21iaW5lZE1hdGNoZXIgPSBpc0FueU9mLmFwcGx5KHZvaWQgMCwgbWF0Y2hlcnMpO1xyXG4gICAgICAgIHJldHVybiBjb21iaW5lZE1hdGNoZXIoYWN0aW9uKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaXNBc3luY1RodW5rQWN0aW9uKCkge1xyXG4gICAgdmFyIGFzeW5jVGh1bmtzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIGFzeW5jVGh1bmtzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHsgcmV0dXJuIGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgW1wicGVuZGluZ1wiLCBcImZ1bGZpbGxlZFwiLCBcInJlamVjdGVkXCJdKTsgfTtcclxuICAgIH1cclxuICAgIGlmICghaXNBc3luY1RodW5rQXJyYXkoYXN5bmNUaHVua3MpKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzQXN5bmNUaHVua0FjdGlvbigpKGFzeW5jVGh1bmtzWzBdKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIG1hdGNoZXJzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBhc3luY1RodW5rc18xID0gYXN5bmNUaHVua3M7IF9pIDwgYXN5bmNUaHVua3NfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGFzeW5jVGh1bmsgPSBhc3luY1RodW5rc18xW19pXTtcclxuICAgICAgICAgICAgbWF0Y2hlcnMucHVzaChhc3luY1RodW5rLnBlbmRpbmcsIGFzeW5jVGh1bmsucmVqZWN0ZWQsIGFzeW5jVGh1bmsuZnVsZmlsbGVkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNvbWJpbmVkTWF0Y2hlciA9IGlzQW55T2YuYXBwbHkodm9pZCAwLCBtYXRjaGVycyk7XHJcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVkTWF0Y2hlcihhY3Rpb24pO1xyXG4gICAgfTtcclxufVxyXG4vLyBzcmMvbGlzdGVuZXJNaWRkbGV3YXJlL3V0aWxzLnRzXHJcbnZhciBhc3NlcnRGdW5jdGlvbiA9IGZ1bmN0aW9uIChmdW5jLCBleHBlY3RlZCkge1xyXG4gICAgaWYgKHR5cGVvZiBmdW5jICE9PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGV4cGVjdGVkICsgXCIgaXMgbm90IGEgZnVuY3Rpb25cIik7XHJcbiAgICB9XHJcbn07XHJcbnZhciBub29wID0gZnVuY3Rpb24gKCkge1xyXG59O1xyXG52YXIgY2F0Y2hSZWplY3Rpb24gPSBmdW5jdGlvbiAocHJvbWlzZTIsIG9uRXJyb3IpIHtcclxuICAgIGlmIChvbkVycm9yID09PSB2b2lkIDApIHsgb25FcnJvciA9IG5vb3A7IH1cclxuICAgIHByb21pc2UyLmNhdGNoKG9uRXJyb3IpO1xyXG4gICAgcmV0dXJuIHByb21pc2UyO1xyXG59O1xyXG52YXIgYWRkQWJvcnRTaWduYWxMaXN0ZW5lciA9IGZ1bmN0aW9uIChhYm9ydFNpZ25hbCwgY2FsbGJhY2spIHtcclxuICAgIGFib3J0U2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBjYWxsYmFjaywgeyBvbmNlOiB0cnVlIH0pO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFib3J0U2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBjYWxsYmFjayk7IH07XHJcbn07XHJcbnZhciBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uID0gZnVuY3Rpb24gKGFib3J0Q29udHJvbGxlciwgcmVhc29uKSB7XHJcbiAgICB2YXIgc2lnbmFsID0gYWJvcnRDb250cm9sbGVyLnNpZ25hbDtcclxuICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICghKFwicmVhc29uXCIgaW4gc2lnbmFsKSkge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaWduYWwsIFwicmVhc29uXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHJlYXNvbixcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgYWJvcnRDb250cm9sbGVyLmFib3J0KHJlYXNvbik7XHJcbn07XHJcbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvZXhjZXB0aW9ucy50c1xyXG52YXIgdGFzayA9IFwidGFza1wiO1xyXG52YXIgbGlzdGVuZXIgPSBcImxpc3RlbmVyXCI7XHJcbnZhciBjb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xyXG52YXIgY2FuY2VsbGVkID0gXCJjYW5jZWxsZWRcIjtcclxudmFyIHRhc2tDYW5jZWxsZWQgPSBcInRhc2stXCIgKyBjYW5jZWxsZWQ7XHJcbnZhciB0YXNrQ29tcGxldGVkID0gXCJ0YXNrLVwiICsgY29tcGxldGVkO1xyXG52YXIgbGlzdGVuZXJDYW5jZWxsZWQgPSBsaXN0ZW5lciArIFwiLVwiICsgY2FuY2VsbGVkO1xyXG52YXIgbGlzdGVuZXJDb21wbGV0ZWQgPSBsaXN0ZW5lciArIFwiLVwiICsgY29tcGxldGVkO1xyXG52YXIgVGFza0Fib3J0RXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBUYXNrQWJvcnRFcnJvcihjb2RlKSB7XHJcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBcIlRhc2tBYm9ydEVycm9yXCI7XHJcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gdGFzayArIFwiIFwiICsgY2FuY2VsbGVkICsgXCIgKHJlYXNvbjogXCIgKyBjb2RlICsgXCIpXCI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gVGFza0Fib3J0RXJyb3I7XHJcbn0oKSk7XHJcbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvdGFzay50c1xyXG52YXIgdmFsaWRhdGVBY3RpdmUgPSBmdW5jdGlvbiAoc2lnbmFsKSB7XHJcbiAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVGFza0Fib3J0RXJyb3Ioc2lnbmFsLnJlYXNvbik7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIHJhY2VXaXRoU2lnbmFsKHNpZ25hbCwgcHJvbWlzZTIpIHtcclxuICAgIHZhciBjbGVhbnVwID0gbm9vcDtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgdmFyIG5vdGlmeVJlamVjdGlvbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlamVjdChuZXcgVGFza0Fib3J0RXJyb3Ioc2lnbmFsLnJlYXNvbikpOyB9O1xyXG4gICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xyXG4gICAgICAgICAgICBub3RpZnlSZWplY3Rpb24oKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjbGVhbnVwID0gYWRkQWJvcnRTaWduYWxMaXN0ZW5lcihzaWduYWwsIG5vdGlmeVJlamVjdGlvbik7XHJcbiAgICAgICAgcHJvbWlzZTIuZmluYWxseShmdW5jdGlvbiAoKSB7IHJldHVybiBjbGVhbnVwKCk7IH0pLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNsZWFudXAgPSBub29wO1xyXG4gICAgfSk7XHJcbn1cclxudmFyIHJ1blRhc2sgPSBmdW5jdGlvbiAodGFzazIsIGNsZWFuVXApIHsgcmV0dXJuIF9fYXN5bmModm9pZCAwLCBudWxsLCBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgdmFsdWUsIGVycm9yXzE7XHJcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XHJcbiAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xyXG4gICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICBfYy50cnlzLnB1c2goWzAsIDMsIDQsIDVdKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIFByb21pc2UucmVzb2x2ZSgpXTtcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGFzazIoKV07XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBcIm9rXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIH1dO1xyXG4gICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICBlcnJvcl8xID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBlcnJvcl8xIGluc3RhbmNlb2YgVGFza0Fib3J0RXJyb3IgPyBcImNhbmNlbGxlZFwiIDogXCJyZWplY3RlZFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JfMVxyXG4gICAgICAgICAgICAgICAgICAgIH1dO1xyXG4gICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICBjbGVhblVwID09IG51bGwgPyB2b2lkIDAgOiBjbGVhblVwKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xyXG4gICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufSk7IH07XHJcbnZhciBjcmVhdGVQYXVzZSA9IGZ1bmN0aW9uIChzaWduYWwpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAocHJvbWlzZTIpIHtcclxuICAgICAgICByZXR1cm4gY2F0Y2hSZWplY3Rpb24ocmFjZVdpdGhTaWduYWwoc2lnbmFsLCBwcm9taXNlMikudGhlbihmdW5jdGlvbiAob3V0cHV0KSB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRlQWN0aXZlKHNpZ25hbCk7XHJcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfTtcclxufTtcclxudmFyIGNyZWF0ZURlbGF5ID0gZnVuY3Rpb24gKHNpZ25hbCkge1xyXG4gICAgdmFyIHBhdXNlID0gY3JlYXRlUGF1c2Uoc2lnbmFsKTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGltZW91dE1zKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhdXNlKG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJldHVybiBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWVvdXRNcyk7IH0pKTtcclxuICAgIH07XHJcbn07XHJcbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvaW5kZXgudHNcclxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XHJcbnZhciBJTlRFUk5BTF9OSUxfVE9LRU4gPSB7fTtcclxudmFyIGFsbSA9IFwibGlzdGVuZXJNaWRkbGV3YXJlXCI7XHJcbnZhciBjcmVhdGVGb3JrID0gZnVuY3Rpb24gKHBhcmVudEFib3J0U2lnbmFsLCBwYXJlbnRCbG9ja2luZ1Byb21pc2VzKSB7XHJcbiAgICB2YXIgbGlua0NvbnRyb2xsZXJzID0gZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHsgcmV0dXJuIGFkZEFib3J0U2lnbmFsTGlzdGVuZXIocGFyZW50QWJvcnRTaWduYWwsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oY29udHJvbGxlciwgcGFyZW50QWJvcnRTaWduYWwucmVhc29uKTsgfSk7IH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhc2tFeGVjdXRvciwgb3B0cykge1xyXG4gICAgICAgIGFzc2VydEZ1bmN0aW9uKHRhc2tFeGVjdXRvciwgXCJ0YXNrRXhlY3V0b3JcIik7XHJcbiAgICAgICAgdmFyIGNoaWxkQWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xyXG4gICAgICAgIGxpbmtDb250cm9sbGVycyhjaGlsZEFib3J0Q29udHJvbGxlcik7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJ1blRhc2soZnVuY3Rpb24gKCkgeyByZXR1cm4gX19hc3luYyh2b2lkIDAsIG51bGwsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdDI7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlQWN0aXZlKHBhcmVudEFib3J0U2lnbmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVBY3RpdmUoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGFza0V4ZWN1dG9yKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXVzZTogY3JlYXRlUGF1c2UoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxheTogY3JlYXRlRGVsYXkoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYWw6IGNoaWxkQWJvcnRDb250cm9sbGVyLnNpZ25hbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MiA9IF9jLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVBY3RpdmUoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdDJdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTsgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihjaGlsZEFib3J0Q29udHJvbGxlciwgdGFza0NvbXBsZXRlZCk7IH0pO1xyXG4gICAgICAgIGlmIChvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmF1dG9Kb2luKSB7XHJcbiAgICAgICAgICAgIHBhcmVudEJsb2NraW5nUHJvbWlzZXMucHVzaChyZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICByZXN1bHQ6IGNyZWF0ZVBhdXNlKHBhcmVudEFib3J0U2lnbmFsKShyZXN1bHQpLFxyXG4gICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oY2hpbGRBYm9ydENvbnRyb2xsZXIsIHRhc2tDYW5jZWxsZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbn07XHJcbnZhciBjcmVhdGVUYWtlUGF0dGVybiA9IGZ1bmN0aW9uIChzdGFydExpc3RlbmluZywgc2lnbmFsKSB7XHJcbiAgICB2YXIgdGFrZSA9IGZ1bmN0aW9uIChwcmVkaWNhdGUsIHRpbWVvdXQpIHsgcmV0dXJuIF9fYXN5bmModm9pZCAwLCBudWxsLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHVuc3Vic2NyaWJlLCB0dXBsZVByb21pc2UsIHByb21pc2VzLCBvdXRwdXQ7XHJcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVBY3RpdmUoc2lnbmFsKTtcclxuICAgICAgICAgICAgICAgICAgICB1bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHR1cGxlUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3BMaXN0ZW5pbmcgPSBzdGFydExpc3RlbmluZyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVkaWNhdGU6IHByZWRpY2F0ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVmZmVjdDogZnVuY3Rpb24gKGFjdGlvbiwgbGlzdGVuZXJBcGkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lckFwaS51bnN1YnNjcmliZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyQXBpLmdldFN0YXRlKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyQXBpLmdldE9yaWdpbmFsU3RhdGUoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9wTGlzdGVuaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcyA9IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHVwbGVQcm9taXNlXHJcbiAgICAgICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGltZW91dCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2gobmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmV0dXJuIHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZW91dCwgbnVsbCk7IH0pKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAxO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIF9jLnRyeXMucHVzaChbMSwgLCAzLCA0XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcmFjZVdpdGhTaWduYWwoc2lnbmFsLCBQcm9taXNlLnJhY2UocHJvbWlzZXMpKV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlQWN0aXZlKHNpZ25hbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG91dHB1dF07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgdW5zdWJzY3JpYmUoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzIgLypyZXR1cm4qL107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pOyB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwcmVkaWNhdGUsIHRpbWVvdXQpIHsgcmV0dXJuIGNhdGNoUmVqZWN0aW9uKHRha2UocHJlZGljYXRlLCB0aW1lb3V0KSk7IH07XHJcbn07XHJcbnZhciBnZXRMaXN0ZW5lckVudHJ5UHJvcHNGcm9tID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgIHZhciB0eXBlID0gb3B0aW9ucy50eXBlLCBhY3Rpb25DcmVhdG9yID0gb3B0aW9ucy5hY3Rpb25DcmVhdG9yLCBtYXRjaGVyID0gb3B0aW9ucy5tYXRjaGVyLCBwcmVkaWNhdGUgPSBvcHRpb25zLnByZWRpY2F0ZSwgZWZmZWN0ID0gb3B0aW9ucy5lZmZlY3Q7XHJcbiAgICBpZiAodHlwZSkge1xyXG4gICAgICAgIHByZWRpY2F0ZSA9IGNyZWF0ZUFjdGlvbih0eXBlKS5tYXRjaDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGFjdGlvbkNyZWF0b3IpIHtcclxuICAgICAgICB0eXBlID0gYWN0aW9uQ3JlYXRvci50eXBlO1xyXG4gICAgICAgIHByZWRpY2F0ZSA9IGFjdGlvbkNyZWF0b3IubWF0Y2g7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChtYXRjaGVyKSB7XHJcbiAgICAgICAgcHJlZGljYXRlID0gbWF0Y2hlcjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHByZWRpY2F0ZSkge1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ3JlYXRpbmcgb3IgcmVtb3ZpbmcgYSBsaXN0ZW5lciByZXF1aXJlcyBvbmUgb2YgdGhlIGtub3duIGZpZWxkcyBmb3IgbWF0Y2hpbmcgYW4gYWN0aW9uXCIpO1xyXG4gICAgfVxyXG4gICAgYXNzZXJ0RnVuY3Rpb24oZWZmZWN0LCBcIm9wdGlvbnMubGlzdGVuZXJcIik7XHJcbiAgICByZXR1cm4geyBwcmVkaWNhdGU6IHByZWRpY2F0ZSwgdHlwZTogdHlwZSwgZWZmZWN0OiBlZmZlY3QgfTtcclxufTtcclxudmFyIGNyZWF0ZUxpc3RlbmVyRW50cnkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgdmFyIF9jID0gZ2V0TGlzdGVuZXJFbnRyeVByb3BzRnJvbShvcHRpb25zKSwgdHlwZSA9IF9jLnR5cGUsIHByZWRpY2F0ZSA9IF9jLnByZWRpY2F0ZSwgZWZmZWN0ID0gX2MuZWZmZWN0O1xyXG4gICAgdmFyIGlkID0gbmFub2lkKCk7XHJcbiAgICB2YXIgZW50cnkgPSB7XHJcbiAgICAgICAgaWQ6IGlkLFxyXG4gICAgICAgIGVmZmVjdDogZWZmZWN0LFxyXG4gICAgICAgIHR5cGU6IHR5cGUsXHJcbiAgICAgICAgcHJlZGljYXRlOiBwcmVkaWNhdGUsXHJcbiAgICAgICAgcGVuZGluZzogbmV3IFNldCgpLFxyXG4gICAgICAgIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3Vic2NyaWJlIG5vdCBpbml0aWFsaXplZFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGVudHJ5O1xyXG59O1xyXG52YXIgY2FuY2VsQWN0aXZlTGlzdGVuZXJzID0gZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICBlbnRyeS5wZW5kaW5nLmZvckVhY2goZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHtcclxuICAgICAgICBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGNvbnRyb2xsZXIsIGxpc3RlbmVyQ2FuY2VsbGVkKTtcclxuICAgIH0pO1xyXG59O1xyXG52YXIgY3JlYXRlQ2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUgPSBmdW5jdGlvbiAobGlzdGVuZXJNYXApIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgbGlzdGVuZXJNYXAuZm9yRWFjaChjYW5jZWxBY3RpdmVMaXN0ZW5lcnMpO1xyXG4gICAgICAgIGxpc3RlbmVyTWFwLmNsZWFyKCk7XHJcbiAgICB9O1xyXG59O1xyXG52YXIgc2FmZWx5Tm90aWZ5RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3JIYW5kbGVyLCBlcnJvclRvTm90aWZ5LCBlcnJvckluZm8pIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgZXJyb3JIYW5kbGVyKGVycm9yVG9Ob3RpZnksIGVycm9ySW5mbyk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3JIYW5kbGVyRXJyb3IpIHtcclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhyb3cgZXJyb3JIYW5kbGVyRXJyb3I7XHJcbiAgICAgICAgfSwgMCk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBhZGRMaXN0ZW5lciA9IGNyZWF0ZUFjdGlvbihhbG0gKyBcIi9hZGRcIik7XHJcbnZhciBjbGVhckFsbExpc3RlbmVycyA9IGNyZWF0ZUFjdGlvbihhbG0gKyBcIi9yZW1vdmVBbGxcIik7XHJcbnZhciByZW1vdmVMaXN0ZW5lciA9IGNyZWF0ZUFjdGlvbihhbG0gKyBcIi9yZW1vdmVcIik7XHJcbnZhciBkZWZhdWx0RXJyb3JIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgY29uc29sZS5lcnJvci5hcHBseShjb25zb2xlLCBfX3NwcmVhZEFycmF5KFthbG0gKyBcIi9lcnJvclwiXSwgYXJncykpO1xyXG59O1xyXG5mdW5jdGlvbiBjcmVhdGVMaXN0ZW5lck1pZGRsZXdhcmUobWlkZGxld2FyZU9wdGlvbnMpIHtcclxuICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICBpZiAobWlkZGxld2FyZU9wdGlvbnMgPT09IHZvaWQgMCkgeyBtaWRkbGV3YXJlT3B0aW9ucyA9IHt9OyB9XHJcbiAgICB2YXIgbGlzdGVuZXJNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICB2YXIgZXh0cmEgPSBtaWRkbGV3YXJlT3B0aW9ucy5leHRyYSwgX2MgPSBtaWRkbGV3YXJlT3B0aW9ucy5vbkVycm9yLCBvbkVycm9yID0gX2MgPT09IHZvaWQgMCA/IGRlZmF1bHRFcnJvckhhbmRsZXIgOiBfYztcclxuICAgIGFzc2VydEZ1bmN0aW9uKG9uRXJyb3IsIFwib25FcnJvclwiKTtcclxuICAgIHZhciBpbnNlcnRFbnRyeSA9IGZ1bmN0aW9uIChlbnRyeSkge1xyXG4gICAgICAgIGVudHJ5LnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbGlzdGVuZXJNYXAuZGVsZXRlKGVudHJ5LmlkKTsgfTtcclxuICAgICAgICBsaXN0ZW5lck1hcC5zZXQoZW50cnkuaWQsIGVudHJ5KTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNhbmNlbE9wdGlvbnMpIHtcclxuICAgICAgICAgICAgZW50cnkudW5zdWJzY3JpYmUoKTtcclxuICAgICAgICAgICAgaWYgKGNhbmNlbE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbmNlbE9wdGlvbnMuY2FuY2VsQWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICBjYW5jZWxBY3RpdmVMaXN0ZW5lcnMoZW50cnkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICB2YXIgZmluZExpc3RlbmVyRW50cnkgPSBmdW5jdGlvbiAoY29tcGFyYXRvcikge1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2MgPSBBcnJheS5mcm9tKGxpc3RlbmVyTWFwLnZhbHVlcygpKTsgX2kgPCBfYy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGVudHJ5ID0gX2NbX2ldO1xyXG4gICAgICAgICAgICBpZiAoY29tcGFyYXRvcihlbnRyeSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdm9pZCAwO1xyXG4gICAgfTtcclxuICAgIHZhciBzdGFydExpc3RlbmluZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gZmluZExpc3RlbmVyRW50cnkoZnVuY3Rpb24gKGV4aXN0aW5nRW50cnkpIHsgcmV0dXJuIGV4aXN0aW5nRW50cnkuZWZmZWN0ID09PSBvcHRpb25zLmVmZmVjdDsgfSk7XHJcbiAgICAgICAgaWYgKCFlbnRyeSkge1xyXG4gICAgICAgICAgICBlbnRyeSA9IGNyZWF0ZUxpc3RlbmVyRW50cnkob3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbnNlcnRFbnRyeShlbnRyeSk7XHJcbiAgICB9O1xyXG4gICAgdmFyIHN0b3BMaXN0ZW5pbmcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYyA9IGdldExpc3RlbmVyRW50cnlQcm9wc0Zyb20ob3B0aW9ucyksIHR5cGUgPSBfYy50eXBlLCBlZmZlY3QgPSBfYy5lZmZlY3QsIHByZWRpY2F0ZSA9IF9jLnByZWRpY2F0ZTtcclxuICAgICAgICB2YXIgZW50cnkgPSBmaW5kTGlzdGVuZXJFbnRyeShmdW5jdGlvbiAoZW50cnkyKSB7XHJcbiAgICAgICAgICAgIHZhciBtYXRjaFByZWRpY2F0ZU9yVHlwZSA9IHR5cGVvZiB0eXBlID09PSBcInN0cmluZ1wiID8gZW50cnkyLnR5cGUgPT09IHR5cGUgOiBlbnRyeTIucHJlZGljYXRlID09PSBwcmVkaWNhdGU7XHJcbiAgICAgICAgICAgIHJldHVybiBtYXRjaFByZWRpY2F0ZU9yVHlwZSAmJiBlbnRyeTIuZWZmZWN0ID09PSBlZmZlY3Q7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGVudHJ5KSB7XHJcbiAgICAgICAgICAgIGVudHJ5LnVuc3Vic2NyaWJlKCk7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNhbmNlbEFjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgY2FuY2VsQWN0aXZlTGlzdGVuZXJzKGVudHJ5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gISFlbnRyeTtcclxuICAgIH07XHJcbiAgICB2YXIgbm90aWZ5TGlzdGVuZXIgPSBmdW5jdGlvbiAoZW50cnksIGFjdGlvbiwgYXBpLCBnZXRPcmlnaW5hbFN0YXRlKSB7IHJldHVybiBfX2FzeW5jKF90aGlzLCBudWxsLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGludGVybmFsVGFza0NvbnRyb2xsZXIsIHRha2UsIGF1dG9Kb2luUHJvbWlzZXMsIGxpc3RlbmVyRXJyb3JfMTtcclxuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFRhc2tDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRha2UgPSBjcmVhdGVUYWtlUGF0dGVybihzdGFydExpc3RlbmluZywgaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGF1dG9Kb2luUHJvbWlzZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDE7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgX2MudHJ5cy5wdXNoKFsxLCAzLCA0LCA2XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZW50cnkucGVuZGluZy5hZGQoaW50ZXJuYWxUYXNrQ29udHJvbGxlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5yZXNvbHZlKGVudHJ5LmVmZmVjdChhY3Rpb24sIGFzc2lnbih7fSwgYXBpLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRPcmlnaW5hbFN0YXRlOiBnZXRPcmlnaW5hbFN0YXRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uOiBmdW5jdGlvbiAocHJlZGljYXRlLCB0aW1lb3V0KSB7IHJldHVybiB0YWtlKHByZWRpY2F0ZSwgdGltZW91dCkudGhlbihCb29sZWFuKTsgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRha2U6IHRha2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxheTogY3JlYXRlRGVsYXkoaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF1c2U6IGNyZWF0ZVBhdXNlKGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhOiBleHRyYSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbDogaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JrOiBjcmVhdGVGb3JrKGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsLCBhdXRvSm9pblByb21pc2VzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlOiBlbnRyeS51bnN1YnNjcmliZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyTWFwLnNldChlbnRyeS5pZCwgZW50cnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbEFjdGl2ZUxpc3RlbmVyczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LnBlbmRpbmcuZm9yRWFjaChmdW5jdGlvbiAoY29udHJvbGxlciwgXywgc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250cm9sbGVyICE9PSBpbnRlcm5hbFRhc2tDb250cm9sbGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGNvbnRyb2xsZXIsIGxpc3RlbmVyQ2FuY2VsbGVkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldC5kZWxldGUoY29udHJvbGxlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpKV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyRXJyb3JfMSA9IF9jLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIShsaXN0ZW5lckVycm9yXzEgaW5zdGFuY2VvZiBUYXNrQWJvcnRFcnJvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2FmZWx5Tm90aWZ5RXJyb3Iob25FcnJvciwgbGlzdGVuZXJFcnJvcl8xLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYWlzZWRCeTogXCJlZmZlY3RcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbNCAvKnlpZWxkKi8sIFByb21pc2UuYWxsU2V0dGxlZChhdXRvSm9pblByb21pc2VzKV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgICAgICAgICAgX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oaW50ZXJuYWxUYXNrQ29udHJvbGxlciwgbGlzdGVuZXJDb21wbGV0ZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVudHJ5LnBlbmRpbmcuZGVsZXRlKGludGVybmFsVGFza0NvbnRyb2xsZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XHJcbiAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7IH07XHJcbiAgICB2YXIgY2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUgPSBjcmVhdGVDbGVhckxpc3RlbmVyTWlkZGxld2FyZShsaXN0ZW5lck1hcCk7XHJcbiAgICB2YXIgbWlkZGxld2FyZSA9IGZ1bmN0aW9uIChhcGkpIHsgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7IHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKCFpc0FjdGlvbihhY3Rpb24pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXh0KGFjdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhZGRMaXN0ZW5lci5tYXRjaChhY3Rpb24pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdGFydExpc3RlbmluZyhhY3Rpb24ucGF5bG9hZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjbGVhckFsbExpc3RlbmVycy5tYXRjaChhY3Rpb24pKSB7XHJcbiAgICAgICAgICAgIGNsZWFyTGlzdGVuZXJNaWRkbGV3YXJlKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlbW92ZUxpc3RlbmVyLm1hdGNoKGFjdGlvbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0b3BMaXN0ZW5pbmcoYWN0aW9uLnBheWxvYWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb3JpZ2luYWxTdGF0ZSA9IGFwaS5nZXRTdGF0ZSgpO1xyXG4gICAgICAgIHZhciBnZXRPcmlnaW5hbFN0YXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAob3JpZ2luYWxTdGF0ZSA9PT0gSU5URVJOQUxfTklMX1RPS0VOKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYWxtICsgXCI6IGdldE9yaWdpbmFsU3RhdGUgY2FuIG9ubHkgYmUgY2FsbGVkIHN5bmNocm9ub3VzbHlcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsU3RhdGU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgcmVzdWx0O1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IG5leHQoYWN0aW9uKTtcclxuICAgICAgICAgICAgaWYgKGxpc3RlbmVyTWFwLnNpemUgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFN0YXRlID0gYXBpLmdldFN0YXRlKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJFbnRyaWVzID0gQXJyYXkuZnJvbShsaXN0ZW5lck1hcC52YWx1ZXMoKSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGxpc3RlbmVyRW50cmllc18xID0gbGlzdGVuZXJFbnRyaWVzOyBfaSA8IGxpc3RlbmVyRW50cmllc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IGxpc3RlbmVyRW50cmllc18xW19pXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcnVuTGlzdGVuZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydW5MaXN0ZW5lciA9IGVudHJ5LnByZWRpY2F0ZShhY3Rpb24sIGN1cnJlbnRTdGF0ZSwgb3JpZ2luYWxTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChwcmVkaWNhdGVFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydW5MaXN0ZW5lciA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzYWZlbHlOb3RpZnlFcnJvcihvbkVycm9yLCBwcmVkaWNhdGVFcnJvciwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFpc2VkQnk6IFwicHJlZGljYXRlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcnVuTGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG5vdGlmeUxpc3RlbmVyKGVudHJ5LCBhY3Rpb24sIGFwaSwgZ2V0T3JpZ2luYWxTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIG9yaWdpbmFsU3RhdGUgPSBJTlRFUk5BTF9OSUxfVE9LRU47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9OyB9OyB9O1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBtaWRkbGV3YXJlOiBtaWRkbGV3YXJlLFxyXG4gICAgICAgIHN0YXJ0TGlzdGVuaW5nOiBzdGFydExpc3RlbmluZyxcclxuICAgICAgICBzdG9wTGlzdGVuaW5nOiBzdG9wTGlzdGVuaW5nLFxyXG4gICAgICAgIGNsZWFyTGlzdGVuZXJzOiBjbGVhckxpc3RlbmVyTWlkZGxld2FyZVxyXG4gICAgfTtcclxufVxyXG4vLyBzcmMvYXV0b0JhdGNoRW5oYW5jZXIudHNcclxudmFyIFNIT1VMRF9BVVRPQkFUQ0ggPSBcIlJUS19hdXRvQmF0Y2hcIjtcclxudmFyIHByZXBhcmVBdXRvQmF0Y2hlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChwYXlsb2FkKSB7XHJcbiAgICB2YXIgX2M7XHJcbiAgICByZXR1cm4gKHtcclxuICAgICAgICBwYXlsb2FkOiBwYXlsb2FkLFxyXG4gICAgICAgIG1ldGE6IChfYyA9IHt9LCBfY1tTSE9VTERfQVVUT0JBVENIXSA9IHRydWUsIF9jKVxyXG4gICAgfSk7XHJcbn07IH07XHJcbnZhciBwcm9taXNlO1xyXG52YXIgcXVldWVNaWNyb3Rhc2tTaGltID0gdHlwZW9mIHF1ZXVlTWljcm90YXNrID09PSBcImZ1bmN0aW9uXCIgPyBxdWV1ZU1pY3JvdGFzay5iaW5kKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogZ2xvYmFsVGhpcykgOiBmdW5jdGlvbiAoY2IpIHsgcmV0dXJuIChwcm9taXNlIHx8IChwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCkpKS50aGVuKGNiKS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgIHRocm93IGVycjtcclxufSwgMCk7IH0pOyB9O1xyXG52YXIgY3JlYXRlUXVldWVXaXRoVGltZXIgPSBmdW5jdGlvbiAodGltZW91dCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChub3RpZnkpIHtcclxuICAgICAgICBzZXRUaW1lb3V0KG5vdGlmeSwgdGltZW91dCk7XHJcbiAgICB9O1xyXG59O1xyXG52YXIgckFGID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA6IGNyZWF0ZVF1ZXVlV2l0aFRpbWVyKDEwKTtcclxudmFyIGF1dG9CYXRjaEVuaGFuY2VyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHsgdHlwZTogXCJyYWZcIiB9OyB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN0b3JlID0gbmV4dC5hcHBseSh2b2lkIDAsIGFyZ3MpO1xyXG4gICAgICAgIHZhciBub3RpZnlpbmcgPSB0cnVlO1xyXG4gICAgICAgIHZhciBzaG91bGROb3RpZnlBdEVuZE9mVGljayA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBub3RpZmljYXRpb25RdWV1ZWQgPSBmYWxzZTtcclxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gbmV3IFNldCgpO1xyXG4gICAgICAgIHZhciBxdWV1ZUNhbGxiYWNrID0gb3B0aW9ucy50eXBlID09PSBcInRpY2tcIiA/IHF1ZXVlTWljcm90YXNrU2hpbSA6IG9wdGlvbnMudHlwZSA9PT0gXCJyYWZcIiA/IHJBRiA6IG9wdGlvbnMudHlwZSA9PT0gXCJjYWxsYmFja1wiID8gb3B0aW9ucy5xdWV1ZU5vdGlmaWNhdGlvbiA6IGNyZWF0ZVF1ZXVlV2l0aFRpbWVyKG9wdGlvbnMudGltZW91dCk7XHJcbiAgICAgICAgdmFyIG5vdGlmeUxpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgbm90aWZpY2F0aW9uUXVldWVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChzaG91bGROb3RpZnlBdEVuZE9mVGljaykge1xyXG4gICAgICAgICAgICAgICAgc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2sgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsKSB7IHJldHVybiBsKCk7IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RvcmUsIHtcclxuICAgICAgICAgICAgc3Vic2NyaWJlOiBmdW5jdGlvbiAobGlzdGVuZXIyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgd3JhcHBlZExpc3RlbmVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbm90aWZ5aW5nICYmIGxpc3RlbmVyMigpOyB9O1xyXG4gICAgICAgICAgICAgICAgdmFyIHVuc3Vic2NyaWJlID0gc3RvcmUuc3Vic2NyaWJlKHdyYXBwZWRMaXN0ZW5lcik7XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuYWRkKGxpc3RlbmVyMik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcjIpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZGlzcGF0Y2g6IGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm90aWZ5aW5nID0gISgoX2EgPSBhY3Rpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGFjdGlvbi5tZXRhKSA9PSBudWxsID8gdm9pZCAwIDogX2FbU0hPVUxEX0FVVE9CQVRDSF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZE5vdGlmeUF0RW5kT2ZUaWNrID0gIW5vdGlmeWluZztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFub3RpZmljYXRpb25RdWV1ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvblF1ZXVlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZUNhbGxiYWNrKG5vdGlmeUxpc3RlbmVycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlLmRpc3BhdGNoKGFjdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgICAgICBub3RpZnlpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9OyB9O1xyXG59O1xyXG4vLyBzcmMvaW5kZXgudHNcclxuZW5hYmxlRVM1KCk7XHJcbmV4cG9ydCB7IEVuaGFuY2VyQXJyYXksIE1pZGRsZXdhcmVBcnJheSwgU0hPVUxEX0FVVE9CQVRDSCwgVGFza0Fib3J0RXJyb3IsIGFkZExpc3RlbmVyLCBhdXRvQmF0Y2hFbmhhbmNlciwgY2xlYXJBbGxMaXN0ZW5lcnMsIGNvbmZpZ3VyZVN0b3JlLCBjcmVhdGVBY3Rpb24sIGNyZWF0ZUFjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlLCBjcmVhdGVBc3luY1RodW5rLCBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvciwgY3JlYXRlRW50aXR5QWRhcHRlciwgY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlLCBjcmVhdGVMaXN0ZW5lck1pZGRsZXdhcmUsIGRlZmF1bHQyIGFzIGNyZWF0ZU5leHRTdGF0ZSwgY3JlYXRlUmVkdWNlciwgY3JlYXRlU2VsZWN0b3IyIGFzIGNyZWF0ZVNlbGVjdG9yLCBjcmVhdGVTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUsIGNyZWF0ZVNsaWNlLCBjdXJyZW50MiBhcyBjdXJyZW50LCBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUsIGZyZWV6ZSwgZ2V0RGVmYXVsdE1pZGRsZXdhcmUsIGdldFR5cGUsIGlzQWN0aW9uLCBpc0FjdGlvbkNyZWF0b3IsIGlzQWxsT2YsIGlzQW55T2YsIGlzQXN5bmNUaHVua0FjdGlvbiwgaXNEcmFmdDQgYXMgaXNEcmFmdCwgaXNGU0EgYXMgaXNGbHV4U3RhbmRhcmRBY3Rpb24sIGlzRnVsZmlsbGVkLCBpc0ltbXV0YWJsZURlZmF1bHQsIGlzUGVuZGluZywgaXNQbGFpbiwgaXNQbGFpbk9iamVjdCwgaXNSZWplY3RlZCwgaXNSZWplY3RlZFdpdGhWYWx1ZSwgbWluaVNlcmlhbGl6ZUVycm9yLCBuYW5vaWQsIG9yaWdpbmFsLCBwcmVwYXJlQXV0b0JhdGNoZWQsIHJlbW92ZUxpc3RlbmVyLCB1bndyYXBSZXN1bHQgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVkdXgtdG9vbGtpdC5lc20uanMubWFwIl0sIm5hbWVzIjpbIl9fZXh0ZW5kcyIsImV4dGVuZFN0YXRpY3MiLCJkIiwiYiIsIk9iamVjdCIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiQXJyYXkiLCJwIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiX18iLCJjb25zdHJ1Y3RvciIsImNyZWF0ZSIsIl9fZ2VuZXJhdG9yIiwidGhpc0FyZyIsImJvZHkiLCJfIiwibGFiZWwiLCJzZW50IiwidCIsInRyeXMiLCJvcHMiLCJmIiwieSIsImciLCJuZXh0IiwidmVyYiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwibiIsInYiLCJzdGVwIiwib3AiLCJkb25lIiwidmFsdWUiLCJwb3AiLCJsZW5ndGgiLCJwdXNoIiwiZSIsIl9fc3ByZWFkQXJyYXkiLCJ0byIsImZyb20iLCJpIiwiaWwiLCJqIiwiX19kZWZQcm9wIiwiZGVmaW5lUHJvcGVydHkiLCJfX2RlZlByb3BzIiwiZGVmaW5lUHJvcGVydGllcyIsIl9fZ2V0T3duUHJvcERlc2NzIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsIl9fZ2V0T3duUHJvcFN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJfX2hhc093blByb3AiLCJfX3Byb3BJc0VudW0iLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIl9fZGVmTm9ybWFsUHJvcCIsIm9iaiIsImtleSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl9fc3ByZWFkVmFsdWVzIiwiYSIsInByb3AiLCJfaSIsIl9jIiwiX19zcHJlYWRQcm9wcyIsIl9fYXN5bmMiLCJfX3RoaXMiLCJfX2FyZ3VtZW50cyIsImdlbmVyYXRvciIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwicmVqZWN0ZWQiLCJ0aHJvdyIsIngiLCJ0aGVuIiwiYXBwbHkiLCJlbmFibGVFUzUiLCJkZWZhdWx0IiwiZGVmYXVsdDIiLCJjdXJyZW50IiwiY3VycmVudDIiLCJmcmVlemUiLCJvcmlnaW5hbCIsImlzRHJhZnQiLCJpc0RyYWZ0NCIsImNyZWF0ZVNlbGVjdG9yIiwiY3JlYXRlU2VsZWN0b3IyIiwiY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IiLCJhcmdzIiwiYXJndW1lbnRzIiwic2VsZWN0b3IiLCJ3cmFwcGVkU2VsZWN0b3IiLCJyZXN0IiwiY3JlYXRlU3RvcmUiLCJjb21wb3NlIiwiY29tcG9zZTIiLCJhcHBseU1pZGRsZXdhcmUiLCJjb21iaW5lUmVkdWNlcnMiLCJjb21wb3NlV2l0aERldlRvb2xzIiwid2luZG93IiwiX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fQ09NUE9TRV9fIiwiZGV2VG9vbHNFbmhhbmNlciIsIl9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18iLCJub29wMiIsImlzUGxhaW5PYmplY3QiLCJwcm90byIsImdldFByb3RvdHlwZU9mIiwiYmFzZVByb3RvIiwidGh1bmtNaWRkbGV3YXJlIiwiaGFzTWF0Y2hGdW5jdGlvbiIsIm1hdGNoIiwiY3JlYXRlQWN0aW9uIiwidHlwZSIsInByZXBhcmVBY3Rpb24iLCJhY3Rpb25DcmVhdG9yIiwicHJlcGFyZWQiLCJFcnJvciIsInBheWxvYWQiLCJtZXRhIiwiZXJyb3IiLCJ0b1N0cmluZyIsImFjdGlvbiIsImlzQWN0aW9uIiwiaXNBY3Rpb25DcmVhdG9yIiwiaXNGU0EiLCJrZXlzIiwiZXZlcnkiLCJpc1ZhbGlkS2V5IiwiaW5kZXhPZiIsImdldFR5cGUiLCJnZXRNZXNzYWdlIiwic3BsaXRUeXBlIiwic3BsaXQiLCJhY3Rpb25OYW1lIiwiY3JlYXRlQWN0aW9uQ3JlYXRvckludmFyaWFudE1pZGRsZXdhcmUiLCJvcHRpb25zIiwicHJvY2VzcyIsImlzQWN0aW9uQ3JlYXRvcjIiLCJjb25zb2xlIiwid2FybiIsImNyZWF0ZU5leHRTdGF0ZSIsImlzRHJhZnRhYmxlIiwiZ2V0VGltZU1lYXN1cmVVdGlscyIsIm1heERlbGF5IiwiZm5OYW1lIiwiZWxhcHNlZCIsIm1lYXN1cmVUaW1lIiwiZm4iLCJzdGFydGVkIiwiRGF0ZSIsIm5vdyIsImZpbmlzaGVkIiwid2FybklmRXhjZWVkZWQiLCJNaWRkbGV3YXJlQXJyYXkiLCJfc3VwZXIiLCJfdGhpcyIsInNwZWNpZXMiLCJnZXQiLCJjb25jYXQiLCJhcnIiLCJwcmVwZW5kIiwiaXNBcnJheSIsImJpbmQiLCJFbmhhbmNlckFycmF5IiwiZnJlZXplRHJhZnRhYmxlIiwidmFsIiwiaXNQcm9kdWN0aW9uIiwicHJlZml4IiwiaW52YXJpYW50IiwiY29uZGl0aW9uIiwibWVzc2FnZSIsInN0cmluZ2lmeSIsInNlcmlhbGl6ZXIiLCJpbmRlbnQiLCJkZWN5Y2xlciIsIkpTT04iLCJnZXRTZXJpYWxpemUiLCJzdGFjayIsInNsaWNlIiwiam9pbiIsInRoaXNQb3MiLCJzcGxpY2UiLCJJbmZpbml0eSIsImlzSW1tdXRhYmxlRGVmYXVsdCIsImlzRnJvemVuIiwidHJhY2tGb3JNdXRhdGlvbnMiLCJpc0ltbXV0YWJsZSIsImlnbm9yZVBhdGhzIiwidHJhY2tlZFByb3BlcnRpZXMiLCJ0cmFja1Byb3BlcnRpZXMiLCJkZXRlY3RNdXRhdGlvbnMiLCJwYXRoIiwiY2hlY2tlZE9iamVjdHMiLCJTZXQiLCJ0cmFja2VkIiwiaGFzIiwiYWRkIiwiY2hpbGRyZW4iLCJjaGlsZFBhdGgiLCJpZ25vcmVkUGF0aHMiLCJ0cmFja2VkUHJvcGVydHkiLCJzYW1lUGFyZW50UmVmIiwicHJldk9iaiIsInNhbWVSZWYiLCJOdW1iZXIiLCJpc05hTiIsIndhc011dGF0ZWQiLCJrZXlzVG9EZXRlY3QiLCJoYXNJZ25vcmVkUGF0aHMiLCJfbG9vcF8xIiwibmVzdGVkUGF0aCIsImhhc01hdGNoZXMiLCJzb21lIiwiaWdub3JlZCIsIlJlZ0V4cCIsInRlc3QiLCJyZXN1bHQiLCJzdGF0ZV8xIiwiY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlIiwiX2QiLCJ3YXJuQWZ0ZXIiLCJpZ25vcmUiLCJ0cmFjayIsImdldFN0YXRlIiwic3RhdGUiLCJ0cmFja2VyIiwibWVhc3VyZVV0aWxzIiwiZGlzcGF0Y2hlZEFjdGlvbiIsImlzUGxhaW4iLCJmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUiLCJpc1NlcmlhbGl6YWJsZSIsImdldEVudHJpZXMiLCJjYWNoZSIsImZvdW5kTmVzdGVkU2VyaWFsaXphYmxlIiwia2V5UGF0aCIsImVudHJpZXMiLCJfbG9vcF8yIiwibmVzdGVkVmFsdWUiLCJlbnRyaWVzXzEiLCJzdGF0ZV8yIiwiaXNOZXN0ZWRGcm96ZW4iLCJ2YWx1ZXMiLCJjcmVhdGVTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUiLCJpZ25vcmVkQWN0aW9ucyIsIl9lIiwiaWdub3JlZEFjdGlvblBhdGhzIiwiX2YiLCJfZyIsIl9oIiwiaWdub3JlU3RhdGUiLCJfaiIsImlnbm9yZUFjdGlvbnMiLCJfayIsImRpc2FibGVDYWNoZSIsIldlYWtTZXQiLCJzdG9yZUFQSSIsImZvdW5kQWN0aW9uTm9uU2VyaWFsaXphYmxlVmFsdWUiLCJmb3VuZFN0YXRlTm9uU2VyaWFsaXphYmxlVmFsdWUiLCJpc0Jvb2xlYW4iLCJjdXJyeUdldERlZmF1bHRNaWRkbGV3YXJlIiwiY3VycmllZEdldERlZmF1bHRNaWRkbGV3YXJlIiwiZ2V0RGVmYXVsdE1pZGRsZXdhcmUiLCJ0aHVuayIsImltbXV0YWJsZUNoZWNrIiwic2VyaWFsaXphYmxlQ2hlY2siLCJhY3Rpb25DcmVhdG9yQ2hlY2siLCJtaWRkbGV3YXJlQXJyYXkiLCJ3aXRoRXh0cmFBcmd1bWVudCIsImV4dHJhQXJndW1lbnQiLCJpbW11dGFibGVPcHRpb25zIiwidW5zaGlmdCIsInNlcmlhbGl6YWJsZU9wdGlvbnMiLCJhY3Rpb25DcmVhdG9yT3B0aW9ucyIsIklTX1BST0RVQ1RJT04iLCJjb25maWd1cmVTdG9yZSIsInJlZHVjZXIiLCJtaWRkbGV3YXJlIiwiZGV2VG9vbHMiLCJwcmVsb2FkZWRTdGF0ZSIsImVuaGFuY2VycyIsInJvb3RSZWR1Y2VyIiwiZmluYWxNaWRkbGV3YXJlIiwiaXRlbSIsIm1pZGRsZXdhcmVFbmhhbmNlciIsImZpbmFsQ29tcG9zZSIsInRyYWNlIiwiZGVmYXVsdEVuaGFuY2VycyIsInN0b3JlRW5oYW5jZXJzIiwiY29tcG9zZWRFbmhhbmNlciIsImNyZWF0ZU5leHRTdGF0ZTIiLCJpc0RyYWZ0MiIsImlzRHJhZnRhYmxlMiIsImV4ZWN1dGVSZWR1Y2VyQnVpbGRlckNhbGxiYWNrIiwiYnVpbGRlckNhbGxiYWNrIiwiYWN0aW9uc01hcCIsImFjdGlvbk1hdGNoZXJzIiwiZGVmYXVsdENhc2VSZWR1Y2VyIiwiYnVpbGRlciIsImFkZENhc2UiLCJ0eXBlT3JBY3Rpb25DcmVhdG9yIiwiYWRkTWF0Y2hlciIsIm1hdGNoZXIiLCJhZGREZWZhdWx0Q2FzZSIsImlzU3RhdGVGdW5jdGlvbiIsImhhc1dhcm5lZEFib3V0T2JqZWN0Tm90YXRpb24iLCJjcmVhdGVSZWR1Y2VyIiwiaW5pdGlhbFN0YXRlIiwibWFwT3JCdWlsZGVyQ2FsbGJhY2siLCJmaW5hbEFjdGlvbk1hdGNoZXJzIiwiZmluYWxEZWZhdWx0Q2FzZVJlZHVjZXIiLCJnZXRJbml0aWFsU3RhdGUiLCJmcm96ZW5Jbml0aWFsU3RhdGVfMSIsImNhc2VSZWR1Y2VycyIsImZpbHRlciIsIm1hcCIsInJlZHVjZXIyIiwiY3IiLCJyZWR1Y2UiLCJwcmV2aW91c1N0YXRlIiwiY2FzZVJlZHVjZXIiLCJkcmFmdCIsImhhc1dhcm5lZEFib3V0T2JqZWN0Tm90YXRpb24yIiwiZ2V0VHlwZTIiLCJhY3Rpb25LZXkiLCJjcmVhdGVTbGljZSIsIm5hbWUiLCJyZWR1Y2VycyIsInJlZHVjZXJOYW1lcyIsInNsaWNlQ2FzZVJlZHVjZXJzQnlOYW1lIiwic2xpY2VDYXNlUmVkdWNlcnNCeVR5cGUiLCJhY3Rpb25DcmVhdG9ycyIsImZvckVhY2giLCJyZWR1Y2VyTmFtZSIsIm1heWJlUmVkdWNlcldpdGhQcmVwYXJlIiwicHJlcGFyZUNhbGxiYWNrIiwicHJlcGFyZSIsImJ1aWxkUmVkdWNlciIsImV4dHJhUmVkdWNlcnMiLCJmaW5hbENhc2VSZWR1Y2VycyIsImFjdGlvbk1hdGNoZXJzXzEiLCJtIiwiX3JlZHVjZXIiLCJhY3Rpb25zIiwiZ2V0SW5pdGlhbEVudGl0eVN0YXRlIiwiaWRzIiwiZW50aXRpZXMiLCJjcmVhdGVJbml0aWFsU3RhdGVGYWN0b3J5IiwiYWRkaXRpb25hbFN0YXRlIiwiYXNzaWduIiwiY3JlYXRlU2VsZWN0b3JzRmFjdG9yeSIsImdldFNlbGVjdG9ycyIsInNlbGVjdFN0YXRlIiwic2VsZWN0SWRzIiwic2VsZWN0RW50aXRpZXMiLCJzZWxlY3RBbGwiLCJpZCIsInNlbGVjdElkIiwic2VsZWN0QnlJZCIsInNlbGVjdFRvdGFsIiwic2VsZWN0R2xvYmFsaXplZEVudGl0aWVzIiwiY3JlYXRlTmV4dFN0YXRlMyIsImlzRHJhZnQzIiwiY3JlYXRlU2luZ2xlQXJndW1lbnRTdGF0ZU9wZXJhdG9yIiwibXV0YXRvciIsIm9wZXJhdG9yIiwiY3JlYXRlU3RhdGVPcGVyYXRvciIsIm9wZXJhdGlvbiIsImFyZyIsImlzUGF5bG9hZEFjdGlvbkFyZ3VtZW50IiwiYXJnMiIsInJ1bk11dGF0b3IiLCJzZWxlY3RJZFZhbHVlIiwiZW50aXR5IiwiZW5zdXJlRW50aXRpZXNBcnJheSIsInNwbGl0QWRkZWRVcGRhdGVkRW50aXRpZXMiLCJuZXdFbnRpdGllcyIsImFkZGVkIiwidXBkYXRlZCIsIm5ld0VudGl0aWVzXzEiLCJjaGFuZ2VzIiwiY3JlYXRlVW5zb3J0ZWRTdGF0ZUFkYXB0ZXIiLCJhZGRPbmVNdXRhYmx5IiwiYWRkTWFueU11dGFibHkiLCJuZXdFbnRpdGllc18yIiwic2V0T25lTXV0YWJseSIsInNldE1hbnlNdXRhYmx5IiwibmV3RW50aXRpZXNfMyIsInNldEFsbE11dGFibHkiLCJyZW1vdmVPbmVNdXRhYmx5IiwicmVtb3ZlTWFueU11dGFibHkiLCJkaWRNdXRhdGUiLCJyZW1vdmVBbGxNdXRhYmx5IiwidGFrZU5ld0tleSIsInVwZGF0ZSIsIm9yaWdpbmFsMiIsIm5ld0tleSIsImhhc05ld0tleSIsInVwZGF0ZU9uZU11dGFibHkiLCJ1cGRhdGVNYW55TXV0YWJseSIsInVwZGF0ZXMiLCJuZXdLZXlzIiwidXBkYXRlc1BlckVudGl0eSIsImRpZE11dGF0ZUVudGl0aWVzIiwiZGlkTXV0YXRlSWRzIiwidXBzZXJ0T25lTXV0YWJseSIsInVwc2VydE1hbnlNdXRhYmx5IiwicmVtb3ZlQWxsIiwiYWRkT25lIiwiYWRkTWFueSIsInNldE9uZSIsInNldE1hbnkiLCJzZXRBbGwiLCJ1cGRhdGVPbmUiLCJ1cGRhdGVNYW55IiwidXBzZXJ0T25lIiwidXBzZXJ0TWFueSIsInJlbW92ZU9uZSIsInJlbW92ZU1hbnkiLCJjcmVhdGVTb3J0ZWRTdGF0ZUFkYXB0ZXIiLCJzb3J0IiwibW9kZWxzIiwibW9kZWwiLCJtZXJnZSIsImFwcGxpZWRVcGRhdGVzIiwidXBkYXRlc18xIiwibmV3SWQiLCJyZXNvcnRFbnRpdGllcyIsImFyZUFycmF5c0VxdWFsIiwiYWxsRW50aXRpZXMiLCJuZXdTb3J0ZWRJZHMiLCJjcmVhdGVFbnRpdHlBZGFwdGVyIiwic29ydENvbXBhcmVyIiwiaW5zdGFuY2UiLCJzdGF0ZUZhY3RvcnkiLCJzZWxlY3RvcnNGYWN0b3J5Iiwic3RhdGVBZGFwdGVyIiwidXJsQWxwaGFiZXQiLCJuYW5vaWQiLCJzaXplIiwiTWF0aCIsInJhbmRvbSIsImNvbW1vblByb3BlcnRpZXMiLCJSZWplY3RXaXRoVmFsdWUiLCJGdWxmaWxsV2l0aE1ldGEiLCJtaW5pU2VyaWFsaXplRXJyb3IiLCJzaW1wbGVFcnJvciIsImNvbW1vblByb3BlcnRpZXNfMSIsInByb3BlcnR5IiwiY3JlYXRlQXN5bmNUaHVuayIsImNyZWF0ZUFzeW5jVGh1bmsyIiwidHlwZVByZWZpeCIsInBheWxvYWRDcmVhdG9yIiwicmVxdWVzdElkIiwicmVxdWVzdFN0YXR1cyIsInBlbmRpbmciLCJzZXJpYWxpemVFcnJvciIsInJlamVjdGVkV2l0aFZhbHVlIiwiYWJvcnRlZCIsImRpc3BsYXllZFdhcm5pbmciLCJBQyIsIkFib3J0Q29udHJvbGxlciIsImNsYXNzXzEiLCJzaWduYWwiLCJhZGRFdmVudExpc3RlbmVyIiwiZGlzcGF0Y2hFdmVudCIsIm9uYWJvcnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVhc29uIiwidGhyb3dJZkFib3J0ZWQiLCJhYm9ydCIsImluZm8iLCJkaXNwYXRjaCIsImV4dHJhIiwiaWRHZW5lcmF0b3IiLCJhYm9ydENvbnRyb2xsZXIiLCJhYm9ydFJlYXNvbiIsInByb21pc2UyIiwiX2EiLCJfYiIsImZpbmFsQWN0aW9uIiwiY29uZGl0aW9uUmVzdWx0IiwiYWJvcnRlZFByb21pc2UiLCJlcnJfMSIsInNraXBEaXNwYXRjaCIsImlzVGhlbmFibGUiLCJnZXRQZW5kaW5nTWV0YSIsInJhY2UiLCJyZWplY3RXaXRoVmFsdWUiLCJmdWxmaWxsV2l0aFZhbHVlIiwiZGlzcGF0Y2hDb25kaXRpb25SZWplY3Rpb24iLCJ1bndyYXAiLCJ1bndyYXBSZXN1bHQiLCJ3aXRoVHlwZXMiLCJtYXRjaGVzIiwiaXNBbnlPZiIsIm1hdGNoZXJzIiwiaXNBbGxPZiIsImhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhIiwidmFsaWRTdGF0dXMiLCJoYXNWYWxpZFJlcXVlc3RJZCIsImhhc1ZhbGlkUmVxdWVzdFN0YXR1cyIsImlzQXN5bmNUaHVua0FycmF5IiwiaXNQZW5kaW5nIiwiYXN5bmNUaHVua3MiLCJhc3luY1RodW5rIiwiY29tYmluZWRNYXRjaGVyIiwiaXNSZWplY3RlZCIsImlzUmVqZWN0ZWRXaXRoVmFsdWUiLCJoYXNGbGFnIiwiaXNGdWxmaWxsZWQiLCJpc0FzeW5jVGh1bmtBY3Rpb24iLCJhc3luY1RodW5rc18xIiwiYXNzZXJ0RnVuY3Rpb24iLCJmdW5jIiwiZXhwZWN0ZWQiLCJub29wIiwiY2F0Y2hSZWplY3Rpb24iLCJvbkVycm9yIiwiY2F0Y2giLCJhZGRBYm9ydFNpZ25hbExpc3RlbmVyIiwiYWJvcnRTaWduYWwiLCJjYWxsYmFjayIsIm9uY2UiLCJhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uIiwidGFzayIsImxpc3RlbmVyIiwiY29tcGxldGVkIiwiY2FuY2VsbGVkIiwidGFza0NhbmNlbGxlZCIsInRhc2tDb21wbGV0ZWQiLCJsaXN0ZW5lckNhbmNlbGxlZCIsImxpc3RlbmVyQ29tcGxldGVkIiwiVGFza0Fib3J0RXJyb3IiLCJjb2RlIiwidmFsaWRhdGVBY3RpdmUiLCJyYWNlV2l0aFNpZ25hbCIsImNsZWFudXAiLCJub3RpZnlSZWplY3Rpb24iLCJmaW5hbGx5IiwicnVuVGFzayIsInRhc2syIiwiY2xlYW5VcCIsImVycm9yXzEiLCJzdGF0dXMiLCJjcmVhdGVQYXVzZSIsIm91dHB1dCIsImNyZWF0ZURlbGF5IiwicGF1c2UiLCJ0aW1lb3V0TXMiLCJzZXRUaW1lb3V0IiwiSU5URVJOQUxfTklMX1RPS0VOIiwiYWxtIiwiY3JlYXRlRm9yayIsInBhcmVudEFib3J0U2lnbmFsIiwicGFyZW50QmxvY2tpbmdQcm9taXNlcyIsImxpbmtDb250cm9sbGVycyIsImNvbnRyb2xsZXIiLCJ0YXNrRXhlY3V0b3IiLCJvcHRzIiwiY2hpbGRBYm9ydENvbnRyb2xsZXIiLCJyZXN1bHQyIiwiZGVsYXkiLCJhdXRvSm9pbiIsImNhbmNlbCIsImNyZWF0ZVRha2VQYXR0ZXJuIiwic3RhcnRMaXN0ZW5pbmciLCJ0YWtlIiwicHJlZGljYXRlIiwidGltZW91dCIsInVuc3Vic2NyaWJlIiwidHVwbGVQcm9taXNlIiwicHJvbWlzZXMiLCJzdG9wTGlzdGVuaW5nIiwiZWZmZWN0IiwibGlzdGVuZXJBcGkiLCJnZXRPcmlnaW5hbFN0YXRlIiwiZ2V0TGlzdGVuZXJFbnRyeVByb3BzRnJvbSIsImNyZWF0ZUxpc3RlbmVyRW50cnkiLCJlbnRyeSIsImNhbmNlbEFjdGl2ZUxpc3RlbmVycyIsImNyZWF0ZUNsZWFyTGlzdGVuZXJNaWRkbGV3YXJlIiwibGlzdGVuZXJNYXAiLCJjbGVhciIsInNhZmVseU5vdGlmeUVycm9yIiwiZXJyb3JIYW5kbGVyIiwiZXJyb3JUb05vdGlmeSIsImVycm9ySW5mbyIsImVycm9ySGFuZGxlckVycm9yIiwiYWRkTGlzdGVuZXIiLCJjbGVhckFsbExpc3RlbmVycyIsInJlbW92ZUxpc3RlbmVyIiwiZGVmYXVsdEVycm9ySGFuZGxlciIsImNyZWF0ZUxpc3RlbmVyTWlkZGxld2FyZSIsIm1pZGRsZXdhcmVPcHRpb25zIiwiTWFwIiwiaW5zZXJ0RW50cnkiLCJkZWxldGUiLCJzZXQiLCJjYW5jZWxPcHRpb25zIiwiY2FuY2VsQWN0aXZlIiwiZmluZExpc3RlbmVyRW50cnkiLCJjb21wYXJhdG9yIiwiZXhpc3RpbmdFbnRyeSIsImVudHJ5MiIsIm1hdGNoUHJlZGljYXRlT3JUeXBlIiwibm90aWZ5TGlzdGVuZXIiLCJhcGkiLCJpbnRlcm5hbFRhc2tDb250cm9sbGVyIiwiYXV0b0pvaW5Qcm9taXNlcyIsImxpc3RlbmVyRXJyb3JfMSIsIkJvb2xlYW4iLCJmb3JrIiwic3Vic2NyaWJlIiwicmFpc2VkQnkiLCJhbGxTZXR0bGVkIiwiY2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUiLCJvcmlnaW5hbFN0YXRlIiwiY3VycmVudFN0YXRlIiwibGlzdGVuZXJFbnRyaWVzIiwibGlzdGVuZXJFbnRyaWVzXzEiLCJydW5MaXN0ZW5lciIsInByZWRpY2F0ZUVycm9yIiwiY2xlYXJMaXN0ZW5lcnMiLCJTSE9VTERfQVVUT0JBVENIIiwicHJlcGFyZUF1dG9CYXRjaGVkIiwicHJvbWlzZSIsInF1ZXVlTWljcm90YXNrU2hpbSIsInF1ZXVlTWljcm90YXNrIiwiZ2xvYmFsIiwiZ2xvYmFsVGhpcyIsImNiIiwiZXJyIiwiY3JlYXRlUXVldWVXaXRoVGltZXIiLCJub3RpZnkiLCJyQUYiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJhdXRvQmF0Y2hFbmhhbmNlciIsInN0b3JlIiwibm90aWZ5aW5nIiwic2hvdWxkTm90aWZ5QXRFbmRPZlRpY2siLCJub3RpZmljYXRpb25RdWV1ZWQiLCJsaXN0ZW5lcnMiLCJxdWV1ZUNhbGxiYWNrIiwicXVldWVOb3RpZmljYXRpb24iLCJub3RpZnlMaXN0ZW5lcnMiLCJsIiwibGlzdGVuZXIyIiwid3JhcHBlZExpc3RlbmVyIiwiaXNGbHV4U3RhbmRhcmRBY3Rpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/api/link.js":
/*!********************************************!*\
  !*** ./node_modules/next/dist/api/link.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* reexport default from dynamic */ _client_link__WEBPACK_IMPORTED_MODULE_0___default.a; }\n/* harmony export */ });\n/* harmony import */ var _client_link__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../client/link */ \"(app-pages-browser)/./node_modules/next/dist/client/link.js\");\n/* harmony import */ var _client_link__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_client_link__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _client_link__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _client_link__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n //# sourceMappingURL=link.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL2xpbmsuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXlDO0FBQ1YsQ0FFL0IsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL2xpbmsuanM/MTMwZCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSBcIi4uL2NsaWVudC9saW5rXCI7XG5leHBvcnQgKiBmcm9tIFwiLi4vY2xpZW50L2xpbmtcIjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGluay5qcy5tYXAiXSwibmFtZXMiOlsiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/api/link.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/api/navigation.js":
/*!**************************************************!*\
  !*** ./node_modules/next/dist/api/navigation.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../client/components/navigation */ \"(app-pages-browser)/./node_modules/next/dist/client/components/navigation.js\");\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_client_components_navigation__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n //# sourceMappingURL=navigation.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL25hdmlnYXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWdELENBRWhELHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2FwaS9uYXZpZ2F0aW9uLmpzPzFkMjgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSBcIi4uL2NsaWVudC9jb21wb25lbnRzL25hdmlnYXRpb25cIjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmF2aWdhdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/api/navigation.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/process.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _global_process, _global_process1;\nmodule.exports = ((_global_process = __webpack_require__.g.process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = __webpack_require__.g.process) == null ? void 0 : _global_process1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! next/dist/compiled/process */ \"(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\"); //# sourceMappingURL=process.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxpQkFBaUJDO0FBQ3JCQyxPQUFPQyxPQUFPLEdBQUcsQ0FBQyxDQUFDSCxrQkFBa0JJLHFCQUFNQSxDQUFDQyxPQUFPLEtBQUssT0FBTyxLQUFLLElBQUlMLGdCQUFnQk0sR0FBRyxLQUFLLE9BQVEsRUFBQ0wsbUJBQW1CRyxxQkFBTUEsQ0FBQ0MsT0FBTyxLQUFLLE9BQU8sS0FBSyxJQUFJSixpQkFBaUJLLEdBQUcsTUFBTSxXQUFXRixxQkFBTUEsQ0FBQ0MsT0FBTyxHQUFHRSxtQkFBT0EsQ0FBQyw0R0FBNEIsR0FFelAsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanM/Y2E2NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfZ2xvYmFsX3Byb2Nlc3MsIF9nbG9iYWxfcHJvY2VzczE7XG5tb2R1bGUuZXhwb3J0cyA9ICgoX2dsb2JhbF9wcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MuZW52KSAmJiB0eXBlb2YgKChfZ2xvYmFsX3Byb2Nlc3MxID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MxLmVudikgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwucHJvY2VzcyA6IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzc1wiKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvY2Vzcy5qcy5tYXAiXSwibmFtZXMiOlsiX2dsb2JhbF9wcm9jZXNzIiwiX2dsb2JhbF9wcm9jZXNzMSIsIm1vZHVsZSIsImV4cG9ydHMiLCJnbG9iYWwiLCJwcm9jZXNzIiwiZW52IiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/process/browser.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("var __dirname = \"/\";\n\n(function() {\n    var e = {\n        229: function(e) {\n            var t = e.exports = {};\n            var r;\n            var n;\n            function defaultSetTimout() {\n                throw new Error(\"setTimeout has not been defined\");\n            }\n            function defaultClearTimeout() {\n                throw new Error(\"clearTimeout has not been defined\");\n            }\n            (function() {\n                try {\n                    if (typeof setTimeout === \"function\") {\n                        r = setTimeout;\n                    } else {\n                        r = defaultSetTimout;\n                    }\n                } catch (e) {\n                    r = defaultSetTimout;\n                }\n                try {\n                    if (typeof clearTimeout === \"function\") {\n                        n = clearTimeout;\n                    } else {\n                        n = defaultClearTimeout;\n                    }\n                } catch (e) {\n                    n = defaultClearTimeout;\n                }\n            })();\n            function runTimeout(e) {\n                if (r === setTimeout) {\n                    return setTimeout(e, 0);\n                }\n                if ((r === defaultSetTimout || !r) && setTimeout) {\n                    r = setTimeout;\n                    return setTimeout(e, 0);\n                }\n                try {\n                    return r(e, 0);\n                } catch (t) {\n                    try {\n                        return r.call(null, e, 0);\n                    } catch (t) {\n                        return r.call(this, e, 0);\n                    }\n                }\n            }\n            function runClearTimeout(e) {\n                if (n === clearTimeout) {\n                    return clearTimeout(e);\n                }\n                if ((n === defaultClearTimeout || !n) && clearTimeout) {\n                    n = clearTimeout;\n                    return clearTimeout(e);\n                }\n                try {\n                    return n(e);\n                } catch (t) {\n                    try {\n                        return n.call(null, e);\n                    } catch (t) {\n                        return n.call(this, e);\n                    }\n                }\n            }\n            var i = [];\n            var o = false;\n            var u;\n            var a = -1;\n            function cleanUpNextTick() {\n                if (!o || !u) {\n                    return;\n                }\n                o = false;\n                if (u.length) {\n                    i = u.concat(i);\n                } else {\n                    a = -1;\n                }\n                if (i.length) {\n                    drainQueue();\n                }\n            }\n            function drainQueue() {\n                if (o) {\n                    return;\n                }\n                var e = runTimeout(cleanUpNextTick);\n                o = true;\n                var t = i.length;\n                while(t){\n                    u = i;\n                    i = [];\n                    while(++a < t){\n                        if (u) {\n                            u[a].run();\n                        }\n                    }\n                    a = -1;\n                    t = i.length;\n                }\n                u = null;\n                o = false;\n                runClearTimeout(e);\n            }\n            t.nextTick = function(e) {\n                var t = new Array(arguments.length - 1);\n                if (arguments.length > 1) {\n                    for(var r = 1; r < arguments.length; r++){\n                        t[r - 1] = arguments[r];\n                    }\n                }\n                i.push(new Item(e, t));\n                if (i.length === 1 && !o) {\n                    runTimeout(drainQueue);\n                }\n            };\n            function Item(e, t) {\n                this.fun = e;\n                this.array = t;\n            }\n            Item.prototype.run = function() {\n                this.fun.apply(null, this.array);\n            };\n            t.title = \"browser\";\n            t.browser = true;\n            t.env = {};\n            t.argv = [];\n            t.version = \"\";\n            t.versions = {};\n            function noop() {}\n            t.on = noop;\n            t.addListener = noop;\n            t.once = noop;\n            t.off = noop;\n            t.removeListener = noop;\n            t.removeAllListeners = noop;\n            t.emit = noop;\n            t.prependListener = noop;\n            t.prependOnceListener = noop;\n            t.listeners = function(e) {\n                return [];\n            };\n            t.binding = function(e) {\n                throw new Error(\"process.binding is not supported\");\n            };\n            t.cwd = function() {\n                return \"/\";\n            };\n            t.chdir = function(e) {\n                throw new Error(\"process.chdir is not supported\");\n            };\n            t.umask = function() {\n                return 0;\n            };\n        }\n    };\n    var t = {};\n    function __nccwpck_require__(r) {\n        var n = t[r];\n        if (n !== undefined) {\n            return n.exports;\n        }\n        var i = t[r] = {\n            exports: {}\n        };\n        var o = true;\n        try {\n            e[r](i, i.exports, __nccwpck_require__);\n            o = false;\n        } finally{\n            if (o) delete t[r];\n        }\n        return i.exports;\n    }\n    if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n    var r = __nccwpck_require__(229);\n    module.exports = r;\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzIiwibWFwcGluZ3MiOiI7O0FBQUM7SUFBVyxJQUFJQSxJQUFFO1FBQUMsS0FBSSxTQUFTQSxDQUFDO1lBQUUsSUFBSUMsSUFBRUQsRUFBRUUsT0FBTyxHQUFDLENBQUM7WUFBRSxJQUFJQztZQUFFLElBQUlDO1lBQUUsU0FBU0M7Z0JBQW1CLE1BQU0sSUFBSUMsTUFBTTtZQUFrQztZQUFDLFNBQVNDO2dCQUFzQixNQUFNLElBQUlELE1BQU07WUFBb0M7WUFBRTtnQkFBVyxJQUFHO29CQUFDLElBQUcsT0FBT0UsZUFBYSxZQUFXO3dCQUFDTCxJQUFFSztvQkFBVSxPQUFLO3dCQUFDTCxJQUFFRTtvQkFBZ0I7Z0JBQUMsRUFBQyxPQUFNTCxHQUFFO29CQUFDRyxJQUFFRTtnQkFBZ0I7Z0JBQUMsSUFBRztvQkFBQyxJQUFHLE9BQU9JLGlCQUFlLFlBQVc7d0JBQUNMLElBQUVLO29CQUFZLE9BQUs7d0JBQUNMLElBQUVHO29CQUFtQjtnQkFBQyxFQUFDLE9BQU1QLEdBQUU7b0JBQUNJLElBQUVHO2dCQUFtQjtZQUFDO1lBQUssU0FBU0csV0FBV1YsQ0FBQztnQkFBRSxJQUFHRyxNQUFJSyxZQUFXO29CQUFDLE9BQU9BLFdBQVdSLEdBQUU7Z0JBQUU7Z0JBQUMsSUFBRyxDQUFDRyxNQUFJRSxvQkFBa0IsQ0FBQ0YsQ0FBQUEsS0FBSUssWUFBVztvQkFBQ0wsSUFBRUs7b0JBQVcsT0FBT0EsV0FBV1IsR0FBRTtnQkFBRTtnQkFBQyxJQUFHO29CQUFDLE9BQU9HLEVBQUVILEdBQUU7Z0JBQUUsRUFBQyxPQUFNQyxHQUFFO29CQUFDLElBQUc7d0JBQUMsT0FBT0UsRUFBRVEsSUFBSSxDQUFDLE1BQUtYLEdBQUU7b0JBQUUsRUFBQyxPQUFNQyxHQUFFO3dCQUFDLE9BQU9FLEVBQUVRLElBQUksQ0FBQyxJQUFJLEVBQUNYLEdBQUU7b0JBQUU7Z0JBQUM7WUFBQztZQUFDLFNBQVNZLGdCQUFnQlosQ0FBQztnQkFBRSxJQUFHSSxNQUFJSyxjQUFhO29CQUFDLE9BQU9BLGFBQWFUO2dCQUFFO2dCQUFDLElBQUcsQ0FBQ0ksTUFBSUcsdUJBQXFCLENBQUNILENBQUFBLEtBQUlLLGNBQWE7b0JBQUNMLElBQUVLO29CQUFhLE9BQU9BLGFBQWFUO2dCQUFFO2dCQUFDLElBQUc7b0JBQUMsT0FBT0ksRUFBRUo7Z0JBQUUsRUFBQyxPQUFNQyxHQUFFO29CQUFDLElBQUc7d0JBQUMsT0FBT0csRUFBRU8sSUFBSSxDQUFDLE1BQUtYO29CQUFFLEVBQUMsT0FBTUMsR0FBRTt3QkFBQyxPQUFPRyxFQUFFTyxJQUFJLENBQUMsSUFBSSxFQUFDWDtvQkFBRTtnQkFBQztZQUFDO1lBQUMsSUFBSWEsSUFBRSxFQUFFO1lBQUMsSUFBSUMsSUFBRTtZQUFNLElBQUlDO1lBQUUsSUFBSUMsSUFBRSxDQUFDO1lBQUUsU0FBU0M7Z0JBQWtCLElBQUcsQ0FBQ0gsS0FBRyxDQUFDQyxHQUFFO29CQUFDO2dCQUFNO2dCQUFDRCxJQUFFO2dCQUFNLElBQUdDLEVBQUVHLE1BQU0sRUFBQztvQkFBQ0wsSUFBRUUsRUFBRUksTUFBTSxDQUFDTjtnQkFBRSxPQUFLO29CQUFDRyxJQUFFLENBQUM7Z0JBQUM7Z0JBQUMsSUFBR0gsRUFBRUssTUFBTSxFQUFDO29CQUFDRTtnQkFBWTtZQUFDO1lBQUMsU0FBU0E7Z0JBQWEsSUFBR04sR0FBRTtvQkFBQztnQkFBTTtnQkFBQyxJQUFJZCxJQUFFVSxXQUFXTztnQkFBaUJILElBQUU7Z0JBQUssSUFBSWIsSUFBRVksRUFBRUssTUFBTTtnQkFBQyxNQUFNakIsRUFBRTtvQkFBQ2MsSUFBRUY7b0JBQUVBLElBQUUsRUFBRTtvQkFBQyxNQUFNLEVBQUVHLElBQUVmLEVBQUU7d0JBQUMsSUFBR2MsR0FBRTs0QkFBQ0EsQ0FBQyxDQUFDQyxFQUFFLENBQUNLLEdBQUc7d0JBQUU7b0JBQUM7b0JBQUNMLElBQUUsQ0FBQztvQkFBRWYsSUFBRVksRUFBRUssTUFBTTtnQkFBQTtnQkFBQ0gsSUFBRTtnQkFBS0QsSUFBRTtnQkFBTUYsZ0JBQWdCWjtZQUFFO1lBQUNDLEVBQUVxQixRQUFRLEdBQUMsU0FBU3RCLENBQUM7Z0JBQUUsSUFBSUMsSUFBRSxJQUFJc0IsTUFBTUMsVUFBVU4sTUFBTSxHQUFDO2dCQUFHLElBQUdNLFVBQVVOLE1BQU0sR0FBQyxHQUFFO29CQUFDLElBQUksSUFBSWYsSUFBRSxHQUFFQSxJQUFFcUIsVUFBVU4sTUFBTSxFQUFDZixJQUFJO3dCQUFDRixDQUFDLENBQUNFLElBQUUsRUFBRSxHQUFDcUIsU0FBUyxDQUFDckIsRUFBRTtvQkFBQTtnQkFBQztnQkFBQ1UsRUFBRVksSUFBSSxDQUFDLElBQUlDLEtBQUsxQixHQUFFQztnQkFBSSxJQUFHWSxFQUFFSyxNQUFNLEtBQUcsS0FBRyxDQUFDSixHQUFFO29CQUFDSixXQUFXVTtnQkFBVztZQUFDO1lBQUUsU0FBU00sS0FBSzFCLENBQUMsRUFBQ0MsQ0FBQztnQkFBRSxJQUFJLENBQUMwQixHQUFHLEdBQUMzQjtnQkFBRSxJQUFJLENBQUM0QixLQUFLLEdBQUMzQjtZQUFDO1lBQUN5QixLQUFLRyxTQUFTLENBQUNSLEdBQUcsR0FBQztnQkFBVyxJQUFJLENBQUNNLEdBQUcsQ0FBQ0csS0FBSyxDQUFDLE1BQUssSUFBSSxDQUFDRixLQUFLO1lBQUM7WUFBRTNCLEVBQUU4QixLQUFLLEdBQUM7WUFBVTlCLEVBQUUrQixPQUFPLEdBQUM7WUFBSy9CLEVBQUVnQyxHQUFHLEdBQUMsQ0FBQztZQUFFaEMsRUFBRWlDLElBQUksR0FBQyxFQUFFO1lBQUNqQyxFQUFFa0MsT0FBTyxHQUFDO1lBQUdsQyxFQUFFbUMsUUFBUSxHQUFDLENBQUM7WUFBRSxTQUFTQyxRQUFPO1lBQUNwQyxFQUFFcUMsRUFBRSxHQUFDRDtZQUFLcEMsRUFBRXNDLFdBQVcsR0FBQ0Y7WUFBS3BDLEVBQUV1QyxJQUFJLEdBQUNIO1lBQUtwQyxFQUFFd0MsR0FBRyxHQUFDSjtZQUFLcEMsRUFBRXlDLGNBQWMsR0FBQ0w7WUFBS3BDLEVBQUUwQyxrQkFBa0IsR0FBQ047WUFBS3BDLEVBQUUyQyxJQUFJLEdBQUNQO1lBQUtwQyxFQUFFNEMsZUFBZSxHQUFDUjtZQUFLcEMsRUFBRTZDLG1CQUFtQixHQUFDVDtZQUFLcEMsRUFBRThDLFNBQVMsR0FBQyxTQUFTL0MsQ0FBQztnQkFBRSxPQUFNLEVBQUU7WUFBQTtZQUFFQyxFQUFFK0MsT0FBTyxHQUFDLFNBQVNoRCxDQUFDO2dCQUFFLE1BQU0sSUFBSU0sTUFBTTtZQUFtQztZQUFFTCxFQUFFZ0QsR0FBRyxHQUFDO2dCQUFXLE9BQU07WUFBRztZQUFFaEQsRUFBRWlELEtBQUssR0FBQyxTQUFTbEQsQ0FBQztnQkFBRSxNQUFNLElBQUlNLE1BQU07WUFBaUM7WUFBRUwsRUFBRWtELEtBQUssR0FBQztnQkFBVyxPQUFPO1lBQUM7UUFBQztJQUFDO0lBQUUsSUFBSWxELElBQUUsQ0FBQztJQUFFLFNBQVNtRCxvQkFBb0JqRCxDQUFDO1FBQUUsSUFBSUMsSUFBRUgsQ0FBQyxDQUFDRSxFQUFFO1FBQUMsSUFBR0MsTUFBSWlELFdBQVU7WUFBQyxPQUFPakQsRUFBRUYsT0FBTztRQUFBO1FBQUMsSUFBSVcsSUFBRVosQ0FBQyxDQUFDRSxFQUFFLEdBQUM7WUFBQ0QsU0FBUSxDQUFDO1FBQUM7UUFBRSxJQUFJWSxJQUFFO1FBQUssSUFBRztZQUFDZCxDQUFDLENBQUNHLEVBQUUsQ0FBQ1UsR0FBRUEsRUFBRVgsT0FBTyxFQUFDa0Q7WUFBcUJ0QyxJQUFFO1FBQUssU0FBUTtZQUFDLElBQUdBLEdBQUUsT0FBT2IsQ0FBQyxDQUFDRSxFQUFFO1FBQUE7UUFBQyxPQUFPVSxFQUFFWCxPQUFPO0lBQUE7SUFBQyxJQUFHLE9BQU9rRCx3QkFBc0IsYUFBWUEsb0JBQW9CRSxFQUFFLEdBQUNDLFNBQVNBLEdBQUM7SUFBSSxJQUFJcEQsSUFBRWlELG9CQUFvQjtJQUFLSSxPQUFPdEQsT0FBTyxHQUFDQztBQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzPzFiMWQiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7dmFyIGU9ezIyOTpmdW5jdGlvbihlKXt2YXIgdD1lLmV4cG9ydHM9e307dmFyIHI7dmFyIG47ZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpe3Rocm93IG5ldyBFcnJvcihcInNldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9ZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCgpe3Rocm93IG5ldyBFcnJvcihcImNsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKX0oZnVuY3Rpb24oKXt0cnl7aWYodHlwZW9mIHNldFRpbWVvdXQ9PT1cImZ1bmN0aW9uXCIpe3I9c2V0VGltZW91dH1lbHNle3I9ZGVmYXVsdFNldFRpbW91dH19Y2F0Y2goZSl7cj1kZWZhdWx0U2V0VGltb3V0fXRyeXtpZih0eXBlb2YgY2xlYXJUaW1lb3V0PT09XCJmdW5jdGlvblwiKXtuPWNsZWFyVGltZW91dH1lbHNle249ZGVmYXVsdENsZWFyVGltZW91dH19Y2F0Y2goZSl7bj1kZWZhdWx0Q2xlYXJUaW1lb3V0fX0pKCk7ZnVuY3Rpb24gcnVuVGltZW91dChlKXtpZihyPT09c2V0VGltZW91dCl7cmV0dXJuIHNldFRpbWVvdXQoZSwwKX1pZigocj09PWRlZmF1bHRTZXRUaW1vdXR8fCFyKSYmc2V0VGltZW91dCl7cj1zZXRUaW1lb3V0O3JldHVybiBzZXRUaW1lb3V0KGUsMCl9dHJ5e3JldHVybiByKGUsMCl9Y2F0Y2godCl7dHJ5e3JldHVybiByLmNhbGwobnVsbCxlLDApfWNhdGNoKHQpe3JldHVybiByLmNhbGwodGhpcyxlLDApfX19ZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KGUpe2lmKG49PT1jbGVhclRpbWVvdXQpe3JldHVybiBjbGVhclRpbWVvdXQoZSl9aWYoKG49PT1kZWZhdWx0Q2xlYXJUaW1lb3V0fHwhbikmJmNsZWFyVGltZW91dCl7bj1jbGVhclRpbWVvdXQ7cmV0dXJuIGNsZWFyVGltZW91dChlKX10cnl7cmV0dXJuIG4oZSl9Y2F0Y2godCl7dHJ5e3JldHVybiBuLmNhbGwobnVsbCxlKX1jYXRjaCh0KXtyZXR1cm4gbi5jYWxsKHRoaXMsZSl9fX12YXIgaT1bXTt2YXIgbz1mYWxzZTt2YXIgdTt2YXIgYT0tMTtmdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKXtpZighb3x8IXUpe3JldHVybn1vPWZhbHNlO2lmKHUubGVuZ3RoKXtpPXUuY29uY2F0KGkpfWVsc2V7YT0tMX1pZihpLmxlbmd0aCl7ZHJhaW5RdWV1ZSgpfX1mdW5jdGlvbiBkcmFpblF1ZXVlKCl7aWYobyl7cmV0dXJufXZhciBlPXJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtvPXRydWU7dmFyIHQ9aS5sZW5ndGg7d2hpbGUodCl7dT1pO2k9W107d2hpbGUoKythPHQpe2lmKHUpe3VbYV0ucnVuKCl9fWE9LTE7dD1pLmxlbmd0aH11PW51bGw7bz1mYWxzZTtydW5DbGVhclRpbWVvdXQoZSl9dC5uZXh0VGljaz1mdW5jdGlvbihlKXt2YXIgdD1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKTtpZihhcmd1bWVudHMubGVuZ3RoPjEpe2Zvcih2YXIgcj0xO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspe3Rbci0xXT1hcmd1bWVudHNbcl19fWkucHVzaChuZXcgSXRlbShlLHQpKTtpZihpLmxlbmd0aD09PTEmJiFvKXtydW5UaW1lb3V0KGRyYWluUXVldWUpfX07ZnVuY3Rpb24gSXRlbShlLHQpe3RoaXMuZnVuPWU7dGhpcy5hcnJheT10fUl0ZW0ucHJvdG90eXBlLnJ1bj1mdW5jdGlvbigpe3RoaXMuZnVuLmFwcGx5KG51bGwsdGhpcy5hcnJheSl9O3QudGl0bGU9XCJicm93c2VyXCI7dC5icm93c2VyPXRydWU7dC5lbnY9e307dC5hcmd2PVtdO3QudmVyc2lvbj1cIlwiO3QudmVyc2lvbnM9e307ZnVuY3Rpb24gbm9vcCgpe310Lm9uPW5vb3A7dC5hZGRMaXN0ZW5lcj1ub29wO3Qub25jZT1ub29wO3Qub2ZmPW5vb3A7dC5yZW1vdmVMaXN0ZW5lcj1ub29wO3QucmVtb3ZlQWxsTGlzdGVuZXJzPW5vb3A7dC5lbWl0PW5vb3A7dC5wcmVwZW5kTGlzdGVuZXI9bm9vcDt0LnByZXBlbmRPbmNlTGlzdGVuZXI9bm9vcDt0Lmxpc3RlbmVycz1mdW5jdGlvbihlKXtyZXR1cm5bXX07dC5iaW5kaW5nPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcInByb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkXCIpfTt0LmN3ZD1mdW5jdGlvbigpe3JldHVyblwiL1wifTt0LmNoZGlyPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcInByb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZFwiKX07dC51bWFzaz1mdW5jdGlvbigpe3JldHVybiAwfX19O3ZhciB0PXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18ocil7dmFyIG49dFtyXTtpZihuIT09dW5kZWZpbmVkKXtyZXR1cm4gbi5leHBvcnRzfXZhciBpPXRbcl09e2V4cG9ydHM6e319O3ZhciBvPXRydWU7dHJ5e2Vbcl0oaSxpLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7bz1mYWxzZX1maW5hbGx5e2lmKG8pZGVsZXRlIHRbcl19cmV0dXJuIGkuZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIHI9X19uY2N3cGNrX3JlcXVpcmVfXygyMjkpO21vZHVsZS5leHBvcnRzPXJ9KSgpOyJdLCJuYW1lcyI6WyJlIiwidCIsImV4cG9ydHMiLCJyIiwibiIsImRlZmF1bHRTZXRUaW1vdXQiLCJFcnJvciIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImNhbGwiLCJydW5DbGVhclRpbWVvdXQiLCJpIiwibyIsInUiLCJhIiwiY2xlYW5VcE5leHRUaWNrIiwibGVuZ3RoIiwiY29uY2F0IiwiZHJhaW5RdWV1ZSIsInJ1biIsIm5leHRUaWNrIiwiQXJyYXkiLCJhcmd1bWVudHMiLCJwdXNoIiwiSXRlbSIsImZ1biIsImFycmF5IiwicHJvdG90eXBlIiwiYXBwbHkiLCJ0aXRsZSIsImJyb3dzZXIiLCJlbnYiLCJhcmd2IiwidmVyc2lvbiIsInZlcnNpb25zIiwibm9vcCIsIm9uIiwiYWRkTGlzdGVuZXIiLCJvbmNlIiwib2ZmIiwicmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJlbWl0IiwicHJlcGVuZExpc3RlbmVyIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsImxpc3RlbmVycyIsImJpbmRpbmciLCJjd2QiLCJjaGRpciIsInVtYXNrIiwiX19uY2N3cGNrX3JlcXVpcmVfXyIsInVuZGVmaW5lZCIsImFiIiwiX19kaXJuYW1lIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n        // ATTENTION\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        var REACT_CACHE_TYPE = Symbol.for(\"react.cache\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n            if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n                return null;\n            }\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n            if (typeof maybeIterator === \"function\") {\n                return maybeIterator;\n            }\n            return null;\n        }\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        function error(format) {\n            {\n                {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning(\"error\", format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                var stack = ReactDebugCurrentFrame.getStackAddendum();\n                if (stack !== \"\") {\n                    format += \"%s\";\n                    args = args.concat([\n                        stack\n                    ]);\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var argsWithFormat = args.map(function(item) {\n                    return String(item);\n                }); // Careful: RN currently depends on this prefix\n                argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, argsWithFormat);\n            }\n        }\n        // -----------------------------------------------------------------------------\n        var enableScopeAPI = false; // Experimental Create Event Handle API.\n        var enableCacheElement = false;\n        var enableTransitionTracing = false; // No known bugs, but needs performance testing\n        var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n        // stuff. Intended to enable React core members to more easily debug scheduling\n        // issues in DEV builds.\n        var enableDebugTracing = false;\n        var REACT_CLIENT_REFERENCE$2 = Symbol.for(\"react.client.reference\");\n        function isValidElementType(type) {\n            if (typeof type === \"string\" || typeof type === \"function\") {\n                return true;\n            } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n                return true;\n            }\n            if (typeof type === \"object\" && type !== null) {\n                if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n                // types supported by any Flight configuration anywhere since\n                // we don't know which Flight build this will end up being used\n                // with.\n                type.$$typeof === REACT_CLIENT_REFERENCE$2 || type.getModuleId !== undefined) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n            var displayName = outerType.displayName;\n            if (displayName) {\n                return displayName;\n            }\n            var functionName = innerType.displayName || innerType.name || \"\";\n            return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        } // Keep in sync with react-reconciler/getComponentNameFromFiber\n        function getContextName(type) {\n            return type.displayName || \"Context\";\n        }\n        var REACT_CLIENT_REFERENCE$1 = Symbol.for(\"react.client.reference\"); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n        function getComponentNameFromType(type) {\n            if (type == null) {\n                // Host root, text node or just invalid type.\n                return null;\n            }\n            if (typeof type === \"function\") {\n                if (type.$$typeof === REACT_CLIENT_REFERENCE$1) {\n                    // TODO: Create a convention for naming client references with debug info.\n                    return null;\n                }\n                return type.displayName || type.name || null;\n            }\n            if (typeof type === \"string\") {\n                return type;\n            }\n            switch(type){\n                case REACT_FRAGMENT_TYPE:\n                    return \"Fragment\";\n                case REACT_PORTAL_TYPE:\n                    return \"Portal\";\n                case REACT_PROFILER_TYPE:\n                    return \"Profiler\";\n                case REACT_STRICT_MODE_TYPE:\n                    return \"StrictMode\";\n                case REACT_SUSPENSE_TYPE:\n                    return \"Suspense\";\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return \"SuspenseList\";\n                case REACT_CACHE_TYPE:\n                    {\n                        return \"Cache\";\n                    }\n            }\n            if (typeof type === \"object\") {\n                {\n                    if (typeof type.tag === \"number\") {\n                        error(\"Received an unexpected object in getComponentNameFromType(). \" + \"This is likely a bug in React. Please file an issue.\");\n                    }\n                }\n                switch(type.$$typeof){\n                    case REACT_CONTEXT_TYPE:\n                        var context = type;\n                        return getContextName(context) + \".Consumer\";\n                    case REACT_PROVIDER_TYPE:\n                        var provider = type;\n                        return getContextName(provider._context) + \".Provider\";\n                    case REACT_FORWARD_REF_TYPE:\n                        return getWrappedName(type, type.render, \"ForwardRef\");\n                    case REACT_MEMO_TYPE:\n                        var outerName = type.displayName || null;\n                        if (outerName !== null) {\n                            return outerName;\n                        }\n                        return getComponentNameFromType(type.type) || \"Memo\";\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                return getComponentNameFromType(init(payload));\n                            } catch (x) {\n                                return null;\n                            }\n                        }\n                }\n            }\n            return null;\n        }\n        var assign = Object.assign;\n        // Helpers to patch console.logs to avoid logging during side-effect free\n        // replaying on render function. This currently only patches the object\n        // lazily which won't cover if the log function was extracted eagerly.\n        // We could also eagerly patch the method.\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {}\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n            {\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;\n                    prevInfo = console.info;\n                    prevWarn = console.warn;\n                    prevError = console.error;\n                    prevGroup = console.group;\n                    prevGroupCollapsed = console.groupCollapsed;\n                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n                    var props = {\n                        configurable: true,\n                        enumerable: true,\n                        value: disabledLog,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        info: props,\n                        log: props,\n                        warn: props,\n                        error: props,\n                        group: props,\n                        groupCollapsed: props,\n                        groupEnd: props\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                disabledDepth++;\n            }\n        }\n        function reenableLogs() {\n            {\n                disabledDepth--;\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ var props = {\n                        configurable: true,\n                        enumerable: true,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        log: assign({}, props, {\n                            value: prevLog\n                        }),\n                        info: assign({}, props, {\n                            value: prevInfo\n                        }),\n                        warn: assign({}, props, {\n                            value: prevWarn\n                        }),\n                        error: assign({}, props, {\n                            value: prevError\n                        }),\n                        group: assign({}, props, {\n                            value: prevGroup\n                        }),\n                        groupCollapsed: assign({}, props, {\n                            value: prevGroupCollapsed\n                        }),\n                        groupEnd: assign({}, props, {\n                            value: prevGroupEnd\n                        })\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                if (disabledDepth < 0) {\n                    error(\"disabledDepth fell below zero. \" + \"This is a bug in React. Please file an issue.\");\n                }\n            }\n        }\n        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n            {\n                if (prefix === undefined) {\n                    // Extract the VM specific prefix used by each line.\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        var match = x.stack.trim().match(/\\n( *(at )?)/);\n                        prefix = match && match[1] || \"\";\n                    }\n                } // We use the prefix to ensure our stacks line up with native stack frames.\n                return \"\\n\" + prefix + name;\n            }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n            var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n            componentFrameCache = new PossiblyWeakMap();\n        }\n        /**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */ function describeNativeComponentFrame(fn, construct) {\n            // If something asked for a stack inside a fake render, it should get ignored.\n            if (!fn || reentry) {\n                return \"\";\n            }\n            {\n                var frame = componentFrameCache.get(fn);\n                if (frame !== undefined) {\n                    return frame;\n                }\n            }\n            reentry = true;\n            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n            Error.prepareStackTrace = undefined;\n            var previousDispatcher;\n            {\n                previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n                // for warnings.\n                ReactCurrentDispatcher.current = null;\n                disableLogs();\n            }\n            /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */ var RunInRootFrame = {\n                DetermineComponentFrameRoot: function() {\n                    var control;\n                    try {\n                        // This should throw.\n                        if (construct) {\n                            // Something should be setting the props in the constructor.\n                            var Fake = function() {\n                                throw Error();\n                            }; // $FlowFixMe[prop-missing]\n                            Object.defineProperty(Fake.prototype, \"props\", {\n                                set: function() {\n                                    // We use a throwing setter instead of frozen or non-writable props\n                                    // because that won't throw in a non-strict mode function.\n                                    throw Error();\n                                }\n                            });\n                            if (typeof Reflect === \"object\" && Reflect.construct) {\n                                // We construct a different control for this case to include any extra\n                                // frames added by the construct call.\n                                try {\n                                    Reflect.construct(Fake, []);\n                                } catch (x) {\n                                    control = x;\n                                }\n                                Reflect.construct(fn, [], Fake);\n                            } else {\n                                try {\n                                    Fake.call();\n                                } catch (x) {\n                                    control = x;\n                                } // $FlowFixMe[prop-missing] found when upgrading Flow\n                                fn.call(Fake.prototype);\n                            }\n                        } else {\n                            try {\n                                throw Error();\n                            } catch (x) {\n                                control = x;\n                            } // TODO(luna): This will currently only throw if the function component\n                            // tries to access React/ReactDOM/props. We should probably make this throw\n                            // in simple components too\n                            var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n                            // component, which we don't yet support. Attach a noop catch handler to\n                            // silence the error.\n                            // TODO: Implement component stacks for async client components?\n                            if (maybePromise && typeof maybePromise.catch === \"function\") {\n                                maybePromise.catch(function() {});\n                            }\n                        }\n                    } catch (sample) {\n                        // This is inlined manually because closure doesn't do it for us.\n                        if (sample && control && typeof sample.stack === \"string\") {\n                            return [\n                                sample.stack,\n                                control.stack\n                            ];\n                        }\n                    }\n                    return [\n                        null,\n                        null\n                    ];\n                }\n            }; // $FlowFixMe[prop-missing]\n            RunInRootFrame.DetermineComponentFrameRoot.displayName = \"DetermineComponentFrameRoot\";\n            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, \"name\"); // Before ES6, the `name` property was not configurable.\n            if (namePropDescriptor && namePropDescriptor.configurable) {\n                // V8 utilizes a function's `name` property when generating a stack trace.\n                Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // is set to `false`.\n                // $FlowFixMe[cannot-write]\n                \"name\", {\n                    value: \"DetermineComponentFrameRoot\"\n                });\n            }\n            try {\n                var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];\n                if (sampleStack && controlStack) {\n                    // This extracts the first frame from the sample that isn't also in the control.\n                    // Skipping one frame that we assume is the frame that calls the two.\n                    var sampleLines = sampleStack.split(\"\\n\");\n                    var controlLines = controlStack.split(\"\\n\");\n                    var s = 0;\n                    var c = 0;\n                    while(s < sampleLines.length && !sampleLines[s].includes(\"DetermineComponentFrameRoot\")){\n                        s++;\n                    }\n                    while(c < controlLines.length && !controlLines[c].includes(\"DetermineComponentFrameRoot\")){\n                        c++;\n                    } // We couldn't find our intentionally injected common root frame, attempt\n                    // to find another common root frame by search from the bottom of the\n                    // control stack...\n                    if (s === sampleLines.length || c === controlLines.length) {\n                        s = sampleLines.length - 1;\n                        c = controlLines.length - 1;\n                        while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){\n                            // We expect at least one stack frame to be shared.\n                            // Typically this will be the root most one. However, stack frames may be\n                            // cut off due to maximum stack limits. In this case, one maybe cut off\n                            // earlier than the other. We assume that the sample is longer or the same\n                            // and there for cut off earlier. So we should find the root most frame in\n                            // the sample somewhere in the control.\n                            c--;\n                        }\n                    }\n                    for(; s >= 1 && c >= 0; s--, c--){\n                        // Next we find the first one that isn't the same which should be the\n                        // frame that called our sample function and the control.\n                        if (sampleLines[s] !== controlLines[c]) {\n                            // In V8, the first line is describing the message but other VMs don't.\n                            // If we're about to return the first line, and the control is also on the same\n                            // line, that's a pretty good indicator that our sample threw at same line as\n                            // the control. I.e. before we entered the sample frame. So we ignore this result.\n                            // This can happen if you passed a class to function component, or non-function.\n                            if (s !== 1 || c !== 1) {\n                                do {\n                                    s--;\n                                    c--; // We may still have similar intermediate frames from the construct call.\n                                    // The next one that isn't the same should be our match though.\n                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                                        // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \"); // If our component frame is labeled \"<anonymous>\"\n                                        // but we have a user-provided \"displayName\"\n                                        // splice it in to make the stack more readable.\n                                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                                            _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                                        }\n                                        if (true) {\n                                            if (typeof fn === \"function\") {\n                                                componentFrameCache.set(fn, _frame);\n                                            }\n                                        } // Return the line we found.\n                                        return _frame;\n                                    }\n                                }while (s >= 1 && c >= 0);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } finally{\n                reentry = false;\n                {\n                    ReactCurrentDispatcher.current = previousDispatcher;\n                    reenableLogs();\n                }\n                Error.prepareStackTrace = previousPrepareStackTrace;\n            } // Fallback to just using the name if we couldn't make it throw.\n            var name = fn ? fn.displayName || fn.name : \"\";\n            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n            {\n                if (typeof fn === \"function\") {\n                    componentFrameCache.set(fn, syntheticFrame);\n                }\n            }\n            return syntheticFrame;\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(fn, false);\n            }\n        }\n        function shouldConstruct(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n            if (type == null) {\n                return \"\";\n            }\n            if (typeof type === \"function\") {\n                {\n                    return describeNativeComponentFrame(type, shouldConstruct(type));\n                }\n            }\n            if (typeof type === \"string\") {\n                return describeBuiltInComponentFrame(type);\n            }\n            switch(type){\n                case REACT_SUSPENSE_TYPE:\n                    return describeBuiltInComponentFrame(\"Suspense\");\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return describeBuiltInComponentFrame(\"SuspenseList\");\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        return describeFunctionComponentFrame(type.render);\n                    case REACT_MEMO_TYPE:\n                        // Memo may contain any component type so we recursively resolve it.\n                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                // Lazy may contain any component type so we recursively resolve it.\n                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                            } catch (x) {}\n                        }\n                }\n            }\n            return \"\";\n        }\n        // $FlowFixMe[method-unbinding]\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement$1(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n                }\n            }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n            {\n                // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n                var has = Function.call.bind(hasOwnProperty);\n                for(var typeSpecName in typeSpecs){\n                    if (has(typeSpecs, typeSpecName)) {\n                        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n                        // fail the render phase where it didn't fail before. So we log it.\n                        // After these have been cleaned up, we'll let them throw.\n                        try {\n                            // This is intentionally an invariant that gets caught. It's the same\n                            // behavior as without this statement except with a better message.\n                            if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                                // eslint-disable-next-line react-internal/prod-error-codes\n                                var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                                err.name = \"Invariant Violation\";\n                                throw err;\n                            }\n                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                        } catch (ex) {\n                            error$1 = ex;\n                        }\n                        if (error$1 && !(error$1 instanceof Error)) {\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"%s: type specification of %s\" + \" `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                            // Only monitor this failure once because there tends to be a lot of the\n                            // same error.\n                            loggedTypeFailures[error$1.message] = true;\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"Failed %s type: %s\", location, error$1.message);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                    }\n                }\n            }\n        }\n        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n        function isArray(a) {\n            return isArrayImpl(a);\n        }\n        /*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function typeName(value) {\n            {\n                // toStringTag is needed for namespaced types like Temporal.Instant\n                var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\"; // $FlowFixMe[incompatible-return]\n                return type;\n            }\n        } // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function willCoercionThrow(value) {\n            {\n                try {\n                    testStringCoercion(value);\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            }\n        }\n        function testStringCoercion(value) {\n            // If you ended up here by following an exception call stack, here's what's\n            // happened: you supplied an object or symbol value to React (as a prop, key,\n            // DOM attribute, CSS property, string ref, etc.) and when React tried to\n            // coerce it to a string using `'' + value`, an exception was thrown.\n            //\n            // The most common types that will cause this exception are `Symbol` instances\n            // and Temporal objects like `Temporal.Instant`. But any object that has a\n            // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n            // exception. (Library authors do this to prevent users from using built-in\n            // numeric operators like `+` or comparison operators like `>=` because custom\n            // methods are needed to perform accurate arithmetic or comparison.)\n            //\n            // To fix the problem, coerce this object or symbol value to a string before\n            // passing it to React. The most reliable way is usually `String(value)`.\n            //\n            // To find which value is throwing, check the browser or debugger console.\n            // Before this exception was thrown, there should be `console.error` output\n            // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n            // problem and how that type was used: key, atrribute, input value prop, etc.\n            // In most cases, this console output also shows the component and its\n            // ancestor components where the exception happened.\n            //\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            return \"\" + value;\n        }\n        function checkKeyStringCoercion(value) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided key is an unsupported type %s.\" + \" This value must be coerced to a string before using it here.\", typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n        var RESERVED_PROPS = {\n            key: true,\n            ref: true,\n            __self: true,\n            __source: true\n        };\n        var specialPropKeyWarningShown;\n        var specialPropRefWarningShown;\n        var didWarnAboutStringRefs;\n        {\n            didWarnAboutStringRefs = {};\n        }\n        function hasValidRef(config) {\n            {\n                if (hasOwnProperty.call(config, \"ref\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"ref\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.ref !== undefined;\n        }\n        function hasValidKey(config) {\n            {\n                if (hasOwnProperty.call(config, \"key\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.key !== undefined;\n        }\n        function warnIfStringRefCannotBeAutoConverted(config, self) {\n            {\n                if (typeof config.ref === \"string\" && ReactCurrentOwner$1.current && self && ReactCurrentOwner$1.current.stateNode !== self) {\n                    var componentName = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n                    if (!didWarnAboutStringRefs[componentName]) {\n                        error('Component \"%s\" contains the string ref \"%s\". ' + \"Support for string refs will be removed in a future major release. \" + \"This case cannot be automatically converted to an arrow function. \" + \"We ask you to manually fix this case by using useRef() or createRef() instead. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-string-ref\", getComponentNameFromType(ReactCurrentOwner$1.current.type), config.ref);\n                        didWarnAboutStringRefs[componentName] = true;\n                    }\n                }\n            }\n        }\n        function defineKeyPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingKey = function() {\n                    if (!specialPropKeyWarningShown) {\n                        specialPropKeyWarningShown = true;\n                        error(\"%s: `key` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingKey.isReactWarning = true;\n                Object.defineProperty(props, \"key\", {\n                    get: warnAboutAccessingKey,\n                    configurable: true\n                });\n            }\n        }\n        function defineRefPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingRef = function() {\n                    if (!specialPropRefWarningShown) {\n                        specialPropRefWarningShown = true;\n                        error(\"%s: `ref` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingRef.isReactWarning = true;\n                Object.defineProperty(props, \"ref\", {\n                    get: warnAboutAccessingRef,\n                    configurable: true\n                });\n            }\n        }\n        /**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */ function ReactElement(type, key, ref, self, source, owner, props) {\n            var element = {\n                // This tag allows us to uniquely identify this as a React Element\n                $$typeof: REACT_ELEMENT_TYPE,\n                // Built-in properties that belong on the element\n                type: type,\n                key: key,\n                ref: ref,\n                props: props,\n                // Record the component responsible for creating this element.\n                _owner: owner\n            };\n            {\n                // The validation flag is currently mutative. We put it on\n                // an external backing store so that we can freeze the whole object.\n                // This can be replaced with a WeakMap once they are implemented in\n                // commonly used development environments.\n                element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n                // the validation flag non-enumerable (where possible, which should\n                // include every environment we run tests in), so the test framework\n                // ignores it.\n                Object.defineProperty(element._store, \"validated\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: true,\n                    value: false\n                }); // self and source are DEV only properties.\n                Object.defineProperty(element, \"_self\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: self\n                }); // Two elements created in two different places should be considered\n                // equal for testing purposes and therefore we hide it from enumeration.\n                Object.defineProperty(element, \"_source\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: source\n                });\n                if (Object.freeze) {\n                    Object.freeze(element.props);\n                    Object.freeze(element);\n                }\n            }\n            return element;\n        }\n        /**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */ function jsxDEV$1(type, config, maybeKey, source, self) {\n            {\n                var propName; // Reserved names are extracted\n                var props = {};\n                var key = null;\n                var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n                // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n                // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n                // but as an intermediary step, we will use jsxDEV for everything except\n                // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n                // key is explicitly declared to be undefined or not.\n                if (maybeKey !== undefined) {\n                    {\n                        checkKeyStringCoercion(maybeKey);\n                    }\n                    key = \"\" + maybeKey;\n                }\n                if (hasValidKey(config)) {\n                    {\n                        checkKeyStringCoercion(config.key);\n                    }\n                    key = \"\" + config.key;\n                }\n                if (hasValidRef(config)) {\n                    ref = config.ref;\n                    warnIfStringRefCannotBeAutoConverted(config, self);\n                } // Remaining properties are added to a new props object\n                for(propName in config){\n                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                        props[propName] = config[propName];\n                    }\n                } // Resolve default props\n                if (type && type.defaultProps) {\n                    var defaultProps = type.defaultProps;\n                    for(propName in defaultProps){\n                        if (props[propName] === undefined) {\n                            props[propName] = defaultProps[propName];\n                        }\n                    }\n                }\n                if (key || ref) {\n                    var displayName = typeof type === \"function\" ? type.displayName || type.name || \"Unknown\" : type;\n                    if (key) {\n                        defineKeyPropWarningGetter(props, displayName);\n                    }\n                    if (ref) {\n                        defineRefPropWarningGetter(props, displayName);\n                    }\n                }\n                return ReactElement(type, key, ref, self, source, ReactCurrentOwner$1.current, props);\n            }\n        }\n        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\n        function setCurrentlyValidatingElement(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame.setExtraStackFrame(null);\n                }\n            }\n        }\n        var propTypesMisspellWarningShown;\n        {\n            propTypesMisspellWarningShown = false;\n        }\n        /**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */ function isValidElement(object) {\n            {\n                return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n            }\n        }\n        function getDeclarationErrorAddendum() {\n            {\n                if (ReactCurrentOwner.current) {\n                    var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n                    if (name) {\n                        return \"\\n\\nCheck the render method of `\" + name + \"`.\";\n                    }\n                }\n                return \"\";\n            }\n        }\n        function getSourceInfoErrorAddendum(source) {\n            {\n                if (source !== undefined) {\n                    var fileName = source.fileName.replace(/^.*[\\\\\\/]/, \"\");\n                    var lineNumber = source.lineNumber;\n                    return \"\\n\\nCheck your code at \" + fileName + \":\" + lineNumber + \".\";\n                }\n                return \"\";\n            }\n        }\n        /**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */ var ownerHasKeyUseWarning = {};\n        function getCurrentComponentErrorInfo(parentType) {\n            {\n                var info = getDeclarationErrorAddendum();\n                if (!info) {\n                    var parentName = getComponentNameFromType(parentType);\n                    if (parentName) {\n                        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n                    }\n                }\n                return info;\n            }\n        }\n        /**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */ function validateExplicitKey(element, parentType) {\n            {\n                if (!element._store || element._store.validated || element.key != null) {\n                    return;\n                }\n                element._store.validated = true;\n                var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n                if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n                    return;\n                }\n                ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n                // property, it may be the creator of the child that's responsible for\n                // assigning it a key.\n                var childOwner = \"\";\n                if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n                    // Give the component that originally created this child.\n                    childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n                }\n                setCurrentlyValidatingElement(element);\n                error('Each child in a list should have a unique \"key\" prop.' + \"%s%s See https://reactjs.org/link/warning-keys for more information.\", currentComponentErrorInfo, childOwner);\n                setCurrentlyValidatingElement(null);\n            }\n        }\n        /**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */ function validateChildKeys(node, parentType) {\n            {\n                if (typeof node !== \"object\" || !node) {\n                    return;\n                }\n                if (node.$$typeof === REACT_CLIENT_REFERENCE) ;\n                else if (isArray(node)) {\n                    for(var i = 0; i < node.length; i++){\n                        var child = node[i];\n                        if (isValidElement(child)) {\n                            validateExplicitKey(child, parentType);\n                        }\n                    }\n                } else if (isValidElement(node)) {\n                    // This element was passed in a valid location.\n                    if (node._store) {\n                        node._store.validated = true;\n                    }\n                } else {\n                    var iteratorFn = getIteratorFn(node);\n                    if (typeof iteratorFn === \"function\") {\n                        // Entry iterators used to provide implicit keys,\n                        // but now we print a separate warning for them later.\n                        if (iteratorFn !== node.entries) {\n                            var iterator = iteratorFn.call(node);\n                            var step;\n                            while(!(step = iterator.next()).done){\n                                if (isValidElement(step.value)) {\n                                    validateExplicitKey(step.value, parentType);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        /**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */ function validatePropTypes(element) {\n            {\n                var type = element.type;\n                if (type === null || type === undefined || typeof type === \"string\") {\n                    return;\n                }\n                if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n                    return;\n                }\n                var propTypes;\n                if (typeof type === \"function\") {\n                    propTypes = type.propTypes;\n                } else if (typeof type === \"object\" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n                // Inner props are checked in the reconciler.\n                type.$$typeof === REACT_MEMO_TYPE)) {\n                    propTypes = type.propTypes;\n                } else {\n                    return;\n                }\n                if (propTypes) {\n                    // Intentionally inside to avoid triggering lazy initializers:\n                    var name = getComponentNameFromType(type);\n                    checkPropTypes(propTypes, element.props, \"prop\", name, element);\n                } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n                    propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n                    var _name = getComponentNameFromType(type);\n                    error(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", _name || \"Unknown\");\n                }\n                if (typeof type.getDefaultProps === \"function\" && !type.getDefaultProps.isReactClassApproved) {\n                    error(\"getDefaultProps is only used on classic React.createClass \" + \"definitions. Use a static property named `defaultProps` instead.\");\n                }\n            }\n        }\n        /**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */ function validateFragmentProps(fragment) {\n            {\n                var keys = Object.keys(fragment.props);\n                for(var i = 0; i < keys.length; i++){\n                    var key = keys[i];\n                    if (key !== \"children\" && key !== \"key\") {\n                        setCurrentlyValidatingElement(fragment);\n                        error(\"Invalid prop `%s` supplied to `React.Fragment`. \" + \"React.Fragment can only have `key` and `children` props.\", key);\n                        setCurrentlyValidatingElement(null);\n                        break;\n                    }\n                }\n                if (fragment.ref !== null) {\n                    setCurrentlyValidatingElement(fragment);\n                    error(\"Invalid attribute `ref` supplied to `React.Fragment`.\");\n                    setCurrentlyValidatingElement(null);\n                }\n            }\n        }\n        var didWarnAboutKeySpread = {};\n        function jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n            {\n                var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n                // succeed and there will likely be errors in render.\n                if (!validType) {\n                    var info = \"\";\n                    if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                        info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and named imports.\";\n                    }\n                    var sourceInfo = getSourceInfoErrorAddendum(source);\n                    if (sourceInfo) {\n                        info += sourceInfo;\n                    } else {\n                        info += getDeclarationErrorAddendum();\n                    }\n                    var typeString;\n                    if (type === null) {\n                        typeString = \"null\";\n                    } else if (isArray(type)) {\n                        typeString = \"array\";\n                    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n                        typeString = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\";\n                        info = \" Did you accidentally export a JSX literal instead of a component?\";\n                    } else {\n                        typeString = typeof type;\n                    }\n                    error(\"React.jsx: type is invalid -- expected a string (for \" + \"built-in components) or a class/function (for composite \" + \"components) but got: %s.%s\", typeString, info);\n                }\n                var element = jsxDEV$1(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n                // TODO: Drop this when these are no longer allowed as the type argument.\n                if (element == null) {\n                    return element;\n                } // Skip key warning if the type isn't valid since our key validation logic\n                // doesn't expect a non-string/function type and can throw confusing errors.\n                // We don't want exception behavior to differ between dev and prod.\n                // (Rendering will throw with a helpful message and as soon as the type is\n                // fixed, the key warnings will appear.)\n                if (validType) {\n                    var children = props.children;\n                    if (children !== undefined) {\n                        if (isStaticChildren) {\n                            if (isArray(children)) {\n                                for(var i = 0; i < children.length; i++){\n                                    validateChildKeys(children[i], type);\n                                }\n                                if (Object.freeze) {\n                                    Object.freeze(children);\n                                }\n                            } else {\n                                error(\"React.jsx: Static children should always be an array. \" + \"You are likely explicitly calling React.jsxs or React.jsxDEV. \" + \"Use the Babel transform instead.\");\n                            }\n                        } else {\n                            validateChildKeys(children, type);\n                        }\n                    }\n                }\n                if (hasOwnProperty.call(props, \"key\")) {\n                    var componentName = getComponentNameFromType(type);\n                    var keys = Object.keys(props).filter(function(k) {\n                        return k !== \"key\";\n                    });\n                    var beforeExample = keys.length > 0 ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\" : \"{key: someKey}\";\n                    if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n                        var afterExample = keys.length > 0 ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\";\n                        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + \"  let props = %s;\\n\" + \"  <%s {...props} />\\n\" + \"React keys must be passed directly to JSX without using spread:\\n\" + \"  let props = %s;\\n\" + \"  <%s key={someKey} {...props} />\", beforeExample, componentName, afterExample, componentName);\n                        didWarnAboutKeySpread[componentName + beforeExample] = true;\n                    }\n                }\n                if (type === REACT_FRAGMENT_TYPE) {\n                    validateFragmentProps(element);\n                } else {\n                    validatePropTypes(element);\n                }\n                return element;\n            }\n        } // These two functions exist to still get child warnings in dev\n        var jsxDEV = jsxWithValidation;\n        exports.Fragment = REACT_FRAGMENT_TYPE;\n        exports.jsxDEV = jsxDEV;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVEO0FBRUEsSUFBSUEsSUFBcUMsRUFBRTtJQUN4QztRQUNIO1FBRUEsSUFBSUMsUUFBUUMsbUJBQU9BLENBQUMsc0dBQTBCO1FBRTlDLFlBQVk7UUFDWix3Q0FBd0M7UUFDeEMsa0ZBQWtGO1FBQ2xGLHNEQUFzRDtRQUN0RCxJQUFJQyxxQkFBcUJDLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJQyxvQkFBb0JGLE9BQU9DLEdBQUcsQ0FBQztRQUNuQyxJQUFJRSxzQkFBc0JILE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJRyx5QkFBeUJKLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJSSxzQkFBc0JMLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJSyxzQkFBc0JOLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJTSxxQkFBcUJQLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJTyx5QkFBeUJSLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJUSxzQkFBc0JULE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJUywyQkFBMkJWLE9BQU9DLEdBQUcsQ0FBQztRQUMxQyxJQUFJVSxrQkFBa0JYLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJVyxrQkFBa0JaLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJWSx1QkFBdUJiLE9BQU9DLEdBQUcsQ0FBQztRQUN0QyxJQUFJYSxtQkFBbUJkLE9BQU9DLEdBQUcsQ0FBQztRQUNsQyxJQUFJYyx3QkFBd0JmLE9BQU9nQixRQUFRO1FBQzNDLElBQUlDLHVCQUF1QjtRQUMzQixTQUFTQyxjQUFjQyxhQUFhO1lBQ2xDLElBQUlBLGtCQUFrQixRQUFRLE9BQU9BLGtCQUFrQixVQUFVO2dCQUMv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LE9BQU8sUUFBUTtvQkFDckMsSUFBSXVFLGdCQUFnQnZHLHlCQUF5QmI7b0JBQzdDLElBQUlzTSxPQUFPM0ssT0FBTzJLLElBQUksQ0FBQ3pKLE9BQU9pSyxNQUFNLENBQUMsU0FBVUMsQ0FBQzt3QkFDOUMsT0FBT0EsTUFBTTtvQkFDZjtvQkFDQSxJQUFJQyxnQkFBZ0JWLEtBQUtqTyxNQUFNLEdBQUcsSUFBSSxvQkFBb0JpTyxLQUFLVyxJQUFJLENBQUMsYUFBYSxXQUFXO29CQUU1RixJQUFJLENBQUNWLHFCQUFxQixDQUFDbkYsZ0JBQWdCNEYsY0FBYyxFQUFFO3dCQUN6RCxJQUFJRSxlQUFlWixLQUFLak8sTUFBTSxHQUFHLElBQUksTUFBTWlPLEtBQUtXLElBQUksQ0FBQyxhQUFhLFdBQVc7d0JBRTdFaFAsTUFBTSx1RUFBdUUsd0JBQXdCLDBCQUEwQixzRUFBc0Usd0JBQXdCLHFDQUFxQytPLGVBQWU1RixlQUFlOEYsY0FBYzlGO3dCQUU5U21GLHFCQUFxQixDQUFDbkYsZ0JBQWdCNEYsY0FBYyxHQUFHO29CQUN6RDtnQkFDRjtnQkFFQSxJQUFJaE4sU0FBU25ELHFCQUFxQjtvQkFDaEN1UCxzQkFBc0J6RjtnQkFDeEIsT0FBTztvQkFDTG1GLGtCQUFrQm5GO2dCQUNwQjtnQkFFQSxPQUFPQTtZQUNUO1FBQ0YsRUFBRSwrREFBK0Q7UUFFakUsSUFBSXdHLFNBQVNYO1FBRWJZLGdCQUFnQixHQUFHdlE7UUFDbkJ1USxjQUFjLEdBQUdEO0lBQ2Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanM/ZmU2MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3RcIik7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpO1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJyk7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG52YXIgUkVBQ1RfQ0FDSEVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNhY2hlJyk7XG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG52YXIgZW5hYmxlQ2FjaGVFbGVtZW50ID0gZmFsc2U7XG52YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcblxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7XG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgZW5hYmxlRGVidWdUcmFjaW5nICB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiAgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgIHx8IGVuYWJsZUNhY2hlRWxlbWVudCAgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgLy8gd2l0aC5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSkge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG4vKipcbiAqIExldmVyYWdlcyBuYXRpdmUgYnJvd3Nlci9WTSBzdGFjayBmcmFtZXMgdG8gZ2V0IHByb3BlciBkZXRhaWxzIChlLmcuXG4gKiBmaWxlbmFtZSwgbGluZSArIGNvbCBudW1iZXIpIGZvciBhIHNpbmdsZSBjb21wb25lbnQgaW4gYSBjb21wb25lbnQgc3RhY2suIFdlXG4gKiBkbyB0aGlzIGJ5OlxuICogICAoMSkgdGhyb3dpbmcgYW5kIGNhdGNoaW5nIGFuIGVycm9yIGluIHRoZSBmdW5jdGlvbiAtIHRoaXMgd2lsbCBiZSBvdXJcbiAqICAgICAgIGNvbnRyb2wgZXJyb3IuXG4gKiAgICgyKSBjYWxsaW5nIHRoZSBjb21wb25lbnQgd2hpY2ggd2lsbCBldmVudHVhbGx5IHRocm93IGFuIGVycm9yIHRoYXQgd2UnbGxcbiAqICAgICAgIGNhdGNoIC0gdGhpcyB3aWxsIGJlIG91ciBzYW1wbGUgZXJyb3IuXG4gKiAgICgzKSBkaWZmaW5nIHRoZSBjb250cm9sIGFuZCBzYW1wbGUgZXJyb3Igc3RhY2tzIHRvIGZpbmQgdGhlIHN0YWNrIGZyYW1lXG4gKiAgICAgICB3aGljaCByZXByZXNlbnRzIG91ciBjb21wb25lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kaW5nIGEgY29tbW9uIHN0YWNrIGZyYW1lIGJldHdlZW4gc2FtcGxlIGFuZCBjb250cm9sIGVycm9ycyBjYW4gYmVcbiAgICogdHJpY2t5IGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMgYW5kIGxldmVscyBvZiBzdGFjayB0cmFjZSB0cnVuY2F0aW9uIGZyb21cbiAgICogZGlmZmVyZW50IEpTIFZNcy4gU28gaW5zdGVhZCB3ZSdsbCBhdHRlbXB0IHRvIGNvbnRyb2wgd2hhdCB0aGF0IGNvbW1vblxuICAgKiBmcmFtZSBzaG91bGQgYmUgdGhyb3VnaCB0aGlzIG9iamVjdCBtZXRob2Q6XG4gICAqIEhhdmluZyBib3RoIHRoZSBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGJlIGluIHRoZSBmdW5jdGlvbiB1bmRlciB0aGVcbiAgICogYERlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWVSb290YCBwcm9wZXJ0eSwgKyBzZXR0aW5nIHRoZSBgbmFtZWAgYW5kXG4gICAqIGBkaXNwbGF5TmFtZWAgcHJvcGVydGllcyBvZiB0aGUgZnVuY3Rpb24gZW5zdXJlcyB0aGF0IGEgc3RhY2tcbiAgICogZnJhbWUgZXhpc3RzIHRoYXQgaGFzIHRoZSBtZXRob2QgbmFtZSBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIGluXG4gICAqIGl0IGZvciBib3RoIGNvbnRyb2wgYW5kIHNhbXBsZSBzdGFja3MuXG4gICAqL1xuXG5cbiAgdmFyIFJ1bkluUm9vdEZyYW1lID0ge1xuICAgIERldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbnRyb2w7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH07IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgIH0gLy8gVE9ETyhsdW5hKTogVGhpcyB3aWxsIGN1cnJlbnRseSBvbmx5IHRocm93IGlmIHRoZSBmdW5jdGlvbiBjb21wb25lbnRcbiAgICAgICAgICAvLyB0cmllcyB0byBhY2Nlc3MgUmVhY3QvUmVhY3RET00vcHJvcHMuIFdlIHNob3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgdGhyb3dcbiAgICAgICAgICAvLyBpbiBzaW1wbGUgY29tcG9uZW50cyB0b29cblxuXG4gICAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IGZuKCk7IC8vIElmIHRoZSBmdW5jdGlvbiBjb21wb25lbnQgcmV0dXJucyBhIHByb21pc2UsIGl0J3MgbGlrZWx5IGFuIGFzeW5jXG4gICAgICAgICAgLy8gY29tcG9uZW50LCB3aGljaCB3ZSBkb24ndCB5ZXQgc3VwcG9ydC4gQXR0YWNoIGEgbm9vcCBjYXRjaCBoYW5kbGVyIHRvXG4gICAgICAgICAgLy8gc2lsZW5jZSB0aGUgZXJyb3IuXG4gICAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGNvbXBvbmVudCBzdGFja3MgZm9yIGFzeW5jIGNsaWVudCBjb21wb25lbnRzP1xuXG4gICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSAmJiB0eXBlb2YgbWF5YmVQcm9taXNlLmNhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiBbc2FtcGxlLnN0YWNrLCBjb250cm9sLnN0YWNrXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgIH1cbiAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cbiAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID0gJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCc7XG4gIHZhciBuYW1lUHJvcERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgJ25hbWUnKTsgLy8gQmVmb3JlIEVTNiwgdGhlIGBuYW1lYCBwcm9wZXJ0eSB3YXMgbm90IGNvbmZpZ3VyYWJsZS5cblxuICBpZiAobmFtZVByb3BEZXNjcmlwdG9yICYmIG5hbWVQcm9wRGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcbiAgICAvLyBWOCB1dGlsaXplcyBhIGZ1bmN0aW9uJ3MgYG5hbWVgIHByb3BlcnR5IHdoZW4gZ2VuZXJhdGluZyBhIHN0YWNrIHRyYWNlLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsIC8vIENvbmZpZ3VyYWJsZSBwcm9wZXJ0aWVzIGNhbiBiZSB1cGRhdGVkIGV2ZW4gaWYgaXRzIHdyaXRhYmxlIGRlc2NyaXB0b3JcbiAgICAvLyBpcyBzZXQgdG8gYGZhbHNlYC5cbiAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cbiAgICAnbmFtZScsIHtcbiAgICAgIHZhbHVlOiAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290J1xuICAgIH0pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIgX1J1bkluUm9vdEZyYW1lJERldGVyID0gUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290KCksXG4gICAgICAgIHNhbXBsZVN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzBdLFxuICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG5cbiAgICBpZiAoc2FtcGxlU3RhY2sgJiYgY29udHJvbFN0YWNrKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbFN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gMDtcbiAgICAgIHZhciBjID0gMDtcblxuICAgICAgd2hpbGUgKHMgPCBzYW1wbGVMaW5lcy5sZW5ndGggJiYgIXNhbXBsZUxpbmVzW3NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBzKys7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChjIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJiAhY29udHJvbExpbmVzW2NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBjKys7XG4gICAgICB9IC8vIFdlIGNvdWxkbid0IGZpbmQgb3VyIGludGVudGlvbmFsbHkgaW5qZWN0ZWQgY29tbW9uIHJvb3QgZnJhbWUsIGF0dGVtcHRcbiAgICAgIC8vIHRvIGZpbmQgYW5vdGhlciBjb21tb24gcm9vdCBmcmFtZSBieSBzZWFyY2ggZnJvbSB0aGUgYm90dG9tIG9mIHRoZVxuICAgICAgLy8gY29udHJvbCBzdGFjay4uLlxuXG5cbiAgICAgIGlmIChzID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHwgYyA9PT0gY29udHJvbExpbmVzLmxlbmd0aCkge1xuICAgICAgICBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgICAgYy0tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbi8qXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICovXG4vLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAge1xuICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JzsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbn0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cblxuXG5mdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICB7XG4gICAgdHJ5IHtcbiAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAvLyBJZiB5b3UgZW5kZWQgdXAgaGVyZSBieSBmb2xsb3dpbmcgYW4gZXhjZXB0aW9uIGNhbGwgc3RhY2ssIGhlcmUncyB3aGF0J3NcbiAgLy8gaGFwcGVuZWQ6IHlvdSBzdXBwbGllZCBhbiBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIFJlYWN0IChhcyBhIHByb3AsIGtleSxcbiAgLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xuICAvLyBjb2VyY2UgaXQgdG8gYSBzdHJpbmcgdXNpbmcgYCcnICsgdmFsdWVgLCBhbiBleGNlcHRpb24gd2FzIHRocm93bi5cbiAgLy9cbiAgLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXG4gIC8vIGFuZCBUZW1wb3JhbCBvYmplY3RzIGxpa2UgYFRlbXBvcmFsLkluc3RhbnRgLiBCdXQgYW55IG9iamVjdCB0aGF0IGhhcyBhXG4gIC8vIGB2YWx1ZU9mYCBvciBgW1N5bWJvbC50b1ByaW1pdGl2ZV1gIG1ldGhvZCB0aGF0IHRocm93cyB3aWxsIGFsc28gY2F1c2UgdGhpc1xuICAvLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cbiAgLy8gbnVtZXJpYyBvcGVyYXRvcnMgbGlrZSBgK2Agb3IgY29tcGFyaXNvbiBvcGVyYXRvcnMgbGlrZSBgPj1gIGJlY2F1c2UgY3VzdG9tXG4gIC8vIG1ldGhvZHMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIGFjY3VyYXRlIGFyaXRobWV0aWMgb3IgY29tcGFyaXNvbi4pXG4gIC8vXG4gIC8vIFRvIGZpeCB0aGUgcHJvYmxlbSwgY29lcmNlIHRoaXMgb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZyBiZWZvcmVcbiAgLy8gcGFzc2luZyBpdCB0byBSZWFjdC4gVGhlIG1vc3QgcmVsaWFibGUgd2F5IGlzIHVzdWFsbHkgYFN0cmluZyh2YWx1ZSlgLlxuICAvL1xuICAvLyBUbyBmaW5kIHdoaWNoIHZhbHVlIGlzIHRocm93aW5nLCBjaGVjayB0aGUgYnJvd3NlciBvciBkZWJ1Z2dlciBjb25zb2xlLlxuICAvLyBCZWZvcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUgc2hvdWxkIGJlIGBjb25zb2xlLmVycm9yYCBvdXRwdXRcbiAgLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxuICAvLyBwcm9ibGVtIGFuZCBob3cgdGhhdCB0eXBlIHdhcyB1c2VkOiBrZXksIGF0cnJpYnV0ZSwgaW5wdXQgdmFsdWUgcHJvcCwgZXRjLlxuICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIGNvbnNvbGUgb3V0cHV0IGFsc28gc2hvd3MgdGhlIGNvbXBvbmVudCBhbmQgaXRzXG4gIC8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cbiAgLy9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHJldHVybiAnJyArIHZhbHVlO1xufVxuZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUocGFyZW50VHlwZSk7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JyB8fCAhbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChub2RlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSA7IGVsc2UgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYkMSh0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrICE9PSAna2V5JztcbiAgICAgIH0pO1xuICAgICAgdmFyIGJlZm9yZUV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAne2tleTogc29tZUtleSwgJyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne2tleTogc29tZUtleX0nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0pIHtcbiAgICAgICAgdmFyIGFmdGVyRXhhbXBsZSA9IGtleXMubGVuZ3RoID4gMCA/ICd7JyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne30nO1xuXG4gICAgICAgIGVycm9yKCdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyB7Li4ucHJvcHN9IC8+XFxuJyArICdSZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLCBiZWZvcmVFeGFtcGxlLCBjb21wb25lbnROYW1lLCBhZnRlckV4YW1wbGUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuXG52YXIganN4REVWID0ganN4V2l0aFZhbGlkYXRpb24gO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJSZWFjdCIsInJlcXVpcmUiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJSRUFDVF9QT1JUQUxfVFlQRSIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUiLCJSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX1BST1ZJREVSX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSIsIlJFQUNUX01FTU9fVFlQRSIsIlJFQUNUX0xBWllfVFlQRSIsIlJFQUNUX09GRlNDUkVFTl9UWVBFIiwiUkVBQ1RfQ0FDSEVfVFlQRSIsIk1BWUJFX0lURVJBVE9SX1NZTUJPTCIsIml0ZXJhdG9yIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIm1heWJlSXRlcmF0b3IiLCJSZWFjdFNoYXJlZEludGVybmFscyIsIl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwiZXJyb3IiLCJmb3JtYXQiLCJfbGVuMiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkyIiwicHJpbnRXYXJuaW5nIiwibGV2ZWwiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lIiwic3RhY2siLCJnZXRTdGFja0FkZGVuZHVtIiwiY29uY2F0IiwiYXJnc1dpdGhGb3JtYXQiLCJtYXAiLCJpdGVtIiwiU3RyaW5nIiwidW5zaGlmdCIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiYXBwbHkiLCJjYWxsIiwiY29uc29sZSIsImVuYWJsZVNjb3BlQVBJIiwiZW5hYmxlQ2FjaGVFbGVtZW50IiwiZW5hYmxlVHJhbnNpdGlvblRyYWNpbmciLCJlbmFibGVMZWdhY3lIaWRkZW4iLCJlbmFibGVEZWJ1Z1RyYWNpbmciLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJ0eXBlIiwiJCR0eXBlb2YiLCJnZXRNb2R1bGVJZCIsInVuZGVmaW5lZCIsImdldFdyYXBwZWROYW1lIiwib3V0ZXJUeXBlIiwiaW5uZXJUeXBlIiwid3JhcHBlck5hbWUiLCJkaXNwbGF5TmFtZSIsImZ1bmN0aW9uTmFtZSIsIm5hbWUiLCJnZXRDb250ZXh0TmFtZSIsIlJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSIsImdldENvbXBvbmVudE5hbWVGcm9tVHlwZSIsInRhZyIsImNvbnRleHQiLCJwcm92aWRlciIsIl9jb250ZXh0IiwicmVuZGVyIiwib3V0ZXJOYW1lIiwibGF6eUNvbXBvbmVudCIsInBheWxvYWQiLCJfcGF5bG9hZCIsImluaXQiLCJfaW5pdCIsIngiLCJhc3NpZ24iLCJPYmplY3QiLCJkaXNhYmxlZERlcHRoIiwicHJldkxvZyIsInByZXZJbmZvIiwicHJldldhcm4iLCJwcmV2RXJyb3IiLCJwcmV2R3JvdXAiLCJwcmV2R3JvdXBDb2xsYXBzZWQiLCJwcmV2R3JvdXBFbmQiLCJkaXNhYmxlZExvZyIsIl9fcmVhY3REaXNhYmxlZExvZyIsImRpc2FibGVMb2dzIiwibG9nIiwiaW5mbyIsIndhcm4iLCJncm91cCIsImdyb3VwQ29sbGFwc2VkIiwiZ3JvdXBFbmQiLCJwcm9wcyIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ2YWx1ZSIsIndyaXRhYmxlIiwiZGVmaW5lUHJvcGVydGllcyIsInJlZW5hYmxlTG9ncyIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIiLCJwcmVmaXgiLCJkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSIsInNvdXJjZSIsIm93bmVyRm4iLCJFcnJvciIsIm1hdGNoIiwidHJpbSIsInJlZW50cnkiLCJjb21wb25lbnRGcmFtZUNhY2hlIiwiUG9zc2libHlXZWFrTWFwIiwiV2Vha01hcCIsIk1hcCIsImRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUiLCJmbiIsImNvbnN0cnVjdCIsImZyYW1lIiwiZ2V0IiwicHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSIsInByZXBhcmVTdGFja1RyYWNlIiwicHJldmlvdXNEaXNwYXRjaGVyIiwiY3VycmVudCIsIlJ1bkluUm9vdEZyYW1lIiwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290IiwiY29udHJvbCIsIkZha2UiLCJkZWZpbmVQcm9wZXJ0eSIsInNldCIsIlJlZmxlY3QiLCJtYXliZVByb21pc2UiLCJjYXRjaCIsInNhbXBsZSIsIm5hbWVQcm9wRGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9SdW5JblJvb3RGcmFtZSREZXRlciIsInNhbXBsZVN0YWNrIiwiY29udHJvbFN0YWNrIiwic2FtcGxlTGluZXMiLCJzcGxpdCIsImNvbnRyb2xMaW5lcyIsInMiLCJjIiwiaW5jbHVkZXMiLCJfZnJhbWUiLCJyZXBsYWNlIiwic3ludGhldGljRnJhbWUiLCJkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUiLCJzaG91bGRDb25zdHJ1Y3QiLCJDb21wb25lbnQiLCJpc1JlYWN0Q29tcG9uZW50IiwiZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWIiwiaGFzT3duUHJvcGVydHkiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEiLCJzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxIiwiZWxlbWVudCIsIm93bmVyIiwiX293bmVyIiwiX3NvdXJjZSIsInNldEV4dHJhU3RhY2tGcmFtZSIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwidmFsdWVzIiwibG9jYXRpb24iLCJjb21wb25lbnROYW1lIiwiaGFzIiwiYmluZCIsInR5cGVTcGVjTmFtZSIsImVycm9yJDEiLCJlcnIiLCJleCIsIm1lc3NhZ2UiLCJpc0FycmF5SW1wbCIsImlzQXJyYXkiLCJhIiwidHlwZU5hbWUiLCJoYXNUb1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwiY29uc3RydWN0b3IiLCJ3aWxsQ29lcmNpb25UaHJvdyIsInRlc3RTdHJpbmdDb2VyY2lvbiIsImUiLCJjaGVja0tleVN0cmluZ0NvZXJjaW9uIiwiUmVhY3RDdXJyZW50T3duZXIkMSIsIlJlYWN0Q3VycmVudE93bmVyIiwiUkVTRVJWRURfUFJPUFMiLCJrZXkiLCJyZWYiLCJfX3NlbGYiLCJfX3NvdXJjZSIsInNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIiwic3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24iLCJkaWRXYXJuQWJvdXRTdHJpbmdSZWZzIiwiaGFzVmFsaWRSZWYiLCJjb25maWciLCJnZXR0ZXIiLCJpc1JlYWN0V2FybmluZyIsImhhc1ZhbGlkS2V5Iiwid2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkIiwic2VsZiIsInN0YXRlTm9kZSIsImRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nS2V5IiwiZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdSZWYiLCJSZWFjdEVsZW1lbnQiLCJfc3RvcmUiLCJmcmVlemUiLCJqc3hERVYkMSIsIm1heWJlS2V5IiwicHJvcE5hbWUiLCJkZWZhdWx0UHJvcHMiLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFIiwic2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQiLCJwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biIsImlzVmFsaWRFbGVtZW50Iiwib2JqZWN0IiwiZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtIiwiZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0iLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJvd25lckhhc0tleVVzZVdhcm5pbmciLCJnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwicGFyZW50VHlwZSIsInBhcmVudE5hbWUiLCJ2YWxpZGF0ZUV4cGxpY2l0S2V5IiwidmFsaWRhdGVkIiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsImNoaWxkT3duZXIiLCJ2YWxpZGF0ZUNoaWxkS2V5cyIsIm5vZGUiLCJpIiwiY2hpbGQiLCJpdGVyYXRvckZuIiwiZW50cmllcyIsInN0ZXAiLCJuZXh0IiwiZG9uZSIsInZhbGlkYXRlUHJvcFR5cGVzIiwicHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwiX25hbWUiLCJnZXREZWZhdWx0UHJvcHMiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsInZhbGlkYXRlRnJhZ21lbnRQcm9wcyIsImZyYWdtZW50Iiwia2V5cyIsImRpZFdhcm5BYm91dEtleVNwcmVhZCIsImpzeFdpdGhWYWxpZGF0aW9uIiwiaXNTdGF0aWNDaGlsZHJlbiIsInZhbGlkVHlwZSIsInNvdXJjZUluZm8iLCJ0eXBlU3RyaW5nIiwiY2hpbGRyZW4iLCJmaWx0ZXIiLCJrIiwiYmVmb3JlRXhhbXBsZSIsImpvaW4iLCJhZnRlckV4YW1wbGUiLCJqc3hERVYiLCJleHBvcnRzIiwiRnJhZ21lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsS0FBeUIsRUFBYyxFQUUxQyxNQUFNO0lBQ0xDLDhMQUF5QjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcz9jYTIwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-date-object/dist/index.module.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-date-object/dist/index.module.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ R; }\n/* harmony export */ });\nfunction t(e) {\n    return (t = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(t) {\n        return typeof t;\n    } : function(t) {\n        return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n    })(e);\n}\nfunction e(t) {\n    return function(t) {\n        if (Array.isArray(t)) return c(t);\n    }(t) || n(t) || h(t) || function() {\n        throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }();\n}\nfunction n(t) {\n    if (\"undefined\" != typeof Symbol && null != t[Symbol.iterator] || null != t[\"@@iterator\"]) return Array.from(t);\n}\nfunction r(t, e) {\n    var n = \"undefined\" != typeof Symbol && t[Symbol.iterator] || t[\"@@iterator\"];\n    if (!n) {\n        if (Array.isArray(t) || (n = h(t)) || e && t && \"number\" == typeof t.length) {\n            n && (t = n);\n            var r = 0, i = function() {};\n            return {\n                s: i,\n                n: function() {\n                    return r >= t.length ? {\n                        done: !0\n                    } : {\n                        done: !1,\n                        value: t[r++]\n                    };\n                },\n                e: function(t) {\n                    throw t;\n                },\n                f: i\n            };\n        }\n        throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    var s, a = !0, u = !1;\n    return {\n        s: function() {\n            n = n.call(t);\n        },\n        n: function() {\n            var t = n.next();\n            return a = t.done, t;\n        },\n        e: function(t) {\n            u = !0, s = t;\n        },\n        f: function() {\n            try {\n                a || null == n.return || n.return();\n            } finally{\n                if (u) throw s;\n            }\n        }\n    };\n}\nfunction i(t, e) {\n    var n = Object.keys(t);\n    if (Object.getOwnPropertySymbols) {\n        var r = Object.getOwnPropertySymbols(t);\n        e && (r = r.filter(function(e) {\n            return Object.getOwnPropertyDescriptor(t, e).enumerable;\n        })), n.push.apply(n, r);\n    }\n    return n;\n}\nfunction s(t) {\n    for(var e = 1; e < arguments.length; e++){\n        var n = null != arguments[e] ? arguments[e] : {};\n        e % 2 ? i(Object(n), !0).forEach(function(e) {\n            a(t, e, n[e]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : i(Object(n)).forEach(function(e) {\n            Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e));\n        });\n    }\n    return t;\n}\nfunction a(t, e, n) {\n    return (e = y(e)) in t ? Object.defineProperty(t, e, {\n        value: n,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n    }) : t[e] = n, t;\n}\nfunction u(t, e) {\n    return l(t) || function(t, e) {\n        var n = null == t ? null : \"undefined\" != typeof Symbol && t[Symbol.iterator] || t[\"@@iterator\"];\n        if (null != n) {\n            var r, i, s, a, u = [], o = !0, h = !1;\n            try {\n                if (s = (n = n.call(t)).next, 0 === e) {\n                    if (Object(n) !== n) return;\n                    o = !1;\n                } else for(; !(o = (r = s.call(n)).done) && (u.push(r.value), u.length !== e); o = !0);\n            } catch (t) {\n                h = !0, i = t;\n            } finally{\n                try {\n                    if (!o && null != n.return && (a = n.return(), Object(a) !== a)) return;\n                } finally{\n                    if (h) throw i;\n                }\n            }\n            return u;\n        }\n    }(t, e) || h(t, e) || o();\n}\nfunction o() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction h(t, e) {\n    if (t) {\n        if (\"string\" == typeof t) return c(t, e);\n        var n = Object.prototype.toString.call(t).slice(8, -1);\n        return \"Object\" === n && t.constructor && (n = t.constructor.name), \"Map\" === n || \"Set\" === n ? Array.from(t) : \"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? c(t, e) : void 0;\n    }\n}\nfunction c(t, e) {\n    (null == e || e > t.length) && (e = t.length);\n    for(var n = 0, r = new Array(e); n < e; n++)r[n] = t[n];\n    return r;\n}\nfunction l(t) {\n    if (Array.isArray(t)) return t;\n}\nfunction f(t, e) {\n    for(var n = 0; n < e.length; n++){\n        var r = e[n];\n        r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, y(r.key), r);\n    }\n}\nfunction y(e) {\n    var n = function(e, n) {\n        if (\"object\" !== t(e) || null === e) return e;\n        var r = e[Symbol.toPrimitive];\n        if (void 0 !== r) {\n            var i = r.call(e, n || \"default\");\n            if (\"object\" !== t(i)) return i;\n            throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n        }\n        return (\"string\" === n ? String : Number)(e);\n    }(e, \"string\");\n    return \"symbol\" === t(n) ? n : String(n);\n}\nfunction d(t, e, n) {\n    !function(t, e) {\n        if (e.has(t)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n    }(t, e), e.set(t, n);\n}\nfunction m(t, e) {\n    return function(t, e) {\n        if (e.get) return e.get.call(t);\n        return e.value;\n    }(t, g(t, e, \"get\"));\n}\nfunction v(t, e, n) {\n    return function(t, e, n) {\n        if (e.set) e.set.call(t, n);\n        else {\n            if (!e.writable) throw new TypeError(\"attempted to set read only private field\");\n            e.value = n;\n        }\n    }(t, g(t, e, \"set\"), n), n;\n}\nfunction g(t, e, n) {\n    if (!e.has(t)) throw new TypeError(\"attempted to \" + n + \" private field on non-instance\");\n    return e.get(t);\n}\nvar k = {\n    name: \"gregorian_en\",\n    months: [\n        [\n            \"January\",\n            \"Jan\"\n        ],\n        [\n            \"February\",\n            \"Feb\"\n        ],\n        [\n            \"March\",\n            \"Mar\"\n        ],\n        [\n            \"April\",\n            \"Apr\"\n        ],\n        [\n            \"May\",\n            \"May\"\n        ],\n        [\n            \"June\",\n            \"Jun\"\n        ],\n        [\n            \"July\",\n            \"Jul\"\n        ],\n        [\n            \"August\",\n            \"Aug\"\n        ],\n        [\n            \"September\",\n            \"Sep\"\n        ],\n        [\n            \"October\",\n            \"Oct\"\n        ],\n        [\n            \"November\",\n            \"Nov\"\n        ],\n        [\n            \"December\",\n            \"Dec\"\n        ]\n    ],\n    weekDays: [\n        [\n            \"Saturday\",\n            \"Sat\"\n        ],\n        [\n            \"Sunday\",\n            \"Sun\"\n        ],\n        [\n            \"Monday\",\n            \"Mon\"\n        ],\n        [\n            \"Tuesday\",\n            \"Tue\"\n        ],\n        [\n            \"Wednesday\",\n            \"Wed\"\n        ],\n        [\n            \"Thursday\",\n            \"Thu\"\n        ],\n        [\n            \"Friday\",\n            \"Fri\"\n        ]\n    ],\n    digits: [\n        \"0\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"7\",\n        \"8\",\n        \"9\"\n    ],\n    meridiems: [\n        [\n            \"AM\",\n            \"am\"\n        ],\n        [\n            \"PM\",\n            \"pm\"\n        ]\n    ]\n}, p = {\n    name: \"gregorian\",\n    startYear: 1,\n    yearLength: 365,\n    epoch: 1721424,\n    century: 20,\n    weekStartDayIndex: 1,\n    getMonthLengths: function(t) {\n        return [\n            31,\n            t ? 29 : 28,\n            31,\n            30,\n            31,\n            30,\n            31,\n            31,\n            30,\n            31,\n            30,\n            31\n        ];\n    },\n    isLeap: function(t) {\n        return t % 4 == 0 && t % 100 != 0 || t % 400 == 0;\n    },\n    getLeaps: function(t) {\n        if (0 !== t) {\n            for(var e = t > 0 ? 1 : -1, n = []; t > 0 ? e <= t : t <= e;)this.isLeap(e) && n.push(e), t > 0 ? e++ : e--;\n            return n;\n        }\n    },\n    getDayOfYear: function(t) {\n        for(var e = t.year, n = t.month, r = t.day, i = this.getMonthLengths(this.isLeap(e)), s = 0; s < n.index; s++)r += i[s];\n        return r;\n    },\n    getAllDays: function(t) {\n        var e = t.year;\n        return this.yearLength * (e - 1) + this.leapsLength(e) + this.getDayOfYear(t);\n    },\n    leapsLength: function(t) {\n        return ((t - 1) / 4 | 0) + (-(t - 1) / 100 | 0) + ((t - 1) / 400 | 0);\n    },\n    guessYear: function(t, e) {\n        return ~~(t / 365.24) + (e > 0 ? 1 : -1);\n    }\n};\nfunction b(t) {\n    return t && t.constructor === Object;\n}\nfunction w(t) {\n    if (!isNaN(t)) return parseInt(t);\n}\nfunction D(t) {\n    return Array.isArray(t);\n}\n_c = D;\nfunction M(t, e, n) {\n    return void 0 === t || t < e || t > n;\n}\n_c1 = M;\nvar O = new WeakMap, S = new WeakMap, Y = new WeakMap, L = new WeakMap, W = new WeakMap, x = new WeakMap, j = new WeakMap, N = new WeakMap, A = new WeakMap, I = new WeakMap, T = new WeakMap, F = new WeakMap, E = new WeakMap, P = new WeakMap, H = new WeakMap, V = new WeakMap, J = new WeakMap, C = new WeakMap, U = new WeakMap, R = function() {\n    function i(t) {\n        var e = this;\n        !function(t, e) {\n            if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n        }(this, i), d(this, O, {\n            writable: !0,\n            value: void 0\n        }), d(this, S, {\n            writable: !0,\n            value: void 0\n        }), d(this, Y, {\n            writable: !0,\n            value: void 0\n        }), d(this, L, {\n            writable: !0,\n            value: void 0\n        }), d(this, W, {\n            writable: !0,\n            value: void 0\n        }), d(this, x, {\n            writable: !0,\n            value: void 0\n        }), d(this, j, {\n            writable: !0,\n            value: void 0\n        }), d(this, N, {\n            writable: !0,\n            value: void 0\n        }), d(this, A, {\n            writable: !0,\n            value: k\n        }), d(this, I, {\n            writable: !0,\n            value: p\n        }), d(this, T, {\n            writable: !0,\n            value: !1\n        }), d(this, F, {\n            writable: !0,\n            value: {}\n        }), d(this, E, {\n            writable: !0,\n            value: /^\\d{4}-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d\\.\\d\\d\\dZ$/\n        }), d(this, P, {\n            writable: !0,\n            value: []\n        }), d(this, H, {\n            writable: !0,\n            value: !0\n        }), d(this, V, {\n            writable: !0,\n            value: function(t, n) {\n                switch(t){\n                    case \"YYYY\":\n                        return [\n                            \"year\",\n                            n\n                        ];\n                    case \"YY\":\n                        return [\n                            \"year\",\n                            \"\".concat(m(e, I).century).concat(n)\n                        ];\n                    case \"MMMM\":\n                    case \"MMM\":\n                        return [\n                            \"month\",\n                            e.months.findIndex(function(t) {\n                                var e = t.name, r = t.shortName;\n                                return new RegExp(n, \"i\").test(e + r);\n                            }) + 1\n                        ];\n                    case \"MM\":\n                    case \"M\":\n                        return [\n                            \"month\",\n                            n\n                        ];\n                    case \"DD\":\n                    case \"D\":\n                        return [\n                            \"day\",\n                            n\n                        ];\n                    case \"HH\":\n                    case \"H\":\n                        return [\n                            \"hour\",\n                            n\n                        ];\n                    case \"hh\":\n                    case \"h\":\n                        var r = w(n);\n                        return [\n                            \"hour\",\n                            r > 12 ? r - 12 : r\n                        ];\n                    case \"mm\":\n                    case \"m\":\n                        return [\n                            \"minute\",\n                            n\n                        ];\n                    case \"ss\":\n                    case \"s\":\n                        return [\n                            \"second\",\n                            n\n                        ];\n                    case \"SSS\":\n                    case \"SS\":\n                    case \"S\":\n                        return [\n                            \"millisecond\",\n                            n\n                        ];\n                    default:\n                        return [];\n                }\n            }\n        }), d(this, J, {\n            writable: !0,\n            value: function() {\n                return 0 === m(e, O) && 0 !== m(e, I).startYear;\n            }\n        }), d(this, C, {\n            writable: !0,\n            value: function() {\n                if (m(e, H) && e.isValid) {\n                    var t = Math.floor, n = function(e, n) {\n                        return [\n                            (s = e, (s < 0 ? -1 : 1) * Math.abs(t(e / n))),\n                            (r = e, i = n, (r < 0 && -0 !== t(r % i) ? i : 0) + t(e % n))\n                        ];\n                        var r, i, s;\n                    }, r = function() {\n                        if (m(e, S) < 0 || m(e, S) > 11) {\n                            var t = m(e, S) < 0 ? -1 : 1, r = u(n(m(e, S), 12), 2), i = r[0], s = r[1];\n                            v(e, O, m(e, O) + i), v(e, S, s), m(e, J).call(e) && v(e, O, t);\n                        }\n                    };\n                    for(v(e, H, !1), [\n                        [\n                            \"millisecond\",\n                            \"second\",\n                            1e3\n                        ],\n                        [\n                            \"second\",\n                            \"minute\",\n                            60\n                        ],\n                        [\n                            \"minute\",\n                            \"hour\",\n                            60\n                        ],\n                        [\n                            \"hour\",\n                            \"day\",\n                            24\n                        ]\n                    ].forEach(function(t) {\n                        var r = u(t, 3), i = r[0], s = r[1], a = r[2];\n                        if (function(t, e) {\n                            return t >= e || t < 0;\n                        }(e[i], a)) {\n                            var o = u(n(e[i], a), 2), h = o[0], c = o[1];\n                            e[s] += h, e[i] = c;\n                        }\n                    }), v(e, H, !0), r(); m(e, Y) < -m(e, I).yearLength || m(e, Y) > m(e, I).yearLength;){\n                        if (m(e, S) > 0) {\n                            for(var i = m(e, I).getMonthLengths(e.isLeap), s = 0; s < m(e, S); s++)v(e, Y, m(e, Y) + i[s]);\n                            v(e, S, 0);\n                        }\n                        var a = e.isLeap ? e.calendar.yearLength + 1 : e.calendar.yearLength;\n                        v(e, Y, m(e, Y) + a * (m(e, Y) < 0 ? 1 : -1)), v(e, O, m(e, O) + (m(e, Y) < 0 ? -1 : 1));\n                    }\n                    for(;;){\n                        var o;\n                        for(r(); m(e, Y) < 1;)v(e, S, m(e, S) - 1), r(), v(e, Y, e.month.length + m(e, Y));\n                        if (m(e, Y) <= e.month.length || isNaN(m(e, Y))) break;\n                        v(e, Y, m(e, Y) - e.month.length), v(e, S, (o = m(e, S), o++, o));\n                    }\n                    m(e, L) || v(e, L, 0), m(e, W) || v(e, W, 0), m(e, x) || v(e, x, 0), m(e, j) || v(e, j, 0);\n                }\n            }\n        }), d(this, U, {\n            writable: !0,\n            value: function() {\n                return (m(e, F).weekDays || m(e, A).weekDays).map(function(t, n) {\n                    var r = u(t, 2), i = r[0], s = r[1], a = n - e.weekStartDayIndex;\n                    return a < 0 && (a += 7), {\n                        name: i,\n                        shortName: s,\n                        index: a,\n                        number: a + 1,\n                        toString: function() {\n                            return this.number.toString();\n                        },\n                        valueOf: function() {\n                            return this.number;\n                        }\n                    };\n                });\n            }\n        });\n        var n = b(t) ? s({}, t) : t, r = !0;\n        if (n && \"boolean\" != typeof n || (n = {\n            date: new Date\n        }), b(n) || (n = {\n            date: n\n        }), 0 !== Object.keys(n).length) {\n            for(var a in b(n.calendar) && v(this, I, n.calendar), b(n.locale) && v(this, A, n.locale), isNaN(n.year) && isNaN(n.month) && isNaN(n.day) && !n.date && (n.date = new Date), n.date && (\"string\" == typeof n.date && n.format && v(this, N, n.format), this.setDate(n.date), n.calendar && this.convert(n.calendar), r = !1), delete n.calendar, delete n.locale, delete n.date, n)this.set(a, n[a]);\n            m(this, J).call(this) && v(this, O, -1), r && m(this, C).call(this);\n        }\n    }\n    var a, c, y;\n    return a = i, (c = [\n        {\n            key: \"parse\",\n            value: function(t) {\n                if (!t) return this;\n                var i, s, a = m(this, N), c = m(this, A).digits, f = r(c);\n                try {\n                    for(f.s(); !(i = f.n()).done;){\n                        var y = i.value;\n                        t = t.replace(new RegExp(y, \"g\"), c.indexOf(y));\n                    }\n                } catch (t) {\n                    f.e(t);\n                } finally{\n                    f.f();\n                }\n                if (a) for(var d = a.split(/[^\\w\\u0600-\\u06FF]/), g = t.split(/[^\\w\\u0600-\\u06FF]/), k = 0; k < d.length; k++)this.set.apply(this, e(m(this, V).call(this, d[k], g[k])));\n                else {\n                    var p = t.match(/(-?\\d{2,4})?\\W?([A-z]{3,9}|\\d{1,2})?\\W?(\\d{1,2})?\\W?(\\d{1,2})?\\W?(\\d{1,2})?\\W?(\\d{1,2})?\\W?(\\d{1,3})?\\W?(am|pm)?/), b = (l(s = p) || n(s) || h(s) || o()).slice(1), D = b[1];\n                    D && (D = /\\d+/.test(D) ? w(D) - 1 : this.months.findIndex(function(t) {\n                        return new RegExp(D, \"i\").test(t.name);\n                    })), b[1] = D;\n                    var M = u(b.map(w), 7), I = M[0], T = M[1], F = M[2], E = M[3], P = M[4], H = M[5], J = M[6];\n                    v(this, O, I), v(this, S, T), v(this, Y, F), v(this, L, E), v(this, W, P), v(this, x, H), v(this, j, J);\n                }\n                var U = u(m(this, A).meridiems[1], 2), R = U[0], _ = U[1];\n                return m(this, L) < 12 && (t.includes(R) || t.includes(_)) && v(this, L, m(this, L) + 12), m(this, C).call(this), this;\n            }\n        },\n        {\n            key: \"convert\",\n            value: function() {\n                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : p, e = arguments.length > 1 ? arguments[1] : void 0;\n                if (b(e) && v(this, A, e), !b(t) || t.name === m(this, I).name) return this;\n                var n = this.toJulianDay() - t.epoch, r = new i({\n                    calendar: t,\n                    year: t.guessYear(n, m(this, O)),\n                    month: 1,\n                    day: 1\n                });\n                return r.day += n - r.toDays(), v(this, O, r.year), v(this, S, r.month.index), v(this, Y, r.day), v(this, I, t), this;\n            }\n        },\n        {\n            key: \"format\",\n            value: function(e, n) {\n                if (!this.isValid || e && \"string\" != typeof e) return \"\";\n                e || (e = m(this, N) || \"YYYY/MM/DD\"), D(n) || (n = []), n = (n = n.concat(m(this, P))).filter(function(e) {\n                    return \"string\" == typeof e || (console.warn(\"type of all items in the ignore list must be string, found\", t(e)), !1);\n                }).map(function(t) {\n                    return t.replace(/[*/+\\-()[\\]{}\\s$^]/g, function(t) {\n                        return \"\\\\\" + t;\n                    });\n                });\n                var i, s = new RegExp(\"\".concat(n.join(\"|\")).concat(n.length > 0 ? \"|\" : \"\", \"YYYY|YY|MMMM|MMM|MM|M|WW|W|DDDD|DDD|DD|D|dddd|ddd|dd|d|HH|H|hh|h|mm|m|ss|s|SSS|SS|S|A|a|.\"), \"g\"), a = \"\", u = r(e.match(s) || []);\n                try {\n                    for(u.s(); !(i = u.n()).done;){\n                        var o = i.value, h = this.getValue(o);\n                        a += n.includes(o) ? o : 0 === h ? h : h || o;\n                    }\n                } catch (t) {\n                    u.e(t);\n                } finally{\n                    u.f();\n                }\n                var c = this.digits;\n                return a.replace(/[0-9]/g, function(t) {\n                    return c[t];\n                });\n            }\n        },\n        {\n            key: \"getProperty\",\n            value: function(t) {\n                return this.getValue(t);\n            }\n        },\n        {\n            key: \"getValue\",\n            value: function(t) {\n                var e = function(t) {\n                    return t < 10 ? \"0\" + t : t;\n                };\n                switch(t){\n                    case \"YYYY\":\n                        return this.year;\n                    case \"YY\":\n                        return this.year.toString().substring(2, 4);\n                    case \"MMMM\":\n                        return this.month.name;\n                    case \"MMM\":\n                        return this.month.shortName;\n                    case \"MM\":\n                        return e(this.month.number);\n                    case \"M\":\n                        return this.month.number;\n                    case \"WW\":\n                        return e(this.weekOfYear);\n                    case \"W\":\n                        return this.weekOfYear;\n                    case \"DDDD\":\n                    case \"DDD\":\n                        return this.dayOfYear;\n                    case \"DD\":\n                        return e(this.day);\n                    case \"D\":\n                        return this.day;\n                    case \"HH\":\n                        return e(this.hour);\n                    case \"H\":\n                        return this.hour;\n                    case \"dddd\":\n                        return this.weekDay.name;\n                    case \"ddd\":\n                        return this.weekDay.shortName;\n                    case \"dd\":\n                        return e(this.weekDay.number);\n                    case \"d\":\n                        return this.weekDay.number;\n                    case \"hh\":\n                        return e(this.hour > 12 ? this.hour - 12 : this.hour || 12);\n                    case \"h\":\n                        return this.hour > 12 ? this.hour - 12 : this.hour || 12;\n                    case \"mm\":\n                        return e(this.minute);\n                    case \"m\":\n                        return this.minute;\n                    case \"ss\":\n                        return e(this.second);\n                    case \"s\":\n                        return this.second;\n                    case \"SSS\":\n                        return m(this, j) < 10 ? \"00\".concat(m(this, j)) : m(this, j) < 100 ? \"0\".concat(m(this, j)) : m(this, j);\n                    case \"SS\":\n                        return m(this, j) < 10 ? \"00\" : m(this, j) < 100 ? (\"0\" + m(this, j)).substring(2, 0) : m(this, j).toString().substring(0, 2);\n                    case \"S\":\n                        return m(this, j) < 10 || m(this, j) < 100 ? \"0\" : m(this, j).toString().substring(0, 1);\n                    case \"a\":\n                        return this.hour >= 12 ? m(this, A).meridiems[1][1] : m(this, A).meridiems[0][1];\n                    case \"A\":\n                        return this.hour >= 12 ? m(this, A).meridiems[1][0] : m(this, A).meridiems[0][0];\n                    default:\n                        return \"\";\n                }\n            }\n        },\n        {\n            key: \"setYear\",\n            value: function(t) {\n                return this.year = t, this;\n            }\n        },\n        {\n            key: \"setMonths\",\n            value: function(t) {\n                return this.months = t, this;\n            }\n        },\n        {\n            key: \"setMonth\",\n            value: function(t) {\n                return this.month = t, this;\n            }\n        },\n        {\n            key: \"setWeekDays\",\n            value: function(t) {\n                return this.weekDays = t, this;\n            }\n        },\n        {\n            key: \"setDigits\",\n            value: function(t) {\n                return this.digits = t, this;\n            }\n        },\n        {\n            key: \"setDay\",\n            value: function(t) {\n                return this.day = t, this;\n            }\n        },\n        {\n            key: \"setHour\",\n            value: function(t) {\n                return this.hour = t, this;\n            }\n        },\n        {\n            key: \"setMinute\",\n            value: function(t) {\n                return this.minute = t, this;\n            }\n        },\n        {\n            key: \"setSecond\",\n            value: function(t) {\n                return this.second = t, this;\n            }\n        },\n        {\n            key: \"setMillisecond\",\n            value: function(t) {\n                return this.millisecond = t, this;\n            }\n        },\n        {\n            key: \"setFormat\",\n            value: function(t) {\n                return v(this, N, t), this;\n            }\n        },\n        {\n            key: \"setLocale\",\n            value: function(t) {\n                return this.locale = t, this;\n            }\n        },\n        {\n            key: \"setCalendar\",\n            value: function(t) {\n                return this.calendar = t, this;\n            }\n        },\n        {\n            key: \"setDate\",\n            value: function(t) {\n                if (\"string\" == typeof t) {\n                    if (!m(this, E).test(t)) return this.parse(t);\n                    t = new Date(t);\n                }\n                return \"number\" == typeof t && (t = new Date(t)), t instanceof Date && (v(this, I, p), v(this, O, t.getFullYear()), v(this, S, t.getMonth()), v(this, Y, t.getDate()), v(this, L, t.getHours()), v(this, W, t.getMinutes()), v(this, x, t.getSeconds()), v(this, j, t.getMilliseconds()), v(this, T, !1)), t instanceof i && (v(this, O, t.year), v(this, S, t.month.index), v(this, Y, t.day), v(this, L, t.hour), v(this, W, t.minute), v(this, x, t.second), v(this, j, t.millisecond), v(this, A, t.locale), v(this, N, t._format), v(this, I, t.calendar), v(this, T, t.isUTC), v(this, P, t.ignoreList), v(this, F, t.custom)), this;\n            }\n        },\n        {\n            key: \"setIgnoreList\",\n            value: function(t) {\n                return this.ignoreList = t, this;\n            }\n        },\n        {\n            key: \"set\",\n            value: function(t, e) {\n                if (null == t) return this;\n                if (b(t)) {\n                    var n = s({}, t);\n                    for(var r in n.date && (this.setDate(n.date), delete n.date), n.calendar && (this.convert(n.calendar), delete n.calendar), n.locale && (this.setLocale(n.locale), delete n.locale), v(this, H, !1), n)this.set(r, n[r]);\n                    return v(this, H, !0), m(this, C).call(this), this;\n                }\n                \"format\" === t && (t = \"_format\");\n                try {\n                    this[t] = e;\n                } catch (t) {}\n                return this;\n            }\n        },\n        {\n            key: \"add\",\n            value: function(t, e) {\n                if (!(t = w(t)) || !e) return this;\n                switch(e){\n                    case \"years\":\n                    case \"y\":\n                        e = \"year\";\n                        break;\n                    case \"months\":\n                    case \"M\":\n                        e = \"month\";\n                        break;\n                    case \"days\":\n                    case \"d\":\n                        e = \"day\";\n                        break;\n                    case \"hours\":\n                    case \"h\":\n                        e = \"hour\";\n                        break;\n                    case \"minutes\":\n                    case \"m\":\n                        e = \"minute\";\n                        break;\n                    case \"seconds\":\n                    case \"s\":\n                        e = \"second\";\n                        break;\n                    case \"milliseconds\":\n                    case \"ms\":\n                        e = \"millisecond\";\n                }\n                return this[e] += t, this;\n            }\n        },\n        {\n            key: \"subtract\",\n            value: function(t, e) {\n                return this.add(-t, e);\n            }\n        },\n        {\n            key: \"toFirstOfYear\",\n            value: function() {\n                return this.month = 1, this.day = 1, this;\n            }\n        },\n        {\n            key: \"toLastOfYear\",\n            value: function() {\n                return this.day >= 29 && (this.day = 29), this.month = 12, this.toLastOfMonth(), this;\n            }\n        },\n        {\n            key: \"toFirstOfMonth\",\n            value: function() {\n                return v(this, Y, 1), this;\n            }\n        },\n        {\n            key: \"toLastOfMonth\",\n            value: function() {\n                return v(this, Y, 0), v(this, S, m(this, S) + 1), m(this, C).call(this), this;\n            }\n        },\n        {\n            key: \"toFirstOfWeek\",\n            value: function() {\n                return this.day -= this.weekDay.index, this;\n            }\n        },\n        {\n            key: \"toLastOfWeek\",\n            value: function() {\n                return this.day += 6 - this.weekDay.index, this;\n            }\n        },\n        {\n            key: \"toFirstWeekOfYear\",\n            value: function() {\n                return this.toFirstOfYear(), 0 === this.weekDay.index ? this : this.toLastOfWeek().setDay(this.day + 1);\n            }\n        },\n        {\n            key: \"toLastWeekOfYear\",\n            value: function() {\n                return this.toLastOfYear().toFirstOfWeek();\n            }\n        },\n        {\n            key: \"toString\",\n            value: function() {\n                return this.format();\n            }\n        },\n        {\n            key: \"toDate\",\n            value: function() {\n                var t = new i(this);\n                return \"gregorian\" !== m(this, I).name && t.convert(p), new Date(t.year, t.month.index, t.day, t.hour, t.minute, t.second, t.millisecond);\n            }\n        },\n        {\n            key: \"toUTC\",\n            value: function() {\n                return m(this, T) || (this.minute += this.toDate().getTimezoneOffset(), v(this, T, !0)), this;\n            }\n        },\n        {\n            key: \"toUnix\",\n            value: function() {\n                return this.unix;\n            }\n        },\n        {\n            key: \"toJulianDay\",\n            value: function() {\n                return this.toDays() + m(this, I).epoch;\n            }\n        },\n        {\n            key: \"toObject\",\n            value: function() {\n                return {\n                    year: m(this, O),\n                    month: this.month,\n                    day: m(this, Y),\n                    weekDay: this.weekDay,\n                    hour: m(this, L),\n                    minute: m(this, W),\n                    second: m(this, x),\n                    millisecond: m(this, j),\n                    weekOfYear: this.weekOfYear,\n                    dayOfYear: this.dayOfYear,\n                    daysLeft: this.daysLeft,\n                    calendar: m(this, I),\n                    locale: m(this, A),\n                    format: m(this, N) || \"YYYY/MM/DD\",\n                    ignoreList: m(this, P)\n                };\n            }\n        },\n        {\n            key: \"toJSON\",\n            value: function() {\n                return this.valueOf();\n            }\n        },\n        {\n            key: \"valueOf\",\n            value: function() {\n                return this.toDate().valueOf();\n            }\n        },\n        {\n            key: \"toDays\",\n            value: function() {\n                if (this.isValid) return m(this, I).getAllDays(this);\n            }\n        },\n        {\n            key: \"dayOfBeginning\",\n            get: function() {\n                return this.toDays();\n            }\n        },\n        {\n            key: \"dayOfYear\",\n            get: function() {\n                if (this.isValid) return m(this, I).getDayOfYear(this);\n            }\n        },\n        {\n            key: \"weekOfYear\",\n            get: function() {\n                if (this.isValid) return 1 + ~~(this.dayOfYear / 7);\n            }\n        },\n        {\n            key: \"daysLeft\",\n            get: function() {\n                if (this.isValid) {\n                    var t = m(this, I).yearLength;\n                    return (this.isLeap ? t + 1 : t) - this.dayOfYear;\n                }\n            }\n        },\n        {\n            key: \"year\",\n            get: function() {\n                return m(this, O);\n            },\n            set: function(t) {\n                v(this, O, w(t)), m(this, C).call(this);\n            }\n        },\n        {\n            key: \"month\",\n            get: function() {\n                return this.months[m(this, S)] || {};\n            },\n            set: function(t) {\n                var e;\n                t = null !== (e = w(t.valueOf()) - 1) && void 0 !== e ? e : void 0, v(this, S, t), M(t, 0, 11) && m(this, C).call(this);\n            }\n        },\n        {\n            key: \"monthIndex\",\n            get: function() {\n                return m(this, S);\n            }\n        },\n        {\n            key: \"day\",\n            get: function() {\n                return m(this, Y);\n            },\n            set: function(t) {\n                t = w(t), v(this, Y, t), M(t, 1, 28) && m(this, C).call(this);\n            }\n        },\n        {\n            key: \"weekDay\",\n            get: function() {\n                if (!this.isValid) return {};\n                var t = (this.toJulianDay() + 3) % 7;\n                return m(this, U).call(this)[t];\n            }\n        },\n        {\n            key: \"hour\",\n            get: function() {\n                return m(this, L);\n            },\n            set: function(t) {\n                t = w(t), v(this, L, t), M(t, 0, 23) && m(this, C).call(this);\n            }\n        },\n        {\n            key: \"minute\",\n            get: function() {\n                return m(this, W);\n            },\n            set: function(t) {\n                t = w(t), v(this, W, t), M(t, 0, 59) && m(this, C).call(this);\n            }\n        },\n        {\n            key: \"second\",\n            get: function() {\n                return m(this, x);\n            },\n            set: function(t) {\n                t = w(t), v(this, x, t), M(t, 0, 59) && m(this, C).call(this);\n            }\n        },\n        {\n            key: \"millisecond\",\n            get: function() {\n                return m(this, j);\n            },\n            set: function(t) {\n                t = w(t), v(this, j, t), M(t, 0, 999) && m(this, C).call(this);\n            }\n        },\n        {\n            key: \"months\",\n            get: function() {\n                var t = m(this, I).getMonthLengths(this.isLeap);\n                return (m(this, F).months || m(this, A).months).map(function(e, n) {\n                    var r = u(e, 2);\n                    return {\n                        name: r[0],\n                        shortName: r[1],\n                        length: t[n],\n                        index: n,\n                        number: n + 1,\n                        toString: function() {\n                            return this.number.toString();\n                        },\n                        valueOf: function() {\n                            return this.number;\n                        }\n                    };\n                });\n            },\n            set: function(t) {\n                if (!t) return delete m(this, F).months;\n                D(t) && 12 === t.length && t.every(function(t) {\n                    return D(t) && 2 === t.length && t.every(function(t) {\n                        return \"string\" == typeof t;\n                    });\n                }) && (m(this, F).months = t);\n            }\n        },\n        {\n            key: \"weekDays\",\n            get: function() {\n                return m(this, U).call(this).sort(function(t, e) {\n                    return t.index - e.index;\n                });\n            },\n            set: function(t) {\n                if (!t) return delete m(this, F).weekDays;\n                D(t) && 7 === t.length && t.every(function(t) {\n                    return D(t) && 2 === t.length && t.every(function(t) {\n                        return \"string\" == typeof t;\n                    });\n                }) && (m(this, F).weekDays = t);\n            }\n        },\n        {\n            key: \"leaps\",\n            get: function() {\n                return m(this, I).getLeaps(m(this, O));\n            }\n        },\n        {\n            key: \"calendar\",\n            get: function() {\n                return m(this, I);\n            },\n            set: function(t) {\n                this.convert(t);\n            }\n        },\n        {\n            key: \"locale\",\n            get: function() {\n                return m(this, A);\n            },\n            set: function() {\n                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : k;\n                b(t) && v(this, A, t);\n            }\n        },\n        {\n            key: \"custom\",\n            get: function() {\n                return m(this, F);\n            }\n        },\n        {\n            key: \"meridiems\",\n            get: function() {\n                return m(this, A).meridiems;\n            }\n        },\n        {\n            key: \"digits\",\n            get: function() {\n                return m(this, F).digits || m(this, A).digits;\n            },\n            set: function(t) {\n                if (!t) return delete m(this, F).digits;\n                D(t) && 10 === t.length && (m(this, F).digits = t);\n            }\n        },\n        {\n            key: \"_format\",\n            get: function() {\n                return m(this, N);\n            },\n            set: function(t) {\n                \"string\" == typeof t && v(this, N, t);\n            }\n        },\n        {\n            key: \"isLeap\",\n            get: function() {\n                return m(this, I).isLeap(m(this, O));\n            }\n        },\n        {\n            key: \"isValid\",\n            get: function() {\n                return !isNaN(m(this, O)) && !isNaN(m(this, S)) && !isNaN(m(this, Y));\n            }\n        },\n        {\n            key: \"isUTC\",\n            get: function() {\n                return m(this, T);\n            }\n        },\n        {\n            key: \"unix\",\n            get: function() {\n                return (this.valueOf() - this.millisecond) / 1e3;\n            }\n        },\n        {\n            key: \"ignoreList\",\n            get: function() {\n                return m(this, P);\n            },\n            set: function(t) {\n                D(t) && v(this, P, t);\n            }\n        },\n        {\n            key: \"weekStartDayIndex\",\n            get: function() {\n                return m(this, I).weekStartDayIndex;\n            },\n            set: function(t) {\n                void 0 !== (t = w(t)) && (m(this, I).weekStartDayIndex = Math.abs(t) % 7);\n            }\n        },\n        {\n            key: \"date\",\n            set: function(t) {\n                this.setDate(t);\n            }\n        }\n    ]) && f(a.prototype, c), y && f(a, y), Object.defineProperty(a, \"prototype\", {\n        writable: !1\n    }), i;\n}();\n\nvar _c, _c1;\n$RefreshReg$(_c, \"D\");\n$RefreshReg$(_c1, \"M\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1kYXRlLW9iamVjdC9kaXN0L2luZGV4Lm1vZHVsZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsU0FBU0EsRUFBRUMsQ0FBQztJQUFFLE9BQU0sQ0FBQ0QsSUFBRSxjQUFZLE9BQU9FLFVBQVEsWUFBVSxPQUFPQSxPQUFPQyxRQUFRLEdBQUMsU0FBU0gsQ0FBQztRQUFFLE9BQU8sT0FBT0E7SUFBQyxJQUFFLFNBQVNBLENBQUM7UUFBRSxPQUFPQSxLQUFHLGNBQVksT0FBT0UsVUFBUUYsRUFBRUksV0FBVyxLQUFHRixVQUFRRixNQUFJRSxPQUFPRyxTQUFTLEdBQUMsV0FBUyxPQUFPTDtJQUFDLEdBQUdDO0FBQUU7QUFBQyxTQUFTQSxFQUFFRCxDQUFDO0lBQUUsT0FBTyxTQUFTQSxDQUFDO1FBQUUsSUFBR00sTUFBTUMsT0FBTyxDQUFDUCxJQUFHLE9BQU9RLEVBQUVSO0lBQUUsRUFBRUEsTUFBSVMsRUFBRVQsTUFBSVUsRUFBRVYsTUFBSTtRQUFXLE1BQU0sSUFBSVcsVUFBVTtJQUF1STtBQUFHO0FBQUMsU0FBU0YsRUFBRVQsQ0FBQztJQUFFLElBQUcsZUFBYSxPQUFPRSxVQUFRLFFBQU1GLENBQUMsQ0FBQ0UsT0FBT0MsUUFBUSxDQUFDLElBQUUsUUFBTUgsQ0FBQyxDQUFDLGFBQWEsRUFBQyxPQUFPTSxNQUFNTSxJQUFJLENBQUNaO0FBQUU7QUFBQyxTQUFTYSxFQUFFYixDQUFDLEVBQUNDLENBQUM7SUFBRSxJQUFJUSxJQUFFLGVBQWEsT0FBT1AsVUFBUUYsQ0FBQyxDQUFDRSxPQUFPQyxRQUFRLENBQUMsSUFBRUgsQ0FBQyxDQUFDLGFBQWE7SUFBQyxJQUFHLENBQUNTLEdBQUU7UUFBQyxJQUFHSCxNQUFNQyxPQUFPLENBQUNQLE1BQUtTLENBQUFBLElBQUVDLEVBQUVWLEVBQUMsS0FBSUMsS0FBR0QsS0FBRyxZQUFVLE9BQU9BLEVBQUVjLE1BQU0sRUFBQztZQUFDTCxLQUFJVCxD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UUFBRTtZQUFDK0MsS0FBSTtZQUFvQlEsS0FBSTtnQkFBVyxPQUFPRCxFQUFFLElBQUksRUFBQzBDLEdBQUc1QixpQkFBaUI7WUFBQTtZQUFFZixLQUFJLFNBQVNyRCxDQUFDO2dCQUFFLEtBQUssTUFBS0EsQ0FBQUEsSUFBRWlGLEVBQUVqRixFQUFDLEtBQUtzRCxDQUFBQSxFQUFFLElBQUksRUFBQzBDLEdBQUc1QixpQkFBaUIsR0FBQzRDLEtBQUtFLEdBQUcsQ0FBQ2xILEtBQUc7WUFBRTtRQUFDO1FBQUU7WUFBQytDLEtBQUk7WUFBT00sS0FBSSxTQUFTckQsQ0FBQztnQkFBRSxJQUFJLENBQUMySCxPQUFPLENBQUMzSDtZQUFFO1FBQUM7S0FBRSxLQUFHbUIsRUFBRUMsRUFBRWYsU0FBUyxFQUFDRyxJQUFHOEIsS0FBR25CLEVBQUVDLEdBQUVrQixJQUFHYixPQUFPWSxjQUFjLENBQUNqQixHQUFFLGFBQVk7UUFBQ29CLFVBQVMsQ0FBQztJQUFDLElBQUd6QjtBQUFDO0FBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1kYXRlLW9iamVjdC9kaXN0L2luZGV4Lm1vZHVsZS5qcz82MGU1Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHQoZSl7cmV0dXJuKHQ9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKGUpfWZ1bmN0aW9uIGUodCl7cmV0dXJuIGZ1bmN0aW9uKHQpe2lmKEFycmF5LmlzQXJyYXkodCkpcmV0dXJuIGModCl9KHQpfHxuKHQpfHxoKHQpfHxmdW5jdGlvbigpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpfSgpfWZ1bmN0aW9uIG4odCl7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmbnVsbCE9dFtTeW1ib2wuaXRlcmF0b3JdfHxudWxsIT10W1wiQEBpdGVyYXRvclwiXSlyZXR1cm4gQXJyYXkuZnJvbSh0KX1mdW5jdGlvbiByKHQsZSl7dmFyIG49XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmdFtTeW1ib2wuaXRlcmF0b3JdfHx0W1wiQEBpdGVyYXRvclwiXTtpZighbil7aWYoQXJyYXkuaXNBcnJheSh0KXx8KG49aCh0KSl8fGUmJnQmJlwibnVtYmVyXCI9PXR5cGVvZiB0Lmxlbmd0aCl7biYmKHQ9bik7dmFyIHI9MCxpPWZ1bmN0aW9uKCl7fTtyZXR1cm57czppLG46ZnVuY3Rpb24oKXtyZXR1cm4gcj49dC5sZW5ndGg/e2RvbmU6ITB9Ontkb25lOiExLHZhbHVlOnRbcisrXX19LGU6ZnVuY3Rpb24odCl7dGhyb3cgdH0sZjppfX10aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIil9dmFyIHMsYT0hMCx1PSExO3JldHVybntzOmZ1bmN0aW9uKCl7bj1uLmNhbGwodCl9LG46ZnVuY3Rpb24oKXt2YXIgdD1uLm5leHQoKTtyZXR1cm4gYT10LmRvbmUsdH0sZTpmdW5jdGlvbih0KXt1PSEwLHM9dH0sZjpmdW5jdGlvbigpe3RyeXthfHxudWxsPT1uLnJldHVybnx8bi5yZXR1cm4oKX1maW5hbGx5e2lmKHUpdGhyb3cgc319fX1mdW5jdGlvbiBpKHQsZSl7dmFyIG49T2JqZWN0LmtleXModCk7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIHI9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0KTtlJiYocj1yLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxlKS5lbnVtZXJhYmxlfSkpKSxuLnB1c2guYXBwbHkobixyKX1yZXR1cm4gbn1mdW5jdGlvbiBzKHQpe2Zvcih2YXIgZT0xO2U8YXJndW1lbnRzLmxlbmd0aDtlKyspe3ZhciBuPW51bGwhPWFyZ3VtZW50c1tlXT9hcmd1bWVudHNbZV06e307ZSUyP2koT2JqZWN0KG4pLCEwKS5mb3JFYWNoKChmdW5jdGlvbihlKXthKHQsZSxuW2VdKX0pKTpPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycz9PYmplY3QuZGVmaW5lUHJvcGVydGllcyh0LE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG4pKTppKE9iamVjdChuKSkuZm9yRWFjaCgoZnVuY3Rpb24oZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sZSkpfSkpfXJldHVybiB0fWZ1bmN0aW9uIGEodCxlLG4pe3JldHVybihlPXkoZSkpaW4gdD9PYmplY3QuZGVmaW5lUHJvcGVydHkodCxlLHt2YWx1ZTpuLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6dFtlXT1uLHR9ZnVuY3Rpb24gdSh0LGUpe3JldHVybiBsKHQpfHxmdW5jdGlvbih0LGUpe3ZhciBuPW51bGw9PXQ/bnVsbDpcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZ0W1N5bWJvbC5pdGVyYXRvcl18fHRbXCJAQGl0ZXJhdG9yXCJdO2lmKG51bGwhPW4pe3ZhciByLGkscyxhLHU9W10sbz0hMCxoPSExO3RyeXtpZihzPShuPW4uY2FsbCh0KSkubmV4dCwwPT09ZSl7aWYoT2JqZWN0KG4pIT09bilyZXR1cm47bz0hMX1lbHNlIGZvcig7IShvPShyPXMuY2FsbChuKSkuZG9uZSkmJih1LnB1c2goci52YWx1ZSksdS5sZW5ndGghPT1lKTtvPSEwKTt9Y2F0Y2godCl7aD0hMCxpPXR9ZmluYWxseXt0cnl7aWYoIW8mJm51bGwhPW4ucmV0dXJuJiYoYT1uLnJldHVybigpLE9iamVjdChhKSE9PWEpKXJldHVybn1maW5hbGx5e2lmKGgpdGhyb3cgaX19cmV0dXJuIHV9fSh0LGUpfHxoKHQsZSl8fG8oKX1mdW5jdGlvbiBvKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKX1mdW5jdGlvbiBoKHQsZSl7aWYodCl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpcmV0dXJuIGModCxlKTt2YXIgbj1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCkuc2xpY2UoOCwtMSk7cmV0dXJuXCJPYmplY3RcIj09PW4mJnQuY29uc3RydWN0b3ImJihuPXQuY29uc3RydWN0b3IubmFtZSksXCJNYXBcIj09PW58fFwiU2V0XCI9PT1uP0FycmF5LmZyb20odCk6XCJBcmd1bWVudHNcIj09PW58fC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pP2ModCxlKTp2b2lkIDB9fWZ1bmN0aW9uIGModCxlKXsobnVsbD09ZXx8ZT50Lmxlbmd0aCkmJihlPXQubGVuZ3RoKTtmb3IodmFyIG49MCxyPW5ldyBBcnJheShlKTtuPGU7bisrKXJbbl09dFtuXTtyZXR1cm4gcn1mdW5jdGlvbiBsKHQpe2lmKEFycmF5LmlzQXJyYXkodCkpcmV0dXJuIHR9ZnVuY3Rpb24gZih0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCx5KHIua2V5KSxyKX19ZnVuY3Rpb24geShlKXt2YXIgbj1mdW5jdGlvbihlLG4pe2lmKFwib2JqZWN0XCIhPT10KGUpfHxudWxsPT09ZSlyZXR1cm4gZTt2YXIgcj1lW1N5bWJvbC50b1ByaW1pdGl2ZV07aWYodm9pZCAwIT09cil7dmFyIGk9ci5jYWxsKGUsbnx8XCJkZWZhdWx0XCIpO2lmKFwib2JqZWN0XCIhPT10KGkpKXJldHVybiBpO3Rocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKX1yZXR1cm4oXCJzdHJpbmdcIj09PW4/U3RyaW5nOk51bWJlcikoZSl9KGUsXCJzdHJpbmdcIik7cmV0dXJuXCJzeW1ib2xcIj09PXQobik/bjpTdHJpbmcobil9ZnVuY3Rpb24gZCh0LGUsbil7IWZ1bmN0aW9uKHQsZSl7aWYoZS5oYXModCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBpbml0aWFsaXplIHRoZSBzYW1lIHByaXZhdGUgZWxlbWVudHMgdHdpY2Ugb24gYW4gb2JqZWN0XCIpfSh0LGUpLGUuc2V0KHQsbil9ZnVuY3Rpb24gbSh0LGUpe3JldHVybiBmdW5jdGlvbih0LGUpe2lmKGUuZ2V0KXJldHVybiBlLmdldC5jYWxsKHQpO3JldHVybiBlLnZhbHVlfSh0LGcodCxlLFwiZ2V0XCIpKX1mdW5jdGlvbiB2KHQsZSxuKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4pe2lmKGUuc2V0KWUuc2V0LmNhbGwodCxuKTtlbHNle2lmKCFlLndyaXRhYmxlKXRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gc2V0IHJlYWQgb25seSBwcml2YXRlIGZpZWxkXCIpO2UudmFsdWU9bn19KHQsZyh0LGUsXCJzZXRcIiksbiksbn1mdW5jdGlvbiBnKHQsZSxuKXtpZighZS5oYXModCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBcIituK1wiIHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO3JldHVybiBlLmdldCh0KX12YXIgaz17bmFtZTpcImdyZWdvcmlhbl9lblwiLG1vbnRoczpbW1wiSmFudWFyeVwiLFwiSmFuXCJdLFtcIkZlYnJ1YXJ5XCIsXCJGZWJcIl0sW1wiTWFyY2hcIixcIk1hclwiXSxbXCJBcHJpbFwiLFwiQXByXCJdLFtcIk1heVwiLFwiTWF5XCJdLFtcIkp1bmVcIixcIkp1blwiXSxbXCJKdWx5XCIsXCJKdWxcIl0sW1wiQXVndXN0XCIsXCJBdWdcIl0sW1wiU2VwdGVtYmVyXCIsXCJTZXBcIl0sW1wiT2N0b2JlclwiLFwiT2N0XCJdLFtcIk5vdmVtYmVyXCIsXCJOb3ZcIl0sW1wiRGVjZW1iZXJcIixcIkRlY1wiXV0sd2Vla0RheXM6W1tcIlNhdHVyZGF5XCIsXCJTYXRcIl0sW1wiU3VuZGF5XCIsXCJTdW5cIl0sW1wiTW9uZGF5XCIsXCJNb25cIl0sW1wiVHVlc2RheVwiLFwiVHVlXCJdLFtcIldlZG5lc2RheVwiLFwiV2VkXCJdLFtcIlRodXJzZGF5XCIsXCJUaHVcIl0sW1wiRnJpZGF5XCIsXCJGcmlcIl1dLGRpZ2l0czpbXCIwXCIsXCIxXCIsXCIyXCIsXCIzXCIsXCI0XCIsXCI1XCIsXCI2XCIsXCI3XCIsXCI4XCIsXCI5XCJdLG1lcmlkaWVtczpbW1wiQU1cIixcImFtXCJdLFtcIlBNXCIsXCJwbVwiXV19LHA9e25hbWU6XCJncmVnb3JpYW5cIixzdGFydFllYXI6MSx5ZWFyTGVuZ3RoOjM2NSxlcG9jaDoxNzIxNDI0LGNlbnR1cnk6MjAsd2Vla1N0YXJ0RGF5SW5kZXg6MSxnZXRNb250aExlbmd0aHM6ZnVuY3Rpb24odCl7cmV0dXJuWzMxLHQ/Mjk6MjgsMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdfSxpc0xlYXA6ZnVuY3Rpb24odCl7cmV0dXJuIHQlND09MCYmdCUxMDAhPTB8fHQlNDAwPT0wfSxnZXRMZWFwczpmdW5jdGlvbih0KXtpZigwIT09dCl7Zm9yKHZhciBlPXQ+MD8xOi0xLG49W107dD4wP2U8PXQ6dDw9ZTspdGhpcy5pc0xlYXAoZSkmJm4ucHVzaChlKSx0PjA/ZSsrOmUtLTtyZXR1cm4gbn19LGdldERheU9mWWVhcjpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC55ZWFyLG49dC5tb250aCxyPXQuZGF5LGk9dGhpcy5nZXRNb250aExlbmd0aHModGhpcy5pc0xlYXAoZSkpLHM9MDtzPG4uaW5kZXg7cysrKXIrPWlbc107cmV0dXJuIHJ9LGdldEFsbERheXM6ZnVuY3Rpb24odCl7dmFyIGU9dC55ZWFyO3JldHVybiB0aGlzLnllYXJMZW5ndGgqKGUtMSkrdGhpcy5sZWFwc0xlbmd0aChlKSt0aGlzLmdldERheU9mWWVhcih0KX0sbGVhcHNMZW5ndGg6ZnVuY3Rpb24odCl7cmV0dXJuKCh0LTEpLzR8MCkrKC0odC0xKS8xMDB8MCkrKCh0LTEpLzQwMHwwKX0sZ3Vlc3NZZWFyOmZ1bmN0aW9uKHQsZSl7cmV0dXJufn4odC8zNjUuMjQpKyhlPjA/MTotMSl9fTtmdW5jdGlvbiBiKHQpe3JldHVybiB0JiZ0LmNvbnN0cnVjdG9yPT09T2JqZWN0fWZ1bmN0aW9uIHcodCl7aWYoIWlzTmFOKHQpKXJldHVybiBwYXJzZUludCh0KX1mdW5jdGlvbiBEKHQpe3JldHVybiBBcnJheS5pc0FycmF5KHQpfWZ1bmN0aW9uIE0odCxlLG4pe3JldHVybiB2b2lkIDA9PT10fHx0PGV8fHQ+bn12YXIgTz1uZXcgV2Vha01hcCxTPW5ldyBXZWFrTWFwLFk9bmV3IFdlYWtNYXAsTD1uZXcgV2Vha01hcCxXPW5ldyBXZWFrTWFwLHg9bmV3IFdlYWtNYXAsaj1uZXcgV2Vha01hcCxOPW5ldyBXZWFrTWFwLEE9bmV3IFdlYWtNYXAsST1uZXcgV2Vha01hcCxUPW5ldyBXZWFrTWFwLEY9bmV3IFdlYWtNYXAsRT1uZXcgV2Vha01hcCxQPW5ldyBXZWFrTWFwLEg9bmV3IFdlYWtNYXAsVj1uZXcgV2Vha01hcCxKPW5ldyBXZWFrTWFwLEM9bmV3IFdlYWtNYXAsVT1uZXcgV2Vha01hcCxSPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gaSh0KXt2YXIgZT10aGlzOyFmdW5jdGlvbih0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsaSksZCh0aGlzLE8se3dyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLGQodGhpcyxTLHt3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxkKHRoaXMsWSx7d3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksZCh0aGlzLEwse3dyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLGQodGhpcyxXLHt3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxkKHRoaXMseCx7d3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksZCh0aGlzLGose3dyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLGQodGhpcyxOLHt3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxkKHRoaXMsQSx7d3JpdGFibGU6ITAsdmFsdWU6a30pLGQodGhpcyxJLHt3cml0YWJsZTohMCx2YWx1ZTpwfSksZCh0aGlzLFQse3dyaXRhYmxlOiEwLHZhbHVlOiExfSksZCh0aGlzLEYse3dyaXRhYmxlOiEwLHZhbHVlOnt9fSksZCh0aGlzLEUse3dyaXRhYmxlOiEwLHZhbHVlOi9eXFxkezR9LVxcZFxcZC1cXGRcXGRUXFxkXFxkOlxcZFxcZDpcXGRcXGRcXC5cXGRcXGRcXGRaJC99KSxkKHRoaXMsUCx7d3JpdGFibGU6ITAsdmFsdWU6W119KSxkKHRoaXMsSCx7d3JpdGFibGU6ITAsdmFsdWU6ITB9KSxkKHRoaXMsVix7d3JpdGFibGU6ITAsdmFsdWU6ZnVuY3Rpb24odCxuKXtzd2l0Y2godCl7Y2FzZVwiWVlZWVwiOnJldHVybltcInllYXJcIixuXTtjYXNlXCJZWVwiOnJldHVybltcInllYXJcIixcIlwiLmNvbmNhdChtKGUsSSkuY2VudHVyeSkuY29uY2F0KG4pXTtjYXNlXCJNTU1NXCI6Y2FzZVwiTU1NXCI6cmV0dXJuW1wibW9udGhcIixlLm1vbnRocy5maW5kSW5kZXgoKGZ1bmN0aW9uKHQpe3ZhciBlPXQubmFtZSxyPXQuc2hvcnROYW1lO3JldHVybiBuZXcgUmVnRXhwKG4sXCJpXCIpLnRlc3QoZStyKX0pKSsxXTtjYXNlXCJNTVwiOmNhc2VcIk1cIjpyZXR1cm5bXCJtb250aFwiLG5dO2Nhc2VcIkREXCI6Y2FzZVwiRFwiOnJldHVybltcImRheVwiLG5dO2Nhc2VcIkhIXCI6Y2FzZVwiSFwiOnJldHVybltcImhvdXJcIixuXTtjYXNlXCJoaFwiOmNhc2VcImhcIjp2YXIgcj13KG4pO3JldHVybltcImhvdXJcIixyPjEyP3ItMTI6cl07Y2FzZVwibW1cIjpjYXNlXCJtXCI6cmV0dXJuW1wibWludXRlXCIsbl07Y2FzZVwic3NcIjpjYXNlXCJzXCI6cmV0dXJuW1wic2Vjb25kXCIsbl07Y2FzZVwiU1NTXCI6Y2FzZVwiU1NcIjpjYXNlXCJTXCI6cmV0dXJuW1wibWlsbGlzZWNvbmRcIixuXTtkZWZhdWx0OnJldHVybltdfX19KSxkKHRoaXMsSix7d3JpdGFibGU6ITAsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gMD09PW0oZSxPKSYmMCE9PW0oZSxJKS5zdGFydFllYXJ9fSksZCh0aGlzLEMse3dyaXRhYmxlOiEwLHZhbHVlOmZ1bmN0aW9uKCl7aWYobShlLEgpJiZlLmlzVmFsaWQpe3ZhciB0PU1hdGguZmxvb3Isbj1mdW5jdGlvbihlLG4pe3JldHVyblsocz1lLChzPDA/LTE6MSkqTWF0aC5hYnModChlL24pKSksKHI9ZSxpPW4sKHI8MCYmLTAhPT10KHIlaSk/aTowKSt0KGUlbikpXTt2YXIgcixpLHN9LHI9ZnVuY3Rpb24oKXtpZihtKGUsUyk8MHx8bShlLFMpPjExKXt2YXIgdD1tKGUsUyk8MD8tMToxLHI9dShuKG0oZSxTKSwxMiksMiksaT1yWzBdLHM9clsxXTt2KGUsTyxtKGUsTykraSksdihlLFMscyksbShlLEopLmNhbGwoZSkmJnYoZSxPLHQpfX07Zm9yKHYoZSxILCExKSxbW1wibWlsbGlzZWNvbmRcIixcInNlY29uZFwiLDFlM10sW1wic2Vjb25kXCIsXCJtaW51dGVcIiw2MF0sW1wibWludXRlXCIsXCJob3VyXCIsNjBdLFtcImhvdXJcIixcImRheVwiLDI0XV0uZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIHI9dSh0LDMpLGk9clswXSxzPXJbMV0sYT1yWzJdO2lmKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQ+PWV8fHQ8MH0oZVtpXSxhKSl7dmFyIG89dShuKGVbaV0sYSksMiksaD1vWzBdLGM9b1sxXTtlW3NdKz1oLGVbaV09Y319KSksdihlLEgsITApLHIoKTttKGUsWSk8LW0oZSxJKS55ZWFyTGVuZ3RofHxtKGUsWSk+bShlLEkpLnllYXJMZW5ndGg7KXtpZihtKGUsUyk+MCl7Zm9yKHZhciBpPW0oZSxJKS5nZXRNb250aExlbmd0aHMoZS5pc0xlYXApLHM9MDtzPG0oZSxTKTtzKyspdihlLFksbShlLFkpK2lbc10pO3YoZSxTLDApfXZhciBhPWUuaXNMZWFwP2UuY2FsZW5kYXIueWVhckxlbmd0aCsxOmUuY2FsZW5kYXIueWVhckxlbmd0aDt2KGUsWSxtKGUsWSkrYSoobShlLFkpPDA/MTotMSkpLHYoZSxPLG0oZSxPKSsobShlLFkpPDA/LTE6MSkpfWZvcig7Oyl7dmFyIG87Zm9yKHIoKTttKGUsWSk8MTspdihlLFMsbShlLFMpLTEpLHIoKSx2KGUsWSxlLm1vbnRoLmxlbmd0aCttKGUsWSkpO2lmKG0oZSxZKTw9ZS5tb250aC5sZW5ndGh8fGlzTmFOKG0oZSxZKSkpYnJlYWs7dihlLFksbShlLFkpLWUubW9udGgubGVuZ3RoKSx2KGUsUywobz1tKGUsUyksbysrLG8pKX1tKGUsTCl8fHYoZSxMLDApLG0oZSxXKXx8dihlLFcsMCksbShlLHgpfHx2KGUseCwwKSxtKGUsail8fHYoZSxqLDApfX19KSxkKHRoaXMsVSx7d3JpdGFibGU6ITAsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4obShlLEYpLndlZWtEYXlzfHxtKGUsQSkud2Vla0RheXMpLm1hcCgoZnVuY3Rpb24odCxuKXt2YXIgcj11KHQsMiksaT1yWzBdLHM9clsxXSxhPW4tZS53ZWVrU3RhcnREYXlJbmRleDtyZXR1cm4gYTwwJiYoYSs9Nykse25hbWU6aSxzaG9ydE5hbWU6cyxpbmRleDphLG51bWJlcjphKzEsdG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5udW1iZXIudG9TdHJpbmcoKX0sdmFsdWVPZjpmdW5jdGlvbigpe3JldHVybiB0aGlzLm51bWJlcn19fSkpfX0pO3ZhciBuPWIodCk/cyh7fSx0KTp0LHI9ITA7aWYobiYmXCJib29sZWFuXCIhPXR5cGVvZiBufHwobj17ZGF0ZTpuZXcgRGF0ZX0pLGIobil8fChuPXtkYXRlOm59KSwwIT09T2JqZWN0LmtleXMobikubGVuZ3RoKXtmb3IodmFyIGEgaW4gYihuLmNhbGVuZGFyKSYmdih0aGlzLEksbi5jYWxlbmRhciksYihuLmxvY2FsZSkmJnYodGhpcyxBLG4ubG9jYWxlKSxpc05hTihuLnllYXIpJiZpc05hTihuLm1vbnRoKSYmaXNOYU4obi5kYXkpJiYhbi5kYXRlJiYobi5kYXRlPW5ldyBEYXRlKSxuLmRhdGUmJihcInN0cmluZ1wiPT10eXBlb2Ygbi5kYXRlJiZuLmZvcm1hdCYmdih0aGlzLE4sbi5mb3JtYXQpLHRoaXMuc2V0RGF0ZShuLmRhdGUpLG4uY2FsZW5kYXImJnRoaXMuY29udmVydChuLmNhbGVuZGFyKSxyPSExKSxkZWxldGUgbi5jYWxlbmRhcixkZWxldGUgbi5sb2NhbGUsZGVsZXRlIG4uZGF0ZSxuKXRoaXMuc2V0KGEsblthXSk7bSh0aGlzLEopLmNhbGwodGhpcykmJnYodGhpcyxPLC0xKSxyJiZtKHRoaXMsQykuY2FsbCh0aGlzKX19dmFyIGEsYyx5O3JldHVybiBhPWksKGM9W3trZXk6XCJwYXJzZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe2lmKCF0KXJldHVybiB0aGlzO3ZhciBpLHMsYT1tKHRoaXMsTiksYz1tKHRoaXMsQSkuZGlnaXRzLGY9cihjKTt0cnl7Zm9yKGYucygpOyEoaT1mLm4oKSkuZG9uZTspe3ZhciB5PWkudmFsdWU7dD10LnJlcGxhY2UobmV3IFJlZ0V4cCh5LFwiZ1wiKSxjLmluZGV4T2YoeSkpfX1jYXRjaCh0KXtmLmUodCl9ZmluYWxseXtmLmYoKX1pZihhKWZvcih2YXIgZD1hLnNwbGl0KC9bXlxcd1xcdTA2MDAtXFx1MDZGRl0vKSxnPXQuc3BsaXQoL1teXFx3XFx1MDYwMC1cXHUwNkZGXS8pLGs9MDtrPGQubGVuZ3RoO2srKyl0aGlzLnNldC5hcHBseSh0aGlzLGUobSh0aGlzLFYpLmNhbGwodGhpcyxkW2tdLGdba10pKSk7ZWxzZXt2YXIgcD10Lm1hdGNoKC8oLT9cXGR7Miw0fSk/XFxXPyhbQS16XXszLDl9fFxcZHsxLDJ9KT9cXFc/KFxcZHsxLDJ9KT9cXFc/KFxcZHsxLDJ9KT9cXFc/KFxcZHsxLDJ9KT9cXFc/KFxcZHsxLDJ9KT9cXFc/KFxcZHsxLDN9KT9cXFc/KGFtfHBtKT8vKSxiPShsKHM9cCl8fG4ocyl8fGgocyl8fG8oKSkuc2xpY2UoMSksRD1iWzFdO0QmJihEPS9cXGQrLy50ZXN0KEQpP3coRCktMTp0aGlzLm1vbnRocy5maW5kSW5kZXgoKGZ1bmN0aW9uKHQpe3JldHVybiBuZXcgUmVnRXhwKEQsXCJpXCIpLnRlc3QodC5uYW1lKX0pKSksYlsxXT1EO3ZhciBNPXUoYi5tYXAodyksNyksST1NWzBdLFQ9TVsxXSxGPU1bMl0sRT1NWzNdLFA9TVs0XSxIPU1bNV0sSj1NWzZdO3YodGhpcyxPLEkpLHYodGhpcyxTLFQpLHYodGhpcyxZLEYpLHYodGhpcyxMLEUpLHYodGhpcyxXLFApLHYodGhpcyx4LEgpLHYodGhpcyxqLEopfXZhciBVPXUobSh0aGlzLEEpLm1lcmlkaWVtc1sxXSwyKSxSPVVbMF0sXz1VWzFdO3JldHVybiBtKHRoaXMsTCk8MTImJih0LmluY2x1ZGVzKFIpfHx0LmluY2x1ZGVzKF8pKSYmdih0aGlzLEwsbSh0aGlzLEwpKzEyKSxtKHRoaXMsQykuY2FsbCh0aGlzKSx0aGlzfX0se2tleTpcImNvbnZlcnRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTpwLGU9YXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDA7aWYoYihlKSYmdih0aGlzLEEsZSksIWIodCl8fHQubmFtZT09PW0odGhpcyxJKS5uYW1lKXJldHVybiB0aGlzO3ZhciBuPXRoaXMudG9KdWxpYW5EYXkoKS10LmVwb2NoLHI9bmV3IGkoe2NhbGVuZGFyOnQseWVhcjp0Lmd1ZXNzWWVhcihuLG0odGhpcyxPKSksbW9udGg6MSxkYXk6MX0pO3JldHVybiByLmRheSs9bi1yLnRvRGF5cygpLHYodGhpcyxPLHIueWVhciksdih0aGlzLFMsci5tb250aC5pbmRleCksdih0aGlzLFksci5kYXkpLHYodGhpcyxJLHQpLHRoaXN9fSx7a2V5OlwiZm9ybWF0XCIsdmFsdWU6ZnVuY3Rpb24oZSxuKXtpZighdGhpcy5pc1ZhbGlkfHxlJiZcInN0cmluZ1wiIT10eXBlb2YgZSlyZXR1cm5cIlwiO2V8fChlPW0odGhpcyxOKXx8XCJZWVlZL01NL0REXCIpLEQobil8fChuPVtdKSxuPShuPW4uY29uY2F0KG0odGhpcyxQKSkpLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGV8fChjb25zb2xlLndhcm4oXCJ0eXBlIG9mIGFsbCBpdGVtcyBpbiB0aGUgaWdub3JlIGxpc3QgbXVzdCBiZSBzdHJpbmcsIGZvdW5kXCIsdChlKSksITEpfSkpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQucmVwbGFjZSgvWyovK1xcLSgpW1xcXXt9XFxzJF5dL2csKGZ1bmN0aW9uKHQpe3JldHVyblwiXFxcXFwiK3R9KSl9KSk7dmFyIGkscz1uZXcgUmVnRXhwKFwiXCIuY29uY2F0KG4uam9pbihcInxcIikpLmNvbmNhdChuLmxlbmd0aD4wP1wifFwiOlwiXCIsXCJZWVlZfFlZfE1NTU18TU1NfE1NfE18V1d8V3xEREREfERERHxERHxEfGRkZGR8ZGRkfGRkfGR8SEh8SHxoaHxofG1tfG18c3N8c3xTU1N8U1N8U3xBfGF8LlwiKSxcImdcIiksYT1cIlwiLHU9cihlLm1hdGNoKHMpfHxbXSk7dHJ5e2Zvcih1LnMoKTshKGk9dS5uKCkpLmRvbmU7KXt2YXIgbz1pLnZhbHVlLGg9dGhpcy5nZXRWYWx1ZShvKTthKz1uLmluY2x1ZGVzKG8pP286MD09PWg/aDpofHxvfX1jYXRjaCh0KXt1LmUodCl9ZmluYWxseXt1LmYoKX12YXIgYz10aGlzLmRpZ2l0cztyZXR1cm4gYS5yZXBsYWNlKC9bMC05XS9nLChmdW5jdGlvbih0KXtyZXR1cm4gY1t0XX0pKX19LHtrZXk6XCJnZXRQcm9wZXJ0eVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmdldFZhbHVlKHQpfX0se2tleTpcImdldFZhbHVlXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24odCl7cmV0dXJuIHQ8MTA/XCIwXCIrdDp0fTtzd2l0Y2godCl7Y2FzZVwiWVlZWVwiOnJldHVybiB0aGlzLnllYXI7Y2FzZVwiWVlcIjpyZXR1cm4gdGhpcy55ZWFyLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIsNCk7Y2FzZVwiTU1NTVwiOnJldHVybiB0aGlzLm1vbnRoLm5hbWU7Y2FzZVwiTU1NXCI6cmV0dXJuIHRoaXMubW9udGguc2hvcnROYW1lO2Nhc2VcIk1NXCI6cmV0dXJuIGUodGhpcy5tb250aC5udW1iZXIpO2Nhc2VcIk1cIjpyZXR1cm4gdGhpcy5tb250aC5udW1iZXI7Y2FzZVwiV1dcIjpyZXR1cm4gZSh0aGlzLndlZWtPZlllYXIpO2Nhc2VcIldcIjpyZXR1cm4gdGhpcy53ZWVrT2ZZZWFyO2Nhc2VcIkRERERcIjpjYXNlXCJERERcIjpyZXR1cm4gdGhpcy5kYXlPZlllYXI7Y2FzZVwiRERcIjpyZXR1cm4gZSh0aGlzLmRheSk7Y2FzZVwiRFwiOnJldHVybiB0aGlzLmRheTtjYXNlXCJISFwiOnJldHVybiBlKHRoaXMuaG91cik7Y2FzZVwiSFwiOnJldHVybiB0aGlzLmhvdXI7Y2FzZVwiZGRkZFwiOnJldHVybiB0aGlzLndlZWtEYXkubmFtZTtjYXNlXCJkZGRcIjpyZXR1cm4gdGhpcy53ZWVrRGF5LnNob3J0TmFtZTtjYXNlXCJkZFwiOnJldHVybiBlKHRoaXMud2Vla0RheS5udW1iZXIpO2Nhc2VcImRcIjpyZXR1cm4gdGhpcy53ZWVrRGF5Lm51bWJlcjtjYXNlXCJoaFwiOnJldHVybiBlKHRoaXMuaG91cj4xMj90aGlzLmhvdXItMTI6dGhpcy5ob3VyfHwxMik7Y2FzZVwiaFwiOnJldHVybiB0aGlzLmhvdXI+MTI/dGhpcy5ob3VyLTEyOnRoaXMuaG91cnx8MTI7Y2FzZVwibW1cIjpyZXR1cm4gZSh0aGlzLm1pbnV0ZSk7Y2FzZVwibVwiOnJldHVybiB0aGlzLm1pbnV0ZTtjYXNlXCJzc1wiOnJldHVybiBlKHRoaXMuc2Vjb25kKTtjYXNlXCJzXCI6cmV0dXJuIHRoaXMuc2Vjb25kO2Nhc2VcIlNTU1wiOnJldHVybiBtKHRoaXMsaik8MTA/XCIwMFwiLmNvbmNhdChtKHRoaXMsaikpOm0odGhpcyxqKTwxMDA/XCIwXCIuY29uY2F0KG0odGhpcyxqKSk6bSh0aGlzLGopO2Nhc2VcIlNTXCI6cmV0dXJuIG0odGhpcyxqKTwxMD9cIjAwXCI6bSh0aGlzLGopPDEwMD8oXCIwXCIrbSh0aGlzLGopKS5zdWJzdHJpbmcoMiwwKTptKHRoaXMsaikudG9TdHJpbmcoKS5zdWJzdHJpbmcoMCwyKTtjYXNlXCJTXCI6cmV0dXJuIG0odGhpcyxqKTwxMHx8bSh0aGlzLGopPDEwMD9cIjBcIjptKHRoaXMsaikudG9TdHJpbmcoKS5zdWJzdHJpbmcoMCwxKTtjYXNlXCJhXCI6cmV0dXJuIHRoaXMuaG91cj49MTI/bSh0aGlzLEEpLm1lcmlkaWVtc1sxXVsxXTptKHRoaXMsQSkubWVyaWRpZW1zWzBdWzFdO2Nhc2VcIkFcIjpyZXR1cm4gdGhpcy5ob3VyPj0xMj9tKHRoaXMsQSkubWVyaWRpZW1zWzFdWzBdOm0odGhpcyxBKS5tZXJpZGllbXNbMF1bMF07ZGVmYXVsdDpyZXR1cm5cIlwifX19LHtrZXk6XCJzZXRZZWFyXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMueWVhcj10LHRoaXN9fSx7a2V5Olwic2V0TW9udGhzXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubW9udGhzPXQsdGhpc319LHtrZXk6XCJzZXRNb250aFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm1vbnRoPXQsdGhpc319LHtrZXk6XCJzZXRXZWVrRGF5c1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLndlZWtEYXlzPXQsdGhpc319LHtrZXk6XCJzZXREaWdpdHNcIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5kaWdpdHM9dCx0aGlzfX0se2tleTpcInNldERheVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmRheT10LHRoaXN9fSx7a2V5Olwic2V0SG91clwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmhvdXI9dCx0aGlzfX0se2tleTpcInNldE1pbnV0ZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm1pbnV0ZT10LHRoaXN9fSx7a2V5Olwic2V0U2Vjb25kXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuc2Vjb25kPXQsdGhpc319LHtrZXk6XCJzZXRNaWxsaXNlY29uZFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm1pbGxpc2Vjb25kPXQsdGhpc319LHtrZXk6XCJzZXRGb3JtYXRcIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gdih0aGlzLE4sdCksdGhpc319LHtrZXk6XCJzZXRMb2NhbGVcIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5sb2NhbGU9dCx0aGlzfX0se2tleTpcInNldENhbGVuZGFyXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY2FsZW5kYXI9dCx0aGlzfX0se2tleTpcInNldERhdGVcIix2YWx1ZTpmdW5jdGlvbih0KXtpZihcInN0cmluZ1wiPT10eXBlb2YgdCl7aWYoIW0odGhpcyxFKS50ZXN0KHQpKXJldHVybiB0aGlzLnBhcnNlKHQpO3Q9bmV3IERhdGUodCl9cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHQmJih0PW5ldyBEYXRlKHQpKSx0IGluc3RhbmNlb2YgRGF0ZSYmKHYodGhpcyxJLHApLHYodGhpcyxPLHQuZ2V0RnVsbFllYXIoKSksdih0aGlzLFMsdC5nZXRNb250aCgpKSx2KHRoaXMsWSx0LmdldERhdGUoKSksdih0aGlzLEwsdC5nZXRIb3VycygpKSx2KHRoaXMsVyx0LmdldE1pbnV0ZXMoKSksdih0aGlzLHgsdC5nZXRTZWNvbmRzKCkpLHYodGhpcyxqLHQuZ2V0TWlsbGlzZWNvbmRzKCkpLHYodGhpcyxULCExKSksdCBpbnN0YW5jZW9mIGkmJih2KHRoaXMsTyx0LnllYXIpLHYodGhpcyxTLHQubW9udGguaW5kZXgpLHYodGhpcyxZLHQuZGF5KSx2KHRoaXMsTCx0LmhvdXIpLHYodGhpcyxXLHQubWludXRlKSx2KHRoaXMseCx0LnNlY29uZCksdih0aGlzLGosdC5taWxsaXNlY29uZCksdih0aGlzLEEsdC5sb2NhbGUpLHYodGhpcyxOLHQuX2Zvcm1hdCksdih0aGlzLEksdC5jYWxlbmRhciksdih0aGlzLFQsdC5pc1VUQyksdih0aGlzLFAsdC5pZ25vcmVMaXN0KSx2KHRoaXMsRix0LmN1c3RvbSkpLHRoaXN9fSx7a2V5Olwic2V0SWdub3JlTGlzdFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmlnbm9yZUxpc3Q9dCx0aGlzfX0se2tleTpcInNldFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7aWYobnVsbD09dClyZXR1cm4gdGhpcztpZihiKHQpKXt2YXIgbj1zKHt9LHQpO2Zvcih2YXIgciBpbiBuLmRhdGUmJih0aGlzLnNldERhdGUobi5kYXRlKSxkZWxldGUgbi5kYXRlKSxuLmNhbGVuZGFyJiYodGhpcy5jb252ZXJ0KG4uY2FsZW5kYXIpLGRlbGV0ZSBuLmNhbGVuZGFyKSxuLmxvY2FsZSYmKHRoaXMuc2V0TG9jYWxlKG4ubG9jYWxlKSxkZWxldGUgbi5sb2NhbGUpLHYodGhpcyxILCExKSxuKXRoaXMuc2V0KHIsbltyXSk7cmV0dXJuIHYodGhpcyxILCEwKSxtKHRoaXMsQykuY2FsbCh0aGlzKSx0aGlzfVwiZm9ybWF0XCI9PT10JiYodD1cIl9mb3JtYXRcIik7dHJ5e3RoaXNbdF09ZX1jYXRjaCh0KXt9cmV0dXJuIHRoaXN9fSx7a2V5OlwiYWRkXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtpZighKHQ9dyh0KSl8fCFlKXJldHVybiB0aGlzO3N3aXRjaChlKXtjYXNlXCJ5ZWFyc1wiOmNhc2VcInlcIjplPVwieWVhclwiO2JyZWFrO2Nhc2VcIm1vbnRoc1wiOmNhc2VcIk1cIjplPVwibW9udGhcIjticmVhaztjYXNlXCJkYXlzXCI6Y2FzZVwiZFwiOmU9XCJkYXlcIjticmVhaztjYXNlXCJob3Vyc1wiOmNhc2VcImhcIjplPVwiaG91clwiO2JyZWFrO2Nhc2VcIm1pbnV0ZXNcIjpjYXNlXCJtXCI6ZT1cIm1pbnV0ZVwiO2JyZWFrO2Nhc2VcInNlY29uZHNcIjpjYXNlXCJzXCI6ZT1cInNlY29uZFwiO2JyZWFrO2Nhc2VcIm1pbGxpc2Vjb25kc1wiOmNhc2VcIm1zXCI6ZT1cIm1pbGxpc2Vjb25kXCJ9cmV0dXJuIHRoaXNbZV0rPXQsdGhpc319LHtrZXk6XCJzdWJ0cmFjdFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuYWRkKC10LGUpfX0se2tleTpcInRvRmlyc3RPZlllYXJcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1vbnRoPTEsdGhpcy5kYXk9MSx0aGlzfX0se2tleTpcInRvTGFzdE9mWWVhclwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGF5Pj0yOSYmKHRoaXMuZGF5PTI5KSx0aGlzLm1vbnRoPTEyLHRoaXMudG9MYXN0T2ZNb250aCgpLHRoaXN9fSx7a2V5OlwidG9GaXJzdE9mTW9udGhcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB2KHRoaXMsWSwxKSx0aGlzfX0se2tleTpcInRvTGFzdE9mTW9udGhcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB2KHRoaXMsWSwwKSx2KHRoaXMsUyxtKHRoaXMsUykrMSksbSh0aGlzLEMpLmNhbGwodGhpcyksdGhpc319LHtrZXk6XCJ0b0ZpcnN0T2ZXZWVrXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kYXktPXRoaXMud2Vla0RheS5pbmRleCx0aGlzfX0se2tleTpcInRvTGFzdE9mV2Vla1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGF5Kz02LXRoaXMud2Vla0RheS5pbmRleCx0aGlzfX0se2tleTpcInRvRmlyc3RXZWVrT2ZZZWFyXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50b0ZpcnN0T2ZZZWFyKCksMD09PXRoaXMud2Vla0RheS5pbmRleD90aGlzOnRoaXMudG9MYXN0T2ZXZWVrKCkuc2V0RGF5KHRoaXMuZGF5KzEpfX0se2tleTpcInRvTGFzdFdlZWtPZlllYXJcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnRvTGFzdE9mWWVhcigpLnRvRmlyc3RPZldlZWsoKX19LHtrZXk6XCJ0b1N0cmluZ1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZm9ybWF0KCl9fSx7a2V5OlwidG9EYXRlXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD1uZXcgaSh0aGlzKTtyZXR1cm5cImdyZWdvcmlhblwiIT09bSh0aGlzLEkpLm5hbWUmJnQuY29udmVydChwKSxuZXcgRGF0ZSh0LnllYXIsdC5tb250aC5pbmRleCx0LmRheSx0LmhvdXIsdC5taW51dGUsdC5zZWNvbmQsdC5taWxsaXNlY29uZCl9fSx7a2V5OlwidG9VVENcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBtKHRoaXMsVCl8fCh0aGlzLm1pbnV0ZSs9dGhpcy50b0RhdGUoKS5nZXRUaW1lem9uZU9mZnNldCgpLHYodGhpcyxULCEwKSksdGhpc319LHtrZXk6XCJ0b1VuaXhcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnVuaXh9fSx7a2V5OlwidG9KdWxpYW5EYXlcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnRvRGF5cygpK20odGhpcyxJKS5lcG9jaH19LHtrZXk6XCJ0b09iamVjdFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJue3llYXI6bSh0aGlzLE8pLG1vbnRoOnRoaXMubW9udGgsZGF5Om0odGhpcyxZKSx3ZWVrRGF5OnRoaXMud2Vla0RheSxob3VyOm0odGhpcyxMKSxtaW51dGU6bSh0aGlzLFcpLHNlY29uZDptKHRoaXMseCksbWlsbGlzZWNvbmQ6bSh0aGlzLGopLHdlZWtPZlllYXI6dGhpcy53ZWVrT2ZZZWFyLGRheU9mWWVhcjp0aGlzLmRheU9mWWVhcixkYXlzTGVmdDp0aGlzLmRheXNMZWZ0LGNhbGVuZGFyOm0odGhpcyxJKSxsb2NhbGU6bSh0aGlzLEEpLGZvcm1hdDptKHRoaXMsTil8fFwiWVlZWS9NTS9ERFwiLGlnbm9yZUxpc3Q6bSh0aGlzLFApfX19LHtrZXk6XCJ0b0pTT05cIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbHVlT2YoKX19LHtrZXk6XCJ2YWx1ZU9mXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50b0RhdGUoKS52YWx1ZU9mKCl9fSx7a2V5OlwidG9EYXlzXCIsdmFsdWU6ZnVuY3Rpb24oKXtpZih0aGlzLmlzVmFsaWQpcmV0dXJuIG0odGhpcyxJKS5nZXRBbGxEYXlzKHRoaXMpfX0se2tleTpcImRheU9mQmVnaW5uaW5nXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudG9EYXlzKCl9fSx7a2V5OlwiZGF5T2ZZZWFyXCIsZ2V0OmZ1bmN0aW9uKCl7aWYodGhpcy5pc1ZhbGlkKXJldHVybiBtKHRoaXMsSSkuZ2V0RGF5T2ZZZWFyKHRoaXMpfX0se2tleTpcIndlZWtPZlllYXJcIixnZXQ6ZnVuY3Rpb24oKXtpZih0aGlzLmlzVmFsaWQpcmV0dXJuIDErfn4odGhpcy5kYXlPZlllYXIvNyl9fSx7a2V5OlwiZGF5c0xlZnRcIixnZXQ6ZnVuY3Rpb24oKXtpZih0aGlzLmlzVmFsaWQpe3ZhciB0PW0odGhpcyxJKS55ZWFyTGVuZ3RoO3JldHVybih0aGlzLmlzTGVhcD90KzE6dCktdGhpcy5kYXlPZlllYXJ9fX0se2tleTpcInllYXJcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbSh0aGlzLE8pfSxzZXQ6ZnVuY3Rpb24odCl7dih0aGlzLE8sdyh0KSksbSh0aGlzLEMpLmNhbGwodGhpcyl9fSx7a2V5OlwibW9udGhcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tb250aHNbbSh0aGlzLFMpXXx8e319LHNldDpmdW5jdGlvbih0KXt2YXIgZTt0PW51bGwhPT0oZT13KHQudmFsdWVPZigpKS0xKSYmdm9pZCAwIT09ZT9lOnZvaWQgMCx2KHRoaXMsUyx0KSxNKHQsMCwxMSkmJm0odGhpcyxDKS5jYWxsKHRoaXMpfX0se2tleTpcIm1vbnRoSW5kZXhcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbSh0aGlzLFMpfX0se2tleTpcImRheVwiLGdldDpmdW5jdGlvbigpe3JldHVybiBtKHRoaXMsWSl9LHNldDpmdW5jdGlvbih0KXt0PXcodCksdih0aGlzLFksdCksTSh0LDEsMjgpJiZtKHRoaXMsQykuY2FsbCh0aGlzKX19LHtrZXk6XCJ3ZWVrRGF5XCIsZ2V0OmZ1bmN0aW9uKCl7aWYoIXRoaXMuaXNWYWxpZClyZXR1cm57fTt2YXIgdD0odGhpcy50b0p1bGlhbkRheSgpKzMpJTc7cmV0dXJuIG0odGhpcyxVKS5jYWxsKHRoaXMpW3RdfX0se2tleTpcImhvdXJcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbSh0aGlzLEwpfSxzZXQ6ZnVuY3Rpb24odCl7dD13KHQpLHYodGhpcyxMLHQpLE0odCwwLDIzKSYmbSh0aGlzLEMpLmNhbGwodGhpcyl9fSx7a2V5OlwibWludXRlXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG0odGhpcyxXKX0sc2V0OmZ1bmN0aW9uKHQpe3Q9dyh0KSx2KHRoaXMsVyx0KSxNKHQsMCw1OSkmJm0odGhpcyxDKS5jYWxsKHRoaXMpfX0se2tleTpcInNlY29uZFwiLGdldDpmdW5jdGlvbigpe3JldHVybiBtKHRoaXMseCl9LHNldDpmdW5jdGlvbih0KXt0PXcodCksdih0aGlzLHgsdCksTSh0LDAsNTkpJiZtKHRoaXMsQykuY2FsbCh0aGlzKX19LHtrZXk6XCJtaWxsaXNlY29uZFwiLGdldDpmdW5jdGlvbigpe3JldHVybiBtKHRoaXMsail9LHNldDpmdW5jdGlvbih0KXt0PXcodCksdih0aGlzLGosdCksTSh0LDAsOTk5KSYmbSh0aGlzLEMpLmNhbGwodGhpcyl9fSx7a2V5OlwibW9udGhzXCIsZ2V0OmZ1bmN0aW9uKCl7dmFyIHQ9bSh0aGlzLEkpLmdldE1vbnRoTGVuZ3Rocyh0aGlzLmlzTGVhcCk7cmV0dXJuKG0odGhpcyxGKS5tb250aHN8fG0odGhpcyxBKS5tb250aHMpLm1hcCgoZnVuY3Rpb24oZSxuKXt2YXIgcj11KGUsMik7cmV0dXJue25hbWU6clswXSxzaG9ydE5hbWU6clsxXSxsZW5ndGg6dFtuXSxpbmRleDpuLG51bWJlcjpuKzEsdG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5udW1iZXIudG9TdHJpbmcoKX0sdmFsdWVPZjpmdW5jdGlvbigpe3JldHVybiB0aGlzLm51bWJlcn19fSkpfSxzZXQ6ZnVuY3Rpb24odCl7aWYoIXQpcmV0dXJuIGRlbGV0ZSBtKHRoaXMsRikubW9udGhzO0QodCkmJjEyPT09dC5sZW5ndGgmJnQuZXZlcnkoKGZ1bmN0aW9uKHQpe3JldHVybiBEKHQpJiYyPT09dC5sZW5ndGgmJnQuZXZlcnkoKGZ1bmN0aW9uKHQpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiB0fSkpfSkpJiYobSh0aGlzLEYpLm1vbnRocz10KX19LHtrZXk6XCJ3ZWVrRGF5c1wiLGdldDpmdW5jdGlvbigpe3JldHVybiBtKHRoaXMsVSkuY2FsbCh0aGlzKS5zb3J0KChmdW5jdGlvbih0LGUpe3JldHVybiB0LmluZGV4LWUuaW5kZXh9KSl9LHNldDpmdW5jdGlvbih0KXtpZighdClyZXR1cm4gZGVsZXRlIG0odGhpcyxGKS53ZWVrRGF5cztEKHQpJiY3PT09dC5sZW5ndGgmJnQuZXZlcnkoKGZ1bmN0aW9uKHQpe3JldHVybiBEKHQpJiYyPT09dC5sZW5ndGgmJnQuZXZlcnkoKGZ1bmN0aW9uKHQpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiB0fSkpfSkpJiYobSh0aGlzLEYpLndlZWtEYXlzPXQpfX0se2tleTpcImxlYXBzXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG0odGhpcyxJKS5nZXRMZWFwcyhtKHRoaXMsTykpfX0se2tleTpcImNhbGVuZGFyXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG0odGhpcyxJKX0sc2V0OmZ1bmN0aW9uKHQpe3RoaXMuY29udmVydCh0KX19LHtrZXk6XCJsb2NhbGVcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbSh0aGlzLEEpfSxzZXQ6ZnVuY3Rpb24oKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06aztiKHQpJiZ2KHRoaXMsQSx0KX19LHtrZXk6XCJjdXN0b21cIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbSh0aGlzLEYpfX0se2tleTpcIm1lcmlkaWVtc1wiLGdldDpmdW5jdGlvbigpe3JldHVybiBtKHRoaXMsQSkubWVyaWRpZW1zfX0se2tleTpcImRpZ2l0c1wiLGdldDpmdW5jdGlvbigpe3JldHVybiBtKHRoaXMsRikuZGlnaXRzfHxtKHRoaXMsQSkuZGlnaXRzfSxzZXQ6ZnVuY3Rpb24odCl7aWYoIXQpcmV0dXJuIGRlbGV0ZSBtKHRoaXMsRikuZGlnaXRzO0QodCkmJjEwPT09dC5sZW5ndGgmJihtKHRoaXMsRikuZGlnaXRzPXQpfX0se2tleTpcIl9mb3JtYXRcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbSh0aGlzLE4pfSxzZXQ6ZnVuY3Rpb24odCl7XCJzdHJpbmdcIj09dHlwZW9mIHQmJnYodGhpcyxOLHQpfX0se2tleTpcImlzTGVhcFwiLGdldDpmdW5jdGlvbigpe3JldHVybiBtKHRoaXMsSSkuaXNMZWFwKG0odGhpcyxPKSl9fSx7a2V5OlwiaXNWYWxpZFwiLGdldDpmdW5jdGlvbigpe3JldHVybiFpc05hTihtKHRoaXMsTykpJiYhaXNOYU4obSh0aGlzLFMpKSYmIWlzTmFOKG0odGhpcyxZKSl9fSx7a2V5OlwiaXNVVENcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbSh0aGlzLFQpfX0se2tleTpcInVuaXhcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4odGhpcy52YWx1ZU9mKCktdGhpcy5taWxsaXNlY29uZCkvMWUzfX0se2tleTpcImlnbm9yZUxpc3RcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbSh0aGlzLFApfSxzZXQ6ZnVuY3Rpb24odCl7RCh0KSYmdih0aGlzLFAsdCl9fSx7a2V5Olwid2Vla1N0YXJ0RGF5SW5kZXhcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbSh0aGlzLEkpLndlZWtTdGFydERheUluZGV4fSxzZXQ6ZnVuY3Rpb24odCl7dm9pZCAwIT09KHQ9dyh0KSkmJihtKHRoaXMsSSkud2Vla1N0YXJ0RGF5SW5kZXg9TWF0aC5hYnModCklNyl9fSx7a2V5OlwiZGF0ZVwiLHNldDpmdW5jdGlvbih0KXt0aGlzLnNldERhdGUodCl9fV0pJiZmKGEucHJvdG90eXBlLGMpLHkmJmYoYSx5KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxcInByb3RvdHlwZVwiLHt3cml0YWJsZTohMX0pLGl9KCk7ZXhwb3J0e1IgYXMgZGVmYXVsdH07XG4iXSwibmFtZXMiOlsidCIsImUiLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiQXJyYXkiLCJpc0FycmF5IiwiYyIsIm4iLCJoIiwiVHlwZUVycm9yIiwiZnJvbSIsInIiLCJsZW5ndGgiLCJpIiwicyIsImRvbmUiLCJ2YWx1ZSIsImYiLCJhIiwidSIsImNhbGwiLCJuZXh0IiwicmV0dXJuIiwiT2JqZWN0Iiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJwdXNoIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJmb3JFYWNoIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJkZWZpbmVQcm9wZXJ0eSIsInkiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImwiLCJvIiwidG9TdHJpbmciLCJzbGljZSIsIm5hbWUiLCJ0ZXN0Iiwia2V5IiwidG9QcmltaXRpdmUiLCJTdHJpbmciLCJOdW1iZXIiLCJkIiwiaGFzIiwic2V0IiwibSIsImdldCIsImciLCJ2IiwiayIsIm1vbnRocyIsIndlZWtEYXlzIiwiZGlnaXRzIiwibWVyaWRpZW1zIiwicCIsInN0YXJ0WWVhciIsInllYXJMZW5ndGgiLCJlcG9jaCIsImNlbnR1cnkiLCJ3ZWVrU3RhcnREYXlJbmRleCIsImdldE1vbnRoTGVuZ3RocyIsImlzTGVhcCIsImdldExlYXBzIiwiZ2V0RGF5T2ZZZWFyIiwieWVhciIsIm1vbnRoIiwiZGF5IiwiaW5kZXgiLCJnZXRBbGxEYXlzIiwibGVhcHNMZW5ndGgiLCJndWVzc1llYXIiLCJiIiwidyIsImlzTmFOIiwicGFyc2VJbnQiLCJEIiwiTSIsIk8iLCJXZWFrTWFwIiwiUyIsIlkiLCJMIiwiVyIsIngiLCJqIiwiTiIsIkEiLCJJIiwiVCIsIkYiLCJFIiwiUCIsIkgiLCJWIiwiSiIsIkMiLCJVIiwiUiIsImNvbmNhdCIsImZpbmRJbmRleCIsInNob3J0TmFtZSIsIlJlZ0V4cCIsImlzVmFsaWQiLCJNYXRoIiwiZmxvb3IiLCJhYnMiLCJjYWxlbmRhciIsIm1hcCIsIm51bWJlciIsInZhbHVlT2YiLCJkYXRlIiwiRGF0ZSIsImxvY2FsZSIsImZvcm1hdCIsInNldERhdGUiLCJjb252ZXJ0IiwicmVwbGFjZSIsImluZGV4T2YiLCJzcGxpdCIsIm1hdGNoIiwiXyIsImluY2x1ZGVzIiwidG9KdWxpYW5EYXkiLCJ0b0RheXMiLCJjb25zb2xlIiwid2FybiIsImpvaW4iLCJnZXRWYWx1ZSIsInN1YnN0cmluZyIsIndlZWtPZlllYXIiLCJkYXlPZlllYXIiLCJob3VyIiwid2Vla0RheSIsIm1pbnV0ZSIsInNlY29uZCIsIm1pbGxpc2Vjb25kIiwicGFyc2UiLCJnZXRGdWxsWWVhciIsImdldE1vbnRoIiwiZ2V0RGF0ZSIsImdldEhvdXJzIiwiZ2V0TWludXRlcyIsImdldFNlY29uZHMiLCJnZXRNaWxsaXNlY29uZHMiLCJfZm9ybWF0IiwiaXNVVEMiLCJpZ25vcmVMaXN0IiwiY3VzdG9tIiwic2V0TG9jYWxlIiwiYWRkIiwidG9MYXN0T2ZNb250aCIsInRvRmlyc3RPZlllYXIiLCJ0b0xhc3RPZldlZWsiLCJzZXREYXkiLCJ0b0xhc3RPZlllYXIiLCJ0b0ZpcnN0T2ZXZWVrIiwidG9EYXRlIiwiZ2V0VGltZXpvbmVPZmZzZXQiLCJ1bml4IiwiZGF5c0xlZnQiLCJldmVyeSIsInNvcnQiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-date-object/dist/index.module.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-element-popper/build/browser.min.js":
/*!****************************************************************!*\
  !*** ./node_modules/react-element-popper/build/browser.min.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n!function(t, e) {\n     true ? module.exports = e(__webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\"), __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\")) : 0;\n}(void 0, function(t, e) {\n    var _s = $RefreshSig$();\n    \"use strict\";\n    function r(t) {\n        return t && \"object\" == typeof t && \"default\" in t ? t : {\n            default: t\n        };\n    }\n    var o = r(e);\n    function n(t, e) {\n        var r = Object.keys(t);\n        if (Object.getOwnPropertySymbols) {\n            var o = Object.getOwnPropertySymbols(t);\n            e && (o = o.filter(function(e) {\n                return Object.getOwnPropertyDescriptor(t, e).enumerable;\n            })), r.push.apply(r, o);\n        }\n        return r;\n    }\n    function i(t) {\n        for(var e = 1; e < arguments.length; e++){\n            var r = null != arguments[e] ? arguments[e] : {};\n            e % 2 ? n(Object(r), !0).forEach(function(e) {\n                a(t, e, r[e]);\n            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : n(Object(r)).forEach(function(e) {\n                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(r, e));\n            });\n        }\n        return t;\n    }\n    function a(t, e, r) {\n        return e in t ? Object.defineProperty(t, e, {\n            value: r,\n            enumerable: !0,\n            configurable: !0,\n            writable: !0\n        }) : t[e] = r, t;\n    }\n    function l(t, e) {\n        return function(t) {\n            if (Array.isArray(t)) return t;\n        }(t) || function(t, e) {\n            var r = null == t ? null : \"undefined\" != typeof Symbol && t[Symbol.iterator] || t[\"@@iterator\"];\n            if (null == r) return;\n            var o, n, i = [], a = !0, l = !1;\n            try {\n                for(r = r.call(t); !(a = (o = r.next()).done) && (i.push(o.value), !e || i.length !== e); a = !0);\n            } catch (t) {\n                l = !0, n = t;\n            } finally{\n                try {\n                    a || null == r.return || r.return();\n                } finally{\n                    if (l) throw n;\n                }\n            }\n            return i;\n        }(t, e) || function(t, e) {\n            if (!t) return;\n            if (\"string\" == typeof t) return c(t, e);\n            var r = Object.prototype.toString.call(t).slice(8, -1);\n            \"Object\" === r && t.constructor && (r = t.constructor.name);\n            if (\"Map\" === r || \"Set\" === r) return Array.from(t);\n            if (\"Arguments\" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return c(t, e);\n        }(t, e) || function() {\n            throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n        }();\n    }\n    function c(t, e) {\n        (null == e || e > t.length) && (e = t.length);\n        for(var r = 0, o = new Array(e); r < e; r++)o[r] = t[r];\n        return o;\n    }\n    function u(r, n) {\n        _s();\n        var a = r.element, l = r.popper, c = r.position, u = void 0 === c ? \"bottom-center\" : c, s = r.containerStyle, d = r.containerClassName, p = void 0 === d ? \"\" : d, h = r.arrow, m = r.arrowStyle, v = void 0 === m ? {} : m, b = r.arrowClassName, y = void 0 === b ? \"\" : b, g = r.fixMainPosition, w = r.fixRelativePosition, O = r.offsetY, E = r.offsetX, P = r.animations, x = r.zIndex, j = void 0 === x ? 0 : x, M = r.popperShadow, T = r.onChange, S = r.active, C = void 0 === S || S, N = r.portal, L = r.portalTarget, R = \"undefined\" != \"object\", A = R && L instanceof HTMLElement, z = !0 === h, I = l && !0 === C, X = e.useRef(), D = e.useRef(), H = e.useRef(), Y = e.useRef(), k = e.useMemo(function() {\n            return {\n                position: u,\n                fixMainPosition: g,\n                fixRelativePosition: w,\n                offsetY: O,\n                offsetX: E,\n                defaultArrow: z,\n                animations: P,\n                zIndex: j,\n                onChange: T\n            };\n        }, [\n            u,\n            g,\n            w,\n            O,\n            E,\n            z,\n            P,\n            T,\n            j\n        ]), V = e.useCallback(function() {\n            H.current && (H.current.style.transition = \"\"), D.current && (D.current.parentNode.style.transition = \"\");\n        }, []), W = {\n            element: i({\n                display: \"inline-block\",\n                height: \"max-content\"\n            }, s),\n            arrow: i({\n                visibility: \"hidden\",\n                left: \"0\",\n                top: \"0\",\n                position: \"absolute\"\n            }, v),\n            popper: {\n                position: \"absolute\",\n                left: \"0\",\n                top: \"0\",\n                willChange: \"transform\",\n                visibility: \"hidden\",\n                zIndex: j\n            }\n        };\n        R && !Y.current && (Y.current = document.createElement(\"div\"), Y.current.data = {\n            portal: N,\n            isValidPortalTarget: A\n        }), e.useEffect(function() {\n            if (N && !A) {\n                var t = Y.current;\n                return document.body.appendChild(t), function() {\n                    document.body.contains(t) && document.body.removeChild(t);\n                };\n            }\n        }, [\n            N,\n            A\n        ]), e.useEffect(function() {\n            if (!I) return V(), D.current.parentNode.style.visibility = \"hidden\", void (H.current && (H.current.style.visibility = \"hidden\"));\n            function t(t) {\n                t && \"resize\" !== t.type && !t.target.contains(X.current) || (t && V(), f(X, D, H, k, t));\n            }\n            return t(), document.addEventListener(\"scroll\", t, !0), window.addEventListener(\"resize\", t), function() {\n                document.removeEventListener(\"scroll\", t, !0), window.removeEventListener(\"resize\", t);\n            };\n        }, [\n            I,\n            k,\n            V\n        ]), e.useEffect(function() {\n            var t = {\n                portal: N,\n                isValidPortalTarget: A\n            }, e = Y.current.data;\n            JSON.stringify(t) !== JSON.stringify(e) && (Y.current.data = t, X.current.refreshPosition());\n        }, [\n            N,\n            A\n        ]);\n        var q = o.default.createElement(o.default.Fragment, null, function() {\n            if (!h || !I) return null;\n            var t = o.default.createElement(\"div\", {\n                ref: H,\n                style: W.arrow\n            }), r = e.isValidElement(h) ? {\n                children: h\n            } : {\n                className: \"ep-arrow \".concat(M ? \"ep-shadow\" : \"\", \" \").concat(y)\n            };\n            return e.cloneElement(t, r);\n        }(), o.default.createElement(\"div\", {\n            className: M ? \"ep-popper-shadow\" : \"\",\n            style: W.popper\n        }, o.default.createElement(\"div\", {\n            ref: D\n        }, l)));\n        return o.default.createElement(\"div\", {\n            ref: function(t) {\n                t && (t.removeTransition = V, t.refreshPosition = function() {\n                    return setTimeout(function() {\n                        return f(X, D, H, k, {});\n                    }, 10);\n                });\n                if (X.current = t, n instanceof Function) return n(t);\n                n && (n.current = t);\n            },\n            className: p,\n            style: W.element\n        }, a, N && R ? t.createPortal(q, A ? L : Y.current) : q);\n    }\n    _s(u, \"dZ5QHwJE7Z6rBBFDcC0UTk4eqKk=\");\n    function f(t, e, r, o, n) {\n        var a = o.position, c = o.fixMainPosition, u = o.fixRelativePosition, f = o.offsetY, h = void 0 === f ? 0 : f, m = o.offsetX, v = void 0 === m ? 0 : m, b = o.defaultArrow, y = o.animations, g = void 0 === y ? [] : y, w = o.zIndex, O = o.onChange;\n        if (t.current && e.current) {\n            var E, P, x, j, M = (P = void 0 !== window.pageXOffset, x = \"CSS1Compat\" === (document.compatMode || \"\"), {\n                scrollLeft: P ? window.pageXOffset : x ? document.documentElement.scrollLeft : document.body.scrollLeft,\n                scrollTop: P ? window.pageYOffset : x ? document.documentElement.scrollTop : document.body.scrollTop\n            }), T = M.scrollLeft, S = M.scrollTop, C = s(t.current, T, S), N = C.top, L = C.left, R = C.height, A = C.width, z = C.right, I = C.bottom, X = s(e.current, T, S), D = X.top, H = X.left, Y = X.height, k = X.width, V = document.documentElement, W = V.clientHeight, q = V.clientWidth, F = e.current.parentNode, J = function(t) {\n                if (!t) return [\n                    0,\n                    0\n                ];\n                var e = l((t.style.transform.match(/translate\\((.*?)px,\\s(.*?)px\\)/) || []).map(function(t) {\n                    return Number(t);\n                }), 3), r = e[1], o = void 0 === r ? 0 : r, n = e[2];\n                return [\n                    o,\n                    void 0 === n ? 0 : n\n                ];\n            }(F), B = l(J, 2), U = B[0], $ = B[1], G = function(t) {\n                var e = l(t.split(\"-\"), 2), r = e[0], o = void 0 === r ? \"bottom\" : r, n = e[1], i = void 0 === n ? \"center\" : n;\n                \"auto\" === o && (o = \"bottom\");\n                \"auto\" === i && (i = \"center\");\n                var a = \"top\" === o || \"bottom\" === o, c = \"left\" === o || \"right\" === o;\n                c && (\"start\" === i && (i = \"top\"), \"end\" === i && (i = \"bottom\"));\n                a && (\"start\" === i && (i = \"left\"), \"end\" === i && (i = \"right\"));\n                return [\n                    o,\n                    i,\n                    a,\n                    c\n                ];\n            }(a), K = l(G, 4), Q = K[0], Z = K[1], _ = K[2], tt = K[3], et = Q, rt = function(t, e) {\n                return \"translate(\".concat(t, \"px, \").concat(e, \"px)\");\n            }, ot = A - k, nt = R - Y, it = \"left\" === Z ? 0 : \"right\" === Z ? ot : ot / 2, at = ot - it, lt = \"top\" === Z ? 0 : \"bottom\" === Z ? nt : nt / 2, ct = nt - lt, ut = L - H + U, ft = N - D + $, st = 0, dt = 0, pt = d(t.current), ht = [], mt = r.current, vt = s(mt, T, S) || {}, bt = vt.height, yt = void 0 === bt ? 0 : bt, gt = vt.width, wt = void 0 === gt ? 0 : gt, Ot = ut, Et = ft, Pt = {\n                top: \"bottom\",\n                bottom: \"top\",\n                left: \"right\",\n                right: \"left\"\n            };\n            for(_ && (ut += it, ft += \"top\" === Q ? -Y : R, b && (yt = 11, wt = 20)), tt && (ut += \"left\" === Q ? -k : A, ft += lt, b && (yt = 20, wt = 11)); pt;)ht.push(pt), jt(s(pt, T, S)), pt = d(pt.parentNode);\n            if (jt({\n                top: S,\n                bottom: S + W,\n                left: T,\n                right: T + q,\n                height: W,\n                width: q\n            }), _ && (ft += \"bottom\" === et ? h : -h), tt && (ut += \"right\" === et ? v : -v), ut -= st, ft -= dt, E = Pt[et], mt) _ && ((j = A < k) ? Ot += A / 2 : Ot = ut + k / 2, Ot -= wt / 2, \"bottom\" === et && (Et = ft, ft += yt), \"top\" === et && (Et = (ft -= yt) + Y), st < 0 && st - it < 0 && (j ? Ot += (it - st) / 2 : A - it + st < k && (Ot += (A - it + st - k) / 2)), st > 0 && st + at > 0 && (j ? Ot -= (st + at) / 2 : A - st - at < k && (Ot -= (A - st - at - k) / 2))), tt && ((j = R < Y) ? Et += R / 2 : Et = ft + Y / 2, Et -= yt / 2, \"left\" === et && (Ot = (ut -= wt) + k), \"right\" === et && (Ot = ut, ut += wt), dt < 0 && dt - lt < 0 && (j ? Et += (lt - dt) / 2 : R - lt + dt < Y && (Et += (R - lt + dt - Y) / 2)), dt > 0 && dt + ct > 0 && (j ? Et -= (dt + ct) / 2 : R - dt - ct < Y && (Et -= (R - dt - ct - Y) / 2))), mt.setAttribute(\"direction\", E), mt.style.height = yt + \"px\", mt.style.width = wt + \"px\", mt.style.transform = rt(Ot, Et), mt.style.visibility = \"visible\", mt.style.zIndex = w + 1;\n            F.style.transform = rt(ut, ft);\n            var xt = {\n                popper: {\n                    top: ft,\n                    bottom: ft + Y,\n                    left: ut,\n                    right: ut + k,\n                    height: Y,\n                    width: k\n                },\n                element: {\n                    top: N,\n                    bottom: I,\n                    left: L,\n                    right: z,\n                    height: R,\n                    width: A\n                },\n                arrow: {\n                    top: Et,\n                    bottom: Et + yt,\n                    left: Ot,\n                    right: Ot + wt,\n                    height: yt,\n                    width: wt,\n                    direction: E\n                },\n                position: et + \"-\" + (0 !== st ? \"auto\" : Z),\n                scroll: {\n                    scrollLeft: T,\n                    scrollTop: S\n                },\n                scrollableParents: ht,\n                event: n\n            };\n            n || g.forEach(function(t) {\n                t({\n                    popper: F,\n                    arrow: mt,\n                    data: i(i({}, xt), {}, {\n                        getTransform: rt,\n                        mirror: Pt\n                    })\n                });\n            }), F.style.visibility = \"visible\", \"function\" == typeof O && O(xt);\n        }\n        function jt(t) {\n            var e = t.top, r = t.bottom, o = t.left, n = t.right, i = t.height, a = t.width;\n            if (_) {\n                var l = Math.round(N - e + R / 2), f = Math.round(i / 2);\n                c || (N - (Y + h + yt) < e && l <= f && \"top\" === et ? (ft += Y + R, et = \"bottom\") : I + Y + h + yt > i + e && l >= f && \"bottom\" === et && (ft -= Y + R, et = \"top\")), u || (L + it < o && (st = p(z - wt > o ? L + it - o : -A + it + wt, st)), z - at > n && (st = p(L + wt < n ? z - at - n : A - at - wt, st)));\n            }\n            if (tt) {\n                var s = Math.round(L - o + A / 2), d = Math.round(a / 2);\n                c || (L - (k + v + wt) < o && s < d && \"left\" === et ? (ut += A + k, et = \"right\") : z + k + v + wt > n && s > d && \"right\" === et && (ut -= A + k, et = \"left\")), u || (N + lt < e && (dt = p(I - yt > e ? N + lt - e : -R + lt + yt, dt)), I - ct > r && (dt = p(N + yt < r ? I - ct - r : R - ct - yt, dt)));\n            }\n        }\n    }\n    function s(t, e, r) {\n        if (t) {\n            var o = t.getBoundingClientRect(), n = o.top, i = o.left, a = o.width, l = o.height, c = n + r, u = i + e;\n            return {\n                top: c,\n                bottom: c + l,\n                left: u,\n                right: u + a,\n                width: a,\n                height: l\n            };\n        }\n    }\n    function d(t) {\n        if (t && \"HTML\" !== t.tagName) {\n            var e = window.getComputedStyle(t), r = function(t) {\n                return [\n                    \"auto\",\n                    \"scroll\"\n                ].includes(t);\n            };\n            return t.clientHeight < t.scrollHeight && r(e.overflowX) || t.clientWidth < t.scrollWidth && r(e.overflowY) ? t : d(t.parentNode);\n        }\n    }\n    function p(t, e) {\n        return Math.round(Math.abs(t)) > Math.round(Math.abs(e)) ? t : e;\n    }\n    return e.forwardRef(u);\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1lbGVtZW50LXBvcHBlci9idWlsZC9icm93c2VyLm1pbi5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsQ0FBQyxTQUFTQSxDQUFDLEVBQUNDLENBQUM7SUFBRSxLQUFvREUsR0FBQ0EsT0FBT0QsT0FBTyxHQUFDRCxFQUFFRyxtQkFBT0EsQ0FBQywyRkFBVyxHQUFFQSxtQkFBT0EsQ0FBQyxtRkFBTyxLQUFHLENBQStKO0FBQUEsRUFBRSxRQUFNLFNBQVNKLENBQUMsRUFBQ0MsQ0FBQzs7SUFBRTtJQUFhLFNBQVNXLEVBQUVaLENBQUM7UUFBRSxPQUFPQSxLQUFHLFlBQVUsT0FBT0EsS0FBRyxhQUFZQSxJQUFFQSxJQUFFO1lBQUNhLFNBQVFiO1FBQUM7SUFBQztJQUFDLElBQUljLElBQUVGLEVBQUVYO0lBQUcsU0FBU2MsRUFBRWYsQ0FBQyxFQUFDQyxDQUFDO1FBQUUsSUFBSVcsSUFBRUksT0FBT0MsSUFBSSxDQUFDakI7UUFBRyxJQUFHZ0IsT0FBT0UscUJBQXFCLEVBQUM7WUFBQyxJQUFJSixJQUFFRSxPQUFPRSxxQkFBcUIsQ0FBQ2xCO1lBQUdDLEtBQUlhLENBQUFBLElBQUVBLEVBQUVLLE1BQU0sQ0FBRSxTQUFTbEIsQ0FBQztnQkFBRSxPQUFPZSxPQUFPSSx3QkFBd0IsQ0FBQ3BCLEdBQUVDLEdBQUdvQixVQUFVO1lBQUEsRUFBRSxHQUFHVCxFQUFFVSxJQUFJLENBQUNDLEtBQUssQ0FBQ1gsR0FBRUU7UUFBRTtRQUFDLE9BQU9GO0lBQUM7SUFBQyxTQUFTWSxFQUFFeEIsQ0FBQztRQUFFLElBQUksSUFBSUMsSUFBRSxHQUFFQSxJQUFFd0IsVUFBVUMsTUFBTSxFQUFDekIsSUFBSTtZQUFDLElBQUlXLElBQUUsUUFBTWEsU0FBUyxDQUFDeEIsRUFBRSxHQUFDd0IsU0FBUyxDQUFDeEIsRUFBRSxHQUFDLENBQUM7WUFBRUEsSUFBRSxJQUFFYyxFQUFFQyxPQUFPSixJQUFHLENBQUMsR0FB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LE9BQU9BLEVBQUUrSixZQUFZLEdBQUMvSixFQUFFdU4sWUFBWSxJQUFFM00sRUFBRVgsRUFBRXVOLFNBQVMsS0FBR3hOLEVBQUVnSyxXQUFXLEdBQUNoSyxFQUFFeU4sV0FBVyxJQUFFN00sRUFBRVgsRUFBRXlOLFNBQVMsSUFBRTFOLElBQUUyRCxFQUFFM0QsRUFBRWdILFVBQVU7UUFBQztJQUFDO0lBQUMsU0FBU25ELEVBQUU3RCxDQUFDLEVBQUNDLENBQUM7UUFBRSxPQUFPZ04sS0FBS0MsS0FBSyxDQUFDRCxLQUFLVSxHQUFHLENBQUMzTixNQUFJaU4sS0FBS0MsS0FBSyxDQUFDRCxLQUFLVSxHQUFHLENBQUMxTixNQUFJRCxJQUFFQztJQUFDO0lBQUMsT0FBT0EsRUFBRTJOLFVBQVUsQ0FBQ3ZLO0FBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWVsZW1lbnQtcG9wcGVyL2J1aWxkL2Jyb3dzZXIubWluLmpzPzA3NjQiXSwic291cmNlc0NvbnRlbnQiOlsiIWZ1bmN0aW9uKHQsZSl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9ZShyZXF1aXJlKFwicmVhY3QtZG9tXCIpLHJlcXVpcmUoXCJyZWFjdFwiKSk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXCJyZWFjdC1kb21cIixcInJlYWN0XCJdLGUpOih0PVwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWxUaGlzP2dsb2JhbFRoaXM6dHx8c2VsZikuRWxlbWVudFBvcHBlcj1lKHQuUmVhY3RET00sdC5SZWFjdCl9KHRoaXMsKGZ1bmN0aW9uKHQsZSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0KXtyZXR1cm4gdCYmXCJvYmplY3RcIj09dHlwZW9mIHQmJlwiZGVmYXVsdFwiaW4gdD90OntkZWZhdWx0OnR9fXZhciBvPXIoZSk7ZnVuY3Rpb24gbih0LGUpe3ZhciByPU9iamVjdC5rZXlzKHQpO2lmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciBvPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModCk7ZSYmKG89by5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsZSkuZW51bWVyYWJsZX0pKSksci5wdXNoLmFwcGx5KHIsbyl9cmV0dXJuIHJ9ZnVuY3Rpb24gaSh0KXtmb3IodmFyIGU9MTtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKXt2YXIgcj1udWxsIT1hcmd1bWVudHNbZV0/YXJndW1lbnRzW2VdOnt9O2UlMj9uKE9iamVjdChyKSwhMCkuZm9yRWFjaCgoZnVuY3Rpb24oZSl7YSh0LGUscltlXSl9KSk6T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM/T2JqZWN0LmRlZmluZVByb3BlcnRpZXModCxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhyKSk6bihPYmplY3QocikpLmZvckVhY2goKGZ1bmN0aW9uKGUpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyLGUpKX0pKX1yZXR1cm4gdH1mdW5jdGlvbiBhKHQsZSxyKXtyZXR1cm4gZSBpbiB0P09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUse3ZhbHVlOnIsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTp0W2VdPXIsdH1mdW5jdGlvbiBsKHQsZSl7cmV0dXJuIGZ1bmN0aW9uKHQpe2lmKEFycmF5LmlzQXJyYXkodCkpcmV0dXJuIHR9KHQpfHxmdW5jdGlvbih0LGUpe3ZhciByPW51bGw9PXQ/bnVsbDpcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZ0W1N5bWJvbC5pdGVyYXRvcl18fHRbXCJAQGl0ZXJhdG9yXCJdO2lmKG51bGw9PXIpcmV0dXJuO3ZhciBvLG4saT1bXSxhPSEwLGw9ITE7dHJ5e2ZvcihyPXIuY2FsbCh0KTshKGE9KG89ci5uZXh0KCkpLmRvbmUpJiYoaS5wdXNoKG8udmFsdWUpLCFlfHxpLmxlbmd0aCE9PWUpO2E9ITApO31jYXRjaCh0KXtsPSEwLG49dH1maW5hbGx5e3RyeXthfHxudWxsPT1yLnJldHVybnx8ci5yZXR1cm4oKX1maW5hbGx5e2lmKGwpdGhyb3cgbn19cmV0dXJuIGl9KHQsZSl8fGZ1bmN0aW9uKHQsZSl7aWYoIXQpcmV0dXJuO2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0KXJldHVybiBjKHQsZSk7dmFyIHI9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpLnNsaWNlKDgsLTEpO1wiT2JqZWN0XCI9PT1yJiZ0LmNvbnN0cnVjdG9yJiYocj10LmNvbnN0cnVjdG9yLm5hbWUpO2lmKFwiTWFwXCI9PT1yfHxcIlNldFwiPT09cilyZXR1cm4gQXJyYXkuZnJvbSh0KTtpZihcIkFyZ3VtZW50c1wiPT09cnx8L14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QocikpcmV0dXJuIGModCxlKX0odCxlKXx8ZnVuY3Rpb24oKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpfSgpfWZ1bmN0aW9uIGModCxlKXsobnVsbD09ZXx8ZT50Lmxlbmd0aCkmJihlPXQubGVuZ3RoKTtmb3IodmFyIHI9MCxvPW5ldyBBcnJheShlKTtyPGU7cisrKW9bcl09dFtyXTtyZXR1cm4gb31mdW5jdGlvbiB1KHIsbil7dmFyIGE9ci5lbGVtZW50LGw9ci5wb3BwZXIsYz1yLnBvc2l0aW9uLHU9dm9pZCAwPT09Yz9cImJvdHRvbS1jZW50ZXJcIjpjLHM9ci5jb250YWluZXJTdHlsZSxkPXIuY29udGFpbmVyQ2xhc3NOYW1lLHA9dm9pZCAwPT09ZD9cIlwiOmQsaD1yLmFycm93LG09ci5hcnJvd1N0eWxlLHY9dm9pZCAwPT09bT97fTptLGI9ci5hcnJvd0NsYXNzTmFtZSx5PXZvaWQgMD09PWI/XCJcIjpiLGc9ci5maXhNYWluUG9zaXRpb24sdz1yLmZpeFJlbGF0aXZlUG9zaXRpb24sTz1yLm9mZnNldFksRT1yLm9mZnNldFgsUD1yLmFuaW1hdGlvbnMseD1yLnpJbmRleCxqPXZvaWQgMD09PXg/MDp4LE09ci5wb3BwZXJTaGFkb3csVD1yLm9uQ2hhbmdlLFM9ci5hY3RpdmUsQz12b2lkIDA9PT1TfHxTLE49ci5wb3J0YWwsTD1yLnBvcnRhbFRhcmdldCxSPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3csQT1SJiZMIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQsej0hMD09PWgsST1sJiYhMD09PUMsWD1lLnVzZVJlZigpLEQ9ZS51c2VSZWYoKSxIPWUudXNlUmVmKCksWT1lLnVzZVJlZigpLGs9ZS51c2VNZW1vKChmdW5jdGlvbigpe3JldHVybntwb3NpdGlvbjp1LGZpeE1haW5Qb3NpdGlvbjpnLGZpeFJlbGF0aXZlUG9zaXRpb246dyxvZmZzZXRZOk8sb2Zmc2V0WDpFLGRlZmF1bHRBcnJvdzp6LGFuaW1hdGlvbnM6UCx6SW5kZXg6aixvbkNoYW5nZTpUfX0pLFt1LGcsdyxPLEUseixQLFQsal0pLFY9ZS51c2VDYWxsYmFjaygoZnVuY3Rpb24oKXtILmN1cnJlbnQmJihILmN1cnJlbnQuc3R5bGUudHJhbnNpdGlvbj1cIlwiKSxELmN1cnJlbnQmJihELmN1cnJlbnQucGFyZW50Tm9kZS5zdHlsZS50cmFuc2l0aW9uPVwiXCIpfSksW10pLFc9e2VsZW1lbnQ6aSh7ZGlzcGxheTpcImlubGluZS1ibG9ja1wiLGhlaWdodDpcIm1heC1jb250ZW50XCJ9LHMpLGFycm93Omkoe3Zpc2liaWxpdHk6XCJoaWRkZW5cIixsZWZ0OlwiMFwiLHRvcDpcIjBcIixwb3NpdGlvbjpcImFic29sdXRlXCJ9LHYpLHBvcHBlcjp7cG9zaXRpb246XCJhYnNvbHV0ZVwiLGxlZnQ6XCIwXCIsdG9wOlwiMFwiLHdpbGxDaGFuZ2U6XCJ0cmFuc2Zvcm1cIix2aXNpYmlsaXR5OlwiaGlkZGVuXCIsekluZGV4Omp9fTtSJiYhWS5jdXJyZW50JiYoWS5jdXJyZW50PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksWS5jdXJyZW50LmRhdGE9e3BvcnRhbDpOLGlzVmFsaWRQb3J0YWxUYXJnZXQ6QX0pLGUudXNlRWZmZWN0KChmdW5jdGlvbigpe2lmKE4mJiFBKXt2YXIgdD1ZLmN1cnJlbnQ7cmV0dXJuIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodCksZnVuY3Rpb24oKXtkb2N1bWVudC5ib2R5LmNvbnRhaW5zKHQpJiZkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHQpfX19KSxbTixBXSksZS51c2VFZmZlY3QoKGZ1bmN0aW9uKCl7aWYoIUkpcmV0dXJuIFYoKSxELmN1cnJlbnQucGFyZW50Tm9kZS5zdHlsZS52aXNpYmlsaXR5PVwiaGlkZGVuXCIsdm9pZChILmN1cnJlbnQmJihILmN1cnJlbnQuc3R5bGUudmlzaWJpbGl0eT1cImhpZGRlblwiKSk7ZnVuY3Rpb24gdCh0KXt0JiZcInJlc2l6ZVwiIT09dC50eXBlJiYhdC50YXJnZXQuY29udGFpbnMoWC5jdXJyZW50KXx8KHQmJlYoKSxmKFgsRCxILGssdCkpfXJldHVybiB0KCksZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLHQsITApLHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsdCksZnVuY3Rpb24oKXtkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsdCwhMCksd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIix0KX19KSxbSSxrLFZdKSxlLnVzZUVmZmVjdCgoZnVuY3Rpb24oKXt2YXIgdD17cG9ydGFsOk4saXNWYWxpZFBvcnRhbFRhcmdldDpBfSxlPVkuY3VycmVudC5kYXRhO0pTT04uc3RyaW5naWZ5KHQpIT09SlNPTi5zdHJpbmdpZnkoZSkmJihZLmN1cnJlbnQuZGF0YT10LFguY3VycmVudC5yZWZyZXNoUG9zaXRpb24oKSl9KSxbTixBXSk7dmFyIHE9by5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoby5kZWZhdWx0LkZyYWdtZW50LG51bGwsZnVuY3Rpb24oKXtpZighaHx8IUkpcmV0dXJuIG51bGw7dmFyIHQ9by5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7cmVmOkgsc3R5bGU6Vy5hcnJvd30pLHI9ZS5pc1ZhbGlkRWxlbWVudChoKT97Y2hpbGRyZW46aH06e2NsYXNzTmFtZTpcImVwLWFycm93IFwiLmNvbmNhdChNP1wiZXAtc2hhZG93XCI6XCJcIixcIiBcIikuY29uY2F0KHkpfTtyZXR1cm4gZS5jbG9uZUVsZW1lbnQodCxyKX0oKSxvLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLHtjbGFzc05hbWU6TT9cImVwLXBvcHBlci1zaGFkb3dcIjpcIlwiLHN0eWxlOlcucG9wcGVyfSxvLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLHtyZWY6RH0sbCkpKTtyZXR1cm4gby5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7cmVmOmZ1bmN0aW9uKHQpe3QmJih0LnJlbW92ZVRyYW5zaXRpb249Vix0LnJlZnJlc2hQb3NpdGlvbj1mdW5jdGlvbigpe3JldHVybiBzZXRUaW1lb3V0KChmdW5jdGlvbigpe3JldHVybiBmKFgsRCxILGsse30pfSksMTApfSk7aWYoWC5jdXJyZW50PXQsbiBpbnN0YW5jZW9mIEZ1bmN0aW9uKXJldHVybiBuKHQpO24mJihuLmN1cnJlbnQ9dCl9LGNsYXNzTmFtZTpwLHN0eWxlOlcuZWxlbWVudH0sYSxOJiZSP3QuY3JlYXRlUG9ydGFsKHEsQT9MOlkuY3VycmVudCk6cSl9ZnVuY3Rpb24gZih0LGUscixvLG4pe3ZhciBhPW8ucG9zaXRpb24sYz1vLmZpeE1haW5Qb3NpdGlvbix1PW8uZml4UmVsYXRpdmVQb3NpdGlvbixmPW8ub2Zmc2V0WSxoPXZvaWQgMD09PWY/MDpmLG09by5vZmZzZXRYLHY9dm9pZCAwPT09bT8wOm0sYj1vLmRlZmF1bHRBcnJvdyx5PW8uYW5pbWF0aW9ucyxnPXZvaWQgMD09PXk/W106eSx3PW8uekluZGV4LE89by5vbkNoYW5nZTtpZih0LmN1cnJlbnQmJmUuY3VycmVudCl7dmFyIEUsUCx4LGosTT0oUD12b2lkIDAhPT13aW5kb3cucGFnZVhPZmZzZXQseD1cIkNTUzFDb21wYXRcIj09PShkb2N1bWVudC5jb21wYXRNb2RlfHxcIlwiKSx7c2Nyb2xsTGVmdDpQP3dpbmRvdy5wYWdlWE9mZnNldDp4P2RvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0OmRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCxzY3JvbGxUb3A6UD93aW5kb3cucGFnZVlPZmZzZXQ6eD9kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wOmRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wfSksVD1NLnNjcm9sbExlZnQsUz1NLnNjcm9sbFRvcCxDPXModC5jdXJyZW50LFQsUyksTj1DLnRvcCxMPUMubGVmdCxSPUMuaGVpZ2h0LEE9Qy53aWR0aCx6PUMucmlnaHQsST1DLmJvdHRvbSxYPXMoZS5jdXJyZW50LFQsUyksRD1YLnRvcCxIPVgubGVmdCxZPVguaGVpZ2h0LGs9WC53aWR0aCxWPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxXPVYuY2xpZW50SGVpZ2h0LHE9Vi5jbGllbnRXaWR0aCxGPWUuY3VycmVudC5wYXJlbnROb2RlLEo9ZnVuY3Rpb24odCl7aWYoIXQpcmV0dXJuWzAsMF07dmFyIGU9bCgodC5zdHlsZS50cmFuc2Zvcm0ubWF0Y2goL3RyYW5zbGF0ZVxcKCguKj8pcHgsXFxzKC4qPylweFxcKS8pfHxbXSkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gTnVtYmVyKHQpfSkpLDMpLHI9ZVsxXSxvPXZvaWQgMD09PXI/MDpyLG49ZVsyXTtyZXR1cm5bbyx2b2lkIDA9PT1uPzA6bl19KEYpLEI9bChKLDIpLFU9QlswXSwkPUJbMV0sRz1mdW5jdGlvbih0KXt2YXIgZT1sKHQuc3BsaXQoXCItXCIpLDIpLHI9ZVswXSxvPXZvaWQgMD09PXI/XCJib3R0b21cIjpyLG49ZVsxXSxpPXZvaWQgMD09PW4/XCJjZW50ZXJcIjpuO1wiYXV0b1wiPT09byYmKG89XCJib3R0b21cIik7XCJhdXRvXCI9PT1pJiYoaT1cImNlbnRlclwiKTt2YXIgYT1cInRvcFwiPT09b3x8XCJib3R0b21cIj09PW8sYz1cImxlZnRcIj09PW98fFwicmlnaHRcIj09PW87YyYmKFwic3RhcnRcIj09PWkmJihpPVwidG9wXCIpLFwiZW5kXCI9PT1pJiYoaT1cImJvdHRvbVwiKSk7YSYmKFwic3RhcnRcIj09PWkmJihpPVwibGVmdFwiKSxcImVuZFwiPT09aSYmKGk9XCJyaWdodFwiKSk7cmV0dXJuW28saSxhLGNdfShhKSxLPWwoRyw0KSxRPUtbMF0sWj1LWzFdLF89S1syXSx0dD1LWzNdLGV0PVEscnQ9ZnVuY3Rpb24odCxlKXtyZXR1cm5cInRyYW5zbGF0ZShcIi5jb25jYXQodCxcInB4LCBcIikuY29uY2F0KGUsXCJweClcIil9LG90PUEtayxudD1SLVksaXQ9XCJsZWZ0XCI9PT1aPzA6XCJyaWdodFwiPT09Wj9vdDpvdC8yLGF0PW90LWl0LGx0PVwidG9wXCI9PT1aPzA6XCJib3R0b21cIj09PVo/bnQ6bnQvMixjdD1udC1sdCx1dD1MLUgrVSxmdD1OLUQrJCxzdD0wLGR0PTAscHQ9ZCh0LmN1cnJlbnQpLGh0PVtdLG10PXIuY3VycmVudCx2dD1zKG10LFQsUyl8fHt9LGJ0PXZ0LmhlaWdodCx5dD12b2lkIDA9PT1idD8wOmJ0LGd0PXZ0LndpZHRoLHd0PXZvaWQgMD09PWd0PzA6Z3QsT3Q9dXQsRXQ9ZnQsUHQ9e3RvcDpcImJvdHRvbVwiLGJvdHRvbTpcInRvcFwiLGxlZnQ6XCJyaWdodFwiLHJpZ2h0OlwibGVmdFwifTtmb3IoXyYmKHV0Kz1pdCxmdCs9XCJ0b3BcIj09PVE/LVk6UixiJiYoeXQ9MTEsd3Q9MjApKSx0dCYmKHV0Kz1cImxlZnRcIj09PVE/LWs6QSxmdCs9bHQsYiYmKHl0PTIwLHd0PTExKSk7cHQ7KWh0LnB1c2gocHQpLGp0KHMocHQsVCxTKSkscHQ9ZChwdC5wYXJlbnROb2RlKTtpZihqdCh7dG9wOlMsYm90dG9tOlMrVyxsZWZ0OlQscmlnaHQ6VCtxLGhlaWdodDpXLHdpZHRoOnF9KSxfJiYoZnQrPVwiYm90dG9tXCI9PT1ldD9oOi1oKSx0dCYmKHV0Kz1cInJpZ2h0XCI9PT1ldD92Oi12KSx1dC09c3QsZnQtPWR0LEU9UHRbZXRdLG10KV8mJigoaj1BPGspP090Kz1BLzI6T3Q9dXQray8yLE90LT13dC8yLFwiYm90dG9tXCI9PT1ldCYmKEV0PWZ0LGZ0Kz15dCksXCJ0b3BcIj09PWV0JiYoRXQ9KGZ0LT15dCkrWSksc3Q8MCYmc3QtaXQ8MCYmKGo/T3QrPShpdC1zdCkvMjpBLWl0K3N0PGsmJihPdCs9KEEtaXQrc3QtaykvMikpLHN0PjAmJnN0K2F0PjAmJihqP090LT0oc3QrYXQpLzI6QS1zdC1hdDxrJiYoT3QtPShBLXN0LWF0LWspLzIpKSksdHQmJigoaj1SPFkpP0V0Kz1SLzI6RXQ9ZnQrWS8yLEV0LT15dC8yLFwibGVmdFwiPT09ZXQmJihPdD0odXQtPXd0KStrKSxcInJpZ2h0XCI9PT1ldCYmKE90PXV0LHV0Kz13dCksZHQ8MCYmZHQtbHQ8MCYmKGo/RXQrPShsdC1kdCkvMjpSLWx0K2R0PFkmJihFdCs9KFItbHQrZHQtWSkvMikpLGR0PjAmJmR0K2N0PjAmJihqP0V0LT0oZHQrY3QpLzI6Ui1kdC1jdDxZJiYoRXQtPShSLWR0LWN0LVkpLzIpKSksbXQuc2V0QXR0cmlidXRlKFwiZGlyZWN0aW9uXCIsRSksbXQuc3R5bGUuaGVpZ2h0PXl0K1wicHhcIixtdC5zdHlsZS53aWR0aD13dCtcInB4XCIsbXQuc3R5bGUudHJhbnNmb3JtPXJ0KE90LEV0KSxtdC5zdHlsZS52aXNpYmlsaXR5PVwidmlzaWJsZVwiLG10LnN0eWxlLnpJbmRleD13KzE7Ri5zdHlsZS50cmFuc2Zvcm09cnQodXQsZnQpO3ZhciB4dD17cG9wcGVyOnt0b3A6ZnQsYm90dG9tOmZ0K1ksbGVmdDp1dCxyaWdodDp1dCtrLGhlaWdodDpZLHdpZHRoOmt9LGVsZW1lbnQ6e3RvcDpOLGJvdHRvbTpJLGxlZnQ6TCxyaWdodDp6LGhlaWdodDpSLHdpZHRoOkF9LGFycm93Ont0b3A6RXQsYm90dG9tOkV0K3l0LGxlZnQ6T3QscmlnaHQ6T3Qrd3QsaGVpZ2h0Onl0LHdpZHRoOnd0LGRpcmVjdGlvbjpFfSxwb3NpdGlvbjpldCtcIi1cIisoMCE9PXN0P1wiYXV0b1wiOlopLHNjcm9sbDp7c2Nyb2xsTGVmdDpULHNjcm9sbFRvcDpTfSxzY3JvbGxhYmxlUGFyZW50czpodCxldmVudDpufTtufHxnLmZvckVhY2goKGZ1bmN0aW9uKHQpe3Qoe3BvcHBlcjpGLGFycm93Om10LGRhdGE6aShpKHt9LHh0KSx7fSx7Z2V0VHJhbnNmb3JtOnJ0LG1pcnJvcjpQdH0pfSl9KSksRi5zdHlsZS52aXNpYmlsaXR5PVwidmlzaWJsZVwiLFwiZnVuY3Rpb25cIj09dHlwZW9mIE8mJk8oeHQpfWZ1bmN0aW9uIGp0KHQpe3ZhciBlPXQudG9wLHI9dC5ib3R0b20sbz10LmxlZnQsbj10LnJpZ2h0LGk9dC5oZWlnaHQsYT10LndpZHRoO2lmKF8pe3ZhciBsPU1hdGgucm91bmQoTi1lK1IvMiksZj1NYXRoLnJvdW5kKGkvMik7Y3x8KE4tKFkraCt5dCk8ZSYmbDw9ZiYmXCJ0b3BcIj09PWV0PyhmdCs9WStSLGV0PVwiYm90dG9tXCIpOkkrWStoK3l0PmkrZSYmbD49ZiYmXCJib3R0b21cIj09PWV0JiYoZnQtPVkrUixldD1cInRvcFwiKSksdXx8KEwraXQ8byYmKHN0PXAoei13dD5vP0wraXQtbzotQStpdCt3dCxzdCkpLHotYXQ+biYmKHN0PXAoTCt3dDxuP3otYXQtbjpBLWF0LXd0LHN0KSkpfWlmKHR0KXt2YXIgcz1NYXRoLnJvdW5kKEwtbytBLzIpLGQ9TWF0aC5yb3VuZChhLzIpO2N8fChMLShrK3Yrd3QpPG8mJnM8ZCYmXCJsZWZ0XCI9PT1ldD8odXQrPUErayxldD1cInJpZ2h0XCIpOnorayt2K3d0Pm4mJnM+ZCYmXCJyaWdodFwiPT09ZXQmJih1dC09QStrLGV0PVwibGVmdFwiKSksdXx8KE4rbHQ8ZSYmKGR0PXAoSS15dD5lP04rbHQtZTotUitsdCt5dCxkdCkpLEktY3Q+ciYmKGR0PXAoTit5dDxyP0ktY3QtcjpSLWN0LXl0LGR0KSkpfX19ZnVuY3Rpb24gcyh0LGUscil7aWYodCl7dmFyIG89dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxuPW8udG9wLGk9by5sZWZ0LGE9by53aWR0aCxsPW8uaGVpZ2h0LGM9bityLHU9aStlO3JldHVybnt0b3A6Yyxib3R0b206YytsLGxlZnQ6dSxyaWdodDp1K2Esd2lkdGg6YSxoZWlnaHQ6bH19fWZ1bmN0aW9uIGQodCl7aWYodCYmXCJIVE1MXCIhPT10LnRhZ05hbWUpe3ZhciBlPXdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHQpLHI9ZnVuY3Rpb24odCl7cmV0dXJuW1wiYXV0b1wiLFwic2Nyb2xsXCJdLmluY2x1ZGVzKHQpfTtyZXR1cm4gdC5jbGllbnRIZWlnaHQ8dC5zY3JvbGxIZWlnaHQmJnIoZS5vdmVyZmxvd1gpfHx0LmNsaWVudFdpZHRoPHQuc2Nyb2xsV2lkdGgmJnIoZS5vdmVyZmxvd1kpP3Q6ZCh0LnBhcmVudE5vZGUpfX1mdW5jdGlvbiBwKHQsZSl7cmV0dXJuIE1hdGgucm91bmQoTWF0aC5hYnModCkpPk1hdGgucm91bmQoTWF0aC5hYnMoZSkpP3Q6ZX1yZXR1cm4gZS5mb3J3YXJkUmVmKHUpfSkpO1xuIl0sIm5hbWVzIjpbInQiLCJlIiwiZXhwb3J0cyIsIm1vZHVsZSIsInJlcXVpcmUiLCJkZWZpbmUiLCJhbWQiLCJnbG9iYWxUaGlzIiwic2VsZiIsIkVsZW1lbnRQb3BwZXIiLCJSZWFjdERPTSIsIlJlYWN0IiwiciIsImRlZmF1bHQiLCJvIiwibiIsIk9iamVjdCIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJmaWx0ZXIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwicHVzaCIsImFwcGx5IiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsImZvckVhY2giLCJhIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJkZWZpbmVQcm9wZXJ0eSIsInZhbHVlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJsIiwiQXJyYXkiLCJpc0FycmF5IiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjYWxsIiwibmV4dCIsImRvbmUiLCJyZXR1cm4iLCJjIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJzbGljZSIsImNvbnN0cnVjdG9yIiwibmFtZSIsImZyb20iLCJ0ZXN0IiwiVHlwZUVycm9yIiwidSIsImVsZW1lbnQiLCJwb3BwZXIiLCJwb3NpdGlvbiIsInMiLCJjb250YWluZXJTdHlsZSIsImQiLCJjb250YWluZXJDbGFzc05hbWUiLCJwIiwiaCIsImFycm93IiwibSIsImFycm93U3R5bGUiLCJ2IiwiYiIsImFycm93Q2xhc3NOYW1lIiwieSIsImciLCJmaXhNYWluUG9zaXRpb24iLCJ3IiwiZml4UmVsYXRpdmVQb3NpdGlvbiIsIk8iLCJvZmZzZXRZIiwiRSIsIm9mZnNldFgiLCJQIiwiYW5pbWF0aW9ucyIsIngiLCJ6SW5kZXgiLCJqIiwiTSIsInBvcHBlclNoYWRvdyIsIlQiLCJvbkNoYW5nZSIsIlMiLCJhY3RpdmUiLCJDIiwiTiIsInBvcnRhbCIsIkwiLCJwb3J0YWxUYXJnZXQiLCJSIiwiQSIsIkhUTUxFbGVtZW50IiwieiIsIkkiLCJYIiwidXNlUmVmIiwiRCIsIkgiLCJZIiwiayIsInVzZU1lbW8iLCJkZWZhdWx0QXJyb3ciLCJWIiwidXNlQ2FsbGJhY2siLCJjdXJyZW50Iiwic3R5bGUiLCJ0cmFuc2l0aW9uIiwicGFyZW50Tm9kZSIsIlciLCJkaXNwbGF5IiwiaGVpZ2h0IiwidmlzaWJpbGl0eSIsImxlZnQiLCJ0b3AiLCJ3aWxsQ2hhbmdlIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiZGF0YSIsImlzVmFsaWRQb3J0YWxUYXJnZXQiLCJ1c2VFZmZlY3QiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJjb250YWlucyIsInJlbW92ZUNoaWxkIiwidHlwZSIsInRhcmdldCIsImYiLCJhZGRFdmVudExpc3RlbmVyIiwid2luZG93IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIkpTT04iLCJzdHJpbmdpZnkiLCJyZWZyZXNoUG9zaXRpb24iLCJxIiwiRnJhZ21lbnQiLCJyZWYiLCJpc1ZhbGlkRWxlbWVudCIsImNoaWxkcmVuIiwiY2xhc3NOYW1lIiwiY29uY2F0IiwiY2xvbmVFbGVtZW50IiwicmVtb3ZlVHJhbnNpdGlvbiIsInNldFRpbWVvdXQiLCJGdW5jdGlvbiIsImNyZWF0ZVBvcnRhbCIsInBhZ2VYT2Zmc2V0IiwiY29tcGF0TW9kZSIsInNjcm9sbExlZnQiLCJkb2N1bWVudEVsZW1lbnQiLCJzY3JvbGxUb3AiLCJwYWdlWU9mZnNldCIsIndpZHRoIiwicmlnaHQiLCJib3R0b20iLCJjbGllbnRIZWlnaHQiLCJjbGllbnRXaWR0aCIsIkYiLCJKIiwidHJhbnNmb3JtIiwibWF0Y2giLCJtYXAiLCJOdW1iZXIiLCJCIiwiVSIsIiQiLCJHIiwic3BsaXQiLCJLIiwiUSIsIloiLCJfIiwidHQiLCJldCIsInJ0Iiwib3QiLCJudCIsIml0IiwiYXQiLCJsdCIsImN0IiwidXQiLCJmdCIsInN0IiwiZHQiLCJwdCIsImh0IiwibXQiLCJ2dCIsImJ0IiwieXQiLCJndCIsInd0IiwiT3QiLCJFdCIsIlB0IiwianQiLCJzZXRBdHRyaWJ1dGUiLCJ4dCIsImRpcmVjdGlvbiIsInNjcm9sbCIsInNjcm9sbGFibGVQYXJlbnRzIiwiZXZlbnQiLCJnZXRUcmFuc2Zvcm0iLCJtaXJyb3IiLCJNYXRoIiwicm91bmQiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ0YWdOYW1lIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImluY2x1ZGVzIiwic2Nyb2xsSGVpZ2h0Iiwib3ZlcmZsb3dYIiwic2Nyb2xsV2lkdGgiLCJvdmVyZmxvd1kiLCJhYnMiLCJmb3J3YXJkUmVmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-element-popper/build/browser.min.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-multi-date-picker/build/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-multi-date-picker/build/index.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$(), _s3 = $RefreshSig$(), _s4 = $RefreshSig$(), _s5 = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: !0\n}));\nvar e = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"), r = __webpack_require__(/*! react-element-popper */ \"(app-pages-browser)/./node_modules/react-element-popper/build/browser.min.js\"), t = __webpack_require__(/*! react-date-object */ \"(app-pages-browser)/./node_modules/react-date-object/dist/index.module.js\");\nfunction n(e) {\n    return e && \"object\" == typeof e && \"default\" in e ? e : {\n        default: e\n    };\n}\nvar a = n(e), o = n(r), d = n(t);\nfunction i(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var n = Object.getOwnPropertySymbols(e);\n        r && (n = n.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, n);\n    }\n    return t;\n}\nfunction l(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? i(Object(t), !0).forEach(function(r) {\n            u(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : i(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction u(e, r, t) {\n    return r in e ? Object.defineProperty(e, r, {\n        value: t,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n    }) : e[r] = t, e;\n}\nfunction c() {\n    return (c = Object.assign ? Object.assign.bind() : function(e) {\n        for(var r = 1; r < arguments.length; r++){\n            var t = arguments[r];\n            for(var n in t)Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);\n        }\n        return e;\n    }).apply(this, arguments);\n}\nfunction s(e, r) {\n    if (null == e) return {};\n    var t, n, a = function(e, r) {\n        if (null == e) return {};\n        var t, n, a = {}, o = Object.keys(e);\n        for(n = 0; n < o.length; n++)t = o[n], r.indexOf(t) >= 0 || (a[t] = e[t]);\n        return a;\n    }(e, r);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        for(n = 0; n < o.length; n++)t = o[n], r.indexOf(t) >= 0 || Object.prototype.propertyIsEnumerable.call(e, t) && (a[t] = e[t]);\n    }\n    return a;\n}\nfunction f(e, r) {\n    return function(e) {\n        if (Array.isArray(e)) return e;\n    }(e) || function(e, r) {\n        var t = null == e ? null : \"undefined\" != typeof Symbol && e[Symbol.iterator] || e[\"@@iterator\"];\n        if (null == t) return;\n        var n, a, o = [], d = !0, i = !1;\n        try {\n            for(t = t.call(e); !(d = (n = t.next()).done) && (o.push(n.value), !r || o.length !== r); d = !0);\n        } catch (e) {\n            i = !0, a = e;\n        } finally{\n            try {\n                d || null == t.return || t.return();\n            } finally{\n                if (i) throw a;\n            }\n        }\n        return o;\n    }(e, r) || m(e, r) || function() {\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }();\n}\nfunction p(e) {\n    return function(e) {\n        if (Array.isArray(e)) return h(e);\n    }(e) || function(e) {\n        if (\"undefined\" != typeof Symbol && null != e[Symbol.iterator] || null != e[\"@@iterator\"]) return Array.from(e);\n    }(e) || m(e) || function() {\n        throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }();\n}\nfunction m(e, r) {\n    if (e) {\n        if (\"string\" == typeof e) return h(e, r);\n        var t = Object.prototype.toString.call(e).slice(8, -1);\n        return \"Object\" === t && e.constructor && (t = e.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(e) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? h(e, r) : void 0;\n    }\n}\nfunction h(e, r) {\n    (null == r || r > e.length) && (r = e.length);\n    for(var t = 0, n = new Array(r); t < r; t++)n[t] = e[t];\n    return n;\n}\nfunction y(e, r) {\n    var t = \"undefined\" != typeof Symbol && e[Symbol.iterator] || e[\"@@iterator\"];\n    if (!t) {\n        if (Array.isArray(e) || (t = m(e)) || r && e && \"number\" == typeof e.length) {\n            t && (e = t);\n            var n = 0, a = function() {};\n            return {\n                s: a,\n                n: function() {\n                    return n >= e.length ? {\n                        done: !0\n                    } : {\n                        done: !1,\n                        value: e[n++]\n                    };\n                },\n                e: function(e) {\n                    throw e;\n                },\n                f: a\n            };\n        }\n        throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    var o, d = !0, i = !1;\n    return {\n        s: function() {\n            t = t.call(e);\n        },\n        n: function() {\n            var e = t.next();\n            return d = e.done, e;\n        },\n        e: function(e) {\n            i = !0, o = e;\n        },\n        f: function() {\n            try {\n                d || null == t.return || t.return();\n            } finally{\n                if (i) throw o;\n            }\n        }\n    };\n}\nfunction g(e) {\n    return Array.isArray(e);\n}\nfunction b(r) {\n    _s();\n    var t = r.state.date, n = t.calendar, o = t.locale, i = r.customWeekDays, l = r.weekStartDayIndex, u = r.displayWeekNumbers, c = r.weekNumber, s = e.useMemo(function() {\n        var e = i;\n        return g(e) && e.length >= 7 ? (e.length = 7, e = e.map(function(e) {\n            return g(e) & e.length > 1 ? e = e[1] : g(e) && (e = e[0]), e;\n        })) : e = new d.default({\n            year: 1,\n            calendar: n,\n            locale: o\n        }).weekDays.map(function(e) {\n            return e.shortName;\n        }), e;\n    }, [\n        n,\n        o,\n        i\n    ]);\n    return s = p(s).slice(l).concat(p(s).splice(0, l)), a.default.createElement(\"div\", {\n        className: \"rmdp-week\"\n    }, u && a.default.createElement(\"div\", {\n        className: \"rmdp-week-day\"\n    }, c), s.map(function(e, r) {\n        return a.default.createElement(\"div\", {\n            key: r,\n            className: \"rmdp-week-day\"\n        }, e);\n    }));\n}\n_s(b, \"JxNLKG1yv0BXSYqRYIzOo7q8eG8=\");\nfunction v(e, r) {\n    var t = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];\n    if (!e || !r) return !1;\n    if (e.year === r.year) {\n        if (n) return !0;\n        if (e.monthIndex === r.monthIndex) return !!t || e.day === r.day;\n    }\n}\nfunction x(e) {\n    var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : \"YYYY/MM/DD\";\n    return e.format(r);\n}\nfunction w(e, r, t) {\n    var n = t.multiple, a = t.range, o = t.selectedDate, i = t.onlyMonthPicker, l = t.onlyYearPicker, u = t.format, c = t.focused, s = t.weekPicker;\n    e.setFormat(u);\n    var m = new d.default(e);\n    return [\n        o = n && a ? function() {\n            var e = !0;\n            g(o) || (o = [\n                [\n                    o\n                ]\n            ]);\n            var r = o.find(function(e) {\n                return 1 === e.length;\n            }), t = i ? \"YYYY/MM\" : \"YYYY/MM/DD\", n = o;\n            if (r) {\n                var a = r[0];\n                n = n.filter(function(e) {\n                    if (1 === e.length) return !0;\n                    var r = f(e, 2), n = r[0], o = r[1], d = f([\n                        a,\n                        m\n                    ].sort(function(e, r) {\n                        return e - r;\n                    }), 2), i = f([\n                        n,\n                        o,\n                        d[0],\n                        d[1]\n                    ].map(function(e) {\n                        return x(e, t);\n                    }), 4), l = i[0], u = i[1], c = i[2], s = i[3];\n                    return !(c <= l && s >= u || c >= l && s >= u && c <= u || c <= l && s <= u && s >= l);\n                });\n            } else n = n.filter(function(e) {\n                if (!g(e)) return !0;\n                if (0 === e.length) return !1;\n                var r = f(e, 2), n = f([\n                    r[0],\n                    r[1],\n                    m\n                ].map(function(e) {\n                    return x(e, t);\n                }), 3), a = n[0], o = n[1], d = n[2];\n                return !(d >= a && d <= o);\n            });\n            n = n.map(function(r) {\n                var t;\n                return g(r) ? 1 === r.length ? (e = !1, t = r.concat(m)) : t = r : (e = !1, t = [\n                    r,\n                    m\n                ]), t.sort(function(e, r) {\n                    return e - r;\n                });\n            }), e && (n = [].concat(p(n), [\n                [\n                    m\n                ]\n            ]));\n            return n;\n        }() : n ? function() {\n            var t = o.filter(function(r) {\n                return !v(e, r, i, l);\n            });\n            t.length === o.length ? t.push(m) : m = t.find(function(e) {\n                return v(e, c);\n            });\n            r && t.sort(function(e, r) {\n                return e - r;\n            });\n            return t;\n        }() : a ? function() {\n            if (s) return [\n                new d.default(m).toFirstOfWeek(),\n                new d.default(m).toLastOfWeek()\n            ];\n            if (2 === o.length || 0 === o.length) return [\n                m\n            ];\n            if (1 === o.length) return [\n                o[0],\n                m\n            ].sort(function(e, r) {\n                return e - r;\n            });\n        }() : m,\n        m\n    ];\n}\nfunction k(e, r, t, n) {\n    var a = [], o = t ? \"YYYY/MM\" : \"YYYY/MM/DD\", d = x(e, o);\n    function i(r) {\n        var n = r[0], i = r[1];\n        if (1 === r.length) v(e, n, t) && a.push(\"rmdp-range\");\n        else if (2 === r.length) {\n            var l = f([\n                n,\n                i\n            ].map(function(e) {\n                return x(e, o);\n            }), 2), u = l[0], c = l[1];\n            d >= u && d <= c && a.push(\"rmdp-range\"), d === u && a.push(\"start\"), d === c && a.push(\"end\");\n        }\n    }\n    return n ? (g(r) ? r : [\n        [\n            r\n        ]\n    ]).forEach(i) : i(r), a.join(\" \");\n}\nfunction D(e, r, t, n) {\n    var a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : \"day\", o = [];\n    if (n && 1 === (null == r ? void 0 : r.length) && t) {\n        var d = \"day\" === a ? \"YYYY/MM/DD\" : \"YYYY/MM\", i = t.format(d), l = r[0].format(d), u = e.format(d);\n        (u > l && u <= i || u < l && u >= i) && (o.push(\"rmdp-range-hover\"), u === i && o.push(i > l ? \"end\" : \"start\"));\n    }\n    return o;\n}\n_c = D;\nvar O;\nfunction E(r) {\n    _s1();\n    var t = r.state, n = r.setState, o = r.onChange, i = r.showOtherDays, s = void 0 !== i && i, p = r.mapDays, m = r.onlyShowInRangeDates, h = r.customWeekDays, y = r.sort, g = r.numberOfMonths, x = r.isRTL, E = r.weekStartDayIndex, Y = r.handleFocusedDate, M = r.hideWeekDays, C = r.fullYear, N = f(r.monthAndYears, 1)[0], P = r.displayWeekNumbers, S = r.weekNumber, I = void 0 === S ? \"\" : S, j = r.rangeHover, T = r.highlightToday, A = e.useRef({}), R = e.useRef(), L = t.today, F = t.minDate, W = t.maxDate, B = t.range, _ = t.multiple, V = t.date, z = t.selectedDate, H = t.onlyMonthPicker, q = t.onlyYearPicker, J = !H && !q, K = f(e.useState(), 2), U = K[0], $ = K[1], G = _ || B ? (null == z ? void 0 : z.length) > 0 : !!z;\n    A.current.date = V;\n    var Q = e.useMemo(function() {\n        return J ? function(e, r, t, n) {\n            if (!e) return [];\n            for(var a = [], o = 0; o < t; o++){\n                var i = (e = new d.default(e).toFirstOfMonth()).monthIndex, l = [];\n                e.toFirstOfWeek().add(n, \"day\"), e.monthIndex === i && e.day > 1 && e.subtract(7, \"days\");\n                for(var u = 0; u < 6; u++){\n                    for(var c = [], s = 0; s < 7; s++)c.push({\n                        date: new d.default(e),\n                        day: e.format(\"D\"),\n                        current: e.monthIndex === i\n                    }), e.day += 1;\n                    if (l.push(c), u > 2 && e.monthIndex !== i && !r) break;\n                }\n                a.push(l);\n            }\n            return a;\n        }(A.current.date, s, g, E) : [];\n    }, [\n        V.monthIndex,\n        V.year,\n        V.calendar,\n        V.locale,\n        J,\n        s,\n        g,\n        E\n    ]);\n    return J && a.default.createElement(\"div\", {\n        ref: R,\n        className: \"rmdp-day-picker \".concat(C ? \"rmdp-full-year\" : \"\"),\n        style: {\n            display: C ? \"grid\" : \"flex\"\n        },\n        onMouseLeave: function() {\n            return j && $();\n        }\n    }, Q.map(function(e, r) {\n        return a.default.createElement(\"div\", {\n            key: r,\n            style: u({}, x ? \"marginLeft\" : \"marginRight\", r + (C ? 0 : 1) < g ? \"10px\" : \"\")\n        }, C && a.default.createElement(\"div\", {\n            className: \"rmdp-month-name\"\n        }, N[r]), !M && a.default.createElement(b, {\n            state: t,\n            customWeekDays: h,\n            weekStartDayIndex: E,\n            displayWeekNumbers: P,\n            weekNumber: I\n        }), e.map(function(e, i) {\n            return a.default.createElement(\"div\", {\n                key: i,\n                className: \"rmdp-week\"\n            }, P && a.default.createElement(\"div\", {\n                className: \"rmdp-day rmdp-disabled\"\n            }, a.default.createElement(\"span\", null, e[0].date.format(\"WW\"))), e.map(function(e, i) {\n                var u = function(e) {\n                    if (!e.current && !s) return {};\n                    var r = {};\n                    return p.forEach(function(n) {\n                        var a, o = n({\n                            date: e.date,\n                            today: L,\n                            currentMonth: t.date.month,\n                            selectedDate: t.selectedDate,\n                            isSameDate: v\n                        });\n                        (null === (a = o) || void 0 === a ? void 0 : a.constructor) !== Object && (o = {}), (o.disabled || o.hidden) && (e.disabled = !0), o.hidden && (e.hidden = !0), r = l(l({}, r), o);\n                    }), delete r.disabled, delete r.hidden, r;\n                }(e = {\n                    date: e.date,\n                    day: e.day,\n                    current: e.current\n                }), h = X(e) && !e.disabled, b = \"\".concat(h ? \"sd\" : \"\"), x = u.children;\n                h && (b = \"\".concat(b, \" \").concat(u.className || \"\")), delete u.className, delete u.children;\n                var E = function(e, r) {\n                    var t = [\n                        \"rmdp-day\"\n                    ], n = e.date, a = e.hidden, o = e.current;\n                    if (!X(e) || a) t.push(\"rmdp-day-hidden\");\n                    else {\n                        (F && n < F || W && n > W || e.disabled) && (t.push(\"rmdp-disabled\"), e.disabled || (e.disabled = !0)), o || t.push(\"rmdp-deactive\");\n                        var d = r > 1 && o || 1 === r;\n                        e.disabled && m || (v(n, L) && T && t.push(\"rmdp-today\"), i = n, [].concat(z).some(function(e) {\n                            return v(e, i);\n                        }) && d && !B && t.push(\"rmdp-selected\")), B && !e.disabled && d && (t.push(k(n, z, void 0, _)), _ || (t = t.concat(D(n, z, U, j))));\n                    }\n                    var i;\n                    return t.join(\" \");\n                }(e, g);\n                (e.hidden || e.disabled) && (b = b.replace(\"sd\", \"\"));\n                var M = G ? E.includes(\"selected\") || E.includes(\"range\") : E.includes(\"today\");\n                return a.default.createElement(\"div\", {\n                    key: i,\n                    tabIndex: M ? 0 : -1,\n                    \"aria-label\": \"Choose \".concat(e.date.format(\"dddd MMMM DD of YYYY\")),\n                    className: E,\n                    onMouseEnter: function() {\n                        return j && $(e.date);\n                    },\n                    onKeyDown: function(r) {\n                        return function(e, r) {\n                            var a = e.currentTarget, o = e.key, i = e.code, u = {\n                                ArrowRight: 1,\n                                ArrowLeft: -1,\n                                ArrowUp: -7,\n                                ArrowDown: 7\n                            };\n                            if (\"Space\" === i || \" \" === o) e.preventDefault(), a.click();\n                            else if (Object.keys(u).includes(o)) {\n                                var c = function(e) {\n                                    if (!e) return s();\n                                    var r = e.getAttribute(\"class\");\n                                    r.includes(\"hidden\") || r.includes(\"disabled\") ? s() : e.focus();\n                                }, s = function() {\n                                    n(l(l({}, t), {}, {\n                                        date: p\n                                    })), clearTimeout(O), O = setTimeout(function() {\n                                        return c(Z(p));\n                                    }, 100);\n                                };\n                                e.preventDefault();\n                                var f = u[o], p = new d.default(r.date).add(f, \"day\"), m = Z(p);\n                                c(m);\n                            }\n                        }(r, e);\n                    },\n                    onClick: function() {\n                        X(e) && !e.disabled && function(e, r, n) {\n                            var a, i, u, c = e.date, s = e.current, p = t.selectedDate, m = t.focused, h = t.date, g = h, b = g.hour, v = g.minute, x = g.second;\n                            c.set({\n                                hour: (null === (a = p) || void 0 === a ? void 0 : a.hour) || b,\n                                minute: (null === (i = p) || void 0 === i ? void 0 : i.minute) || v,\n                                second: (null === (u = p) || void 0 === u ? void 0 : u.second) || x\n                            }), 1 !== n || s ? n > 1 && !s && (0 === r && c < h && (h = new d.default(h).toFirstOfMonth()), r > 0 && c.monthIndex > h.monthIndex + r && r + 1 === n && (h = new d.default(h).toFirstOfMonth().add(1, \"month\"))) : h = new d.default(h).toFirstOfMonth();\n                            var k = f(w(c, y, t), 2);\n                            p = k[0], m = k[1], o(p, l(l({}, t), {}, {\n                                date: h,\n                                focused: m,\n                                selectedDate: p\n                            })), Y(m, c);\n                        }(e, r, g);\n                    }\n                }, a.default.createElement(\"span\", c({\n                    className: b\n                }, u), X(e) && !e.hidden ? null != x ? x : e.day : \"\"));\n            }));\n        }));\n    }));\n    function X(e) {\n        return !!e.current || s;\n    }\n    function Z(e) {\n        return R.current.querySelector(\"[aria-label*='\".concat(e.format(\"dddd MMMM DD of YYYY\"), \"']\"));\n    }\n}\n_s1(E, \"8MMh9Kszj9DPwvViKNVnd76j1A4=\");\n_c1 = E;\nfunction Y(e) {\n    var r = e.direction, t = e.onClick, n = e.disabled;\n    return a.default.createElement(\"button\", {\n        type: \"button\",\n        className: \"rmdp-arrow-container \".concat(r, \" \").concat(n ? \"disabled\" : \"\"),\n        onClick: t,\n        \"aria-roledescription\": \"button to navigate \".concat(r.replace(\"rmdp-\", \"\"))\n    }, a.default.createElement(\"i\", {\n        className: \"rmdp-arrow\"\n    }));\n}\n_c2 = Y;\nfunction M(r) {\n    var t = r.state, n = r.setState, o = r.disableYearPicker, d = r.disableMonthPicker, i = r.buttons, u = r.renderButton, c = r.handleMonthChange, s = r.disabled, p = r.hideMonth, m = r.hideYear, h = r.isRTL, y = r.fullYear, g = f(r.monthAndYears, 2), b = g[0], v = g[1], x = r.monthYearSeparator, w = r.formatMonth, k = r.formatYear, D = r.headerOrder, O = {}, E = t.date, M = t.onlyMonthPicker, C = t.onlyYearPicker, N = t.mustShowYearPicker, P = t.minDate, S = t.maxDate, I = t.year, j = t.today, T = P && E.year <= P.year && P.monthIndex > E.monthIndex - 1, A = S && E.year >= S.year && S.monthIndex < E.monthIndex + 1, R = j.year + 7;\n    if (R -= 12 * Math.floor((R - I) / 12), (p || y) && m && !i) return null;\n    if ((M || y) && (P && P.year >= E.year && (T = !0), S && S.year <= E.year && (A = !0)), N || C) {\n        var L = R - 11;\n        T = P && P.year > L, A = S && S.year < R;\n    }\n    return s && (T = !0, A = !0), a.default.createElement(\"div\", {\n        className: \"rmdp-header\"\n    }, a.default.createElement(\"div\", {\n        style: {\n            position: \"relative\",\n            display: \"flex\",\n            alignItems: \"center\"\n        }\n    }, Array.from(new Set(D)).map(function(r, t) {\n        return a.default.createElement(e.Fragment, {\n            key: t\n        }, function(r) {\n            switch(r){\n                case \"LEFT_BUTTON\":\n                    return i && W(\"left\");\n                case \"RIGHT_BUTTON\":\n                    return i && W(\"right\");\n                case \"MONTH_YEAR\":\n                case \"YEAR_MONTH\":\n                    if (y) return a.default.createElement(\"div\", {\n                        className: \"rmdp-header-values\",\n                        style: O\n                    }, !m && E.format(\"YYYY\"));\n                    var t = r.split(\"_\").filter(function(e) {\n                        return \"MONTH\" === e && !p || \"YEAR\" === e && !m;\n                    });\n                    return t.length > 1 && (t = [\n                        t[0],\n                        F(),\n                        t[1]\n                    ]), b.map(function(r, n) {\n                        return a.default.createElement(\"div\", {\n                            key: n,\n                            className: \"rmdp-header-values\",\n                            style: O\n                        }, t.map(function(t, i) {\n                            return a.default.createElement(e.Fragment, {\n                                key: i\n                            }, function(e, r, t) {\n                                switch(e){\n                                    case \"MONTH\":\n                                        return a.default.createElement(\"span\", {\n                                            style: {\n                                                cursor: s || d || M ? \"default\" : \"pointer\"\n                                            },\n                                            onClick: function() {\n                                                return !d && _(\"mustShowMonthPicker\");\n                                            }\n                                        }, function(e, r) {\n                                            return \"function\" == typeof w ? w(e, r) : e;\n                                        }(r, v[t]));\n                                    case \"YEAR\":\n                                        return a.default.createElement(\"span\", {\n                                            style: {\n                                                cursor: s || o || C ? \"default\" : \"pointer\"\n                                            },\n                                            onClick: function() {\n                                                return !o && _(\"mustShowYearPicker\");\n                                            }\n                                        }, function(e, r) {\n                                            return \"function\" == typeof w ? k(e, r) : e;\n                                        }(v[t], r));\n                                    default:\n                                        return e;\n                                }\n                            }(t, r, n));\n                        }));\n                    });\n                default:\n                    return;\n            }\n        }(r));\n    })));\n    function F() {\n        return x ? a.default.createElement(\"span\", null, x) : h ? \"،\" : \",\";\n    }\n    function W(r) {\n        var t = function(e) {\n            e.preventDefault(), B(\"right\" === r ? 1 : -1), function(e) {\n                setTimeout(function() {\n                    var r = e.target.closest(\".rmdp-calendar\");\n                    if (r) {\n                        var t = r.querySelector(\"div[tabindex='0']\");\n                        t && t.getAttribute(\"class\").includes(\"hidden\") && (t.setAttribute(\"tabindex\", \"-1\"), t = void 0), t || (t = r.querySelector(\"div[tabindex='-1']:not(.rmdp-day-hidden)\")) && t.setAttribute(\"tabindex\", \"0\");\n                    }\n                }, 200);\n            }(e);\n        }, n = \"left\" === r && T || \"right\" === r && A;\n        return u instanceof Function ? u(r, t, n) : e.isValidElement(u) ? e.cloneElement(u, {\n            direction: r,\n            handleClick: t,\n            disabled: n\n        }) : a.default.createElement(Y, {\n            direction: \"rmdp-\".concat(r),\n            onClick: t,\n            disabled: n\n        });\n    }\n    function B(e) {\n        s || e < 0 && T || e > 0 && A || (y ? E.year += e : N || C ? (I += 12 * e, e < 0 && P && I < P.year && (I = P.year), e > 0 && S && I > S.year && (I = S.year)) : (E.toFirstOfMonth(), M ? E.year += e : (E.month += e, c(E))), n(l(l({}, t), {}, {\n            date: E,\n            year: I\n        })));\n    }\n    function _(e) {\n        if (!s) {\n            var r = {\n                mustShowMonthPicker: !1,\n                mustShowYearPicker: !1\n            };\n            r[e] = !t[e], n(l(l({}, t), r));\n        }\n    }\n}\n_c3 = M;\nfunction C(e) {\n    return g(e) || (e = []), JSON.stringify(e);\n}\n_c4 = C;\nfunction N(r) {\n    _s2();\n    var t = r.state, n = r.onChange, o = r.customMonths, i = r.sort, u = r.handleMonthChange, c = r.handleFocusedDate, s = r.rangeHover, p = r.highlightToday, m = r.numberOfMonths, h = t.date, y = t.today, b = t.minDate, x = t.maxDate, O = t.calendar, E = t.locale, Y = t.onlyMonthPicker, M = t.onlyYearPicker, N = t.range, P = t.onlyShowInRangeDates, S = (t.mustShowMonthPicker || Y) && !M, I = f(e.useState(), 2), j = I[0], T = I[1];\n    o = o && C(o);\n    var A = e.useMemo(function() {\n        var e = [], r = Y ? m : 1, n = o && JSON.parse(o), a = new d.default({\n            calendar: O,\n            locale: E,\n            format: t.date._format,\n            year: t.date.year,\n            month: 1,\n            day: 1\n        });\n        g(n) && n.length >= 12 ? (n.length = 12, n = n.map(function(e) {\n            return g(e) ? e[0] : e;\n        })) : n = a.locale.months.map(function(e) {\n            return f(e, 1)[0];\n        });\n        for(var i = 0; i < r; i++){\n            for(var l = [], u = 0, c = 0; c < 4; c++){\n                for(var s = [], p = 0; p < 3; p++)s.push({\n                    date: new d.default(a),\n                    name: n[u]\n                }), u++, a.add(1, \"month\");\n                l.push(s);\n            }\n            e.push(l);\n        }\n        return e;\n    }, [\n        O,\n        E,\n        o,\n        t.date.year,\n        t.date._format,\n        m,\n        Y\n    ]);\n    return a.default.createElement(\"div\", {\n        className: \"\".concat(Y ? \"only \" : \"\", \"rmdp-month-picker\"),\n        style: {\n            display: S ? \"flex\" : \"none\"\n        },\n        onMouseLeave: function() {\n            return s && T();\n        }\n    }, A.map(function(e, r) {\n        return a.default.createElement(\"div\", {\n            key: r,\n            style: {\n                margin: \"0 5px\",\n                flex: 1\n            }\n        }, e.map(function(e, r) {\n            return a.default.createElement(\"div\", {\n                key: r,\n                className: \"rmdp-ym\"\n            }, e.map(function(e, r) {\n                var t = e.date, n = e.name;\n                return a.default.createElement(\"div\", {\n                    key: r,\n                    className: L(t),\n                    onClick: function() {\n                        return R(t);\n                    },\n                    onMouseEnter: function() {\n                        return s && T(t);\n                    }\n                }, a.default.createElement(\"span\", {\n                    className: Y ? \"sd\" : \"\"\n                }, n));\n            }));\n        }));\n    }));\n    function R(e) {\n        var r = t.selectedDate, a = t.focused, o = e.year, d = e.monthIndex;\n        if (!(b && o <= b.year && d < b.monthIndex || x && o >= x.year && d > x.monthIndex)) {\n            if (h.setMonth(d + 1), Y) {\n                var s = f(w(e, i, t), 2);\n                r = s[0], a = s[1];\n            } else u(h);\n            n(Y ? r : void 0, l(l({}, t), {}, {\n                date: h,\n                focused: a,\n                selectedDate: r,\n                mustShowMonthPicker: !1\n            })), Y && c(a, e);\n        }\n    }\n    function L(e) {\n        var r = [\n            \"rmdp-day\"\n        ], n = e.year, a = e.monthIndex, o = t.selectedDate, d = t.multiple;\n        if ((b && (n < b.year || n === b.year && a < b.monthIndex) || x && (n > x.year || n === x.year && a > x.monthIndex)) && r.push(\"rmdp-disabled\"), !r.includes(\"rmdp-disabled\") || !P) return v(y, e, !0) && p && r.push(\"rmdp-today\"), Y ? N ? (r.push(k(e, o, !0, d)), d || (r = r.concat(D(e, o, j, s, \"month\")))) : [].concat(o).some(function(r) {\n            return v(r, e, !0);\n        }) && r.push(\"rmdp-selected\") : h.monthIndex === a && r.push(\"rmdp-selected\"), r.join(\" \");\n    }\n}\n_s2(N, \"MKGIpT0ZP57Hx4mYtHWkVh8KlIg=\");\n_c5 = N;\nfunction P(e, r) {\n    return e.replace(/[0-9]/g, function(e) {\n        return r[e];\n    });\n}\n_c6 = P;\nfunction S(r) {\n    _s3();\n    var t = r.state, n = r.onChange, o = r.sort, i = r.handleFocusedDate, u = r.onYearChange, c = r.rangeHover, s = r.highlightToday, p = t.date, m = t.today, h = t.minDate, y = t.maxDate, b = t.onlyYearPicker, v = t.range, x = t.onlyShowInRangeDates, k = t.year, D = t.mustShowYearPicker || b, O = p.digits, E = f(e.useState(), 2), Y = E[0], M = E[1], C = m.year - 4;\n    C -= 12 * Math.ceil((C - k) / 12);\n    var N = e.useMemo(function() {\n        for(var e = [], r = C, t = 0; t < 4; t++){\n            for(var n = [], a = 0; a < 3; a++)n.push(r), r++;\n            e.push(n);\n        }\n        return e;\n    }, [\n        C\n    ]);\n    return a.default.createElement(\"div\", {\n        className: \"\".concat(b ? \"only \" : \"\", \"rmdp-year-picker\"),\n        style: {\n            display: D ? \"block\" : \"none\"\n        }\n    }, N.map(function(e, r) {\n        return a.default.createElement(\"div\", {\n            key: r,\n            className: \"rmdp-ym\",\n            onMouseLeave: function() {\n                return c && M();\n            }\n        }, e.map(function(e, r) {\n            return a.default.createElement(\"div\", {\n                key: r,\n                className: S(e),\n                onClick: function() {\n                    return function(e) {\n                        if (I(e)) return;\n                        var r = new d.default(t.date).setYear(e), a = t.selectedDate, c = t.focused;\n                        if (b) {\n                            var s = f(w(r, o, t), 2);\n                            a = s[0], c = s[1];\n                        } else h && r.monthIndex < h.monthIndex ? r = r.setMonth(h.monthIndex + 1) : y && r.monthIndex > y.monthIndex && (r = r.setMonth(y.monthIndex + 1)), null == u || u(r);\n                        n(b ? a : void 0, l(l({}, t), {}, {\n                            date: r,\n                            focused: c,\n                            selectedDate: a,\n                            mustShowYearPicker: !1\n                        })), b && i(c, r);\n                    }(e);\n                },\n                onMouseEnter: function() {\n                    return c && M(e);\n                }\n            }, a.default.createElement(\"span\", {\n                className: b ? \"sd\" : \"\"\n            }, P(e.toString(), O)));\n        }));\n    }));\n    function S(e) {\n        var r = [\n            \"rmdp-day\"\n        ], n = t.date, a = t.selectedDate, o = t.multiple;\n        if (I(e) && r.push(\"rmdp-disabled\"), !r.includes(\"rmdp-disabled\") || !x) {\n            if (m.year === e && s && r.push(\"rmdp-today\"), b) if (v) {\n                var d = function(t) {\n                    var n = t[0], a = t[1];\n                    if (1 === t.length) {\n                        if (e === n.year && r.push(\"rmdp-range\"), c) {\n                            var o = t[0].year;\n                            (e > o && e <= Y || e < o && e >= Y) && (r.push(\"rmdp-range-hover\"), e === Y && r.push(Y > o ? \"end\" : \"start\"));\n                        }\n                    } else 2 === t.length && (e >= n.year && e <= a.year && r.push(\"rmdp-range\"), e === n.year && r.push(\"start\"), e === a.year && r.push(\"end\"));\n                };\n                o ? (g(a) ? a : [\n                    [\n                        a\n                    ]\n                ]).forEach(function(e) {\n                    return d(e);\n                }) : d(a);\n            } else [].concat(a).some(function(r) {\n                return r && r.year === e;\n            }) && r.push(\"rmdp-selected\");\n            else e === n.year && r.push(\"rmdp-selected\");\n            return r.join(\" \");\n        }\n    }\n    function I(e) {\n        return h && e < h.year || y && e > y.year;\n    }\n}\n_s3(S, \"JfU+JMq/NhmvCvVj7D9tEwjUh7o=\");\n_c7 = S;\nfunction I(e, r, t) {\n    return t || (e ? \"MM/YYYY\" : r ? \"YYYY\" : \"YYYY/MM/DD\");\n}\n_c8 = I;\nfunction j(e, r) {\n    return e instanceof d.default ? e.setCalendar(r) : e = new d.default({\n        date: e,\n        calendar: r\n    }), e;\n}\nfunction T(e) {\n    \"_self\" in a.default.createElement(\"div\") && console.warn(e.join(\"\\n\"));\n}\n_c9 = T;\nvar A = new d.default, R = A.calendar, L = A.locale;\nfunction F(e, r) {\n    return e && e.constructor !== Object && (T(W(\"calendar\")), e = void 0), r && r.constructor !== Object && (T(W(\"locale\")), r = void 0), [\n        e || R,\n        r || L\n    ];\n}\n_c10 = F;\nfunction W(e) {\n    return [\n        \"\".concat(e, \" must be an object\"),\n        \"https://shahabyazdi.github.io/react-multi-date-picker/calendars/\"\n    ];\n}\n_c11 = W;\nfunction B(e) {\n    return e && e.name ? e.name.split(\"_\")[1] : \"\";\n}\n_c12 = B;\nfunction _(e) {\n    return [\n        \"fa\",\n        \"ar\"\n    ].includes(B(e));\n}\nfunction V(e, r) {\n    void 0 === r && (r = {});\n    var t = r.insertAt;\n    if (e && \"undefined\" != typeof document) {\n        var n = document.head || document.getElementsByTagName(\"head\")[0], a = document.createElement(\"style\");\n        a.type = \"text/css\", \"top\" === t && n.firstChild ? n.insertBefore(a, n.firstChild) : n.appendChild(a), a.styleSheet ? a.styleSheet.cssText = e : a.appendChild(document.createTextNode(e));\n    }\n}\n_c13 = V;\nV(\".rmdp-wrapper{background-color:#fff;border-radius:5px;direction:ltr;text-align:center;width:max-content}.rmdp-shadow{box-shadow:0 0 5px #8798ad}.rmdp-border{border:1px solid #cfd8e2}.rmdp-calendar{height:max-content;padding:4px}.rmdp-border-top{border-top:1px solid #cfd8e2}.rmdp-border-bottom{border-bottom:1px solid #cfd8e2}.rmdp-border-left{border-left:1px solid #cfd8e2}.rmdp-border-right{border-right:1px solid #cfd8e2}.rmdp-week,.rmdp-ym{display:flex;justify-content:space-between}.rmdp-ym{height:25%}.rmdp-day,.rmdp-week-day{color:#000;cursor:pointer;height:34px;position:relative;width:34px}.rmdp-week-day{color:#0074d9;cursor:default;font-size:13px;font-weight:500}.rmdp-day span,.rmdp-week-day{display:flex;flex-direction:column;justify-content:center}.rmdp-day span{border-radius:50%;bottom:3px;font-size:14px;left:3px;position:absolute;right:3px;top:3px}.rmdp-day.rmdp-today span{background-color:#7fdbff;color:#fff}.rmdp-day.rmdp-selected span:not(.highlight){background-color:#0074d9;box-shadow:0 0 3px #8798ad;color:#fff}.rmdp-day.rmdp-deactive,.rmdp-day.rmdp-disabled{color:#8798ad}.rmdp-day.rmdp-deactive.rmdp-selected span{background-color:#4ca6f5;box-shadow:0 0 3px #bac5d3}.rmdp-ym .rmdp-day{flex:1;margin:auto}.rmdp-ym .rmdp-day span{border-radius:12px;padding:2px 0}.rmdp-range{background-color:#0074d9;box-shadow:0 0 3px #8798ad;color:#fff}.rmdp-range-hover{background-color:#7ea6f0;color:#fff}.rmdp-range-hover.start,.rmdp-range.start{border-bottom-left-radius:50%;border-top-left-radius:50%}.rmdp-range-hover.end,.rmdp-range.end{border-bottom-right-radius:50%;border-top-right-radius:50%}.rmdp-ym .rmdp-range-hover.start,.rmdp-ym .rmdp-range.start{border-bottom-left-radius:15px;border-top-left-radius:15px}.rmdp-ym .rmdp-range-hover.end,.rmdp-ym .rmdp-range.end{border-bottom-right-radius:15px;border-top-right-radius:15px}.rmdp-day:not(.rmdp-disabled):not(.rmdp-day-hidden) span:hover{background-color:#7ea6f0;color:#fff}.rmdp-day-picker{padding:5px}.rmdp-header{font-size:14px;margin-top:5px;padding:9px 0}.rmdp-month-picker,.rmdp-year-picker{background-color:#fff;border-radius:0 0 5px 5px;bottom:2px;left:2px;position:absolute;right:2px;top:2px}.only.rmdp-month-picker,.only.rmdp-year-picker{height:240px;position:static;width:240px}.rmdp-header-values{color:#000;margin:auto}.rmdp-header-values span{padding:0 0 0 5px}.rmdp-arrow{border:solid #0074d9;border-width:0 2px 2px 0;display:inline-block;height:3px;margin-top:5px;padding:2px;width:3px}.rmdp-right i{margin-right:3px;transform:rotate(-45deg);-webkit-transform:rotate(-45deg)}.rmdp-left i{margin-left:3px;transform:rotate(135deg);-webkit-transform:rotate(135deg)}.rmdp-left{left:0}.rmdp-right{right:0}.rmdp-arrow-container{background:transparent;border:none;border-radius:50%;cursor:pointer;display:flex;height:20px;justify-content:center;margin:0 5px;padding:0;width:20px}.rmdp-arrow-container:hover{background-color:#0074d9;box-shadow:0 0 3px #8798ad}.rmdp-arrow-container:hover .rmdp-arrow{border:solid #fff;border-width:0 2px 2px 0}.rmdp-arrow-container.disabled{cursor:default}.rmdp-arrow-container.disabled:hover{background-color:inherit;box-shadow:inherit}.rmdp-arrow-container.disabled .rmdp-arrow,.rmdp-arrow-container.disabled:hover .rmdp-arrow{border:solid gray;border-width:0 2px 2px 0}.rmdp-rtl{direction:rtl}.rmdp-rtl .rmdp-left i{margin-left:0;margin-right:3px;transform:rotate(-45deg);-webkit-transform:rotate(-45deg)}.rmdp-rtl .rmdp-right i{margin-left:3px;margin-right:0;transform:rotate(135deg);-webkit-transform:rotate(135deg)}.rmdp-rtl .rmdp-right{left:0;right:auto}.rmdp-rtl .rmdp-left{left:auto;right:0}.rmdp-rtl .rmdp-range-hover.start,.rmdp-rtl .rmdp-range.start{border-bottom-left-radius:unset;border-bottom-right-radius:50%;border-top-left-radius:unset;border-top-right-radius:50%}.rmdp-rtl .rmdp-range-hover.end,.rmdp-rtl .rmdp-range.end{border-bottom-left-radius:50%;border-bottom-right-radius:unset;border-top-left-radius:50%;border-top-right-radius:unset}.rmdp-rtl .rmdp-range.start.end{border-radius:50%}.rmdp-rtl .rmdp-ym .rmdp-range-hover.start,.rmdp-rtl .rmdp-ym .rmdp-range.start{border-bottom-right-radius:15px;border-top-right-radius:15px}.rmdp-rtl .rmdp-ym .rmdp-range-hover.end,.rmdp-rtl .rmdp-ym .rmdp-range.end{border-bottom-left-radius:15px;border-top-left-radius:15px}.rmdp-day-hidden,.rmdp-day.rmdp-disabled{cursor:default}.rmdp-selected .highlight{box-shadow:0 0 3px #8798ad}.rmdp-day:not(.rmdp-disabled):not(.rmdp-day-hidden) .highlight-red:hover{background-color:#ff6687}.rmdp-day:not(.rmdp-deactive) .highlight-red{color:#cc0303}.rmdp-day.rmdp-deactive .highlight-red{color:#e08e8e}.rmdp-day.rmdp-selected .highlight-red{background-color:#ea0034;color:#fff}.rmdp-day.rmdp-deactive.rmdp-selected .highlight-red{background-color:#e4b0ba;color:#fff}.rmdp-day:not(.rmdp-disabled):not(.rmdp-day-hidden) .highlight-green:hover{background-color:#4db6ac}.rmdp-day:not(.rmdp-deactive) .highlight-green{color:#00796b}.rmdp-day.rmdp-deactive .highlight-green{color:#7ab3ac}.rmdp-day.rmdp-selected .highlight-green{background-color:#009688;color:#fff}.rmdp-day.rmdp-deactive.rmdp-selected .highlight-green{background-color:#749c98;color:#fff}.rmdp-day-hidden,.rmdp-day-hidden:hover span{background-color:unset;color:transparent}.rmdp-month-name{cursor:default;font-size:14px;margin:3px 0}.rmdp-full-year{grid-template-columns:1fr 1fr 1fr}@media (max-height:450px),(max-width:450px){.rmdp-day,.rmdp-week-day{height:28px;width:28px}.rmdp-day span{font-size:12px;padding-left:.5px}.only.rmdp-month-picker,.only.rmdp-year-picker{height:200px;width:230px}.rmdp-header{padding:3px 0 0}.rmdp-header,.rmdp-month-name{font-size:12px}.rmdp-full-year{grid-template-columns:1fr 1fr}}\");\nvar z = [\n    \"datePickerProps\",\n    \"DatePicker\"\n];\nfunction H(r, t) {\n    _s4();\n    var n, o = r.value, i = r.calendar, u = r.locale, p = r.format, m = r.onlyMonthPicker, h = r.onlyYearPicker, y = r.range, b = void 0 !== y && y, v = r.multiple, x = void 0 !== v && v, w = r.className, k = r.role, D = r.weekDays, O = r.months, Y = r.children, j = r.onChange, T = r.showOtherDays, A = r.minDate, R = r.maxDate, L = r.mapDays, W = r.disableMonthPicker, B = r.disableYearPicker, V = r.formattingIgnoreList, H = r.onReady, q = r.onlyShowInRangeDates, U = void 0 === q || q, $ = r.zIndex, G = void 0 === $ ? 100 : $, Q = r.plugins, X = void 0 === Q ? [] : Q, Z = r.sort, ee = r.numberOfMonths, re = void 0 === ee ? 1 : ee, te = r.currentDate, ne = r.digits, ae = r.buttons, oe = void 0 === ae || ae, de = r.renderButton, ie = r.weekStartDayIndex, le = void 0 === ie ? 0 : ie, ue = r.disableDayPicker, ce = r.onPropsChange, se = r.onMonthChange, fe = r.onYearChange, pe = r.onFocusedDateChange, me = r.readOnly, he = r.disabled, ye = r.hideMonth, ge = r.hideYear, be = r.hideWeekDays, ve = r.shadow, xe = void 0 === ve || ve, we = r.fullYear, ke = r.displayWeekNumbers, De = r.weekNumber, Oe = r.weekPicker, Ee = r.rangeHover, Ye = r.monthYearSeparator, Me = r.formatMonth, Ce = r.formatYear, Ne = r.highlightToday, Pe = void 0 === Ne || Ne, Se = r.headerOrder, Ie = void 0 === Se ? [\n        \"LEFT_BUTTON\",\n        \"MONTH_YEAR\",\n        \"RIGHT_BUTTON\"\n    ] : Se, je = r.style, Te = void 0 === je ? {} : je;\n    !te || te instanceof d.default || (console.warn(\"currentDate must be instance of DateObject\"), te = void 0), (\"number\" != typeof le || le < 0 || le > 6) && (le = 0), (\"number\" != typeof re || re < 1 || h) && (re = 1), !(x || b || g(o)) || b || x || (x = !0), Oe && (b = !0, x = !1), we && (re = 12, m = !1, h = !1), h && !ye && (ye = !0);\n    var Ae = F(i, u), Re = f(Ae, 2);\n    i = Re[0], u = Re[1], p = I(m, h, p), V = C(V), L = [].concat(L).filter(Boolean), X = [].concat.apply([], X);\n    var Le = e.useState({}), Fe = f(Le, 2), We = Fe[0], Be = Fe[1], _e = {}, Ve = e.useRef({\n        mustCallOnReady: !0,\n        currentDate: te\n    });\n    e.useEffect(function() {\n        Be(function(e) {\n            var r = Ve.current.currentDate, t = e.date, n = e.selectedDate, a = e.initialValue, c = e.focused, s = e.mustSortDates;\n            function f(e) {\n                if (e) return e.calendar.name !== i.name && e.setCalendar(i), e.locale.name !== u.name && e.setLocale(u), e._format !== p && e.setFormat(p), e.digits = ne, e.ignoreList = JSON.parse(V), e;\n            }\n            function y(e) {\n                return new d.default(r || e);\n            }\n            if (o) if (g(n = K(o, i, u, p))) t || (t = y(n.flat()[0]));\n            else if (t && 1 !== re) {\n                var v = new d.default(t).toFirstOfMonth(), w = new d.default(t).add(re - 1, m ? \"years\" : \"months\").toLastOfMonth();\n                (n < v || n > w) && (t = new d.default(n));\n            } else t = y(n);\n            else t || (t = y({\n                calendar: i,\n                locale: u,\n                format: p\n            })), a && (n = void 0);\n            if ([].concat(n).flat().forEach(f), f(t), x || b || g(o)) {\n                if (n || (n = []), g(n) || (n = x && b ? [\n                    [\n                        n\n                    ]\n                ] : [\n                    n\n                ]), b && !x && n.length > 2) {\n                    var k = n[n.length - 1];\n                    n = [\n                        n[0],\n                        k\n                    ], c = k;\n                }\n                x && !b && Z && !s ? (s = !0, n.sort(function(e, r) {\n                    return e - r;\n                })) : b && !x && n.sort(function(e, r) {\n                    return e - r;\n                });\n            } else g(n) && (n = n.flat()[n.length - 1]);\n            return we && t.toFirstOfYear(), delete Ve.current.currentDate, l(l({}, e), {}, {\n                date: t,\n                selectedDate: n,\n                multiple: x,\n                range: b,\n                onlyMonthPicker: m,\n                onlyYearPicker: h,\n                initialValue: e.initialValue || o,\n                value: o,\n                focused: c,\n                calendar: i,\n                locale: u,\n                format: p,\n                mustSortDates: s,\n                year: t.year,\n                today: f(e.today) || new d.default({\n                    calendar: i\n                }),\n                weekPicker: Oe\n            });\n        });\n    }, [\n        o,\n        i,\n        u,\n        p,\n        m,\n        h,\n        b,\n        x,\n        Z,\n        re,\n        ne,\n        V,\n        we,\n        Oe\n    ]), e.useEffect(function() {\n        (A || R) && Be(function(e) {\n            var r = e.calendar, t = e.locale, n = e.format, a = f(J(K(o, r, t, n), A, R, r), 3), d = a[0], i = a[1], u = a[2];\n            return l(l({}, e), {}, {\n                inRangeDates: U ? d : e.selectedDate,\n                minDate: i,\n                maxDate: u\n            });\n        });\n    }, [\n        A,\n        R,\n        U,\n        o\n    ]), We.today && !Ve.current.isReady && (Ve.current.isReady = !0), e.useEffect(function() {\n        Ve.current.isReady && Ve.current.mustCallOnReady && H instanceof Function && (Ve.current.mustCallOnReady = !1, H());\n    }, [\n        Ve.current.isReady,\n        H\n    ]);\n    var ze = \"rmdp-top-class \" + tr([\n        \"top\",\n        \"bottom\"\n    ]), He = {\n        top: [],\n        bottom: [],\n        left: [],\n        right: []\n    }, qe = _(null === (n = We.date) || void 0 === n ? void 0 : n.locale), Je = {\n        state: We,\n        setState: Be,\n        onChange: Xe,\n        sort: Z,\n        handleFocusedDate: er,\n        isRTL: qe,\n        fullYear: we,\n        monthAndYears: or(),\n        rangeHover: Ee,\n        highlightToday: Pe,\n        numberOfMonths: re\n    }, Ke = arguments[0], Ue = Ke.datePickerProps, $e = Ke.DatePicker, Ge = s(Ke, z);\n    return Qe(), We.today ? a.default.createElement(\"div\", {\n        ref: ar,\n        role: k || \"dialog\",\n        className: \"rmdp-wrapper rmdp-\".concat(xe ? \"shadow\" : \"border\", \" \").concat(w || \"\"),\n        style: l({\n            zIndex: G\n        }, Te)\n    }, He.top, a.default.createElement(\"div\", {\n        style: {\n            display: \"flex\"\n        },\n        className: ze\n    }, He.left, !ue && a.default.createElement(\"div\", {\n        className: \"rmdp-calendar \".concat(qe ? \"rmdp-rtl\" : \"\", \" \").concat(tr([\n            \"left\",\n            \"right\"\n        ]))\n    }, a.default.createElement(M, l(l({}, Je), {}, {\n        disableYearPicker: B,\n        disableMonthPicker: W,\n        buttons: oe,\n        renderButton: de,\n        handleMonthChange: rr,\n        disabled: he,\n        hideMonth: ye,\n        hideYear: ge,\n        monthYearSeparator: Ye,\n        formatMonth: Me,\n        formatYear: Ce,\n        headerOrder: Ie\n    })), a.default.createElement(\"div\", {\n        style: {\n            position: \"relative\"\n        }\n    }, a.default.createElement(E, l(l({}, Je), {}, {\n        showOtherDays: T,\n        mapDays: L,\n        onlyShowInRangeDates: U,\n        customWeekDays: D,\n        weekStartDayIndex: le,\n        hideWeekDays: be,\n        displayWeekNumbers: ke,\n        weekNumber: De\n    })), !we && a.default.createElement(a.default.Fragment, null, !W && a.default.createElement(N, c({}, Je, {\n        customMonths: O,\n        handleMonthChange: rr\n    })), !B && a.default.createElement(S, c({}, Je, {\n        onYearChange: fe\n    }))))), He.right), He.bottom, Y) : null;\n    function Qe() {\n        if (Ve.current.isReady && g(X)) {\n            var r = {\n                state: We,\n                setState: Be,\n                registerListener: nr,\n                calendarProps: Ge,\n                datePickerProps: Ue,\n                handleChange: Xe,\n                Calendar: Ve.current.Calendar,\n                DatePicker: $e,\n                handlePropsChange: Ze,\n                handleFocusedDate: function(e) {\n                    return er(e);\n                }\n            }, t = function(e) {\n                return ue ? \"bottom\" : e.props.position || \"right\";\n            };\n            X.forEach(function(n, a) {\n                if (\"string\" != typeof n.type) {\n                    var o = {}, d = t(n);\n                    if (He[d] && !n.props.disabled) {\n                        for(var i = 0; i < X.length; i++)if (\"string\" != typeof X[i].type && !X[i].props.disabled) {\n                            if (4 === Object.keys(o).length) break;\n                            var u = t(X[i]);\n                            [\n                                \"top\",\n                                \"bottom\"\n                            ].includes(d) ? (u === d && i > a && (o.bottom = !0), u === d && i < a && (o.top = !0)) : (ze.includes(\"border-top\") && (o.top = !0), ze.includes(\"border-bottom\") && (o.bottom = !0), u === d && i > a && (o.right = !0), u === d && i < a && (o.left = !0));\n                        }\n                        He[d].push(e.cloneElement(n, l({\n                            key: a,\n                            position: d,\n                            nodes: o\n                        }, r)));\n                    }\n                } else \"mapDays\" === n.type && L.push(n.fn(r));\n            });\n        }\n    }\n    function Xe(e, r) {\n        if (e instanceof d.default && (e = new d.default(e)), !he) {\n            if (e || null === e) {\n                if (me) return;\n                _e.change && _e.change.forEach(function(r) {\n                    return r(e);\n                });\n            }\n            if (e || null === e) {\n                var t = null == j ? void 0 : j(e);\n                r && !1 !== t && Be(r);\n            } else r && Be(r);\n            Ze({\n                value: e\n            });\n        }\n    }\n    function Ze() {\n        var e, r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};\n        if (!me && !he) {\n            var t = l(l(l(l({}, Ge), Ue), r), {}, {\n                value: null !== (e = r.value) && void 0 !== e ? e : We.selectedDate\n            });\n            delete t.onPropsChange, null == ce || ce(t);\n        }\n    }\n    function er(e, r) {\n        me || he || null == pe || pe(e, r);\n    }\n    function rr(e) {\n        null == se || se(e);\n    }\n    function tr(e) {\n        return ue || !g(X) ? \"\" : Array.from(new Set(X.map(function(r) {\n            if (!r.props) return \"\";\n            var t = r.props.position || \"right\";\n            return e.includes(t) && !r.props.disabled ? \"rmdp-border-\" + t : \"\";\n        }))).join(\" \");\n    }\n    function nr(e, r) {\n        _e[e] || (_e[e] = []), _e[e].push(r);\n    }\n    function ar(e) {\n        if (e && (e.date = We.date, e.set = function(e, r) {\n            he || Be(l(l({}, We), {}, {\n                date: new d.default(We.date.set(e, r))\n            }));\n        }), Ve.current.Calendar = e, t instanceof Function) return t(e);\n        t && (t.current = e);\n    }\n    function or() {\n        var e = We.date;\n        if (!e) return [];\n        for(var r = [], t = [], n = e.digits, a = 0; a < re; a++){\n            var o = void 0, d = e.year, i = e.monthIndex + a;\n            if (m && (d += a), i > 11 && (i -= 12, m || d++), g(O) && O.length >= 12) {\n                var l = O[i];\n                o = g(l) ? l[0] : l;\n            } else o = e.months[i].name;\n            d = P(d.toString(), n), r.push(o), t.push(d);\n        }\n        return [\n            r,\n            t\n        ];\n    }\n}\n_s4(H, \"ScWUIp5X75airy4JABDQpECo2as=\");\n_c14 = H;\nvar q = e.forwardRef(H);\n_c15 = q;\nfunction J(e, r, t, n) {\n    return r && (r = j(r, n).set({\n        hour: 0,\n        minute: 0,\n        second: 0,\n        millisecond: 0\n    })), t && (t = j(t, n).set({\n        hour: 23,\n        minute: 59,\n        second: 59,\n        millisecond: 999\n    })), g(e) && (e = e.filter(function(e) {\n        return !(r && e < r) && !(t && e > t);\n    })), [\n        e,\n        r,\n        t\n    ];\n}\n_c16 = J;\nfunction K(e, r, t, n) {\n    var a = [].concat(e).map(function(e) {\n        return g(e) ? e.map(o).filter(i) : o(e);\n    }).filter(i);\n    return g(e) ? a : a.flat()[0];\n    function o(e) {\n        return e ? e instanceof d.default ? e : new d.default({\n            date: e,\n            calendar: r,\n            locale: t,\n            format: n\n        }) : {};\n    }\n    function i(e) {\n        return g(e) || e.isValid;\n    }\n}\n_c17 = K;\nV('.rmdp-visible{visibility:visible}.rmdp-invisible{visibility:hidden}.rmdp-input{border:1px solid #c0c4d6;border-radius:5px;height:22px;margin:1px 0;padding:2px 5px}.rmdp-input:focus{border:1px solid #a4b3c5;box-shadow:0 0 2px #a4b3c5;outline:none!important}.rmdp-button{background-color:#0074d9;border:none;border-radius:5px;color:#fff;cursor:pointer;display:inline-block;padding:7px 16px;text-align:center;text-decoration:none;transition:.3s}.rmdp-button:hover{background-color:#143ac5;transition:.4s}.rmdp-button:disabled{background-color:#8798ad}.rmdp-action-button{border-radius:unset;color:#2682d3;float:right;font-weight:700;margin:15px 10px 15px 0}.rmdp-action-button,.rmdp-action-button:hover{background-color:transparent}.rmdp-ep-arrow{overflow:hidden;will-change:transform}.rmdp-ep-arrow:after{background-color:#fff;content:\"\";height:12px;position:absolute;transform:rotate(45deg);width:12px}.rmdp-ep-shadow:after{box-shadow:0 0 6px #8798ad}.rmdp-ep-border:after{border:1px solid #cfd8e2}.rmdp-ep-arrow[direction=top]{border-bottom:1px solid #fff}.rmdp-ep-arrow[direction=left]{border-right:1px solid #fff}.rmdp-ep-arrow[direction=right]{border-left:1px solid #fff;margin-left:-1px}.rmdp-ep-arrow[direction=bottom]{border-top:1px solid #fff;margin-top:-1.5px}.rmdp-ep-arrow[direction=top]:after{left:4px;top:5px}.rmdp-ep-arrow[direction=bottom]:after{left:4px;top:-6px}.rmdp-ep-arrow[direction=left]:after{left:5px;top:3px}.rmdp-ep-arrow[direction=right]:after{left:-6px;top:3px}');\nvar U = [\n    \"value\",\n    \"calendar\",\n    \"locale\",\n    \"format\",\n    \"onlyMonthPicker\",\n    \"onlyYearPicker\",\n    \"onChange\",\n    \"range\",\n    \"multiple\",\n    \"name\",\n    \"id\",\n    \"title\",\n    \"placeholder\",\n    \"required\",\n    \"style\",\n    \"className\",\n    \"inputClass\",\n    \"disabled\",\n    \"render\",\n    \"weekDays\",\n    \"months\",\n    \"children\",\n    \"inputMode\",\n    \"scrollSensitive\",\n    \"hideOnScroll\",\n    \"minDate\",\n    \"maxDate\",\n    \"formattingIgnoreList\",\n    \"containerClassName\",\n    \"calendarPosition\",\n    \"editable\",\n    \"onOpen\",\n    \"onClose\",\n    \"arrowClassName\",\n    \"zIndex\",\n    \"arrow\",\n    \"fixMainPosition\",\n    \"onPositionChange\",\n    \"onPropsChange\",\n    \"digits\",\n    \"readOnly\",\n    \"shadow\",\n    \"onFocusedDateChange\",\n    \"type\",\n    \"weekPicker\",\n    \"mobileLabels\",\n    \"onOpenPickNewDate\",\n    \"mobileButtons\",\n    \"dateSeparator\",\n    \"multipleRangeSeparator\",\n    \"typingTimeout\"\n], $ = [\n    \"label\"\n];\nfunction G(r, t) {\n    _s5();\n    var n = r.value, i = r.calendar, u = r.locale, p = r.format, m = r.onlyMonthPicker, h = r.onlyYearPicker, b = r.onChange, v = r.range, x = void 0 !== v && v, w = r.multiple, k = void 0 !== w && w, D = r.name, O = r.id, E = r.title, Y = r.placeholder, M = r.required, N = r.style, S = void 0 === N ? {} : N, j = r.className, T = void 0 === j ? \"\" : j, A = r.inputClass, R = r.disabled, L = r.render, W = r.weekDays, V = r.months, z = r.children, H = r.inputMode, J = r.scrollSensitive, K = void 0 === J || J, G = r.hideOnScroll, Q = r.minDate, ee = r.maxDate, re = r.formattingIgnoreList, te = r.containerClassName, ne = void 0 === te ? \"\" : te, ae = r.calendarPosition, oe = void 0 === ae ? \"bottom-left\" : ae, de = r.editable, ie = void 0 === de || de, le = r.onOpen, ue = r.onClose, ce = r.arrowClassName, se = void 0 === ce ? \"\" : ce, fe = r.zIndex, pe = void 0 === fe ? 100 : fe, me = r.arrow, he = void 0 === me || me, ye = r.fixMainPosition, ge = r.onPositionChange, be = r.onPropsChange, ve = r.digits, xe = r.readOnly, we = r.shadow, ke = void 0 === we || we, De = r.onFocusedDateChange, Oe = r.type, Ee = r.weekPicker, Ye = r.mobileLabels, Me = r.onOpenPickNewDate, Ce = void 0 === Me || Me, Ne = r.mobileButtons, Pe = void 0 === Ne ? [] : Ne, Se = r.dateSeparator, Ie = r.multipleRangeSeparator, je = void 0 === Ie ? \",\" : Ie, Te = r.typingTimeout, Ae = void 0 === Te ? 700 : Te, Re = s(r, U), Le = e.useState(), Fe = f(Le, 2), We = Fe[0], Be = Fe[1], _e = e.useState(), Ve = f(_e, 2), ze = Ve[0], He = Ve[1], qe = e.useState(\"\"), Je = f(qe, 2), Ke = Je[0], Ue = Je[1], $e = e.useState(!1), Ge = f($e, 2), Qe = Ge[0], Xe = Ge[1], Ze = e.useState(!1), er = f(Ze, 2), rr = er[0], tr = er[1], nr = e.useRef(), ar = e.useRef(), or = e.useRef(), dr = e.useRef({\n        isTyping: !1\n    }), ir = Se || (x || Ee ? \" ~ \" : \", \"), lr = arguments[0], ur = gr(), cr = e.useCallback(function() {\n        if (!1 !== (null == ue ? void 0 : ue())) {\n            var e = Z(ar);\n            if (e && e.forEach(function(e) {\n                return e.blur();\n            }), dr.current.mobile) {\n                var r = or.current.parentNode.parentNode;\n                r.classList.remove(\"rmdp-calendar-container-mobile\"), r.style.position = \"absolute\", r.style.visibility = \"hidden\";\n            }\n            Xe(!1), tr(!1);\n        }\n    }, [\n        ue\n    ]), sr = [\n        {\n            type: \"button\",\n            className: \"rmdp-button rmdp-action-button\",\n            onClick: function() {\n                He(void 0), cr();\n            },\n            label: vr(\"CANCEL\")\n        },\n        {\n            type: \"button\",\n            className: \"rmdp-button rmdp-action-button\",\n            onClick: function() {\n                ze && (kr(ze, !0), He(void 0)), cr();\n            },\n            label: vr(\"OK\")\n        }\n    ];\n    ur && !dr.current.mobile && (dr.current = l(l({}, dr.current), {}, {\n        mobile: !0\n    })), !ur && dr.current.mobile && (dr.current = l(l({}, dr.current), {}, {\n        mobile: !1\n    })), re = C(re), p = I(m, h, p);\n    var fr = F(i, u), pr = f(fr, 2);\n    return i = pr[0], u = pr[1], e.useEffect(function() {\n        function e(e) {\n            if (Qe && !dr.current.mobile) {\n                var r = [];\n                if ([\n                    ar.current,\n                    or.current\n                ].forEach(function(t) {\n                    var n, a, o;\n                    !t || t.contains(e.target) || e.target.classList.contains(\"b-deselect\") || null !== (n = e.target.parentNode) && void 0 !== n && null !== (a = n.classList) && void 0 !== a && null !== (o = a.contains) && void 0 !== o && o.call(a, \"b-deselect\") || r.push(t);\n                }), 2 === r.length) return cr();\n                or.current && or.current.contains(e.target) && (nr.current.removeTransition(), nr.current.refreshPosition());\n            }\n        }\n        function r() {\n            G && Qe && cr();\n        }\n        return document.addEventListener(\"click\", e, !1), document.addEventListener(\"scroll\", r, !0), function() {\n            document.removeEventListener(\"click\", e, !1), document.removeEventListener(\"scroll\", r, !0);\n        };\n    }, [\n        cr,\n        t,\n        Qe,\n        G\n    ]), e.useEffect(function() {\n        var e = n, r = dr.current, t = r.date, a = r.initialValue, o = function() {\n            return e[e.length - 1];\n        };\n        function c(e) {\n            if (e) return e instanceof d.default || (e = new d.default({\n                date: e,\n                calendar: i,\n                locale: u,\n                format: p\n            })), e.calendar !== i && e.setCalendar(i), e.set({\n                weekDays: W,\n                months: V,\n                digits: ve,\n                locale: u,\n                format: p,\n                ignoreList: JSON.parse(re)\n            }), e;\n        }\n        n || a || !t ? a && !n && (a = void 0) : e = t;\n        var s = \"\";\n        if (x || k || g(e)) {\n            var m = function(e) {\n                return e = e.map(c).filter(function(e) {\n                    return void 0 !== e;\n                }), x && e.length > 2 && (e = [\n                    e[0],\n                    o()\n                ]), [\n                    e,\n                    X(e, ir)\n                ];\n            };\n            if (g(e) || (e = x && k ? e ? [\n                [\n                    e\n                ]\n            ] : [] : [\n                e\n            ]), k && x) e = e.map(function(r, t) {\n                var n = f(m(g(r) ? r : [\n                    r\n                ]), 2), a = n[0], o = n[1];\n                return s += o + (t < e.length - 1 ? \" \".concat(je, \" \") : \"\"), a;\n            });\n            else {\n                var h = f(m(e), 2);\n                e = h[0], s = h[1];\n            }\n            s = s.toString().replace(/\\s,\\s$/, \"\");\n        } else g(e) && (e = o()), (e = c(e)) && (s = e.format());\n        dr.current.isTyping || Ue(s), dr.current = l(l({}, dr.current), {}, {\n            date: e,\n            separator: ir,\n            initialValue: a || n\n        }), dr.current.mobile && nr.current.isOpen ? He(e) : Be(e);\n    }, [\n        n,\n        i,\n        u,\n        p,\n        x,\n        k,\n        ir,\n        m,\n        h,\n        W,\n        V,\n        ve,\n        re\n    ]), e.useEffect(function() {\n        var e = dr.current.selection;\n        if (e) {\n            var r = Z(ar);\n            0 !== r.length && (r.forEach(function(r) {\n                document.activeElement === r && (r.setSelectionRange(e, e), dr.current.selection = void 0);\n            }), nr.current.refreshPosition());\n        }\n    }, [\n        Ke\n    ]), (k || x || g(We) || !ie) && (H = \"none\"), a.default.createElement(o.default, c({\n        ref: mr,\n        element: hr(),\n        popper: Qe && yr(),\n        active: !ur && rr,\n        position: oe,\n        arrow: !ur && he,\n        fixMainPosition: !K || ye,\n        zIndex: pe,\n        onChange: !ur && ge,\n        containerClassName: \"rmdp-container \".concat(ne),\n        arrowClassName: [\n            \"rmdp-ep-arrow\",\n            \"rmdp-ep-\".concat(ke ? \"shadow\" : \"border\"),\n            T,\n            se\n        ].join(\" \")\n    }, Re));\n    function mr(e) {\n        if (e && (e.openCalendar = function() {\n            return setTimeout(function() {\n                return xr();\n            }, 10);\n        }, e.closeCalendar = cr, e.isOpen = Qe && rr), nr.current = e, t instanceof Function) return t(e);\n        t && (t.current = e);\n    }\n    function hr() {\n        return L ? a.default.createElement(\"div\", {\n            ref: ar\n        }, e.isValidElement(L) ? e.cloneElement(L, {\n            value: Ke,\n            openCalendar: xr,\n            onFocus: xr,\n            handleValueChange: Dr,\n            onChange: Dr,\n            locale: u,\n            separator: ir\n        }) : L instanceof Function ? L(Ke, xr, Dr, u, ir) : null) : a.default.createElement(\"input\", {\n            ref: ar,\n            type: Oe || \"text\",\n            name: D,\n            id: O,\n            title: E,\n            required: M,\n            onFocus: xr,\n            className: A || \"rmdp-input\",\n            placeholder: Y,\n            value: Ke,\n            onChange: Dr,\n            style: S,\n            autoComplete: \"off\",\n            disabled: !!R,\n            inputMode: H || (ur ? \"none\" : void 0),\n            readOnly: xe\n        });\n    }\n    function yr() {\n        return a.default.createElement(q, c({\n            ref: or,\n            value: ze || We,\n            onChange: kr,\n            range: x,\n            multiple: k,\n            calendar: i,\n            locale: u,\n            format: p,\n            onlyMonthPicker: m,\n            onlyYearPicker: h,\n            className: T + (ur ? \" rmdp-mobile\" : \"\"),\n            weekDays: W,\n            months: V,\n            digits: ve,\n            minDate: Q,\n            maxDate: ee,\n            formattingIgnoreList: JSON.parse(re),\n            onPropsChange: be,\n            shadow: ke,\n            onReady: Or,\n            DatePicker: nr.current,\n            datePickerProps: lr,\n            onFocusedDateChange: Er,\n            weekPicker: Ee\n        }, Re), z, ur && br());\n    }\n    function gr() {\n        return \"string\" == typeof T && T.includes(\"rmdp-mobile\");\n    }\n    function br() {\n        var e = [].concat.apply([], lr.plugins || []).some(function(e) {\n            var r = e.props;\n            return !(void 0 === r ? {} : r).disabled;\n        });\n        return g(Pe) && a.default.createElement(\"div\", {\n            className: \"rmdp-action-buttons \".concat(_(u) ? \"rmdp-rtl\" : \"\", \" \").concat(e ? \"rmdp-border-top\" : \"\")\n        }, Pe.concat(sr).map(function(e, r) {\n            var t = e.label, n = s(e, $);\n            return a.default.createElement(\"button\", c({\n                key: r\n            }, n), t);\n        }));\n    }\n    function vr(e) {\n        var r, t = u || (new d.default).locale;\n        if (\"string\" != typeof t.name) return e;\n        return (null == Ye ? void 0 : Ye[e]) || (null === (r = ({\n            en: {\n                OK: \"OK\",\n                CANCEL: \"CANCEL\"\n            },\n            fa: {\n                OK: \"تأیید\",\n                CANCEL: \"لغو\"\n            },\n            ar: {\n                OK: \"تأكيد\",\n                CANCEL: \"الغاء\"\n            },\n            hi: {\n                OK: \"पुष्टि\",\n                CANCEL: \"रद्द करें\"\n            }\n        })[B(t)]) || void 0 === r ? void 0 : r[e]) || e;\n    }\n    function xr() {\n        if (!R && !xe && !1 !== (null == le ? void 0 : le())) {\n            if (wr()) {\n                var e = new d.default({\n                    calendar: i,\n                    locale: u,\n                    format: p,\n                    months: V,\n                    weekDays: W,\n                    digits: ve,\n                    ignoreList: JSON.parse(re)\n                });\n                (!Q || e > Q) && (!ee || e < ee) && (kr(e), null == be || be(l(l({}, lr), {}, {\n                    value: e\n                })), dr.current.date = e);\n            }\n            var r = Z(ar);\n            ur && r.length > 0 && r.forEach(function(e) {\n                return e.blur();\n            }), r.length > 0 || !Qe ? Xe(!0) : cr();\n        }\n    }\n    function wr() {\n        return Ce && !n && !dr.current.date && !x && !k && !ur;\n    }\n    function kr(e, r, t) {\n        if (ur && !r) return He(e);\n        var n = \"\";\n        if (e && (n = k && x && g(e) ? e.map(function(e) {\n            return X(e, ir);\n        }).join(\" \".concat(je, \" \")) : X(e, ir)), !1 === (null == b ? void 0 : b(e, {\n            validatedValue: n,\n            input: ar.current,\n            isTyping: !!t\n        }))) return Ue(Ke), !1;\n        Be(e), Ue(t || n.toString().replace(/\\s,\\s$/, \"\")), dr.current = l(l({}, dr.current), {}, {\n            date: e\n        });\n    }\n    function Dr(e) {\n        if (ie) {\n            dr.current.isTyping = !0, setTimeout(function() {\n                dr.current.isTyping = !1;\n            }, Ae), dr.current.selection = e.target.selectionStart;\n            var r = e.target.value, t = {\n                calendar: i,\n                locale: u,\n                format: p,\n                ignoreList: JSON.parse(re)\n            };\n            if (ve = g(ve) ? ve : u.digits, !r) return Ue(\"\"), kr(null);\n            if (ve) {\n                var n, a, o = y(ve);\n                try {\n                    for(o.s(); !(n = o.n()).done;){\n                        var c = n.value;\n                        r = r.replace(new RegExp(c, \"g\"), ve.indexOf(c));\n                    }\n                } catch (e) {\n                    o.e(e);\n                } finally{\n                    o.f();\n                }\n                a = g(We) ? k && x ? (r || \"\").split(je).filter(Boolean).map(f) : f(r) : s(r), kr(g(We) || a.isValid ? a : null, void 0, P(r, ve));\n            }\n        }\n        function s(e) {\n            return /(?=.*Y)(?=.*M)(?=.*D)/.test(p) ? new d.default(l(l({}, t), {}, {\n                date: e\n            })) : new d.default(t).parse(e);\n        }\n        function f(e) {\n            return (e || \"\").split(ir).filter(Boolean).map(function(e) {\n                return s(e.trim());\n            });\n        }\n    }\n    function Or() {\n        if (tr(!0), ur) {\n            var e = or.current.parentNode.parentNode;\n            e.className = \"rmdp-calendar-container-mobile\", e.style.position = \"fixed\", e.style.transform = \"\", setTimeout(function() {\n                e.style.visibility = \"visible\";\n            }, 50);\n        }\n    }\n    function Er(e, r) {\n        g(dr.current.date) || !r || ur || cr(), null == De || De(e, r);\n    }\n}\n_s5(G, \"3BTMe/vKeCxLgOMCrJBOJjVJbLU=\");\n_c18 = G;\nvar Q = e.forwardRef(G);\n_c19 = Q;\nfunction X(e, r) {\n    var t = [].concat(e).map(function(e) {\n        return null != e && e.isValid ? e.format() : \"\";\n    });\n    return t.toString = function() {\n        return this.filter(Boolean).join(r);\n    }, t;\n}\n_c20 = X;\nfunction Z(e) {\n    return e.current ? \"INPUT\" === e.current.tagName ? [\n        e.current\n    ] : Array.from(e.current.querySelectorAll(\"input\")) : [];\n}\n_c21 = Z;\nObject.defineProperty(exports, \"DateObject\", ({\n    enumerable: !0,\n    get: function() {\n        return d.default;\n    }\n})), exports.Calendar = q, exports[\"default\"] = Q, exports.getAllDatesInRange = function() {\n    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], r = arguments.length > 1 ? arguments[1] : void 0;\n    if (!Array.isArray(e)) return [];\n    var t = e[0], n = e[e.length - 1], a = [];\n    if (!(t instanceof d.default && n instanceof d.default && t.isValid && n.isValid && !(t > n))) return [];\n    for(t = new d.default(t), n = new d.default(n); t <= n; t.day++)a.push(r ? t.toDate() : new d.default(t));\n    return a;\n}, exports.toDateObject = j;\nvar _c, _c1, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9, _c10, _c11, _c12, _c13, _c14, _c15, _c16, _c17, _c18, _c19, _c20, _c21;\n$RefreshReg$(_c, \"D\");\n$RefreshReg$(_c1, \"E\");\n$RefreshReg$(_c2, \"Y\");\n$RefreshReg$(_c3, \"M\");\n$RefreshReg$(_c4, \"C\");\n$RefreshReg$(_c5, \"N\");\n$RefreshReg$(_c6, \"P\");\n$RefreshReg$(_c7, \"S\");\n$RefreshReg$(_c8, \"I\");\n$RefreshReg$(_c9, \"T\");\n$RefreshReg$(_c10, \"F\");\n$RefreshReg$(_c11, \"W\");\n$RefreshReg$(_c12, \"B\");\n$RefreshReg$(_c13, \"V\");\n$RefreshReg$(_c14, \"H\");\n$RefreshReg$(_c15, \"q\");\n$RefreshReg$(_c16, \"J\");\n$RefreshReg$(_c17, \"K\");\n$RefreshReg$(_c18, \"G\");\n$RefreshReg$(_c19, \"Q\");\n$RefreshReg$(_c20, \"X\");\n$RefreshReg$(_c21, \"Z\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1tdWx0aS1kYXRlLXBpY2tlci9idWlsZC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOztBQUFBO0FBQWFBLDhDQUEyQztJQUFDRyxPQUFNLENBQUM7QUFBQyxDQUFDLEVBQUM7QUFBQyxJQUFJQyxJQUFFQyxtQkFBT0EsQ0FBQyxtRkFBTyxHQUFFQyxJQUFFRCxtQkFBT0EsQ0FBQywwR0FBc0IsR0FBRUUsSUFBRUYsbUJBQU9BLENBQUMsb0dBQW1CO0FBQUUsU0FBU0csRUFBRUosQ0FBQztJQUFFLE9BQU9BLEtBQUcsWUFBVSxPQUFPQSxLQUFHLGFBQVlBLElBQUVBLElBQUU7UUFBQ0ssU0FBUUw7SUFBQztBQUFDO0FBQUMsSUFBSU0sSUFBRUYsRUFBRUosSUFBR08sSUFBRUgsRUFBRUYsSUFBR00sSUFBRUosRUFBRUQ7QUFBRyxTQUFTTSxFQUFFVCxDQUFDLEVBQUNFLENBQUM7SUFBRSxJQUFJQyxJQUFFUCxPQUFPYyxJQUFJLENBQUNWO0lBQUcsSUFBR0osT0FBT2UscUJBQXFCLEVBQUM7UUFBQyxJQUFJUCxJQUFFUixPQUFPZSxxQkFBcUIsQ0FBQ1g7UUFBR0UsS0FBSUUsQ0FBQUEsSUFBRUEsRUFBRVEsTUFBTSxDQUFFLFNBQVNWLENBQUM7WUFBRSxPQUFPTixPQUFPaUIsd0JBQXdCLENBQUNiLEdBQUVFLEdBQUdZLFVBQVU7UUFBQSxFQUFFLEdBQUdYLEVBQUVZLElBQUksQ0FBQ0MsS0FBSyxDQUFDYixHQUFFQztJQUFFO0lBQUMsT0FBT0Q7QUFBQztBQUFDLFNBQVNjLEVBQUVqQixDQUFDO0lBQUUsSUFBSSxJQUFJRSxJQUFFLEdBQUVBLElBQUVnQixVQUFVQyxNQUFNLEVBQUNqQixJQUFJO1FBQUMsSUFBSUMsSUFBRSxRQUFNZSxTQUFTLENBQUNoQixFQUFFLEdBQUNnQixTQUFTLENBQUNoQixFQUFFLEdBQUMsQ0FBQztRQUFFQSxJQUFFLElBQUVPLEVBQUViLE9BQU9PLElBQUcsQ0FB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QUMsRUFBRSxHQUFDQSxTQUFTLENBQUMsRUFBRSxHQUFDLEVBQUUsRUFBQ2hCLElBQUVnQixVQUFVQyxNQUFNLEdBQUMsSUFBRUQsU0FBUyxDQUFDLEVBQUUsR0FBQyxLQUFLO0lBQUUsSUFBRyxDQUFDa0IsTUFBTUMsT0FBTyxDQUFDckMsSUFBRyxPQUFNLEVBQUU7SUFBQyxJQUFJRyxJQUFFSCxDQUFDLENBQUMsRUFBRSxFQUFDSSxJQUFFSixDQUFDLENBQUNBLEVBQUVtQixNQUFNLEdBQUMsRUFBRSxFQUFDYixJQUFFLEVBQUU7SUFBQyxJQUFHLENBQUVILENBQUFBLGFBQWFLLEVBQUVILE9BQU8sSUFBRUQsYUFBYUksRUFBRUgsT0FBTyxJQUFFRixFQUFFK1UsT0FBTyxJQUFFOVUsRUFBRThVLE9BQU8sSUFBRSxDQUFFL1UsQ0FBQUEsSUFBRUMsQ0FBQUEsQ0FBQyxHQUFHLE9BQU0sRUFBRTtJQUFDLElBQUlELElBQUUsSUFBSUssRUFBRUgsT0FBTyxDQUFDRixJQUFHQyxJQUFFLElBQUlJLEVBQUVILE9BQU8sQ0FBQ0QsSUFBR0QsS0FBR0MsR0FBRUQsRUFBRXlFLEdBQUcsR0FBR3RFLEVBQUVTLElBQUksQ0FBQ2IsSUFBRUMsRUFBRXNhLE1BQU0sS0FBRyxJQUFJamEsRUFBRUgsT0FBTyxDQUFDRjtJQUFJLE9BQU9HO0FBQUMsR0FBRVIsb0JBQW9CLEdBQUNxSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtbXVsdGktZGF0ZS1waWNrZXIvYnVpbGQvaW5kZXguanM/ZTEzNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgZT1yZXF1aXJlKFwicmVhY3RcIikscj1yZXF1aXJlKFwicmVhY3QtZWxlbWVudC1wb3BwZXJcIiksdD1yZXF1aXJlKFwicmVhY3QtZGF0ZS1vYmplY3RcIik7ZnVuY3Rpb24gbihlKXtyZXR1cm4gZSYmXCJvYmplY3RcIj09dHlwZW9mIGUmJlwiZGVmYXVsdFwiaW4gZT9lOntkZWZhdWx0OmV9fXZhciBhPW4oZSksbz1uKHIpLGQ9bih0KTtmdW5jdGlvbiBpKGUscil7dmFyIHQ9T2JqZWN0LmtleXMoZSk7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIG49T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtyJiYobj1uLmZpbHRlcigoZnVuY3Rpb24ocil7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSxyKS5lbnVtZXJhYmxlfSkpKSx0LnB1c2guYXBwbHkodCxuKX1yZXR1cm4gdH1mdW5jdGlvbiBsKGUpe2Zvcih2YXIgcj0xO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspe3ZhciB0PW51bGwhPWFyZ3VtZW50c1tyXT9hcmd1bWVudHNbcl06e307ciUyP2koT2JqZWN0KHQpLCEwKS5mb3JFYWNoKChmdW5jdGlvbihyKXt1KGUscix0W3JdKX0pKTpPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycz9PYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKTppKE9iamVjdCh0KSkuZm9yRWFjaCgoZnVuY3Rpb24ocil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUscixPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQscikpfSkpfXJldHVybiBlfWZ1bmN0aW9uIHUoZSxyLHQpe3JldHVybiByIGluIGU/T2JqZWN0LmRlZmluZVByb3BlcnR5KGUscix7dmFsdWU6dCxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmVbcl09dCxlfWZ1bmN0aW9uIGMoKXtyZXR1cm4oYz1PYmplY3QuYXNzaWduP09iamVjdC5hc3NpZ24uYmluZCgpOmZ1bmN0aW9uKGUpe2Zvcih2YXIgcj0xO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspe3ZhciB0PWFyZ3VtZW50c1tyXTtmb3IodmFyIG4gaW4gdClPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxuKSYmKGVbbl09dFtuXSl9cmV0dXJuIGV9KS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZnVuY3Rpb24gcyhlLHIpe2lmKG51bGw9PWUpcmV0dXJue307dmFyIHQsbixhPWZ1bmN0aW9uKGUscil7aWYobnVsbD09ZSlyZXR1cm57fTt2YXIgdCxuLGE9e30sbz1PYmplY3Qua2V5cyhlKTtmb3Iobj0wO248by5sZW5ndGg7bisrKXQ9b1tuXSxyLmluZGV4T2YodCk+PTB8fChhW3RdPWVbdF0pO3JldHVybiBhfShlLHIpO2lmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciBvPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7Zm9yKG49MDtuPG8ubGVuZ3RoO24rKyl0PW9bbl0sci5pbmRleE9mKHQpPj0wfHxPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoZSx0KSYmKGFbdF09ZVt0XSl9cmV0dXJuIGF9ZnVuY3Rpb24gZihlLHIpe3JldHVybiBmdW5jdGlvbihlKXtpZihBcnJheS5pc0FycmF5KGUpKXJldHVybiBlfShlKXx8ZnVuY3Rpb24oZSxyKXt2YXIgdD1udWxsPT1lP251bGw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmZVtTeW1ib2wuaXRlcmF0b3JdfHxlW1wiQEBpdGVyYXRvclwiXTtpZihudWxsPT10KXJldHVybjt2YXIgbixhLG89W10sZD0hMCxpPSExO3RyeXtmb3IodD10LmNhbGwoZSk7IShkPShuPXQubmV4dCgpKS5kb25lKSYmKG8ucHVzaChuLnZhbHVlKSwhcnx8by5sZW5ndGghPT1yKTtkPSEwKTt9Y2F0Y2goZSl7aT0hMCxhPWV9ZmluYWxseXt0cnl7ZHx8bnVsbD09dC5yZXR1cm58fHQucmV0dXJuKCl9ZmluYWxseXtpZihpKXRocm93IGF9fXJldHVybiBvfShlLHIpfHxtKGUscil8fGZ1bmN0aW9uKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKX0oKX1mdW5jdGlvbiBwKGUpe3JldHVybiBmdW5jdGlvbihlKXtpZihBcnJheS5pc0FycmF5KGUpKXJldHVybiBoKGUpfShlKXx8ZnVuY3Rpb24oZSl7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmbnVsbCE9ZVtTeW1ib2wuaXRlcmF0b3JdfHxudWxsIT1lW1wiQEBpdGVyYXRvclwiXSlyZXR1cm4gQXJyYXkuZnJvbShlKX0oZSl8fG0oZSl8fGZ1bmN0aW9uKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIil9KCl9ZnVuY3Rpb24gbShlLHIpe2lmKGUpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKXJldHVybiBoKGUscik7dmFyIHQ9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpLnNsaWNlKDgsLTEpO3JldHVyblwiT2JqZWN0XCI9PT10JiZlLmNvbnN0cnVjdG9yJiYodD1lLmNvbnN0cnVjdG9yLm5hbWUpLFwiTWFwXCI9PT10fHxcIlNldFwiPT09dD9BcnJheS5mcm9tKGUpOlwiQXJndW1lbnRzXCI9PT10fHwvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdCh0KT9oKGUscik6dm9pZCAwfX1mdW5jdGlvbiBoKGUscil7KG51bGw9PXJ8fHI+ZS5sZW5ndGgpJiYocj1lLmxlbmd0aCk7Zm9yKHZhciB0PTAsbj1uZXcgQXJyYXkocik7dDxyO3QrKyluW3RdPWVbdF07cmV0dXJuIG59ZnVuY3Rpb24geShlLHIpe3ZhciB0PVwidW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJmVbU3ltYm9sLml0ZXJhdG9yXXx8ZVtcIkBAaXRlcmF0b3JcIl07aWYoIXQpe2lmKEFycmF5LmlzQXJyYXkoZSl8fCh0PW0oZSkpfHxyJiZlJiZcIm51bWJlclwiPT10eXBlb2YgZS5sZW5ndGgpe3QmJihlPXQpO3ZhciBuPTAsYT1mdW5jdGlvbigpe307cmV0dXJue3M6YSxuOmZ1bmN0aW9uKCl7cmV0dXJuIG4+PWUubGVuZ3RoP3tkb25lOiEwfTp7ZG9uZTohMSx2YWx1ZTplW24rK119fSxlOmZ1bmN0aW9uKGUpe3Rocm93IGV9LGY6YX19dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpfXZhciBvLGQ9ITAsaT0hMTtyZXR1cm57czpmdW5jdGlvbigpe3Q9dC5jYWxsKGUpfSxuOmZ1bmN0aW9uKCl7dmFyIGU9dC5uZXh0KCk7cmV0dXJuIGQ9ZS5kb25lLGV9LGU6ZnVuY3Rpb24oZSl7aT0hMCxvPWV9LGY6ZnVuY3Rpb24oKXt0cnl7ZHx8bnVsbD09dC5yZXR1cm58fHQucmV0dXJuKCl9ZmluYWxseXtpZihpKXRocm93IG99fX19ZnVuY3Rpb24gZyhlKXtyZXR1cm4gQXJyYXkuaXNBcnJheShlKX1mdW5jdGlvbiBiKHIpe3ZhciB0PXIuc3RhdGUuZGF0ZSxuPXQuY2FsZW5kYXIsbz10LmxvY2FsZSxpPXIuY3VzdG9tV2Vla0RheXMsbD1yLndlZWtTdGFydERheUluZGV4LHU9ci5kaXNwbGF5V2Vla051bWJlcnMsYz1yLndlZWtOdW1iZXIscz1lLnVzZU1lbW8oKGZ1bmN0aW9uKCl7dmFyIGU9aTtyZXR1cm4gZyhlKSYmZS5sZW5ndGg+PTc/KGUubGVuZ3RoPTcsZT1lLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIGcoZSkmZS5sZW5ndGg+MT9lPWVbMV06ZyhlKSYmKGU9ZVswXSksZX0pKSk6ZT1uZXcgZC5kZWZhdWx0KHt5ZWFyOjEsY2FsZW5kYXI6bixsb2NhbGU6b30pLndlZWtEYXlzLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc2hvcnROYW1lfSkpLGV9KSxbbixvLGldKTtyZXR1cm4gcz1wKHMpLnNsaWNlKGwpLmNvbmNhdChwKHMpLnNwbGljZSgwLGwpKSxhLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLHtjbGFzc05hbWU6XCJybWRwLXdlZWtcIn0sdSYmYS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7Y2xhc3NOYW1lOlwicm1kcC13ZWVrLWRheVwifSxjKSxzLm1hcCgoZnVuY3Rpb24oZSxyKXtyZXR1cm4gYS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7a2V5OnIsY2xhc3NOYW1lOlwicm1kcC13ZWVrLWRheVwifSxlKX0pKSl9ZnVuY3Rpb24gdihlLHIpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdJiZhcmd1bWVudHNbMl0sbj1hcmd1bWVudHMubGVuZ3RoPjMmJnZvaWQgMCE9PWFyZ3VtZW50c1szXSYmYXJndW1lbnRzWzNdO2lmKCFlfHwhcilyZXR1cm4hMTtpZihlLnllYXI9PT1yLnllYXIpe2lmKG4pcmV0dXJuITA7aWYoZS5tb250aEluZGV4PT09ci5tb250aEluZGV4KXJldHVybiEhdHx8ZS5kYXk9PT1yLmRheX19ZnVuY3Rpb24geChlKXt2YXIgcj1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06XCJZWVlZL01NL0REXCI7cmV0dXJuIGUuZm9ybWF0KHIpfWZ1bmN0aW9uIHcoZSxyLHQpe3ZhciBuPXQubXVsdGlwbGUsYT10LnJhbmdlLG89dC5zZWxlY3RlZERhdGUsaT10Lm9ubHlNb250aFBpY2tlcixsPXQub25seVllYXJQaWNrZXIsdT10LmZvcm1hdCxjPXQuZm9jdXNlZCxzPXQud2Vla1BpY2tlcjtlLnNldEZvcm1hdCh1KTt2YXIgbT1uZXcgZC5kZWZhdWx0KGUpO3JldHVybltvPW4mJmE/ZnVuY3Rpb24oKXt2YXIgZT0hMDtnKG8pfHwobz1bW29dXSk7dmFyIHI9by5maW5kKChmdW5jdGlvbihlKXtyZXR1cm4gMT09PWUubGVuZ3RofSkpLHQ9aT9cIllZWVkvTU1cIjpcIllZWVkvTU0vRERcIixuPW87aWYocil7dmFyIGE9clswXTtuPW4uZmlsdGVyKChmdW5jdGlvbihlKXtpZigxPT09ZS5sZW5ndGgpcmV0dXJuITA7dmFyIHI9ZihlLDIpLG49clswXSxvPXJbMV0sZD1mKFthLG1dLnNvcnQoKGZ1bmN0aW9uKGUscil7cmV0dXJuIGUtcn0pKSwyKSxpPWYoW24sbyxkWzBdLGRbMV1dLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIHgoZSx0KX0pKSw0KSxsPWlbMF0sdT1pWzFdLGM9aVsyXSxzPWlbM107cmV0dXJuIShjPD1sJiZzPj11fHxjPj1sJiZzPj11JiZjPD11fHxjPD1sJiZzPD11JiZzPj1sKX0pKX1lbHNlIG49bi5maWx0ZXIoKGZ1bmN0aW9uKGUpe2lmKCFnKGUpKXJldHVybiEwO2lmKDA9PT1lLmxlbmd0aClyZXR1cm4hMTt2YXIgcj1mKGUsMiksbj1mKFtyWzBdLHJbMV0sbV0ubWFwKChmdW5jdGlvbihlKXtyZXR1cm4geChlLHQpfSkpLDMpLGE9blswXSxvPW5bMV0sZD1uWzJdO3JldHVybiEoZD49YSYmZDw9byl9KSk7bj1uLm1hcCgoZnVuY3Rpb24ocil7dmFyIHQ7cmV0dXJuIGcocik/MT09PXIubGVuZ3RoPyhlPSExLHQ9ci5jb25jYXQobSkpOnQ9cjooZT0hMSx0PVtyLG1dKSx0LnNvcnQoKGZ1bmN0aW9uKGUscil7cmV0dXJuIGUtcn0pKX0pKSxlJiYobj1bXS5jb25jYXQocChuKSxbW21dXSkpO3JldHVybiBufSgpOm4/ZnVuY3Rpb24oKXt2YXIgdD1vLmZpbHRlcigoZnVuY3Rpb24ocil7cmV0dXJuIXYoZSxyLGksbCl9KSk7dC5sZW5ndGg9PT1vLmxlbmd0aD90LnB1c2gobSk6bT10LmZpbmQoKGZ1bmN0aW9uKGUpe3JldHVybiB2KGUsYyl9KSk7ciYmdC5zb3J0KChmdW5jdGlvbihlLHIpe3JldHVybiBlLXJ9KSk7cmV0dXJuIHR9KCk6YT9mdW5jdGlvbigpe2lmKHMpcmV0dXJuW25ldyBkLmRlZmF1bHQobSkudG9GaXJzdE9mV2VlaygpLG5ldyBkLmRlZmF1bHQobSkudG9MYXN0T2ZXZWVrKCldO2lmKDI9PT1vLmxlbmd0aHx8MD09PW8ubGVuZ3RoKXJldHVyblttXTtpZigxPT09by5sZW5ndGgpcmV0dXJuW29bMF0sbV0uc29ydCgoZnVuY3Rpb24oZSxyKXtyZXR1cm4gZS1yfSkpfSgpOm0sbV19ZnVuY3Rpb24gayhlLHIsdCxuKXt2YXIgYT1bXSxvPXQ/XCJZWVlZL01NXCI6XCJZWVlZL01NL0REXCIsZD14KGUsbyk7ZnVuY3Rpb24gaShyKXt2YXIgbj1yWzBdLGk9clsxXTtpZigxPT09ci5sZW5ndGgpdihlLG4sdCkmJmEucHVzaChcInJtZHAtcmFuZ2VcIik7ZWxzZSBpZigyPT09ci5sZW5ndGgpe3ZhciBsPWYoW24saV0ubWFwKChmdW5jdGlvbihlKXtyZXR1cm4geChlLG8pfSkpLDIpLHU9bFswXSxjPWxbMV07ZD49dSYmZDw9YyYmYS5wdXNoKFwicm1kcC1yYW5nZVwiKSxkPT09dSYmYS5wdXNoKFwic3RhcnRcIiksZD09PWMmJmEucHVzaChcImVuZFwiKX19cmV0dXJuIG4/KGcocik/cjpbW3JdXSkuZm9yRWFjaChpKTppKHIpLGEuam9pbihcIiBcIil9ZnVuY3Rpb24gRChlLHIsdCxuKXt2YXIgYT1hcmd1bWVudHMubGVuZ3RoPjQmJnZvaWQgMCE9PWFyZ3VtZW50c1s0XT9hcmd1bWVudHNbNF06XCJkYXlcIixvPVtdO2lmKG4mJjE9PT0obnVsbD09cj92b2lkIDA6ci5sZW5ndGgpJiZ0KXt2YXIgZD1cImRheVwiPT09YT9cIllZWVkvTU0vRERcIjpcIllZWVkvTU1cIixpPXQuZm9ybWF0KGQpLGw9clswXS5mb3JtYXQoZCksdT1lLmZvcm1hdChkKTsodT5sJiZ1PD1pfHx1PGwmJnU+PWkpJiYoby5wdXNoKFwicm1kcC1yYW5nZS1ob3ZlclwiKSx1PT09aSYmby5wdXNoKGk+bD9cImVuZFwiOlwic3RhcnRcIikpfXJldHVybiBvfXZhciBPO2Z1bmN0aW9uIEUocil7dmFyIHQ9ci5zdGF0ZSxuPXIuc2V0U3RhdGUsbz1yLm9uQ2hhbmdlLGk9ci5zaG93T3RoZXJEYXlzLHM9dm9pZCAwIT09aSYmaSxwPXIubWFwRGF5cyxtPXIub25seVNob3dJblJhbmdlRGF0ZXMsaD1yLmN1c3RvbVdlZWtEYXlzLHk9ci5zb3J0LGc9ci5udW1iZXJPZk1vbnRocyx4PXIuaXNSVEwsRT1yLndlZWtTdGFydERheUluZGV4LFk9ci5oYW5kbGVGb2N1c2VkRGF0ZSxNPXIuaGlkZVdlZWtEYXlzLEM9ci5mdWxsWWVhcixOPWYoci5tb250aEFuZFllYXJzLDEpWzBdLFA9ci5kaXNwbGF5V2Vla051bWJlcnMsUz1yLndlZWtOdW1iZXIsST12b2lkIDA9PT1TP1wiXCI6UyxqPXIucmFuZ2VIb3ZlcixUPXIuaGlnaGxpZ2h0VG9kYXksQT1lLnVzZVJlZih7fSksUj1lLnVzZVJlZigpLEw9dC50b2RheSxGPXQubWluRGF0ZSxXPXQubWF4RGF0ZSxCPXQucmFuZ2UsXz10Lm11bHRpcGxlLFY9dC5kYXRlLHo9dC5zZWxlY3RlZERhdGUsSD10Lm9ubHlNb250aFBpY2tlcixxPXQub25seVllYXJQaWNrZXIsSj0hSCYmIXEsSz1mKGUudXNlU3RhdGUoKSwyKSxVPUtbMF0sJD1LWzFdLEc9X3x8Qj8obnVsbD09ej92b2lkIDA6ei5sZW5ndGgpPjA6ISF6O0EuY3VycmVudC5kYXRlPVY7dmFyIFE9ZS51c2VNZW1vKChmdW5jdGlvbigpe3JldHVybiBKP2Z1bmN0aW9uKGUscix0LG4pe2lmKCFlKXJldHVybltdO2Zvcih2YXIgYT1bXSxvPTA7bzx0O28rKyl7dmFyIGk9KGU9bmV3IGQuZGVmYXVsdChlKS50b0ZpcnN0T2ZNb250aCgpKS5tb250aEluZGV4LGw9W107ZS50b0ZpcnN0T2ZXZWVrKCkuYWRkKG4sXCJkYXlcIiksZS5tb250aEluZGV4PT09aSYmZS5kYXk+MSYmZS5zdWJ0cmFjdCg3LFwiZGF5c1wiKTtmb3IodmFyIHU9MDt1PDY7dSsrKXtmb3IodmFyIGM9W10scz0wO3M8NztzKyspYy5wdXNoKHtkYXRlOm5ldyBkLmRlZmF1bHQoZSksZGF5OmUuZm9ybWF0KFwiRFwiKSxjdXJyZW50OmUubW9udGhJbmRleD09PWl9KSxlLmRheSs9MTtpZihsLnB1c2goYyksdT4yJiZlLm1vbnRoSW5kZXghPT1pJiYhcilicmVha31hLnB1c2gobCl9cmV0dXJuIGF9KEEuY3VycmVudC5kYXRlLHMsZyxFKTpbXX0pLFtWLm1vbnRoSW5kZXgsVi55ZWFyLFYuY2FsZW5kYXIsVi5sb2NhbGUsSixzLGcsRV0pO3JldHVybiBKJiZhLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLHtyZWY6UixjbGFzc05hbWU6XCJybWRwLWRheS1waWNrZXIgXCIuY29uY2F0KEM/XCJybWRwLWZ1bGwteWVhclwiOlwiXCIpLHN0eWxlOntkaXNwbGF5OkM/XCJncmlkXCI6XCJmbGV4XCJ9LG9uTW91c2VMZWF2ZTpmdW5jdGlvbigpe3JldHVybiBqJiYkKCl9fSxRLm1hcCgoZnVuY3Rpb24oZSxyKXtyZXR1cm4gYS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7a2V5OnIsc3R5bGU6dSh7fSx4P1wibWFyZ2luTGVmdFwiOlwibWFyZ2luUmlnaHRcIixyKyhDPzA6MSk8Zz9cIjEwcHhcIjpcIlwiKX0sQyYmYS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7Y2xhc3NOYW1lOlwicm1kcC1tb250aC1uYW1lXCJ9LE5bcl0pLCFNJiZhLmRlZmF1bHQuY3JlYXRlRWxlbWVudChiLHtzdGF0ZTp0LGN1c3RvbVdlZWtEYXlzOmgsd2Vla1N0YXJ0RGF5SW5kZXg6RSxkaXNwbGF5V2Vla051bWJlcnM6UCx3ZWVrTnVtYmVyOkl9KSxlLm1hcCgoZnVuY3Rpb24oZSxpKXtyZXR1cm4gYS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7a2V5OmksY2xhc3NOYW1lOlwicm1kcC13ZWVrXCJ9LFAmJmEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2NsYXNzTmFtZTpcInJtZHAtZGF5IHJtZHAtZGlzYWJsZWRcIn0sYS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsbnVsbCxlWzBdLmRhdGUuZm9ybWF0KFwiV1dcIikpKSxlLm1hcCgoZnVuY3Rpb24oZSxpKXt2YXIgdT1mdW5jdGlvbihlKXtpZighZS5jdXJyZW50JiYhcylyZXR1cm57fTt2YXIgcj17fTtyZXR1cm4gcC5mb3JFYWNoKChmdW5jdGlvbihuKXt2YXIgYSxvPW4oe2RhdGU6ZS5kYXRlLHRvZGF5OkwsY3VycmVudE1vbnRoOnQuZGF0ZS5tb250aCxzZWxlY3RlZERhdGU6dC5zZWxlY3RlZERhdGUsaXNTYW1lRGF0ZTp2fSk7KG51bGw9PT0oYT1vKXx8dm9pZCAwPT09YT92b2lkIDA6YS5jb25zdHJ1Y3RvcikhPT1PYmplY3QmJihvPXt9KSwoby5kaXNhYmxlZHx8by5oaWRkZW4pJiYoZS5kaXNhYmxlZD0hMCksby5oaWRkZW4mJihlLmhpZGRlbj0hMCkscj1sKGwoe30sciksbyl9KSksZGVsZXRlIHIuZGlzYWJsZWQsZGVsZXRlIHIuaGlkZGVuLHJ9KGU9e2RhdGU6ZS5kYXRlLGRheTplLmRheSxjdXJyZW50OmUuY3VycmVudH0pLGg9WChlKSYmIWUuZGlzYWJsZWQsYj1cIlwiLmNvbmNhdChoP1wic2RcIjpcIlwiKSx4PXUuY2hpbGRyZW47aCYmKGI9XCJcIi5jb25jYXQoYixcIiBcIikuY29uY2F0KHUuY2xhc3NOYW1lfHxcIlwiKSksZGVsZXRlIHUuY2xhc3NOYW1lLGRlbGV0ZSB1LmNoaWxkcmVuO3ZhciBFPWZ1bmN0aW9uKGUscil7dmFyIHQ9W1wicm1kcC1kYXlcIl0sbj1lLmRhdGUsYT1lLmhpZGRlbixvPWUuY3VycmVudDtpZighWChlKXx8YSl0LnB1c2goXCJybWRwLWRheS1oaWRkZW5cIik7ZWxzZXsoRiYmbjxGfHxXJiZuPld8fGUuZGlzYWJsZWQpJiYodC5wdXNoKFwicm1kcC1kaXNhYmxlZFwiKSxlLmRpc2FibGVkfHwoZS5kaXNhYmxlZD0hMCkpLG98fHQucHVzaChcInJtZHAtZGVhY3RpdmVcIik7dmFyIGQ9cj4xJiZvfHwxPT09cjtlLmRpc2FibGVkJiZtfHwodihuLEwpJiZUJiZ0LnB1c2goXCJybWRwLXRvZGF5XCIpLGk9bixbXS5jb25jYXQoeikuc29tZSgoZnVuY3Rpb24oZSl7cmV0dXJuIHYoZSxpKX0pKSYmZCYmIUImJnQucHVzaChcInJtZHAtc2VsZWN0ZWRcIikpLEImJiFlLmRpc2FibGVkJiZkJiYodC5wdXNoKGsobix6LHZvaWQgMCxfKSksX3x8KHQ9dC5jb25jYXQoRChuLHosVSxqKSkpKX12YXIgaTtyZXR1cm4gdC5qb2luKFwiIFwiKX0oZSxnKTsoZS5oaWRkZW58fGUuZGlzYWJsZWQpJiYoYj1iLnJlcGxhY2UoXCJzZFwiLFwiXCIpKTt2YXIgTT1HP0UuaW5jbHVkZXMoXCJzZWxlY3RlZFwiKXx8RS5pbmNsdWRlcyhcInJhbmdlXCIpOkUuaW5jbHVkZXMoXCJ0b2RheVwiKTtyZXR1cm4gYS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7a2V5OmksdGFiSW5kZXg6TT8wOi0xLFwiYXJpYS1sYWJlbFwiOlwiQ2hvb3NlIFwiLmNvbmNhdChlLmRhdGUuZm9ybWF0KFwiZGRkZCBNTU1NIEREIG9mIFlZWVlcIikpLGNsYXNzTmFtZTpFLG9uTW91c2VFbnRlcjpmdW5jdGlvbigpe3JldHVybiBqJiYkKGUuZGF0ZSl9LG9uS2V5RG93bjpmdW5jdGlvbihyKXtyZXR1cm4gZnVuY3Rpb24oZSxyKXt2YXIgYT1lLmN1cnJlbnRUYXJnZXQsbz1lLmtleSxpPWUuY29kZSx1PXtBcnJvd1JpZ2h0OjEsQXJyb3dMZWZ0Oi0xLEFycm93VXA6LTcsQXJyb3dEb3duOjd9O2lmKFwiU3BhY2VcIj09PWl8fFwiIFwiPT09byllLnByZXZlbnREZWZhdWx0KCksYS5jbGljaygpO2Vsc2UgaWYoT2JqZWN0LmtleXModSkuaW5jbHVkZXMobykpe3ZhciBjPWZ1bmN0aW9uKGUpe2lmKCFlKXJldHVybiBzKCk7dmFyIHI9ZS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKTtyLmluY2x1ZGVzKFwiaGlkZGVuXCIpfHxyLmluY2x1ZGVzKFwiZGlzYWJsZWRcIik/cygpOmUuZm9jdXMoKX0scz1mdW5jdGlvbigpe24obChsKHt9LHQpLHt9LHtkYXRlOnB9KSksY2xlYXJUaW1lb3V0KE8pLE89c2V0VGltZW91dCgoZnVuY3Rpb24oKXtyZXR1cm4gYyhaKHApKX0pLDEwMCl9O2UucHJldmVudERlZmF1bHQoKTt2YXIgZj11W29dLHA9bmV3IGQuZGVmYXVsdChyLmRhdGUpLmFkZChmLFwiZGF5XCIpLG09WihwKTtjKG0pfX0ocixlKX0sb25DbGljazpmdW5jdGlvbigpe1goZSkmJiFlLmRpc2FibGVkJiZmdW5jdGlvbihlLHIsbil7dmFyIGEsaSx1LGM9ZS5kYXRlLHM9ZS5jdXJyZW50LHA9dC5zZWxlY3RlZERhdGUsbT10LmZvY3VzZWQsaD10LmRhdGUsZz1oLGI9Zy5ob3VyLHY9Zy5taW51dGUseD1nLnNlY29uZDtjLnNldCh7aG91cjoobnVsbD09PShhPXApfHx2b2lkIDA9PT1hP3ZvaWQgMDphLmhvdXIpfHxiLG1pbnV0ZToobnVsbD09PShpPXApfHx2b2lkIDA9PT1pP3ZvaWQgMDppLm1pbnV0ZSl8fHYsc2Vjb25kOihudWxsPT09KHU9cCl8fHZvaWQgMD09PXU/dm9pZCAwOnUuc2Vjb25kKXx8eH0pLDEhPT1ufHxzP24+MSYmIXMmJigwPT09ciYmYzxoJiYoaD1uZXcgZC5kZWZhdWx0KGgpLnRvRmlyc3RPZk1vbnRoKCkpLHI+MCYmYy5tb250aEluZGV4PmgubW9udGhJbmRleCtyJiZyKzE9PT1uJiYoaD1uZXcgZC5kZWZhdWx0KGgpLnRvRmlyc3RPZk1vbnRoKCkuYWRkKDEsXCJtb250aFwiKSkpOmg9bmV3IGQuZGVmYXVsdChoKS50b0ZpcnN0T2ZNb250aCgpO3ZhciBrPWYodyhjLHksdCksMik7cD1rWzBdLG09a1sxXSxvKHAsbChsKHt9LHQpLHt9LHtkYXRlOmgsZm9jdXNlZDptLHNlbGVjdGVkRGF0ZTpwfSkpLFkobSxjKX0oZSxyLGcpfX0sYS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsYyh7Y2xhc3NOYW1lOmJ9LHUpLFgoZSkmJiFlLmhpZGRlbj9udWxsIT14P3g6ZS5kYXk6XCJcIikpfSkpKX0pKSl9KSkpO2Z1bmN0aW9uIFgoZSl7cmV0dXJuISFlLmN1cnJlbnR8fHN9ZnVuY3Rpb24gWihlKXtyZXR1cm4gUi5jdXJyZW50LnF1ZXJ5U2VsZWN0b3IoXCJbYXJpYS1sYWJlbCo9J1wiLmNvbmNhdChlLmZvcm1hdChcImRkZGQgTU1NTSBERCBvZiBZWVlZXCIpLFwiJ11cIikpfX1mdW5jdGlvbiBZKGUpe3ZhciByPWUuZGlyZWN0aW9uLHQ9ZS5vbkNsaWNrLG49ZS5kaXNhYmxlZDtyZXR1cm4gYS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIix7dHlwZTpcImJ1dHRvblwiLGNsYXNzTmFtZTpcInJtZHAtYXJyb3ctY29udGFpbmVyIFwiLmNvbmNhdChyLFwiIFwiKS5jb25jYXQobj9cImRpc2FibGVkXCI6XCJcIiksb25DbGljazp0LFwiYXJpYS1yb2xlZGVzY3JpcHRpb25cIjpcImJ1dHRvbiB0byBuYXZpZ2F0ZSBcIi5jb25jYXQoci5yZXBsYWNlKFwicm1kcC1cIixcIlwiKSl9LGEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaVwiLHtjbGFzc05hbWU6XCJybWRwLWFycm93XCJ9KSl9ZnVuY3Rpb24gTShyKXt2YXIgdD1yLnN0YXRlLG49ci5zZXRTdGF0ZSxvPXIuZGlzYWJsZVllYXJQaWNrZXIsZD1yLmRpc2FibGVNb250aFBpY2tlcixpPXIuYnV0dG9ucyx1PXIucmVuZGVyQnV0dG9uLGM9ci5oYW5kbGVNb250aENoYW5nZSxzPXIuZGlzYWJsZWQscD1yLmhpZGVNb250aCxtPXIuaGlkZVllYXIsaD1yLmlzUlRMLHk9ci5mdWxsWWVhcixnPWYoci5tb250aEFuZFllYXJzLDIpLGI9Z1swXSx2PWdbMV0seD1yLm1vbnRoWWVhclNlcGFyYXRvcix3PXIuZm9ybWF0TW9udGgsaz1yLmZvcm1hdFllYXIsRD1yLmhlYWRlck9yZGVyLE89e30sRT10LmRhdGUsTT10Lm9ubHlNb250aFBpY2tlcixDPXQub25seVllYXJQaWNrZXIsTj10Lm11c3RTaG93WWVhclBpY2tlcixQPXQubWluRGF0ZSxTPXQubWF4RGF0ZSxJPXQueWVhcixqPXQudG9kYXksVD1QJiZFLnllYXI8PVAueWVhciYmUC5tb250aEluZGV4PkUubW9udGhJbmRleC0xLEE9UyYmRS55ZWFyPj1TLnllYXImJlMubW9udGhJbmRleDxFLm1vbnRoSW5kZXgrMSxSPWoueWVhcis3O2lmKFItPTEyKk1hdGguZmxvb3IoKFItSSkvMTIpLChwfHx5KSYmbSYmIWkpcmV0dXJuIG51bGw7aWYoKE18fHkpJiYoUCYmUC55ZWFyPj1FLnllYXImJihUPSEwKSxTJiZTLnllYXI8PUUueWVhciYmKEE9ITApKSxOfHxDKXt2YXIgTD1SLTExO1Q9UCYmUC55ZWFyPkwsQT1TJiZTLnllYXI8Un1yZXR1cm4gcyYmKFQ9ITAsQT0hMCksYS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7Y2xhc3NOYW1lOlwicm1kcC1oZWFkZXJcIn0sYS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7c3R5bGU6e3Bvc2l0aW9uOlwicmVsYXRpdmVcIixkaXNwbGF5OlwiZmxleFwiLGFsaWduSXRlbXM6XCJjZW50ZXJcIn19LEFycmF5LmZyb20obmV3IFNldChEKSkubWFwKChmdW5jdGlvbihyLHQpe3JldHVybiBhLmRlZmF1bHQuY3JlYXRlRWxlbWVudChlLkZyYWdtZW50LHtrZXk6dH0sZnVuY3Rpb24ocil7c3dpdGNoKHIpe2Nhc2VcIkxFRlRfQlVUVE9OXCI6cmV0dXJuIGkmJlcoXCJsZWZ0XCIpO2Nhc2VcIlJJR0hUX0JVVFRPTlwiOnJldHVybiBpJiZXKFwicmlnaHRcIik7Y2FzZVwiTU9OVEhfWUVBUlwiOmNhc2VcIllFQVJfTU9OVEhcIjppZih5KXJldHVybiBhLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLHtjbGFzc05hbWU6XCJybWRwLWhlYWRlci12YWx1ZXNcIixzdHlsZTpPfSwhbSYmRS5mb3JtYXQoXCJZWVlZXCIpKTt2YXIgdD1yLnNwbGl0KFwiX1wiKS5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVyblwiTU9OVEhcIj09PWUmJiFwfHxcIllFQVJcIj09PWUmJiFtfSkpO3JldHVybiB0Lmxlbmd0aD4xJiYodD1bdFswXSxGKCksdFsxXV0pLGIubWFwKChmdW5jdGlvbihyLG4pe3JldHVybiBhLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLHtrZXk6bixjbGFzc05hbWU6XCJybWRwLWhlYWRlci12YWx1ZXNcIixzdHlsZTpPfSx0Lm1hcCgoZnVuY3Rpb24odCxpKXtyZXR1cm4gYS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoZS5GcmFnbWVudCx7a2V5Oml9LGZ1bmN0aW9uKGUscix0KXtzd2l0Y2goZSl7Y2FzZVwiTU9OVEhcIjpyZXR1cm4gYS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIse3N0eWxlOntjdXJzb3I6c3x8ZHx8TT9cImRlZmF1bHRcIjpcInBvaW50ZXJcIn0sb25DbGljazpmdW5jdGlvbigpe3JldHVybiFkJiZfKFwibXVzdFNob3dNb250aFBpY2tlclwiKX19LGZ1bmN0aW9uKGUscil7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2Ygdz93KGUscik6ZX0ocix2W3RdKSk7Y2FzZVwiWUVBUlwiOnJldHVybiBhLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInNwYW5cIix7c3R5bGU6e2N1cnNvcjpzfHxvfHxDP1wiZGVmYXVsdFwiOlwicG9pbnRlclwifSxvbkNsaWNrOmZ1bmN0aW9uKCl7cmV0dXJuIW8mJl8oXCJtdXN0U2hvd1llYXJQaWNrZXJcIil9fSxmdW5jdGlvbihlLHIpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIHc/ayhlLHIpOmV9KHZbdF0scikpO2RlZmF1bHQ6cmV0dXJuIGV9fSh0LHIsbikpfSkpKX0pKTtkZWZhdWx0OnJldHVybn19KHIpKX0pKSkpO2Z1bmN0aW9uIEYoKXtyZXR1cm4geD9hLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInNwYW5cIixudWxsLHgpOmg/XCLYjFwiOlwiLFwifWZ1bmN0aW9uIFcocil7dmFyIHQ9ZnVuY3Rpb24oZSl7ZS5wcmV2ZW50RGVmYXVsdCgpLEIoXCJyaWdodFwiPT09cj8xOi0xKSxmdW5jdGlvbihlKXtzZXRUaW1lb3V0KChmdW5jdGlvbigpe3ZhciByPWUudGFyZ2V0LmNsb3Nlc3QoXCIucm1kcC1jYWxlbmRhclwiKTtpZihyKXt2YXIgdD1yLnF1ZXJ5U2VsZWN0b3IoXCJkaXZbdGFiaW5kZXg9JzAnXVwiKTt0JiZ0LmdldEF0dHJpYnV0ZShcImNsYXNzXCIpLmluY2x1ZGVzKFwiaGlkZGVuXCIpJiYodC5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLFwiLTFcIiksdD12b2lkIDApLHR8fCh0PXIucXVlcnlTZWxlY3RvcihcImRpdlt0YWJpbmRleD0nLTEnXTpub3QoLnJtZHAtZGF5LWhpZGRlbilcIikpJiZ0LnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsXCIwXCIpfX0pLDIwMCl9KGUpfSxuPVwibGVmdFwiPT09ciYmVHx8XCJyaWdodFwiPT09ciYmQTtyZXR1cm4gdSBpbnN0YW5jZW9mIEZ1bmN0aW9uP3Uocix0LG4pOmUuaXNWYWxpZEVsZW1lbnQodSk/ZS5jbG9uZUVsZW1lbnQodSx7ZGlyZWN0aW9uOnIsaGFuZGxlQ2xpY2s6dCxkaXNhYmxlZDpufSk6YS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoWSx7ZGlyZWN0aW9uOlwicm1kcC1cIi5jb25jYXQociksb25DbGljazp0LGRpc2FibGVkOm59KX1mdW5jdGlvbiBCKGUpe3N8fGU8MCYmVHx8ZT4wJiZBfHwoeT9FLnllYXIrPWU6Tnx8Qz8oSSs9MTIqZSxlPDAmJlAmJkk8UC55ZWFyJiYoST1QLnllYXIpLGU+MCYmUyYmST5TLnllYXImJihJPVMueWVhcikpOihFLnRvRmlyc3RPZk1vbnRoKCksTT9FLnllYXIrPWU6KEUubW9udGgrPWUsYyhFKSkpLG4obChsKHt9LHQpLHt9LHtkYXRlOkUseWVhcjpJfSkpKX1mdW5jdGlvbiBfKGUpe2lmKCFzKXt2YXIgcj17bXVzdFNob3dNb250aFBpY2tlcjohMSxtdXN0U2hvd1llYXJQaWNrZXI6ITF9O3JbZV09IXRbZV0sbihsKGwoe30sdCkscikpfX19ZnVuY3Rpb24gQyhlKXtyZXR1cm4gZyhlKXx8KGU9W10pLEpTT04uc3RyaW5naWZ5KGUpfWZ1bmN0aW9uIE4ocil7dmFyIHQ9ci5zdGF0ZSxuPXIub25DaGFuZ2Usbz1yLmN1c3RvbU1vbnRocyxpPXIuc29ydCx1PXIuaGFuZGxlTW9udGhDaGFuZ2UsYz1yLmhhbmRsZUZvY3VzZWREYXRlLHM9ci5yYW5nZUhvdmVyLHA9ci5oaWdobGlnaHRUb2RheSxtPXIubnVtYmVyT2ZNb250aHMsaD10LmRhdGUseT10LnRvZGF5LGI9dC5taW5EYXRlLHg9dC5tYXhEYXRlLE89dC5jYWxlbmRhcixFPXQubG9jYWxlLFk9dC5vbmx5TW9udGhQaWNrZXIsTT10Lm9ubHlZZWFyUGlja2VyLE49dC5yYW5nZSxQPXQub25seVNob3dJblJhbmdlRGF0ZXMsUz0odC5tdXN0U2hvd01vbnRoUGlja2VyfHxZKSYmIU0sST1mKGUudXNlU3RhdGUoKSwyKSxqPUlbMF0sVD1JWzFdO289byYmQyhvKTt2YXIgQT1lLnVzZU1lbW8oKGZ1bmN0aW9uKCl7dmFyIGU9W10scj1ZP206MSxuPW8mJkpTT04ucGFyc2UobyksYT1uZXcgZC5kZWZhdWx0KHtjYWxlbmRhcjpPLGxvY2FsZTpFLGZvcm1hdDp0LmRhdGUuX2Zvcm1hdCx5ZWFyOnQuZGF0ZS55ZWFyLG1vbnRoOjEsZGF5OjF9KTtnKG4pJiZuLmxlbmd0aD49MTI/KG4ubGVuZ3RoPTEyLG49bi5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBnKGUpP2VbMF06ZX0pKSk6bj1hLmxvY2FsZS5tb250aHMubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gZihlLDEpWzBdfSkpO2Zvcih2YXIgaT0wO2k8cjtpKyspe2Zvcih2YXIgbD1bXSx1PTAsYz0wO2M8NDtjKyspe2Zvcih2YXIgcz1bXSxwPTA7cDwzO3ArKylzLnB1c2goe2RhdGU6bmV3IGQuZGVmYXVsdChhKSxuYW1lOm5bdV19KSx1KyssYS5hZGQoMSxcIm1vbnRoXCIpO2wucHVzaChzKX1lLnB1c2gobCl9cmV0dXJuIGV9KSxbTyxFLG8sdC5kYXRlLnllYXIsdC5kYXRlLl9mb3JtYXQsbSxZXSk7cmV0dXJuIGEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2NsYXNzTmFtZTpcIlwiLmNvbmNhdChZP1wib25seSBcIjpcIlwiLFwicm1kcC1tb250aC1waWNrZXJcIiksc3R5bGU6e2Rpc3BsYXk6Uz9cImZsZXhcIjpcIm5vbmVcIn0sb25Nb3VzZUxlYXZlOmZ1bmN0aW9uKCl7cmV0dXJuIHMmJlQoKX19LEEubWFwKChmdW5jdGlvbihlLHIpe3JldHVybiBhLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLHtrZXk6cixzdHlsZTp7bWFyZ2luOlwiMCA1cHhcIixmbGV4OjF9fSxlLm1hcCgoZnVuY3Rpb24oZSxyKXtyZXR1cm4gYS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7a2V5OnIsY2xhc3NOYW1lOlwicm1kcC15bVwifSxlLm1hcCgoZnVuY3Rpb24oZSxyKXt2YXIgdD1lLmRhdGUsbj1lLm5hbWU7cmV0dXJuIGEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2tleTpyLGNsYXNzTmFtZTpMKHQpLG9uQ2xpY2s6ZnVuY3Rpb24oKXtyZXR1cm4gUih0KX0sb25Nb3VzZUVudGVyOmZ1bmN0aW9uKCl7cmV0dXJuIHMmJlQodCl9fSxhLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInNwYW5cIix7Y2xhc3NOYW1lOlk/XCJzZFwiOlwiXCJ9LG4pKX0pKSl9KSkpfSkpKTtmdW5jdGlvbiBSKGUpe3ZhciByPXQuc2VsZWN0ZWREYXRlLGE9dC5mb2N1c2VkLG89ZS55ZWFyLGQ9ZS5tb250aEluZGV4O2lmKCEoYiYmbzw9Yi55ZWFyJiZkPGIubW9udGhJbmRleHx8eCYmbz49eC55ZWFyJiZkPngubW9udGhJbmRleCkpe2lmKGguc2V0TW9udGgoZCsxKSxZKXt2YXIgcz1mKHcoZSxpLHQpLDIpO3I9c1swXSxhPXNbMV19ZWxzZSB1KGgpO24oWT9yOnZvaWQgMCxsKGwoe30sdCkse30se2RhdGU6aCxmb2N1c2VkOmEsc2VsZWN0ZWREYXRlOnIsbXVzdFNob3dNb250aFBpY2tlcjohMX0pKSxZJiZjKGEsZSl9fWZ1bmN0aW9uIEwoZSl7dmFyIHI9W1wicm1kcC1kYXlcIl0sbj1lLnllYXIsYT1lLm1vbnRoSW5kZXgsbz10LnNlbGVjdGVkRGF0ZSxkPXQubXVsdGlwbGU7aWYoKGImJihuPGIueWVhcnx8bj09PWIueWVhciYmYTxiLm1vbnRoSW5kZXgpfHx4JiYobj54LnllYXJ8fG49PT14LnllYXImJmE+eC5tb250aEluZGV4KSkmJnIucHVzaChcInJtZHAtZGlzYWJsZWRcIiksIXIuaW5jbHVkZXMoXCJybWRwLWRpc2FibGVkXCIpfHwhUClyZXR1cm4gdih5LGUsITApJiZwJiZyLnB1c2goXCJybWRwLXRvZGF5XCIpLFk/Tj8oci5wdXNoKGsoZSxvLCEwLGQpKSxkfHwocj1yLmNvbmNhdChEKGUsbyxqLHMsXCJtb250aFwiKSkpKTpbXS5jb25jYXQobykuc29tZSgoZnVuY3Rpb24ocil7cmV0dXJuIHYocixlLCEwKX0pKSYmci5wdXNoKFwicm1kcC1zZWxlY3RlZFwiKTpoLm1vbnRoSW5kZXg9PT1hJiZyLnB1c2goXCJybWRwLXNlbGVjdGVkXCIpLHIuam9pbihcIiBcIil9fWZ1bmN0aW9uIFAoZSxyKXtyZXR1cm4gZS5yZXBsYWNlKC9bMC05XS9nLChmdW5jdGlvbihlKXtyZXR1cm4gcltlXX0pKX1mdW5jdGlvbiBTKHIpe3ZhciB0PXIuc3RhdGUsbj1yLm9uQ2hhbmdlLG89ci5zb3J0LGk9ci5oYW5kbGVGb2N1c2VkRGF0ZSx1PXIub25ZZWFyQ2hhbmdlLGM9ci5yYW5nZUhvdmVyLHM9ci5oaWdobGlnaHRUb2RheSxwPXQuZGF0ZSxtPXQudG9kYXksaD10Lm1pbkRhdGUseT10Lm1heERhdGUsYj10Lm9ubHlZZWFyUGlja2VyLHY9dC5yYW5nZSx4PXQub25seVNob3dJblJhbmdlRGF0ZXMsaz10LnllYXIsRD10Lm11c3RTaG93WWVhclBpY2tlcnx8YixPPXAuZGlnaXRzLEU9ZihlLnVzZVN0YXRlKCksMiksWT1FWzBdLE09RVsxXSxDPW0ueWVhci00O0MtPTEyKk1hdGguY2VpbCgoQy1rKS8xMik7dmFyIE49ZS51c2VNZW1vKChmdW5jdGlvbigpe2Zvcih2YXIgZT1bXSxyPUMsdD0wO3Q8NDt0Kyspe2Zvcih2YXIgbj1bXSxhPTA7YTwzO2ErKyluLnB1c2gocikscisrO2UucHVzaChuKX1yZXR1cm4gZX0pLFtDXSk7cmV0dXJuIGEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2NsYXNzTmFtZTpcIlwiLmNvbmNhdChiP1wib25seSBcIjpcIlwiLFwicm1kcC15ZWFyLXBpY2tlclwiKSxzdHlsZTp7ZGlzcGxheTpEP1wiYmxvY2tcIjpcIm5vbmVcIn19LE4ubWFwKChmdW5jdGlvbihlLHIpe3JldHVybiBhLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLHtrZXk6cixjbGFzc05hbWU6XCJybWRwLXltXCIsb25Nb3VzZUxlYXZlOmZ1bmN0aW9uKCl7cmV0dXJuIGMmJk0oKX19LGUubWFwKChmdW5jdGlvbihlLHIpe3JldHVybiBhLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLHtrZXk6cixjbGFzc05hbWU6UyhlKSxvbkNsaWNrOmZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGUpe2lmKEkoZSkpcmV0dXJuO3ZhciByPW5ldyBkLmRlZmF1bHQodC5kYXRlKS5zZXRZZWFyKGUpLGE9dC5zZWxlY3RlZERhdGUsYz10LmZvY3VzZWQ7aWYoYil7dmFyIHM9Zih3KHIsbyx0KSwyKTthPXNbMF0sYz1zWzFdfWVsc2UgaCYmci5tb250aEluZGV4PGgubW9udGhJbmRleD9yPXIuc2V0TW9udGgoaC5tb250aEluZGV4KzEpOnkmJnIubW9udGhJbmRleD55Lm1vbnRoSW5kZXgmJihyPXIuc2V0TW9udGgoeS5tb250aEluZGV4KzEpKSxudWxsPT11fHx1KHIpO24oYj9hOnZvaWQgMCxsKGwoe30sdCkse30se2RhdGU6cixmb2N1c2VkOmMsc2VsZWN0ZWREYXRlOmEsbXVzdFNob3dZZWFyUGlja2VyOiExfSkpLGImJmkoYyxyKX0oZSl9LG9uTW91c2VFbnRlcjpmdW5jdGlvbigpe3JldHVybiBjJiZNKGUpfX0sYS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIse2NsYXNzTmFtZTpiP1wic2RcIjpcIlwifSxQKGUudG9TdHJpbmcoKSxPKSkpfSkpKX0pKSk7ZnVuY3Rpb24gUyhlKXt2YXIgcj1bXCJybWRwLWRheVwiXSxuPXQuZGF0ZSxhPXQuc2VsZWN0ZWREYXRlLG89dC5tdWx0aXBsZTtpZihJKGUpJiZyLnB1c2goXCJybWRwLWRpc2FibGVkXCIpLCFyLmluY2x1ZGVzKFwicm1kcC1kaXNhYmxlZFwiKXx8IXgpe2lmKG0ueWVhcj09PWUmJnMmJnIucHVzaChcInJtZHAtdG9kYXlcIiksYilpZih2KXt2YXIgZD1mdW5jdGlvbih0KXt2YXIgbj10WzBdLGE9dFsxXTtpZigxPT09dC5sZW5ndGgpe2lmKGU9PT1uLnllYXImJnIucHVzaChcInJtZHAtcmFuZ2VcIiksYyl7dmFyIG89dFswXS55ZWFyOyhlPm8mJmU8PVl8fGU8byYmZT49WSkmJihyLnB1c2goXCJybWRwLXJhbmdlLWhvdmVyXCIpLGU9PT1ZJiZyLnB1c2goWT5vP1wiZW5kXCI6XCJzdGFydFwiKSl9fWVsc2UgMj09PXQubGVuZ3RoJiYoZT49bi55ZWFyJiZlPD1hLnllYXImJnIucHVzaChcInJtZHAtcmFuZ2VcIiksZT09PW4ueWVhciYmci5wdXNoKFwic3RhcnRcIiksZT09PWEueWVhciYmci5wdXNoKFwiZW5kXCIpKX07bz8oZyhhKT9hOltbYV1dKS5mb3JFYWNoKChmdW5jdGlvbihlKXtyZXR1cm4gZChlKX0pKTpkKGEpfWVsc2VbXS5jb25jYXQoYSkuc29tZSgoZnVuY3Rpb24ocil7cmV0dXJuIHImJnIueWVhcj09PWV9KSkmJnIucHVzaChcInJtZHAtc2VsZWN0ZWRcIik7ZWxzZSBlPT09bi55ZWFyJiZyLnB1c2goXCJybWRwLXNlbGVjdGVkXCIpO3JldHVybiByLmpvaW4oXCIgXCIpfX1mdW5jdGlvbiBJKGUpe3JldHVybiBoJiZlPGgueWVhcnx8eSYmZT55LnllYXJ9fWZ1bmN0aW9uIEkoZSxyLHQpe3JldHVybiB0fHwoZT9cIk1NL1lZWVlcIjpyP1wiWVlZWVwiOlwiWVlZWS9NTS9ERFwiKX1mdW5jdGlvbiBqKGUscil7cmV0dXJuIGUgaW5zdGFuY2VvZiBkLmRlZmF1bHQ/ZS5zZXRDYWxlbmRhcihyKTplPW5ldyBkLmRlZmF1bHQoe2RhdGU6ZSxjYWxlbmRhcjpyfSksZX1mdW5jdGlvbiBUKGUpe1wiX3NlbGZcImluIGEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpJiZjb25zb2xlLndhcm4oZS5qb2luKFwiXFxuXCIpKX12YXIgQT1uZXcgZC5kZWZhdWx0LFI9QS5jYWxlbmRhcixMPUEubG9jYWxlO2Z1bmN0aW9uIEYoZSxyKXtyZXR1cm4gZSYmZS5jb25zdHJ1Y3RvciE9PU9iamVjdCYmKFQoVyhcImNhbGVuZGFyXCIpKSxlPXZvaWQgMCksciYmci5jb25zdHJ1Y3RvciE9PU9iamVjdCYmKFQoVyhcImxvY2FsZVwiKSkscj12b2lkIDApLFtlfHxSLHJ8fExdfWZ1bmN0aW9uIFcoZSl7cmV0dXJuW1wiXCIuY29uY2F0KGUsXCIgbXVzdCBiZSBhbiBvYmplY3RcIiksXCJodHRwczovL3NoYWhhYnlhemRpLmdpdGh1Yi5pby9yZWFjdC1tdWx0aS1kYXRlLXBpY2tlci9jYWxlbmRhcnMvXCJdfWZ1bmN0aW9uIEIoZSl7cmV0dXJuIGUmJmUubmFtZT9lLm5hbWUuc3BsaXQoXCJfXCIpWzFdOlwiXCJ9ZnVuY3Rpb24gXyhlKXtyZXR1cm5bXCJmYVwiLFwiYXJcIl0uaW5jbHVkZXMoQihlKSl9ZnVuY3Rpb24gVihlLHIpe3ZvaWQgMD09PXImJihyPXt9KTt2YXIgdD1yLmluc2VydEF0O2lmKGUmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCl7dmFyIG49ZG9jdW1lbnQuaGVhZHx8ZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdLGE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO2EudHlwZT1cInRleHQvY3NzXCIsXCJ0b3BcIj09PXQmJm4uZmlyc3RDaGlsZD9uLmluc2VydEJlZm9yZShhLG4uZmlyc3RDaGlsZCk6bi5hcHBlbmRDaGlsZChhKSxhLnN0eWxlU2hlZXQ/YS5zdHlsZVNoZWV0LmNzc1RleHQ9ZTphLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGUpKX19VihcIi5ybWRwLXdyYXBwZXJ7YmFja2dyb3VuZC1jb2xvcjojZmZmO2JvcmRlci1yYWRpdXM6NXB4O2RpcmVjdGlvbjpsdHI7dGV4dC1hbGlnbjpjZW50ZXI7d2lkdGg6bWF4LWNvbnRlbnR9LnJtZHAtc2hhZG93e2JveC1zaGFkb3c6MCAwIDVweCAjODc5OGFkfS5ybWRwLWJvcmRlcntib3JkZXI6MXB4IHNvbGlkICNjZmQ4ZTJ9LnJtZHAtY2FsZW5kYXJ7aGVpZ2h0Om1heC1jb250ZW50O3BhZGRpbmc6NHB4fS5ybWRwLWJvcmRlci10b3B7Ym9yZGVyLXRvcDoxcHggc29saWQgI2NmZDhlMn0ucm1kcC1ib3JkZXItYm90dG9te2JvcmRlci1ib3R0b206MXB4IHNvbGlkICNjZmQ4ZTJ9LnJtZHAtYm9yZGVyLWxlZnR7Ym9yZGVyLWxlZnQ6MXB4IHNvbGlkICNjZmQ4ZTJ9LnJtZHAtYm9yZGVyLXJpZ2h0e2JvcmRlci1yaWdodDoxcHggc29saWQgI2NmZDhlMn0ucm1kcC13ZWVrLC5ybWRwLXlte2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2Vlbn0ucm1kcC15bXtoZWlnaHQ6MjUlfS5ybWRwLWRheSwucm1kcC13ZWVrLWRheXtjb2xvcjojMDAwO2N1cnNvcjpwb2ludGVyO2hlaWdodDozNHB4O3Bvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOjM0cHh9LnJtZHAtd2Vlay1kYXl7Y29sb3I6IzAwNzRkOTtjdXJzb3I6ZGVmYXVsdDtmb250LXNpemU6MTNweDtmb250LXdlaWdodDo1MDB9LnJtZHAtZGF5IHNwYW4sLnJtZHAtd2Vlay1kYXl7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyfS5ybWRwLWRheSBzcGFue2JvcmRlci1yYWRpdXM6NTAlO2JvdHRvbTozcHg7Zm9udC1zaXplOjE0cHg7bGVmdDozcHg7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6M3B4O3RvcDozcHh9LnJtZHAtZGF5LnJtZHAtdG9kYXkgc3BhbntiYWNrZ3JvdW5kLWNvbG9yOiM3ZmRiZmY7Y29sb3I6I2ZmZn0ucm1kcC1kYXkucm1kcC1zZWxlY3RlZCBzcGFuOm5vdCguaGlnaGxpZ2h0KXtiYWNrZ3JvdW5kLWNvbG9yOiMwMDc0ZDk7Ym94LXNoYWRvdzowIDAgM3B4ICM4Nzk4YWQ7Y29sb3I6I2ZmZn0ucm1kcC1kYXkucm1kcC1kZWFjdGl2ZSwucm1kcC1kYXkucm1kcC1kaXNhYmxlZHtjb2xvcjojODc5OGFkfS5ybWRwLWRheS5ybWRwLWRlYWN0aXZlLnJtZHAtc2VsZWN0ZWQgc3BhbntiYWNrZ3JvdW5kLWNvbG9yOiM0Y2E2ZjU7Ym94LXNoYWRvdzowIDAgM3B4ICNiYWM1ZDN9LnJtZHAteW0gLnJtZHAtZGF5e2ZsZXg6MTttYXJnaW46YXV0b30ucm1kcC15bSAucm1kcC1kYXkgc3Bhbntib3JkZXItcmFkaXVzOjEycHg7cGFkZGluZzoycHggMH0ucm1kcC1yYW5nZXtiYWNrZ3JvdW5kLWNvbG9yOiMwMDc0ZDk7Ym94LXNoYWRvdzowIDAgM3B4ICM4Nzk4YWQ7Y29sb3I6I2ZmZn0ucm1kcC1yYW5nZS1ob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiM3ZWE2ZjA7Y29sb3I6I2ZmZn0ucm1kcC1yYW5nZS1ob3Zlci5zdGFydCwucm1kcC1yYW5nZS5zdGFydHtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOjUwJTtib3JkZXItdG9wLWxlZnQtcmFkaXVzOjUwJX0ucm1kcC1yYW5nZS1ob3Zlci5lbmQsLnJtZHAtcmFuZ2UuZW5ke2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOjUwJTtib3JkZXItdG9wLXJpZ2h0LXJhZGl1czo1MCV9LnJtZHAteW0gLnJtZHAtcmFuZ2UtaG92ZXIuc3RhcnQsLnJtZHAteW0gLnJtZHAtcmFuZ2Uuc3RhcnR7Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czoxNXB4O2JvcmRlci10b3AtbGVmdC1yYWRpdXM6MTVweH0ucm1kcC15bSAucm1kcC1yYW5nZS1ob3Zlci5lbmQsLnJtZHAteW0gLnJtZHAtcmFuZ2UuZW5ke2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOjE1cHg7Ym9yZGVyLXRvcC1yaWdodC1yYWRpdXM6MTVweH0ucm1kcC1kYXk6bm90KC5ybWRwLWRpc2FibGVkKTpub3QoLnJtZHAtZGF5LWhpZGRlbikgc3Bhbjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiM3ZWE2ZjA7Y29sb3I6I2ZmZn0ucm1kcC1kYXktcGlja2Vye3BhZGRpbmc6NXB4fS5ybWRwLWhlYWRlcntmb250LXNpemU6MTRweDttYXJnaW4tdG9wOjVweDtwYWRkaW5nOjlweCAwfS5ybWRwLW1vbnRoLXBpY2tlciwucm1kcC15ZWFyLXBpY2tlcntiYWNrZ3JvdW5kLWNvbG9yOiNmZmY7Ym9yZGVyLXJhZGl1czowIDAgNXB4IDVweDtib3R0b206MnB4O2xlZnQ6MnB4O3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjJweDt0b3A6MnB4fS5vbmx5LnJtZHAtbW9udGgtcGlja2VyLC5vbmx5LnJtZHAteWVhci1waWNrZXJ7aGVpZ2h0OjI0MHB4O3Bvc2l0aW9uOnN0YXRpYzt3aWR0aDoyNDBweH0ucm1kcC1oZWFkZXItdmFsdWVze2NvbG9yOiMwMDA7bWFyZ2luOmF1dG99LnJtZHAtaGVhZGVyLXZhbHVlcyBzcGFue3BhZGRpbmc6MCAwIDAgNXB4fS5ybWRwLWFycm93e2JvcmRlcjpzb2xpZCAjMDA3NGQ5O2JvcmRlci13aWR0aDowIDJweCAycHggMDtkaXNwbGF5OmlubGluZS1ibG9jaztoZWlnaHQ6M3B4O21hcmdpbi10b3A6NXB4O3BhZGRpbmc6MnB4O3dpZHRoOjNweH0ucm1kcC1yaWdodCBpe21hcmdpbi1yaWdodDozcHg7dHJhbnNmb3JtOnJvdGF0ZSgtNDVkZWcpOy13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgtNDVkZWcpfS5ybWRwLWxlZnQgaXttYXJnaW4tbGVmdDozcHg7dHJhbnNmb3JtOnJvdGF0ZSgxMzVkZWcpOy13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgxMzVkZWcpfS5ybWRwLWxlZnR7bGVmdDowfS5ybWRwLXJpZ2h0e3JpZ2h0OjB9LnJtZHAtYXJyb3ctY29udGFpbmVye2JhY2tncm91bmQ6dHJhbnNwYXJlbnQ7Ym9yZGVyOm5vbmU7Ym9yZGVyLXJhZGl1czo1MCU7Y3Vyc29yOnBvaW50ZXI7ZGlzcGxheTpmbGV4O2hlaWdodDoyMHB4O2p1c3RpZnktY29udGVudDpjZW50ZXI7bWFyZ2luOjAgNXB4O3BhZGRpbmc6MDt3aWR0aDoyMHB4fS5ybWRwLWFycm93LWNvbnRhaW5lcjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiMwMDc0ZDk7Ym94LXNoYWRvdzowIDAgM3B4ICM4Nzk4YWR9LnJtZHAtYXJyb3ctY29udGFpbmVyOmhvdmVyIC5ybWRwLWFycm93e2JvcmRlcjpzb2xpZCAjZmZmO2JvcmRlci13aWR0aDowIDJweCAycHggMH0ucm1kcC1hcnJvdy1jb250YWluZXIuZGlzYWJsZWR7Y3Vyc29yOmRlZmF1bHR9LnJtZHAtYXJyb3ctY29udGFpbmVyLmRpc2FibGVkOmhvdmVye2JhY2tncm91bmQtY29sb3I6aW5oZXJpdDtib3gtc2hhZG93OmluaGVyaXR9LnJtZHAtYXJyb3ctY29udGFpbmVyLmRpc2FibGVkIC5ybWRwLWFycm93LC5ybWRwLWFycm93LWNvbnRhaW5lci5kaXNhYmxlZDpob3ZlciAucm1kcC1hcnJvd3tib3JkZXI6c29saWQgZ3JheTtib3JkZXItd2lkdGg6MCAycHggMnB4IDB9LnJtZHAtcnRse2RpcmVjdGlvbjpydGx9LnJtZHAtcnRsIC5ybWRwLWxlZnQgaXttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDozcHg7dHJhbnNmb3JtOnJvdGF0ZSgtNDVkZWcpOy13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgtNDVkZWcpfS5ybWRwLXJ0bCAucm1kcC1yaWdodCBpe21hcmdpbi1sZWZ0OjNweDttYXJnaW4tcmlnaHQ6MDt0cmFuc2Zvcm06cm90YXRlKDEzNWRlZyk7LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDEzNWRlZyl9LnJtZHAtcnRsIC5ybWRwLXJpZ2h0e2xlZnQ6MDtyaWdodDphdXRvfS5ybWRwLXJ0bCAucm1kcC1sZWZ0e2xlZnQ6YXV0bztyaWdodDowfS5ybWRwLXJ0bCAucm1kcC1yYW5nZS1ob3Zlci5zdGFydCwucm1kcC1ydGwgLnJtZHAtcmFuZ2Uuc3RhcnR7Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czp1bnNldDtib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czo1MCU7Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czp1bnNldDtib3JkZXItdG9wLXJpZ2h0LXJhZGl1czo1MCV9LnJtZHAtcnRsIC5ybWRwLXJhbmdlLWhvdmVyLmVuZCwucm1kcC1ydGwgLnJtZHAtcmFuZ2UuZW5ke2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6NTAlO2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOnVuc2V0O2JvcmRlci10b3AtbGVmdC1yYWRpdXM6NTAlO2JvcmRlci10b3AtcmlnaHQtcmFkaXVzOnVuc2V0fS5ybWRwLXJ0bCAucm1kcC1yYW5nZS5zdGFydC5lbmR7Ym9yZGVyLXJhZGl1czo1MCV9LnJtZHAtcnRsIC5ybWRwLXltIC5ybWRwLXJhbmdlLWhvdmVyLnN0YXJ0LC5ybWRwLXJ0bCAucm1kcC15bSAucm1kcC1yYW5nZS5zdGFydHtib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czoxNXB4O2JvcmRlci10b3AtcmlnaHQtcmFkaXVzOjE1cHh9LnJtZHAtcnRsIC5ybWRwLXltIC5ybWRwLXJhbmdlLWhvdmVyLmVuZCwucm1kcC1ydGwgLnJtZHAteW0gLnJtZHAtcmFuZ2UuZW5ke2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6MTVweDtib3JkZXItdG9wLWxlZnQtcmFkaXVzOjE1cHh9LnJtZHAtZGF5LWhpZGRlbiwucm1kcC1kYXkucm1kcC1kaXNhYmxlZHtjdXJzb3I6ZGVmYXVsdH0ucm1kcC1zZWxlY3RlZCAuaGlnaGxpZ2h0e2JveC1zaGFkb3c6MCAwIDNweCAjODc5OGFkfS5ybWRwLWRheTpub3QoLnJtZHAtZGlzYWJsZWQpOm5vdCgucm1kcC1kYXktaGlkZGVuKSAuaGlnaGxpZ2h0LXJlZDpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNmZjY2ODd9LnJtZHAtZGF5Om5vdCgucm1kcC1kZWFjdGl2ZSkgLmhpZ2hsaWdodC1yZWR7Y29sb3I6I2NjMDMwM30ucm1kcC1kYXkucm1kcC1kZWFjdGl2ZSAuaGlnaGxpZ2h0LXJlZHtjb2xvcjojZTA4ZThlfS5ybWRwLWRheS5ybWRwLXNlbGVjdGVkIC5oaWdobGlnaHQtcmVke2JhY2tncm91bmQtY29sb3I6I2VhMDAzNDtjb2xvcjojZmZmfS5ybWRwLWRheS5ybWRwLWRlYWN0aXZlLnJtZHAtc2VsZWN0ZWQgLmhpZ2hsaWdodC1yZWR7YmFja2dyb3VuZC1jb2xvcjojZTRiMGJhO2NvbG9yOiNmZmZ9LnJtZHAtZGF5Om5vdCgucm1kcC1kaXNhYmxlZCk6bm90KC5ybWRwLWRheS1oaWRkZW4pIC5oaWdobGlnaHQtZ3JlZW46aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojNGRiNmFjfS5ybWRwLWRheTpub3QoLnJtZHAtZGVhY3RpdmUpIC5oaWdobGlnaHQtZ3JlZW57Y29sb3I6IzAwNzk2Yn0ucm1kcC1kYXkucm1kcC1kZWFjdGl2ZSAuaGlnaGxpZ2h0LWdyZWVue2NvbG9yOiM3YWIzYWN9LnJtZHAtZGF5LnJtZHAtc2VsZWN0ZWQgLmhpZ2hsaWdodC1ncmVlbntiYWNrZ3JvdW5kLWNvbG9yOiMwMDk2ODg7Y29sb3I6I2ZmZn0ucm1kcC1kYXkucm1kcC1kZWFjdGl2ZS5ybWRwLXNlbGVjdGVkIC5oaWdobGlnaHQtZ3JlZW57YmFja2dyb3VuZC1jb2xvcjojNzQ5Yzk4O2NvbG9yOiNmZmZ9LnJtZHAtZGF5LWhpZGRlbiwucm1kcC1kYXktaGlkZGVuOmhvdmVyIHNwYW57YmFja2dyb3VuZC1jb2xvcjp1bnNldDtjb2xvcjp0cmFuc3BhcmVudH0ucm1kcC1tb250aC1uYW1le2N1cnNvcjpkZWZhdWx0O2ZvbnQtc2l6ZToxNHB4O21hcmdpbjozcHggMH0ucm1kcC1mdWxsLXllYXJ7Z3JpZC10ZW1wbGF0ZS1jb2x1bW5zOjFmciAxZnIgMWZyfUBtZWRpYSAobWF4LWhlaWdodDo0NTBweCksKG1heC13aWR0aDo0NTBweCl7LnJtZHAtZGF5LC5ybWRwLXdlZWstZGF5e2hlaWdodDoyOHB4O3dpZHRoOjI4cHh9LnJtZHAtZGF5IHNwYW57Zm9udC1zaXplOjEycHg7cGFkZGluZy1sZWZ0Oi41cHh9Lm9ubHkucm1kcC1tb250aC1waWNrZXIsLm9ubHkucm1kcC15ZWFyLXBpY2tlcntoZWlnaHQ6MjAwcHg7d2lkdGg6MjMwcHh9LnJtZHAtaGVhZGVye3BhZGRpbmc6M3B4IDAgMH0ucm1kcC1oZWFkZXIsLnJtZHAtbW9udGgtbmFtZXtmb250LXNpemU6MTJweH0ucm1kcC1mdWxsLXllYXJ7Z3JpZC10ZW1wbGF0ZS1jb2x1bW5zOjFmciAxZnJ9fVwiKTt2YXIgej1bXCJkYXRlUGlja2VyUHJvcHNcIixcIkRhdGVQaWNrZXJcIl07ZnVuY3Rpb24gSChyLHQpe3ZhciBuLG89ci52YWx1ZSxpPXIuY2FsZW5kYXIsdT1yLmxvY2FsZSxwPXIuZm9ybWF0LG09ci5vbmx5TW9udGhQaWNrZXIsaD1yLm9ubHlZZWFyUGlja2VyLHk9ci5yYW5nZSxiPXZvaWQgMCE9PXkmJnksdj1yLm11bHRpcGxlLHg9dm9pZCAwIT09diYmdix3PXIuY2xhc3NOYW1lLGs9ci5yb2xlLEQ9ci53ZWVrRGF5cyxPPXIubW9udGhzLFk9ci5jaGlsZHJlbixqPXIub25DaGFuZ2UsVD1yLnNob3dPdGhlckRheXMsQT1yLm1pbkRhdGUsUj1yLm1heERhdGUsTD1yLm1hcERheXMsVz1yLmRpc2FibGVNb250aFBpY2tlcixCPXIuZGlzYWJsZVllYXJQaWNrZXIsVj1yLmZvcm1hdHRpbmdJZ25vcmVMaXN0LEg9ci5vblJlYWR5LHE9ci5vbmx5U2hvd0luUmFuZ2VEYXRlcyxVPXZvaWQgMD09PXF8fHEsJD1yLnpJbmRleCxHPXZvaWQgMD09PSQ/MTAwOiQsUT1yLnBsdWdpbnMsWD12b2lkIDA9PT1RP1tdOlEsWj1yLnNvcnQsZWU9ci5udW1iZXJPZk1vbnRocyxyZT12b2lkIDA9PT1lZT8xOmVlLHRlPXIuY3VycmVudERhdGUsbmU9ci5kaWdpdHMsYWU9ci5idXR0b25zLG9lPXZvaWQgMD09PWFlfHxhZSxkZT1yLnJlbmRlckJ1dHRvbixpZT1yLndlZWtTdGFydERheUluZGV4LGxlPXZvaWQgMD09PWllPzA6aWUsdWU9ci5kaXNhYmxlRGF5UGlja2VyLGNlPXIub25Qcm9wc0NoYW5nZSxzZT1yLm9uTW9udGhDaGFuZ2UsZmU9ci5vblllYXJDaGFuZ2UscGU9ci5vbkZvY3VzZWREYXRlQ2hhbmdlLG1lPXIucmVhZE9ubHksaGU9ci5kaXNhYmxlZCx5ZT1yLmhpZGVNb250aCxnZT1yLmhpZGVZZWFyLGJlPXIuaGlkZVdlZWtEYXlzLHZlPXIuc2hhZG93LHhlPXZvaWQgMD09PXZlfHx2ZSx3ZT1yLmZ1bGxZZWFyLGtlPXIuZGlzcGxheVdlZWtOdW1iZXJzLERlPXIud2Vla051bWJlcixPZT1yLndlZWtQaWNrZXIsRWU9ci5yYW5nZUhvdmVyLFllPXIubW9udGhZZWFyU2VwYXJhdG9yLE1lPXIuZm9ybWF0TW9udGgsQ2U9ci5mb3JtYXRZZWFyLE5lPXIuaGlnaGxpZ2h0VG9kYXksUGU9dm9pZCAwPT09TmV8fE5lLFNlPXIuaGVhZGVyT3JkZXIsSWU9dm9pZCAwPT09U2U/W1wiTEVGVF9CVVRUT05cIixcIk1PTlRIX1lFQVJcIixcIlJJR0hUX0JVVFRPTlwiXTpTZSxqZT1yLnN0eWxlLFRlPXZvaWQgMD09PWplP3t9OmplOyF0ZXx8dGUgaW5zdGFuY2VvZiBkLmRlZmF1bHR8fChjb25zb2xlLndhcm4oXCJjdXJyZW50RGF0ZSBtdXN0IGJlIGluc3RhbmNlIG9mIERhdGVPYmplY3RcIiksdGU9dm9pZCAwKSwoXCJudW1iZXJcIiE9dHlwZW9mIGxlfHxsZTwwfHxsZT42KSYmKGxlPTApLChcIm51bWJlclwiIT10eXBlb2YgcmV8fHJlPDF8fGgpJiYocmU9MSksISh4fHxifHxnKG8pKXx8Ynx8eHx8KHg9ITApLE9lJiYoYj0hMCx4PSExKSx3ZSYmKHJlPTEyLG09ITEsaD0hMSksaCYmIXllJiYoeWU9ITApO3ZhciBBZT1GKGksdSksUmU9ZihBZSwyKTtpPVJlWzBdLHU9UmVbMV0scD1JKG0saCxwKSxWPUMoViksTD1bXS5jb25jYXQoTCkuZmlsdGVyKEJvb2xlYW4pLFg9W10uY29uY2F0LmFwcGx5KFtdLFgpO3ZhciBMZT1lLnVzZVN0YXRlKHt9KSxGZT1mKExlLDIpLFdlPUZlWzBdLEJlPUZlWzFdLF9lPXt9LFZlPWUudXNlUmVmKHttdXN0Q2FsbE9uUmVhZHk6ITAsY3VycmVudERhdGU6dGV9KTtlLnVzZUVmZmVjdCgoZnVuY3Rpb24oKXtCZSgoZnVuY3Rpb24oZSl7dmFyIHI9VmUuY3VycmVudC5jdXJyZW50RGF0ZSx0PWUuZGF0ZSxuPWUuc2VsZWN0ZWREYXRlLGE9ZS5pbml0aWFsVmFsdWUsYz1lLmZvY3VzZWQscz1lLm11c3RTb3J0RGF0ZXM7ZnVuY3Rpb24gZihlKXtpZihlKXJldHVybiBlLmNhbGVuZGFyLm5hbWUhPT1pLm5hbWUmJmUuc2V0Q2FsZW5kYXIoaSksZS5sb2NhbGUubmFtZSE9PXUubmFtZSYmZS5zZXRMb2NhbGUodSksZS5fZm9ybWF0IT09cCYmZS5zZXRGb3JtYXQocCksZS5kaWdpdHM9bmUsZS5pZ25vcmVMaXN0PUpTT04ucGFyc2UoViksZX1mdW5jdGlvbiB5KGUpe3JldHVybiBuZXcgZC5kZWZhdWx0KHJ8fGUpfWlmKG8paWYoZyhuPUsobyxpLHUscCkpKXR8fCh0PXkobi5mbGF0KClbMF0pKTtlbHNlIGlmKHQmJjEhPT1yZSl7dmFyIHY9bmV3IGQuZGVmYXVsdCh0KS50b0ZpcnN0T2ZNb250aCgpLHc9bmV3IGQuZGVmYXVsdCh0KS5hZGQocmUtMSxtP1wieWVhcnNcIjpcIm1vbnRoc1wiKS50b0xhc3RPZk1vbnRoKCk7KG48dnx8bj53KSYmKHQ9bmV3IGQuZGVmYXVsdChuKSl9ZWxzZSB0PXkobik7ZWxzZSB0fHwodD15KHtjYWxlbmRhcjppLGxvY2FsZTp1LGZvcm1hdDpwfSkpLGEmJihuPXZvaWQgMCk7aWYoW10uY29uY2F0KG4pLmZsYXQoKS5mb3JFYWNoKGYpLGYodCkseHx8Ynx8ZyhvKSl7aWYobnx8KG49W10pLGcobil8fChuPXgmJmI/W1tuXV06W25dKSxiJiYheCYmbi5sZW5ndGg+Mil7dmFyIGs9bltuLmxlbmd0aC0xXTtuPVtuWzBdLGtdLGM9a314JiYhYiYmWiYmIXM/KHM9ITAsbi5zb3J0KChmdW5jdGlvbihlLHIpe3JldHVybiBlLXJ9KSkpOmImJiF4JiZuLnNvcnQoKGZ1bmN0aW9uKGUscil7cmV0dXJuIGUtcn0pKX1lbHNlIGcobikmJihuPW4uZmxhdCgpW24ubGVuZ3RoLTFdKTtyZXR1cm4gd2UmJnQudG9GaXJzdE9mWWVhcigpLGRlbGV0ZSBWZS5jdXJyZW50LmN1cnJlbnREYXRlLGwobCh7fSxlKSx7fSx7ZGF0ZTp0LHNlbGVjdGVkRGF0ZTpuLG11bHRpcGxlOngscmFuZ2U6Yixvbmx5TW9udGhQaWNrZXI6bSxvbmx5WWVhclBpY2tlcjpoLGluaXRpYWxWYWx1ZTplLmluaXRpYWxWYWx1ZXx8byx2YWx1ZTpvLGZvY3VzZWQ6YyxjYWxlbmRhcjppLGxvY2FsZTp1LGZvcm1hdDpwLG11c3RTb3J0RGF0ZXM6cyx5ZWFyOnQueWVhcix0b2RheTpmKGUudG9kYXkpfHxuZXcgZC5kZWZhdWx0KHtjYWxlbmRhcjppfSksd2Vla1BpY2tlcjpPZX0pfSkpfSksW28saSx1LHAsbSxoLGIseCxaLHJlLG5lLFYsd2UsT2VdKSxlLnVzZUVmZmVjdCgoZnVuY3Rpb24oKXsoQXx8UikmJkJlKChmdW5jdGlvbihlKXt2YXIgcj1lLmNhbGVuZGFyLHQ9ZS5sb2NhbGUsbj1lLmZvcm1hdCxhPWYoSihLKG8scix0LG4pLEEsUixyKSwzKSxkPWFbMF0saT1hWzFdLHU9YVsyXTtyZXR1cm4gbChsKHt9LGUpLHt9LHtpblJhbmdlRGF0ZXM6VT9kOmUuc2VsZWN0ZWREYXRlLG1pbkRhdGU6aSxtYXhEYXRlOnV9KX0pKX0pLFtBLFIsVSxvXSksV2UudG9kYXkmJiFWZS5jdXJyZW50LmlzUmVhZHkmJihWZS5jdXJyZW50LmlzUmVhZHk9ITApLGUudXNlRWZmZWN0KChmdW5jdGlvbigpe1ZlLmN1cnJlbnQuaXNSZWFkeSYmVmUuY3VycmVudC5tdXN0Q2FsbE9uUmVhZHkmJkggaW5zdGFuY2VvZiBGdW5jdGlvbiYmKFZlLmN1cnJlbnQubXVzdENhbGxPblJlYWR5PSExLEgoKSl9KSxbVmUuY3VycmVudC5pc1JlYWR5LEhdKTt2YXIgemU9XCJybWRwLXRvcC1jbGFzcyBcIit0cihbXCJ0b3BcIixcImJvdHRvbVwiXSksSGU9e3RvcDpbXSxib3R0b206W10sbGVmdDpbXSxyaWdodDpbXX0scWU9XyhudWxsPT09KG49V2UuZGF0ZSl8fHZvaWQgMD09PW4/dm9pZCAwOm4ubG9jYWxlKSxKZT17c3RhdGU6V2Usc2V0U3RhdGU6QmUsb25DaGFuZ2U6WGUsc29ydDpaLGhhbmRsZUZvY3VzZWREYXRlOmVyLGlzUlRMOnFlLGZ1bGxZZWFyOndlLG1vbnRoQW5kWWVhcnM6b3IoKSxyYW5nZUhvdmVyOkVlLGhpZ2hsaWdodFRvZGF5OlBlLG51bWJlck9mTW9udGhzOnJlfSxLZT1hcmd1bWVudHNbMF0sVWU9S2UuZGF0ZVBpY2tlclByb3BzLCRlPUtlLkRhdGVQaWNrZXIsR2U9cyhLZSx6KTtyZXR1cm4gUWUoKSxXZS50b2RheT9hLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLHtyZWY6YXIscm9sZTprfHxcImRpYWxvZ1wiLGNsYXNzTmFtZTpcInJtZHAtd3JhcHBlciBybWRwLVwiLmNvbmNhdCh4ZT9cInNoYWRvd1wiOlwiYm9yZGVyXCIsXCIgXCIpLmNvbmNhdCh3fHxcIlwiKSxzdHlsZTpsKHt6SW5kZXg6R30sVGUpfSxIZS50b3AsYS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7c3R5bGU6e2Rpc3BsYXk6XCJmbGV4XCJ9LGNsYXNzTmFtZTp6ZX0sSGUubGVmdCwhdWUmJmEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2NsYXNzTmFtZTpcInJtZHAtY2FsZW5kYXIgXCIuY29uY2F0KHFlP1wicm1kcC1ydGxcIjpcIlwiLFwiIFwiKS5jb25jYXQodHIoW1wibGVmdFwiLFwicmlnaHRcIl0pKX0sYS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoTSxsKGwoe30sSmUpLHt9LHtkaXNhYmxlWWVhclBpY2tlcjpCLGRpc2FibGVNb250aFBpY2tlcjpXLGJ1dHRvbnM6b2UscmVuZGVyQnV0dG9uOmRlLGhhbmRsZU1vbnRoQ2hhbmdlOnJyLGRpc2FibGVkOmhlLGhpZGVNb250aDp5ZSxoaWRlWWVhcjpnZSxtb250aFllYXJTZXBhcmF0b3I6WWUsZm9ybWF0TW9udGg6TWUsZm9ybWF0WWVhcjpDZSxoZWFkZXJPcmRlcjpJZX0pKSxhLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLHtzdHlsZTp7cG9zaXRpb246XCJyZWxhdGl2ZVwifX0sYS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoRSxsKGwoe30sSmUpLHt9LHtzaG93T3RoZXJEYXlzOlQsbWFwRGF5czpMLG9ubHlTaG93SW5SYW5nZURhdGVzOlUsY3VzdG9tV2Vla0RheXM6RCx3ZWVrU3RhcnREYXlJbmRleDpsZSxoaWRlV2Vla0RheXM6YmUsZGlzcGxheVdlZWtOdW1iZXJzOmtlLHdlZWtOdW1iZXI6RGV9KSksIXdlJiZhLmRlZmF1bHQuY3JlYXRlRWxlbWVudChhLmRlZmF1bHQuRnJhZ21lbnQsbnVsbCwhVyYmYS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoTixjKHt9LEplLHtjdXN0b21Nb250aHM6TyxoYW5kbGVNb250aENoYW5nZTpycn0pKSwhQiYmYS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUyxjKHt9LEplLHtvblllYXJDaGFuZ2U6ZmV9KSkpKSksSGUucmlnaHQpLEhlLmJvdHRvbSxZKTpudWxsO2Z1bmN0aW9uIFFlKCl7aWYoVmUuY3VycmVudC5pc1JlYWR5JiZnKFgpKXt2YXIgcj17c3RhdGU6V2Usc2V0U3RhdGU6QmUscmVnaXN0ZXJMaXN0ZW5lcjpucixjYWxlbmRhclByb3BzOkdlLGRhdGVQaWNrZXJQcm9wczpVZSxoYW5kbGVDaGFuZ2U6WGUsQ2FsZW5kYXI6VmUuY3VycmVudC5DYWxlbmRhcixEYXRlUGlja2VyOiRlLGhhbmRsZVByb3BzQ2hhbmdlOlplLGhhbmRsZUZvY3VzZWREYXRlOmZ1bmN0aW9uKGUpe3JldHVybiBlcihlKX19LHQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHVlP1wiYm90dG9tXCI6ZS5wcm9wcy5wb3NpdGlvbnx8XCJyaWdodFwifTtYLmZvckVhY2goKGZ1bmN0aW9uKG4sYSl7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIG4udHlwZSl7dmFyIG89e30sZD10KG4pO2lmKEhlW2RdJiYhbi5wcm9wcy5kaXNhYmxlZCl7Zm9yKHZhciBpPTA7aTxYLmxlbmd0aDtpKyspaWYoXCJzdHJpbmdcIiE9dHlwZW9mIFhbaV0udHlwZSYmIVhbaV0ucHJvcHMuZGlzYWJsZWQpe2lmKDQ9PT1PYmplY3Qua2V5cyhvKS5sZW5ndGgpYnJlYWs7dmFyIHU9dChYW2ldKTtbXCJ0b3BcIixcImJvdHRvbVwiXS5pbmNsdWRlcyhkKT8odT09PWQmJmk+YSYmKG8uYm90dG9tPSEwKSx1PT09ZCYmaTxhJiYoby50b3A9ITApKTooemUuaW5jbHVkZXMoXCJib3JkZXItdG9wXCIpJiYoby50b3A9ITApLHplLmluY2x1ZGVzKFwiYm9yZGVyLWJvdHRvbVwiKSYmKG8uYm90dG9tPSEwKSx1PT09ZCYmaT5hJiYoby5yaWdodD0hMCksdT09PWQmJmk8YSYmKG8ubGVmdD0hMCkpfUhlW2RdLnB1c2goZS5jbG9uZUVsZW1lbnQobixsKHtrZXk6YSxwb3NpdGlvbjpkLG5vZGVzOm99LHIpKSl9fWVsc2VcIm1hcERheXNcIj09PW4udHlwZSYmTC5wdXNoKG4uZm4ocikpfSkpfX1mdW5jdGlvbiBYZShlLHIpe2lmKGUgaW5zdGFuY2VvZiBkLmRlZmF1bHQmJihlPW5ldyBkLmRlZmF1bHQoZSkpLCFoZSl7aWYoZXx8bnVsbD09PWUpe2lmKG1lKXJldHVybjtfZS5jaGFuZ2UmJl9lLmNoYW5nZS5mb3JFYWNoKChmdW5jdGlvbihyKXtyZXR1cm4gcihlKX0pKX1pZihlfHxudWxsPT09ZSl7dmFyIHQ9bnVsbD09aj92b2lkIDA6aihlKTtyJiYhMSE9PXQmJkJlKHIpfWVsc2UgciYmQmUocik7WmUoe3ZhbHVlOmV9KX19ZnVuY3Rpb24gWmUoKXt2YXIgZSxyPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fTtpZighbWUmJiFoZSl7dmFyIHQ9bChsKGwobCh7fSxHZSksVWUpLHIpLHt9LHt2YWx1ZTpudWxsIT09KGU9ci52YWx1ZSkmJnZvaWQgMCE9PWU/ZTpXZS5zZWxlY3RlZERhdGV9KTtkZWxldGUgdC5vblByb3BzQ2hhbmdlLG51bGw9PWNlfHxjZSh0KX19ZnVuY3Rpb24gZXIoZSxyKXttZXx8aGV8fG51bGw9PXBlfHxwZShlLHIpfWZ1bmN0aW9uIHJyKGUpe251bGw9PXNlfHxzZShlKX1mdW5jdGlvbiB0cihlKXtyZXR1cm4gdWV8fCFnKFgpP1wiXCI6QXJyYXkuZnJvbShuZXcgU2V0KFgubWFwKChmdW5jdGlvbihyKXtpZighci5wcm9wcylyZXR1cm5cIlwiO3ZhciB0PXIucHJvcHMucG9zaXRpb258fFwicmlnaHRcIjtyZXR1cm4gZS5pbmNsdWRlcyh0KSYmIXIucHJvcHMuZGlzYWJsZWQ/XCJybWRwLWJvcmRlci1cIit0OlwiXCJ9KSkpKS5qb2luKFwiIFwiKX1mdW5jdGlvbiBucihlLHIpe19lW2VdfHwoX2VbZV09W10pLF9lW2VdLnB1c2gocil9ZnVuY3Rpb24gYXIoZSl7aWYoZSYmKGUuZGF0ZT1XZS5kYXRlLGUuc2V0PWZ1bmN0aW9uKGUscil7aGV8fEJlKGwobCh7fSxXZSkse30se2RhdGU6bmV3IGQuZGVmYXVsdChXZS5kYXRlLnNldChlLHIpKX0pKX0pLFZlLmN1cnJlbnQuQ2FsZW5kYXI9ZSx0IGluc3RhbmNlb2YgRnVuY3Rpb24pcmV0dXJuIHQoZSk7dCYmKHQuY3VycmVudD1lKX1mdW5jdGlvbiBvcigpe3ZhciBlPVdlLmRhdGU7aWYoIWUpcmV0dXJuW107Zm9yKHZhciByPVtdLHQ9W10sbj1lLmRpZ2l0cyxhPTA7YTxyZTthKyspe3ZhciBvPXZvaWQgMCxkPWUueWVhcixpPWUubW9udGhJbmRleCthO2lmKG0mJihkKz1hKSxpPjExJiYoaS09MTIsbXx8ZCsrKSxnKE8pJiZPLmxlbmd0aD49MTIpe3ZhciBsPU9baV07bz1nKGwpP2xbMF06bH1lbHNlIG89ZS5tb250aHNbaV0ubmFtZTtkPVAoZC50b1N0cmluZygpLG4pLHIucHVzaChvKSx0LnB1c2goZCl9cmV0dXJuW3IsdF19fXZhciBxPWUuZm9yd2FyZFJlZihIKTtmdW5jdGlvbiBKKGUscix0LG4pe3JldHVybiByJiYocj1qKHIsbikuc2V0KHtob3VyOjAsbWludXRlOjAsc2Vjb25kOjAsbWlsbGlzZWNvbmQ6MH0pKSx0JiYodD1qKHQsbikuc2V0KHtob3VyOjIzLG1pbnV0ZTo1OSxzZWNvbmQ6NTksbWlsbGlzZWNvbmQ6OTk5fSkpLGcoZSkmJihlPWUuZmlsdGVyKChmdW5jdGlvbihlKXtyZXR1cm4hKHImJmU8cikmJiEodCYmZT50KX0pKSksW2Uscix0XX1mdW5jdGlvbiBLKGUscix0LG4pe3ZhciBhPVtdLmNvbmNhdChlKS5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBnKGUpP2UubWFwKG8pLmZpbHRlcihpKTpvKGUpfSkpLmZpbHRlcihpKTtyZXR1cm4gZyhlKT9hOmEuZmxhdCgpWzBdO2Z1bmN0aW9uIG8oZSl7cmV0dXJuIGU/ZSBpbnN0YW5jZW9mIGQuZGVmYXVsdD9lOm5ldyBkLmRlZmF1bHQoe2RhdGU6ZSxjYWxlbmRhcjpyLGxvY2FsZTp0LGZvcm1hdDpufSk6e319ZnVuY3Rpb24gaShlKXtyZXR1cm4gZyhlKXx8ZS5pc1ZhbGlkfX1WKCcucm1kcC12aXNpYmxle3Zpc2liaWxpdHk6dmlzaWJsZX0ucm1kcC1pbnZpc2libGV7dmlzaWJpbGl0eTpoaWRkZW59LnJtZHAtaW5wdXR7Ym9yZGVyOjFweCBzb2xpZCAjYzBjNGQ2O2JvcmRlci1yYWRpdXM6NXB4O2hlaWdodDoyMnB4O21hcmdpbjoxcHggMDtwYWRkaW5nOjJweCA1cHh9LnJtZHAtaW5wdXQ6Zm9jdXN7Ym9yZGVyOjFweCBzb2xpZCAjYTRiM2M1O2JveC1zaGFkb3c6MCAwIDJweCAjYTRiM2M1O291dGxpbmU6bm9uZSFpbXBvcnRhbnR9LnJtZHAtYnV0dG9ue2JhY2tncm91bmQtY29sb3I6IzAwNzRkOTtib3JkZXI6bm9uZTtib3JkZXItcmFkaXVzOjVweDtjb2xvcjojZmZmO2N1cnNvcjpwb2ludGVyO2Rpc3BsYXk6aW5saW5lLWJsb2NrO3BhZGRpbmc6N3B4IDE2cHg7dGV4dC1hbGlnbjpjZW50ZXI7dGV4dC1kZWNvcmF0aW9uOm5vbmU7dHJhbnNpdGlvbjouM3N9LnJtZHAtYnV0dG9uOmhvdmVye2JhY2tncm91bmQtY29sb3I6IzE0M2FjNTt0cmFuc2l0aW9uOi40c30ucm1kcC1idXR0b246ZGlzYWJsZWR7YmFja2dyb3VuZC1jb2xvcjojODc5OGFkfS5ybWRwLWFjdGlvbi1idXR0b257Ym9yZGVyLXJhZGl1czp1bnNldDtjb2xvcjojMjY4MmQzO2Zsb2F0OnJpZ2h0O2ZvbnQtd2VpZ2h0OjcwMDttYXJnaW46MTVweCAxMHB4IDE1cHggMH0ucm1kcC1hY3Rpb24tYnV0dG9uLC5ybWRwLWFjdGlvbi1idXR0b246aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudH0ucm1kcC1lcC1hcnJvd3tvdmVyZmxvdzpoaWRkZW47d2lsbC1jaGFuZ2U6dHJhbnNmb3JtfS5ybWRwLWVwLWFycm93OmFmdGVye2JhY2tncm91bmQtY29sb3I6I2ZmZjtjb250ZW50OlwiXCI7aGVpZ2h0OjEycHg7cG9zaXRpb246YWJzb2x1dGU7dHJhbnNmb3JtOnJvdGF0ZSg0NWRlZyk7d2lkdGg6MTJweH0ucm1kcC1lcC1zaGFkb3c6YWZ0ZXJ7Ym94LXNoYWRvdzowIDAgNnB4ICM4Nzk4YWR9LnJtZHAtZXAtYm9yZGVyOmFmdGVye2JvcmRlcjoxcHggc29saWQgI2NmZDhlMn0ucm1kcC1lcC1hcnJvd1tkaXJlY3Rpb249dG9wXXtib3JkZXItYm90dG9tOjFweCBzb2xpZCAjZmZmfS5ybWRwLWVwLWFycm93W2RpcmVjdGlvbj1sZWZ0XXtib3JkZXItcmlnaHQ6MXB4IHNvbGlkICNmZmZ9LnJtZHAtZXAtYXJyb3dbZGlyZWN0aW9uPXJpZ2h0XXtib3JkZXItbGVmdDoxcHggc29saWQgI2ZmZjttYXJnaW4tbGVmdDotMXB4fS5ybWRwLWVwLWFycm93W2RpcmVjdGlvbj1ib3R0b21de2JvcmRlci10b3A6MXB4IHNvbGlkICNmZmY7bWFyZ2luLXRvcDotMS41cHh9LnJtZHAtZXAtYXJyb3dbZGlyZWN0aW9uPXRvcF06YWZ0ZXJ7bGVmdDo0cHg7dG9wOjVweH0ucm1kcC1lcC1hcnJvd1tkaXJlY3Rpb249Ym90dG9tXTphZnRlcntsZWZ0OjRweDt0b3A6LTZweH0ucm1kcC1lcC1hcnJvd1tkaXJlY3Rpb249bGVmdF06YWZ0ZXJ7bGVmdDo1cHg7dG9wOjNweH0ucm1kcC1lcC1hcnJvd1tkaXJlY3Rpb249cmlnaHRdOmFmdGVye2xlZnQ6LTZweDt0b3A6M3B4fScpO3ZhciBVPVtcInZhbHVlXCIsXCJjYWxlbmRhclwiLFwibG9jYWxlXCIsXCJmb3JtYXRcIixcIm9ubHlNb250aFBpY2tlclwiLFwib25seVllYXJQaWNrZXJcIixcIm9uQ2hhbmdlXCIsXCJyYW5nZVwiLFwibXVsdGlwbGVcIixcIm5hbWVcIixcImlkXCIsXCJ0aXRsZVwiLFwicGxhY2Vob2xkZXJcIixcInJlcXVpcmVkXCIsXCJzdHlsZVwiLFwiY2xhc3NOYW1lXCIsXCJpbnB1dENsYXNzXCIsXCJkaXNhYmxlZFwiLFwicmVuZGVyXCIsXCJ3ZWVrRGF5c1wiLFwibW9udGhzXCIsXCJjaGlsZHJlblwiLFwiaW5wdXRNb2RlXCIsXCJzY3JvbGxTZW5zaXRpdmVcIixcImhpZGVPblNjcm9sbFwiLFwibWluRGF0ZVwiLFwibWF4RGF0ZVwiLFwiZm9ybWF0dGluZ0lnbm9yZUxpc3RcIixcImNvbnRhaW5lckNsYXNzTmFtZVwiLFwiY2FsZW5kYXJQb3NpdGlvblwiLFwiZWRpdGFibGVcIixcIm9uT3BlblwiLFwib25DbG9zZVwiLFwiYXJyb3dDbGFzc05hbWVcIixcInpJbmRleFwiLFwiYXJyb3dcIixcImZpeE1haW5Qb3NpdGlvblwiLFwib25Qb3NpdGlvbkNoYW5nZVwiLFwib25Qcm9wc0NoYW5nZVwiLFwiZGlnaXRzXCIsXCJyZWFkT25seVwiLFwic2hhZG93XCIsXCJvbkZvY3VzZWREYXRlQ2hhbmdlXCIsXCJ0eXBlXCIsXCJ3ZWVrUGlja2VyXCIsXCJtb2JpbGVMYWJlbHNcIixcIm9uT3BlblBpY2tOZXdEYXRlXCIsXCJtb2JpbGVCdXR0b25zXCIsXCJkYXRlU2VwYXJhdG9yXCIsXCJtdWx0aXBsZVJhbmdlU2VwYXJhdG9yXCIsXCJ0eXBpbmdUaW1lb3V0XCJdLCQ9W1wibGFiZWxcIl07ZnVuY3Rpb24gRyhyLHQpe3ZhciBuPXIudmFsdWUsaT1yLmNhbGVuZGFyLHU9ci5sb2NhbGUscD1yLmZvcm1hdCxtPXIub25seU1vbnRoUGlja2VyLGg9ci5vbmx5WWVhclBpY2tlcixiPXIub25DaGFuZ2Usdj1yLnJhbmdlLHg9dm9pZCAwIT09diYmdix3PXIubXVsdGlwbGUsaz12b2lkIDAhPT13JiZ3LEQ9ci5uYW1lLE89ci5pZCxFPXIudGl0bGUsWT1yLnBsYWNlaG9sZGVyLE09ci5yZXF1aXJlZCxOPXIuc3R5bGUsUz12b2lkIDA9PT1OP3t9Ok4saj1yLmNsYXNzTmFtZSxUPXZvaWQgMD09PWo/XCJcIjpqLEE9ci5pbnB1dENsYXNzLFI9ci5kaXNhYmxlZCxMPXIucmVuZGVyLFc9ci53ZWVrRGF5cyxWPXIubW9udGhzLHo9ci5jaGlsZHJlbixIPXIuaW5wdXRNb2RlLEo9ci5zY3JvbGxTZW5zaXRpdmUsSz12b2lkIDA9PT1KfHxKLEc9ci5oaWRlT25TY3JvbGwsUT1yLm1pbkRhdGUsZWU9ci5tYXhEYXRlLHJlPXIuZm9ybWF0dGluZ0lnbm9yZUxpc3QsdGU9ci5jb250YWluZXJDbGFzc05hbWUsbmU9dm9pZCAwPT09dGU/XCJcIjp0ZSxhZT1yLmNhbGVuZGFyUG9zaXRpb24sb2U9dm9pZCAwPT09YWU/XCJib3R0b20tbGVmdFwiOmFlLGRlPXIuZWRpdGFibGUsaWU9dm9pZCAwPT09ZGV8fGRlLGxlPXIub25PcGVuLHVlPXIub25DbG9zZSxjZT1yLmFycm93Q2xhc3NOYW1lLHNlPXZvaWQgMD09PWNlP1wiXCI6Y2UsZmU9ci56SW5kZXgscGU9dm9pZCAwPT09ZmU/MTAwOmZlLG1lPXIuYXJyb3csaGU9dm9pZCAwPT09bWV8fG1lLHllPXIuZml4TWFpblBvc2l0aW9uLGdlPXIub25Qb3NpdGlvbkNoYW5nZSxiZT1yLm9uUHJvcHNDaGFuZ2UsdmU9ci5kaWdpdHMseGU9ci5yZWFkT25seSx3ZT1yLnNoYWRvdyxrZT12b2lkIDA9PT13ZXx8d2UsRGU9ci5vbkZvY3VzZWREYXRlQ2hhbmdlLE9lPXIudHlwZSxFZT1yLndlZWtQaWNrZXIsWWU9ci5tb2JpbGVMYWJlbHMsTWU9ci5vbk9wZW5QaWNrTmV3RGF0ZSxDZT12b2lkIDA9PT1NZXx8TWUsTmU9ci5tb2JpbGVCdXR0b25zLFBlPXZvaWQgMD09PU5lP1tdOk5lLFNlPXIuZGF0ZVNlcGFyYXRvcixJZT1yLm11bHRpcGxlUmFuZ2VTZXBhcmF0b3IsamU9dm9pZCAwPT09SWU/XCIsXCI6SWUsVGU9ci50eXBpbmdUaW1lb3V0LEFlPXZvaWQgMD09PVRlPzcwMDpUZSxSZT1zKHIsVSksTGU9ZS51c2VTdGF0ZSgpLEZlPWYoTGUsMiksV2U9RmVbMF0sQmU9RmVbMV0sX2U9ZS51c2VTdGF0ZSgpLFZlPWYoX2UsMiksemU9VmVbMF0sSGU9VmVbMV0scWU9ZS51c2VTdGF0ZShcIlwiKSxKZT1mKHFlLDIpLEtlPUplWzBdLFVlPUplWzFdLCRlPWUudXNlU3RhdGUoITEpLEdlPWYoJGUsMiksUWU9R2VbMF0sWGU9R2VbMV0sWmU9ZS51c2VTdGF0ZSghMSksZXI9ZihaZSwyKSxycj1lclswXSx0cj1lclsxXSxucj1lLnVzZVJlZigpLGFyPWUudXNlUmVmKCksb3I9ZS51c2VSZWYoKSxkcj1lLnVzZVJlZih7aXNUeXBpbmc6ITF9KSxpcj1TZXx8KHh8fEVlP1wiIH4gXCI6XCIsIFwiKSxscj1hcmd1bWVudHNbMF0sdXI9Z3IoKSxjcj1lLnVzZUNhbGxiYWNrKChmdW5jdGlvbigpe2lmKCExIT09KG51bGw9PXVlP3ZvaWQgMDp1ZSgpKSl7dmFyIGU9Wihhcik7aWYoZSYmZS5mb3JFYWNoKChmdW5jdGlvbihlKXtyZXR1cm4gZS5ibHVyKCl9KSksZHIuY3VycmVudC5tb2JpbGUpe3ZhciByPW9yLmN1cnJlbnQucGFyZW50Tm9kZS5wYXJlbnROb2RlO3IuY2xhc3NMaXN0LnJlbW92ZShcInJtZHAtY2FsZW5kYXItY29udGFpbmVyLW1vYmlsZVwiKSxyLnN0eWxlLnBvc2l0aW9uPVwiYWJzb2x1dGVcIixyLnN0eWxlLnZpc2liaWxpdHk9XCJoaWRkZW5cIn1YZSghMSksdHIoITEpfX0pLFt1ZV0pLHNyPVt7dHlwZTpcImJ1dHRvblwiLGNsYXNzTmFtZTpcInJtZHAtYnV0dG9uIHJtZHAtYWN0aW9uLWJ1dHRvblwiLG9uQ2xpY2s6ZnVuY3Rpb24oKXtIZSh2b2lkIDApLGNyKCl9LGxhYmVsOnZyKFwiQ0FOQ0VMXCIpfSx7dHlwZTpcImJ1dHRvblwiLGNsYXNzTmFtZTpcInJtZHAtYnV0dG9uIHJtZHAtYWN0aW9uLWJ1dHRvblwiLG9uQ2xpY2s6ZnVuY3Rpb24oKXt6ZSYmKGtyKHplLCEwKSxIZSh2b2lkIDApKSxjcigpfSxsYWJlbDp2cihcIk9LXCIpfV07dXImJiFkci5jdXJyZW50Lm1vYmlsZSYmKGRyLmN1cnJlbnQ9bChsKHt9LGRyLmN1cnJlbnQpLHt9LHttb2JpbGU6ITB9KSksIXVyJiZkci5jdXJyZW50Lm1vYmlsZSYmKGRyLmN1cnJlbnQ9bChsKHt9LGRyLmN1cnJlbnQpLHt9LHttb2JpbGU6ITF9KSkscmU9QyhyZSkscD1JKG0saCxwKTt2YXIgZnI9RihpLHUpLHByPWYoZnIsMik7cmV0dXJuIGk9cHJbMF0sdT1wclsxXSxlLnVzZUVmZmVjdCgoZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe2lmKFFlJiYhZHIuY3VycmVudC5tb2JpbGUpe3ZhciByPVtdO2lmKFthci5jdXJyZW50LG9yLmN1cnJlbnRdLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBuLGEsbzshdHx8dC5jb250YWlucyhlLnRhcmdldCl8fGUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhcImItZGVzZWxlY3RcIil8fG51bGwhPT0obj1lLnRhcmdldC5wYXJlbnROb2RlKSYmdm9pZCAwIT09biYmbnVsbCE9PShhPW4uY2xhc3NMaXN0KSYmdm9pZCAwIT09YSYmbnVsbCE9PShvPWEuY29udGFpbnMpJiZ2b2lkIDAhPT1vJiZvLmNhbGwoYSxcImItZGVzZWxlY3RcIil8fHIucHVzaCh0KX0pKSwyPT09ci5sZW5ndGgpcmV0dXJuIGNyKCk7b3IuY3VycmVudCYmb3IuY3VycmVudC5jb250YWlucyhlLnRhcmdldCkmJihuci5jdXJyZW50LnJlbW92ZVRyYW5zaXRpb24oKSxuci5jdXJyZW50LnJlZnJlc2hQb3NpdGlvbigpKX19ZnVuY3Rpb24gcigpe0cmJlFlJiZjcigpfXJldHVybiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIixlLCExKSxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsciwhMCksZnVuY3Rpb24oKXtkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIixlLCExKSxkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsciwhMCl9fSksW2NyLHQsUWUsR10pLGUudXNlRWZmZWN0KChmdW5jdGlvbigpe3ZhciBlPW4scj1kci5jdXJyZW50LHQ9ci5kYXRlLGE9ci5pbml0aWFsVmFsdWUsbz1mdW5jdGlvbigpe3JldHVybiBlW2UubGVuZ3RoLTFdfTtmdW5jdGlvbiBjKGUpe2lmKGUpcmV0dXJuIGUgaW5zdGFuY2VvZiBkLmRlZmF1bHR8fChlPW5ldyBkLmRlZmF1bHQoe2RhdGU6ZSxjYWxlbmRhcjppLGxvY2FsZTp1LGZvcm1hdDpwfSkpLGUuY2FsZW5kYXIhPT1pJiZlLnNldENhbGVuZGFyKGkpLGUuc2V0KHt3ZWVrRGF5czpXLG1vbnRoczpWLGRpZ2l0czp2ZSxsb2NhbGU6dSxmb3JtYXQ6cCxpZ25vcmVMaXN0OkpTT04ucGFyc2UocmUpfSksZX1ufHxhfHwhdD9hJiYhbiYmKGE9dm9pZCAwKTplPXQ7dmFyIHM9XCJcIjtpZih4fHxrfHxnKGUpKXt2YXIgbT1mdW5jdGlvbihlKXtyZXR1cm4gZT1lLm1hcChjKS5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDAhPT1lfSkpLHgmJmUubGVuZ3RoPjImJihlPVtlWzBdLG8oKV0pLFtlLFgoZSxpcildfTtpZihnKGUpfHwoZT14JiZrP2U/W1tlXV06W106W2VdKSxrJiZ4KWU9ZS5tYXAoKGZ1bmN0aW9uKHIsdCl7dmFyIG49ZihtKGcocik/cjpbcl0pLDIpLGE9blswXSxvPW5bMV07cmV0dXJuIHMrPW8rKHQ8ZS5sZW5ndGgtMT9cIiBcIi5jb25jYXQoamUsXCIgXCIpOlwiXCIpLGF9KSk7ZWxzZXt2YXIgaD1mKG0oZSksMik7ZT1oWzBdLHM9aFsxXX1zPXMudG9TdHJpbmcoKS5yZXBsYWNlKC9cXHMsXFxzJC8sXCJcIil9ZWxzZSBnKGUpJiYoZT1vKCkpLChlPWMoZSkpJiYocz1lLmZvcm1hdCgpKTtkci5jdXJyZW50LmlzVHlwaW5nfHxVZShzKSxkci5jdXJyZW50PWwobCh7fSxkci5jdXJyZW50KSx7fSx7ZGF0ZTplLHNlcGFyYXRvcjppcixpbml0aWFsVmFsdWU6YXx8bn0pLGRyLmN1cnJlbnQubW9iaWxlJiZuci5jdXJyZW50LmlzT3Blbj9IZShlKTpCZShlKX0pLFtuLGksdSxwLHgsayxpcixtLGgsVyxWLHZlLHJlXSksZS51c2VFZmZlY3QoKGZ1bmN0aW9uKCl7dmFyIGU9ZHIuY3VycmVudC5zZWxlY3Rpb247aWYoZSl7dmFyIHI9Wihhcik7MCE9PXIubGVuZ3RoJiYoci5mb3JFYWNoKChmdW5jdGlvbihyKXtkb2N1bWVudC5hY3RpdmVFbGVtZW50PT09ciYmKHIuc2V0U2VsZWN0aW9uUmFuZ2UoZSxlKSxkci5jdXJyZW50LnNlbGVjdGlvbj12b2lkIDApfSkpLG5yLmN1cnJlbnQucmVmcmVzaFBvc2l0aW9uKCkpfX0pLFtLZV0pLChrfHx4fHxnKFdlKXx8IWllKSYmKEg9XCJub25lXCIpLGEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KG8uZGVmYXVsdCxjKHtyZWY6bXIsZWxlbWVudDpocigpLHBvcHBlcjpRZSYmeXIoKSxhY3RpdmU6IXVyJiZycixwb3NpdGlvbjpvZSxhcnJvdzohdXImJmhlLGZpeE1haW5Qb3NpdGlvbjohS3x8eWUsekluZGV4OnBlLG9uQ2hhbmdlOiF1ciYmZ2UsY29udGFpbmVyQ2xhc3NOYW1lOlwicm1kcC1jb250YWluZXIgXCIuY29uY2F0KG5lKSxhcnJvd0NsYXNzTmFtZTpbXCJybWRwLWVwLWFycm93XCIsXCJybWRwLWVwLVwiLmNvbmNhdChrZT9cInNoYWRvd1wiOlwiYm9yZGVyXCIpLFQsc2VdLmpvaW4oXCIgXCIpfSxSZSkpO2Z1bmN0aW9uIG1yKGUpe2lmKGUmJihlLm9wZW5DYWxlbmRhcj1mdW5jdGlvbigpe3JldHVybiBzZXRUaW1lb3V0KChmdW5jdGlvbigpe3JldHVybiB4cigpfSksMTApfSxlLmNsb3NlQ2FsZW5kYXI9Y3IsZS5pc09wZW49UWUmJnJyKSxuci5jdXJyZW50PWUsdCBpbnN0YW5jZW9mIEZ1bmN0aW9uKXJldHVybiB0KGUpO3QmJih0LmN1cnJlbnQ9ZSl9ZnVuY3Rpb24gaHIoKXtyZXR1cm4gTD9hLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLHtyZWY6YXJ9LGUuaXNWYWxpZEVsZW1lbnQoTCk/ZS5jbG9uZUVsZW1lbnQoTCx7dmFsdWU6S2Usb3BlbkNhbGVuZGFyOnhyLG9uRm9jdXM6eHIsaGFuZGxlVmFsdWVDaGFuZ2U6RHIsb25DaGFuZ2U6RHIsbG9jYWxlOnUsc2VwYXJhdG9yOmlyfSk6TCBpbnN0YW5jZW9mIEZ1bmN0aW9uP0woS2UseHIsRHIsdSxpcik6bnVsbCk6YS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLHtyZWY6YXIsdHlwZTpPZXx8XCJ0ZXh0XCIsbmFtZTpELGlkOk8sdGl0bGU6RSxyZXF1aXJlZDpNLG9uRm9jdXM6eHIsY2xhc3NOYW1lOkF8fFwicm1kcC1pbnB1dFwiLHBsYWNlaG9sZGVyOlksdmFsdWU6S2Usb25DaGFuZ2U6RHIsc3R5bGU6UyxhdXRvQ29tcGxldGU6XCJvZmZcIixkaXNhYmxlZDohIVIsaW5wdXRNb2RlOkh8fCh1cj9cIm5vbmVcIjp2b2lkIDApLHJlYWRPbmx5OnhlfSl9ZnVuY3Rpb24geXIoKXtyZXR1cm4gYS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQocSxjKHtyZWY6b3IsdmFsdWU6emV8fFdlLG9uQ2hhbmdlOmtyLHJhbmdlOngsbXVsdGlwbGU6ayxjYWxlbmRhcjppLGxvY2FsZTp1LGZvcm1hdDpwLG9ubHlNb250aFBpY2tlcjptLG9ubHlZZWFyUGlja2VyOmgsY2xhc3NOYW1lOlQrKHVyP1wiIHJtZHAtbW9iaWxlXCI6XCJcIiksd2Vla0RheXM6Vyxtb250aHM6VixkaWdpdHM6dmUsbWluRGF0ZTpRLG1heERhdGU6ZWUsZm9ybWF0dGluZ0lnbm9yZUxpc3Q6SlNPTi5wYXJzZShyZSksb25Qcm9wc0NoYW5nZTpiZSxzaGFkb3c6a2Usb25SZWFkeTpPcixEYXRlUGlja2VyOm5yLmN1cnJlbnQsZGF0ZVBpY2tlclByb3BzOmxyLG9uRm9jdXNlZERhdGVDaGFuZ2U6RXIsd2Vla1BpY2tlcjpFZX0sUmUpLHosdXImJmJyKCkpfWZ1bmN0aW9uIGdyKCl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIFQmJlQuaW5jbHVkZXMoXCJybWRwLW1vYmlsZVwiKX1mdW5jdGlvbiBicigpe3ZhciBlPVtdLmNvbmNhdC5hcHBseShbXSxsci5wbHVnaW5zfHxbXSkuc29tZSgoZnVuY3Rpb24oZSl7dmFyIHI9ZS5wcm9wcztyZXR1cm4hKHZvaWQgMD09PXI/e306cikuZGlzYWJsZWR9KSk7cmV0dXJuIGcoUGUpJiZhLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLHtjbGFzc05hbWU6XCJybWRwLWFjdGlvbi1idXR0b25zIFwiLmNvbmNhdChfKHUpP1wicm1kcC1ydGxcIjpcIlwiLFwiIFwiKS5jb25jYXQoZT9cInJtZHAtYm9yZGVyLXRvcFwiOlwiXCIpfSxQZS5jb25jYXQoc3IpLm1hcCgoZnVuY3Rpb24oZSxyKXt2YXIgdD1lLmxhYmVsLG49cyhlLCQpO3JldHVybiBhLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLGMoe2tleTpyfSxuKSx0KX0pKSl9ZnVuY3Rpb24gdnIoZSl7dmFyIHIsdD11fHwobmV3IGQuZGVmYXVsdCkubG9jYWxlO2lmKFwic3RyaW5nXCIhPXR5cGVvZiB0Lm5hbWUpcmV0dXJuIGU7cmV0dXJuKG51bGw9PVllP3ZvaWQgMDpZZVtlXSl8fChudWxsPT09KHI9e2VuOntPSzpcIk9LXCIsQ0FOQ0VMOlwiQ0FOQ0VMXCJ9LGZhOntPSzpcItiq2KPbjNuM2K9cIixDQU5DRUw6XCLZhNi62YhcIn0sYXI6e09LOlwi2KrYo9mD2YrYr1wiLENBTkNFTDpcItin2YTYutin2KFcIn0saGk6e09LOlwi4KSq4KWB4KS34KWN4KSf4KS/XCIsQ0FOQ0VMOlwi4KSw4KSm4KWN4KSmIOCkleCksOClh+CkglwifX1bQih0KV0pfHx2b2lkIDA9PT1yP3ZvaWQgMDpyW2VdKXx8ZX1mdW5jdGlvbiB4cigpe2lmKCFSJiYheGUmJiExIT09KG51bGw9PWxlP3ZvaWQgMDpsZSgpKSl7aWYod3IoKSl7dmFyIGU9bmV3IGQuZGVmYXVsdCh7Y2FsZW5kYXI6aSxsb2NhbGU6dSxmb3JtYXQ6cCxtb250aHM6Vix3ZWVrRGF5czpXLGRpZ2l0czp2ZSxpZ25vcmVMaXN0OkpTT04ucGFyc2UocmUpfSk7KCFRfHxlPlEpJiYoIWVlfHxlPGVlKSYmKGtyKGUpLG51bGw9PWJlfHxiZShsKGwoe30sbHIpLHt9LHt2YWx1ZTplfSkpLGRyLmN1cnJlbnQuZGF0ZT1lKX12YXIgcj1aKGFyKTt1ciYmci5sZW5ndGg+MCYmci5mb3JFYWNoKChmdW5jdGlvbihlKXtyZXR1cm4gZS5ibHVyKCl9KSksci5sZW5ndGg+MHx8IVFlP1hlKCEwKTpjcigpfX1mdW5jdGlvbiB3cigpe3JldHVybiBDZSYmIW4mJiFkci5jdXJyZW50LmRhdGUmJiF4JiYhayYmIXVyfWZ1bmN0aW9uIGtyKGUscix0KXtpZih1ciYmIXIpcmV0dXJuIEhlKGUpO3ZhciBuPVwiXCI7aWYoZSYmKG49ayYmeCYmZyhlKT9lLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIFgoZSxpcil9KSkuam9pbihcIiBcIi5jb25jYXQoamUsXCIgXCIpKTpYKGUsaXIpKSwhMT09PShudWxsPT1iP3ZvaWQgMDpiKGUse3ZhbGlkYXRlZFZhbHVlOm4saW5wdXQ6YXIuY3VycmVudCxpc1R5cGluZzohIXR9KSkpcmV0dXJuIFVlKEtlKSwhMTtCZShlKSxVZSh0fHxuLnRvU3RyaW5nKCkucmVwbGFjZSgvXFxzLFxccyQvLFwiXCIpKSxkci5jdXJyZW50PWwobCh7fSxkci5jdXJyZW50KSx7fSx7ZGF0ZTplfSl9ZnVuY3Rpb24gRHIoZSl7aWYoaWUpe2RyLmN1cnJlbnQuaXNUeXBpbmc9ITAsc2V0VGltZW91dCgoZnVuY3Rpb24oKXtkci5jdXJyZW50LmlzVHlwaW5nPSExfSksQWUpLGRyLmN1cnJlbnQuc2VsZWN0aW9uPWUudGFyZ2V0LnNlbGVjdGlvblN0YXJ0O3ZhciByPWUudGFyZ2V0LnZhbHVlLHQ9e2NhbGVuZGFyOmksbG9jYWxlOnUsZm9ybWF0OnAsaWdub3JlTGlzdDpKU09OLnBhcnNlKHJlKX07aWYodmU9Zyh2ZSk/dmU6dS5kaWdpdHMsIXIpcmV0dXJuIFVlKFwiXCIpLGtyKG51bGwpO2lmKHZlKXt2YXIgbixhLG89eSh2ZSk7dHJ5e2ZvcihvLnMoKTshKG49by5uKCkpLmRvbmU7KXt2YXIgYz1uLnZhbHVlO3I9ci5yZXBsYWNlKG5ldyBSZWdFeHAoYyxcImdcIiksdmUuaW5kZXhPZihjKSl9fWNhdGNoKGUpe28uZShlKX1maW5hbGx5e28uZigpfWE9ZyhXZSk/ayYmeD8ocnx8XCJcIikuc3BsaXQoamUpLmZpbHRlcihCb29sZWFuKS5tYXAoZik6ZihyKTpzKHIpLGtyKGcoV2UpfHxhLmlzVmFsaWQ/YTpudWxsLHZvaWQgMCxQKHIsdmUpKX19ZnVuY3Rpb24gcyhlKXtyZXR1cm4vKD89LipZKSg/PS4qTSkoPz0uKkQpLy50ZXN0KHApP25ldyBkLmRlZmF1bHQobChsKHt9LHQpLHt9LHtkYXRlOmV9KSk6bmV3IGQuZGVmYXVsdCh0KS5wYXJzZShlKX1mdW5jdGlvbiBmKGUpe3JldHVybihlfHxcIlwiKS5zcGxpdChpcikuZmlsdGVyKEJvb2xlYW4pLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIHMoZS50cmltKCkpfSkpfX1mdW5jdGlvbiBPcigpe2lmKHRyKCEwKSx1cil7dmFyIGU9b3IuY3VycmVudC5wYXJlbnROb2RlLnBhcmVudE5vZGU7ZS5jbGFzc05hbWU9XCJybWRwLWNhbGVuZGFyLWNvbnRhaW5lci1tb2JpbGVcIixlLnN0eWxlLnBvc2l0aW9uPVwiZml4ZWRcIixlLnN0eWxlLnRyYW5zZm9ybT1cIlwiLHNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7ZS5zdHlsZS52aXNpYmlsaXR5PVwidmlzaWJsZVwifSksNTApfX1mdW5jdGlvbiBFcihlLHIpe2coZHIuY3VycmVudC5kYXRlKXx8IXJ8fHVyfHxjcigpLG51bGw9PURlfHxEZShlLHIpfX12YXIgUT1lLmZvcndhcmRSZWYoRyk7ZnVuY3Rpb24gWChlLHIpe3ZhciB0PVtdLmNvbmNhdChlKS5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBudWxsIT1lJiZlLmlzVmFsaWQ/ZS5mb3JtYXQoKTpcIlwifSkpO3JldHVybiB0LnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZmlsdGVyKEJvb2xlYW4pLmpvaW4ocil9LHR9ZnVuY3Rpb24gWihlKXtyZXR1cm4gZS5jdXJyZW50P1wiSU5QVVRcIj09PWUuY3VycmVudC50YWdOYW1lP1tlLmN1cnJlbnRdOkFycmF5LmZyb20oZS5jdXJyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbnB1dFwiKSk6W119T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJEYXRlT2JqZWN0XCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGQuZGVmYXVsdH19KSxleHBvcnRzLkNhbGVuZGFyPXEsZXhwb3J0cy5kZWZhdWx0PVEsZXhwb3J0cy5nZXRBbGxEYXRlc0luUmFuZ2U9ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06W10scj1hcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnZvaWQgMDtpZighQXJyYXkuaXNBcnJheShlKSlyZXR1cm5bXTt2YXIgdD1lWzBdLG49ZVtlLmxlbmd0aC0xXSxhPVtdO2lmKCEodCBpbnN0YW5jZW9mIGQuZGVmYXVsdCYmbiBpbnN0YW5jZW9mIGQuZGVmYXVsdCYmdC5pc1ZhbGlkJiZuLmlzVmFsaWQmJiEodD5uKSkpcmV0dXJuW107Zm9yKHQ9bmV3IGQuZGVmYXVsdCh0KSxuPW5ldyBkLmRlZmF1bHQobik7dDw9bjt0LmRheSsrKWEucHVzaChyP3QudG9EYXRlKCk6bmV3IGQuZGVmYXVsdCh0KSk7cmV0dXJuIGF9LGV4cG9ydHMudG9EYXRlT2JqZWN0PWo7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlIiwicmVxdWlyZSIsInIiLCJ0IiwibiIsImRlZmF1bHQiLCJhIiwibyIsImQiLCJpIiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJwdXNoIiwiYXBwbHkiLCJsIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiZm9yRWFjaCIsInUiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiYyIsImFzc2lnbiIsImJpbmQiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJzIiwiaW5kZXhPZiIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiZiIsIkFycmF5IiwiaXNBcnJheSIsIlN5bWJvbCIsIml0ZXJhdG9yIiwibmV4dCIsImRvbmUiLCJyZXR1cm4iLCJtIiwiVHlwZUVycm9yIiwicCIsImgiLCJmcm9tIiwidG9TdHJpbmciLCJzbGljZSIsImNvbnN0cnVjdG9yIiwibmFtZSIsInRlc3QiLCJ5IiwiZyIsImIiLCJzdGF0ZSIsImRhdGUiLCJjYWxlbmRhciIsImxvY2FsZSIsImN1c3RvbVdlZWtEYXlzIiwid2Vla1N0YXJ0RGF5SW5kZXgiLCJkaXNwbGF5V2Vla051bWJlcnMiLCJ3ZWVrTnVtYmVyIiwidXNlTWVtbyIsIm1hcCIsInllYXIiLCJ3ZWVrRGF5cyIsInNob3J0TmFtZSIsImNvbmNhdCIsInNwbGljZSIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJrZXkiLCJ2IiwibW9udGhJbmRleCIsImRheSIsIngiLCJmb3JtYXQiLCJ3IiwibXVsdGlwbGUiLCJyYW5nZSIsInNlbGVjdGVkRGF0ZSIsIm9ubHlNb250aFBpY2tlciIsIm9ubHlZZWFyUGlja2VyIiwiZm9jdXNlZCIsIndlZWtQaWNrZXIiLCJzZXRGb3JtYXQiLCJmaW5kIiwic29ydCIsInRvRmlyc3RPZldlZWsiLCJ0b0xhc3RPZldlZWsiLCJrIiwiam9pbiIsIkQiLCJPIiwiRSIsInNldFN0YXRlIiwib25DaGFuZ2UiLCJzaG93T3RoZXJEYXlzIiwibWFwRGF5cyIsIm9ubHlTaG93SW5SYW5nZURhdGVzIiwibnVtYmVyT2ZNb250aHMiLCJpc1JUTCIsIlkiLCJoYW5kbGVGb2N1c2VkRGF0ZSIsIk0iLCJoaWRlV2Vla0RheXMiLCJDIiwiZnVsbFllYXIiLCJOIiwibW9udGhBbmRZZWFycyIsIlAiLCJTIiwiSSIsImoiLCJyYW5nZUhvdmVyIiwiVCIsImhpZ2hsaWdodFRvZGF5IiwiQSIsInVzZVJlZiIsIlIiLCJMIiwidG9kYXkiLCJGIiwibWluRGF0ZSIsIlciLCJtYXhEYXRlIiwiQiIsIl8iLCJWIiwieiIsIkgiLCJxIiwiSiIsIksiLCJ1c2VTdGF0ZSIsIlUiLCIkIiwiRyIsImN1cnJlbnQiLCJRIiwidG9GaXJzdE9mTW9udGgiLCJhZGQiLCJzdWJ0cmFjdCIsInJlZiIsInN0eWxlIiwiZGlzcGxheSIsIm9uTW91c2VMZWF2ZSIsImN1cnJlbnRNb250aCIsIm1vbnRoIiwiaXNTYW1lRGF0ZSIsImRpc2FibGVkIiwiaGlkZGVuIiwiWCIsImNoaWxkcmVuIiwic29tZSIsInJlcGxhY2UiLCJpbmNsdWRlcyIsInRhYkluZGV4Iiwib25Nb3VzZUVudGVyIiwib25LZXlEb3duIiwiY3VycmVudFRhcmdldCIsImNvZGUiLCJBcnJvd1JpZ2h0IiwiQXJyb3dMZWZ0IiwiQXJyb3dVcCIsIkFycm93RG93biIsInByZXZlbnREZWZhdWx0IiwiY2xpY2siLCJnZXRBdHRyaWJ1dGUiLCJmb2N1cyIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJaIiwib25DbGljayIsImhvdXIiLCJtaW51dGUiLCJzZWNvbmQiLCJzZXQiLCJxdWVyeVNlbGVjdG9yIiwiZGlyZWN0aW9uIiwidHlwZSIsImRpc2FibGVZZWFyUGlja2VyIiwiZGlzYWJsZU1vbnRoUGlja2VyIiwiYnV0dG9ucyIsInJlbmRlckJ1dHRvbiIsImhhbmRsZU1vbnRoQ2hhbmdlIiwiaGlkZU1vbnRoIiwiaGlkZVllYXIiLCJtb250aFllYXJTZXBhcmF0b3IiLCJmb3JtYXRNb250aCIsImZvcm1hdFllYXIiLCJoZWFkZXJPcmRlciIsIm11c3RTaG93WWVhclBpY2tlciIsIk1hdGgiLCJmbG9vciIsInBvc2l0aW9uIiwiYWxpZ25JdGVtcyIsIlNldCIsIkZyYWdtZW50Iiwic3BsaXQiLCJjdXJzb3IiLCJ0YXJnZXQiLCJjbG9zZXN0Iiwic2V0QXR0cmlidXRlIiwiRnVuY3Rpb24iLCJpc1ZhbGlkRWxlbWVudCIsImNsb25lRWxlbWVudCIsImhhbmRsZUNsaWNrIiwibXVzdFNob3dNb250aFBpY2tlciIsIkpTT04iLCJzdHJpbmdpZnkiLCJjdXN0b21Nb250aHMiLCJwYXJzZSIsIl9mb3JtYXQiLCJtb250aHMiLCJtYXJnaW4iLCJmbGV4Iiwic2V0TW9udGgiLCJvblllYXJDaGFuZ2UiLCJkaWdpdHMiLCJjZWlsIiwic2V0WWVhciIsInNldENhbGVuZGFyIiwiY29uc29sZSIsIndhcm4iLCJpbnNlcnRBdCIsImRvY3VtZW50IiwiaGVhZCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiZmlyc3RDaGlsZCIsImluc2VydEJlZm9yZSIsImFwcGVuZENoaWxkIiwic3R5bGVTaGVldCIsImNzc1RleHQiLCJjcmVhdGVUZXh0Tm9kZSIsInJvbGUiLCJmb3JtYXR0aW5nSWdub3JlTGlzdCIsIm9uUmVhZHkiLCJ6SW5kZXgiLCJwbHVnaW5zIiwiZWUiLCJyZSIsInRlIiwiY3VycmVudERhdGUiLCJuZSIsImFlIiwib2UiLCJkZSIsImllIiwibGUiLCJ1ZSIsImRpc2FibGVEYXlQaWNrZXIiLCJjZSIsIm9uUHJvcHNDaGFuZ2UiLCJzZSIsIm9uTW9udGhDaGFuZ2UiLCJmZSIsInBlIiwib25Gb2N1c2VkRGF0ZUNoYW5nZSIsIm1lIiwicmVhZE9ubHkiLCJoZSIsInllIiwiZ2UiLCJiZSIsInZlIiwic2hhZG93IiwieGUiLCJ3ZSIsImtlIiwiRGUiLCJPZSIsIkVlIiwiWWUiLCJNZSIsIkNlIiwiTmUiLCJQZSIsIlNlIiwiSWUiLCJqZSIsIlRlIiwiQWUiLCJSZSIsIkJvb2xlYW4iLCJMZSIsIkZlIiwiV2UiLCJCZSIsIl9lIiwiVmUiLCJtdXN0Q2FsbE9uUmVhZHkiLCJ1c2VFZmZlY3QiLCJpbml0aWFsVmFsdWUiLCJtdXN0U29ydERhdGVzIiwic2V0TG9jYWxlIiwiaWdub3JlTGlzdCIsImZsYXQiLCJ0b0xhc3RPZk1vbnRoIiwidG9GaXJzdE9mWWVhciIsImluUmFuZ2VEYXRlcyIsImlzUmVhZHkiLCJ6ZSIsInRyIiwiSGUiLCJ0b3AiLCJib3R0b20iLCJsZWZ0IiwicmlnaHQiLCJxZSIsIkplIiwiWGUiLCJlciIsIm9yIiwiS2UiLCJVZSIsImRhdGVQaWNrZXJQcm9wcyIsIiRlIiwiRGF0ZVBpY2tlciIsIkdlIiwiUWUiLCJhciIsInJyIiwicmVnaXN0ZXJMaXN0ZW5lciIsIm5yIiwiY2FsZW5kYXJQcm9wcyIsImhhbmRsZUNoYW5nZSIsIkNhbGVuZGFyIiwiaGFuZGxlUHJvcHNDaGFuZ2UiLCJaZSIsInByb3BzIiwibm9kZXMiLCJmbiIsImNoYW5nZSIsImZvcndhcmRSZWYiLCJtaWxsaXNlY29uZCIsImlzVmFsaWQiLCJpZCIsInRpdGxlIiwicGxhY2Vob2xkZXIiLCJyZXF1aXJlZCIsImlucHV0Q2xhc3MiLCJyZW5kZXIiLCJpbnB1dE1vZGUiLCJzY3JvbGxTZW5zaXRpdmUiLCJoaWRlT25TY3JvbGwiLCJjb250YWluZXJDbGFzc05hbWUiLCJjYWxlbmRhclBvc2l0aW9uIiwiZWRpdGFibGUiLCJvbk9wZW4iLCJvbkNsb3NlIiwiYXJyb3dDbGFzc05hbWUiLCJhcnJvdyIsImZpeE1haW5Qb3NpdGlvbiIsIm9uUG9zaXRpb25DaGFuZ2UiLCJtb2JpbGVMYWJlbHMiLCJvbk9wZW5QaWNrTmV3RGF0ZSIsIm1vYmlsZUJ1dHRvbnMiLCJkYXRlU2VwYXJhdG9yIiwibXVsdGlwbGVSYW5nZVNlcGFyYXRvciIsInR5cGluZ1RpbWVvdXQiLCJkciIsImlzVHlwaW5nIiwiaXIiLCJsciIsInVyIiwiZ3IiLCJjciIsInVzZUNhbGxiYWNrIiwiYmx1ciIsIm1vYmlsZSIsInBhcmVudE5vZGUiLCJjbGFzc0xpc3QiLCJyZW1vdmUiLCJ2aXNpYmlsaXR5Iiwic3IiLCJsYWJlbCIsInZyIiwia3IiLCJmciIsInByIiwiY29udGFpbnMiLCJyZW1vdmVUcmFuc2l0aW9uIiwicmVmcmVzaFBvc2l0aW9uIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJzZXBhcmF0b3IiLCJpc09wZW4iLCJzZWxlY3Rpb24iLCJhY3RpdmVFbGVtZW50Iiwic2V0U2VsZWN0aW9uUmFuZ2UiLCJtciIsImVsZW1lbnQiLCJociIsInBvcHBlciIsInlyIiwiYWN0aXZlIiwib3BlbkNhbGVuZGFyIiwieHIiLCJjbG9zZUNhbGVuZGFyIiwib25Gb2N1cyIsImhhbmRsZVZhbHVlQ2hhbmdlIiwiRHIiLCJhdXRvQ29tcGxldGUiLCJPciIsIkVyIiwiYnIiLCJlbiIsIk9LIiwiQ0FOQ0VMIiwiZmEiLCJoaSIsIndyIiwidmFsaWRhdGVkVmFsdWUiLCJpbnB1dCIsInNlbGVjdGlvblN0YXJ0IiwiUmVnRXhwIiwidHJpbSIsInRyYW5zZm9ybSIsInRhZ05hbWUiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZ2V0IiwiZ2V0QWxsRGF0ZXNJblJhbmdlIiwidG9EYXRlIiwidG9EYXRlT2JqZWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-multi-date-picker/build/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-pro-sidebar/dist/index.es.js":
/*!*********************************************************!*\
  !*** ./node_modules/react-pro-sidebar/dist/index.es.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LevelContext: function() { return /* binding */ LevelContext; },\n/* harmony export */   Menu: function() { return /* binding */ Menu; },\n/* harmony export */   MenuContext: function() { return /* binding */ MenuContext; },\n/* harmony export */   MenuItem: function() { return /* binding */ MenuItem; },\n/* harmony export */   MenuItemFR: function() { return /* binding */ MenuItemFR; },\n/* harmony export */   ProSidebarProvider: function() { return /* binding */ ProSidebarProvider; },\n/* harmony export */   Sidebar: function() { return /* binding */ Sidebar; },\n/* harmony export */   SidebarContext: function() { return /* binding */ SidebarContext; },\n/* harmony export */   SubMenu: function() { return /* binding */ SubMenu; },\n/* harmony export */   SubMenuFR: function() { return /* binding */ SubMenuFR; },\n/* harmony export */   menuClasses: function() { return /* binding */ menuClasses; },\n/* harmony export */   sidebarClasses: function() { return /* binding */ sidebarClasses; },\n/* harmony export */   useProSidebar: function() { return /* binding */ useProSidebar; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$(), _s3 = $RefreshSig$(), _s4 = $RefreshSig$(), _s5 = $RefreshSig$(), _s6 = $RefreshSig$(), _s7 = $RefreshSig$(), _s8 = $RefreshSig$(), _s9 = $RefreshSig$(), _s10 = $RefreshSig$(), _s11 = $RefreshSig$(), _s12 = $RefreshSig$(), _s13 = $RefreshSig$();\n\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ var __assign = function() {\n    __assign = Object.assign || function __assign(t) {\n        for(var s, i = 1, n = arguments.length; i < n; i++){\n            s = arguments[i];\n            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nfunction __rest(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n}\nfunction __makeTemplateObject(cooked, raw) {\n    if (Object.defineProperty) {\n        Object.defineProperty(cooked, \"raw\", {\n            value: raw\n        });\n    } else {\n        cooked.raw = raw;\n    }\n    return cooked;\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction memoize(fn) {\n    var cache = Object.create(null);\n    return function(arg) {\n        if (cache[arg] === undefined) cache[arg] = fn(arg);\n        return cache[arg];\n    };\n}\nvar reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/; // https://esbench.com/bench/5bfee68a4cd7e6009ef61d23\nvar isPropValid = /* #__PURE__ */ memoize(function(prop) {\n    return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;\n});\n/*\n\nBased off glamor's StyleSheet, thanks Sunil ❤️\n\nhigh performance StyleSheet for css-in-js systems\n\n- uses multiple style tags behind the scenes for millions of rules\n- uses `insertRule` for appending in production for *much* faster performance\n\n// usage\n\nimport { StyleSheet } from '@emotion/sheet'\n\nlet styleSheet = new StyleSheet({ key: '', container: document.head })\n\nstyleSheet.insert('#box { border: 1px solid red; }')\n- appends a css rule into the stylesheet\n\nstyleSheet.flush()\n- empties the stylesheet of all its contents\n\n*/ // $FlowFixMe\nfunction sheetForTag(tag) {\n    if (tag.sheet) {\n        // $FlowFixMe\n        return tag.sheet;\n    } // this weirdness brought to you by firefox\n    /* istanbul ignore next */ for(var i = 0; i < document.styleSheets.length; i++){\n        if (document.styleSheets[i].ownerNode === tag) {\n            // $FlowFixMe\n            return document.styleSheets[i];\n        }\n    }\n}\nfunction createStyleElement(options) {\n    var tag = document.createElement(\"style\");\n    tag.setAttribute(\"data-emotion\", options.key);\n    if (options.nonce !== undefined) {\n        tag.setAttribute(\"nonce\", options.nonce);\n    }\n    tag.appendChild(document.createTextNode(\"\"));\n    tag.setAttribute(\"data-s\", \"\");\n    return tag;\n}\nvar StyleSheet = /*#__PURE__*/ function() {\n    // Using Node instead of HTMLElement since container may be a ShadowRoot\n    function StyleSheet(options) {\n        var _this = this;\n        this._insertTag = function(tag) {\n            var before;\n            if (_this.tags.length === 0) {\n                if (_this.insertionPoint) {\n                    before = _this.insertionPoint.nextSibling;\n                } else if (_this.prepend) {\n                    before = _this.container.firstChild;\n                } else {\n                    before = _this.before;\n                }\n            } else {\n                before = _this.tags[_this.tags.length - 1].nextSibling;\n            }\n            _this.container.insertBefore(tag, before);\n            _this.tags.push(tag);\n        };\n        this.isSpeedy = options.speedy === undefined ? \"development\" === \"production\" : options.speedy;\n        this.tags = [];\n        this.ctr = 0;\n        this.nonce = options.nonce; // key is the value of the data-emotion attribute, it's used to identify different sheets\n        this.key = options.key;\n        this.container = options.container;\n        this.prepend = options.prepend;\n        this.insertionPoint = options.insertionPoint;\n        this.before = null;\n    }\n    var _proto = StyleSheet.prototype;\n    _proto.hydrate = function hydrate(nodes) {\n        nodes.forEach(this._insertTag);\n    };\n    _proto.insert = function insert(rule) {\n        // the max length is how many rules we have per style tag, it's 65000 in speedy mode\n        // it's 1 in dev because we insert source maps that map a single rule to a location\n        // and you can only have one source map per style tag\n        if (this.ctr % (this.isSpeedy ? 65000 : 1) === 0) {\n            this._insertTag(createStyleElement(this));\n        }\n        var tag = this.tags[this.tags.length - 1];\n        if (true) {\n            var isImportRule = rule.charCodeAt(0) === 64 && rule.charCodeAt(1) === 105;\n            if (isImportRule && this._alreadyInsertedOrderInsensitiveRule) {\n                // this would only cause problem in speedy mode\n                // but we don't want enabling speedy to affect the observable behavior\n                // so we report this error at all times\n                console.error(\"You're attempting to insert the following rule:\\n\" + rule + \"\\n\\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules.\");\n            }\n            this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !isImportRule;\n        }\n        if (this.isSpeedy) {\n            var sheet = sheetForTag(tag);\n            try {\n                // this is the ultrafast version, works across browsers\n                // the big drawback is that the css won't be editable in devtools\n                sheet.insertRule(rule, sheet.cssRules.length);\n            } catch (e) {\n                if ( true && !/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear|-ms-expand|-ms-reveal){/.test(rule)) {\n                    console.error('There was a problem inserting the following rule: \"' + rule + '\"', e);\n                }\n            }\n        } else {\n            tag.appendChild(document.createTextNode(rule));\n        }\n        this.ctr++;\n    };\n    _proto.flush = function flush() {\n        // $FlowFixMe\n        this.tags.forEach(function(tag) {\n            return tag.parentNode && tag.parentNode.removeChild(tag);\n        });\n        this.tags = [];\n        this.ctr = 0;\n        if (true) {\n            this._alreadyInsertedOrderInsensitiveRule = false;\n        }\n    };\n    return StyleSheet;\n}();\nvar MS = \"-ms-\";\nvar MOZ = \"-moz-\";\nvar WEBKIT = \"-webkit-\";\nvar COMMENT = \"comm\";\nvar RULESET = \"rule\";\nvar DECLARATION = \"decl\";\nvar IMPORT = \"@import\";\nvar KEYFRAMES = \"@keyframes\";\n/**\n * @param {number}\n * @return {number}\n */ var abs = Math.abs;\n/**\n * @param {number}\n * @return {string}\n */ var from = String.fromCharCode;\n/**\n * @param {object}\n * @return {object}\n */ var assign = Object.assign;\n/**\n * @param {string} value\n * @param {number} length\n * @return {number}\n */ function hash$2(value, length) {\n    return charat(value, 0) ^ 45 ? (((length << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;\n}\n/**\n * @param {string} value\n * @return {string}\n */ function trim(value) {\n    return value.trim();\n}\n/**\n * @param {string} value\n * @param {RegExp} pattern\n * @return {string?}\n */ function match(value, pattern) {\n    return (value = pattern.exec(value)) ? value[0] : value;\n}\n/**\n * @param {string} value\n * @param {(string|RegExp)} pattern\n * @param {string} replacement\n * @return {string}\n */ function replace(value, pattern, replacement) {\n    return value.replace(pattern, replacement);\n}\n/**\n * @param {string} value\n * @param {string} search\n * @return {number}\n */ function indexof(value, search) {\n    return value.indexOf(search);\n}\n/**\n * @param {string} value\n * @param {number} index\n * @return {number}\n */ function charat(value, index) {\n    return value.charCodeAt(index) | 0;\n}\n/**\n * @param {string} value\n * @param {number} begin\n * @param {number} end\n * @return {string}\n */ function substr(value, begin, end) {\n    return value.slice(begin, end);\n}\n/**\n * @param {string} value\n * @return {number}\n */ function strlen(value) {\n    return value.length;\n}\n/**\n * @param {any[]} value\n * @return {number}\n */ function sizeof(value) {\n    return value.length;\n}\n/**\n * @param {any} value\n * @param {any[]} array\n * @return {any}\n */ function append(value, array) {\n    return array.push(value), value;\n}\n/**\n * @param {string[]} array\n * @param {function} callback\n * @return {string}\n */ function combine(array, callback) {\n    return array.map(callback).join(\"\");\n}\nvar line = 1;\nvar column = 1;\nvar length = 0;\nvar position = 0;\nvar character = 0;\nvar characters = \"\";\n/**\n * @param {string} value\n * @param {object | null} root\n * @param {object | null} parent\n * @param {string} type\n * @param {string[] | string} props\n * @param {object[] | string} children\n * @param {number} length\n */ function node(value, root, parent, type, props, children, length) {\n    return {\n        value: value,\n        root: root,\n        parent: parent,\n        type: type,\n        props: props,\n        children: children,\n        line: line,\n        column: column,\n        length: length,\n        return: \"\"\n    };\n}\n/**\n * @param {object} root\n * @param {object} props\n * @return {object}\n */ function copy(root, props) {\n    return assign(node(\"\", null, null, \"\", null, null, 0), root, {\n        length: -root.length\n    }, props);\n}\n/**\n * @return {number}\n */ function char() {\n    return character;\n}\n/**\n * @return {number}\n */ function prev() {\n    character = position > 0 ? charat(characters, --position) : 0;\n    if (column--, character === 10) column = 1, line--;\n    return character;\n}\n/**\n * @return {number}\n */ function next() {\n    character = position < length ? charat(characters, position++) : 0;\n    if (column++, character === 10) column = 1, line++;\n    return character;\n}\n/**\n * @return {number}\n */ function peek() {\n    return charat(characters, position);\n}\n/**\n * @return {number}\n */ function caret() {\n    return position;\n}\n/**\n * @param {number} begin\n * @param {number} end\n * @return {string}\n */ function slice(begin, end) {\n    return substr(characters, begin, end);\n}\n/**\n * @param {number} type\n * @return {number}\n */ function token(type) {\n    switch(type){\n        // \\0 \\t \\n \\r \\s whitespace token\n        case 0:\n        case 9:\n        case 10:\n        case 13:\n        case 32:\n            return 5;\n        // ! + , / > @ ~ isolate token\n        case 33:\n        case 43:\n        case 44:\n        case 47:\n        case 62:\n        case 64:\n        case 126:\n        // ; { } breakpoint token\n        case 59:\n        case 123:\n        case 125:\n            return 4;\n        // : accompanied token\n        case 58:\n            return 3;\n        // \" ' ( [ opening delimit token\n        case 34:\n        case 39:\n        case 40:\n        case 91:\n            return 2;\n        // ) ] closing delimit token\n        case 41:\n        case 93:\n            return 1;\n    }\n    return 0;\n}\n/**\n * @param {string} value\n * @return {any[]}\n */ function alloc(value) {\n    return line = column = 1, length = strlen(characters = value), position = 0, [];\n}\n/**\n * @param {any} value\n * @return {any}\n */ function dealloc(value) {\n    return characters = \"\", value;\n}\n/**\n * @param {number} type\n * @return {string}\n */ function delimit(type) {\n    return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));\n}\n/**\n * @param {number} type\n * @return {string}\n */ function whitespace(type) {\n    while(character = peek())if (character < 33) next();\n    else break;\n    return token(type) > 2 || token(character) > 3 ? \"\" : \" \";\n}\n/**\n * @param {number} index\n * @param {number} count\n * @return {string}\n */ function escaping(index, count) {\n    while(--count && next())// not 0-9 A-F a-f\n    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97) break;\n    return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32));\n}\n/**\n * @param {number} type\n * @return {number}\n */ function delimiter(type) {\n    while(next())switch(character){\n        // ] ) \" '\n        case type:\n            return position;\n        // \" '\n        case 34:\n        case 39:\n            if (type !== 34 && type !== 39) delimiter(character);\n            break;\n        // (\n        case 40:\n            if (type === 41) delimiter(type);\n            break;\n        // \\\n        case 92:\n            next();\n            break;\n    }\n    return position;\n}\n/**\n * @param {number} type\n * @param {number} index\n * @return {number}\n */ function commenter(type, index) {\n    while(next())// //\n    if (type + character === 47 + 10) break;\n    else if (type + character === 42 + 42 && peek() === 47) break;\n    return \"/*\" + slice(index, position - 1) + \"*\" + from(type === 47 ? type : next());\n}\n/**\n * @param {number} index\n * @return {string}\n */ function identifier(index) {\n    while(!token(peek()))next();\n    return slice(index, position);\n}\n/**\n * @param {string} value\n * @return {object[]}\n */ function compile(value) {\n    return dealloc(parse(\"\", null, null, null, [\n        \"\"\n    ], value = alloc(value), 0, [\n        0\n    ], value));\n}\n/**\n * @param {string} value\n * @param {object} root\n * @param {object?} parent\n * @param {string[]} rule\n * @param {string[]} rules\n * @param {string[]} rulesets\n * @param {number[]} pseudo\n * @param {number[]} points\n * @param {string[]} declarations\n * @return {object}\n */ function parse(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {\n    var index = 0;\n    var offset = 0;\n    var length = pseudo;\n    var atrule = 0;\n    var property = 0;\n    var previous = 0;\n    var variable = 1;\n    var scanning = 1;\n    var ampersand = 1;\n    var character = 0;\n    var type = \"\";\n    var props = rules;\n    var children = rulesets;\n    var reference = rule;\n    var characters = type;\n    while(scanning)switch(previous = character, character = next()){\n        // (\n        case 40:\n            if (previous != 108 && charat(characters, length - 1) == 58) {\n                if (indexof(characters += replace(delimit(character), \"&\", \"&\\f\"), \"&\\f\") != -1) ampersand = -1;\n                break;\n            }\n        // \" ' [\n        case 34:\n        case 39:\n        case 91:\n            characters += delimit(character);\n            break;\n        // \\t \\n \\r \\s\n        case 9:\n        case 10:\n        case 13:\n        case 32:\n            characters += whitespace(previous);\n            break;\n        // \\\n        case 92:\n            characters += escaping(caret() - 1, 7);\n            continue;\n        // /\n        case 47:\n            switch(peek()){\n                case 42:\n                case 47:\n                    append(comment(commenter(next(), caret()), root, parent), declarations);\n                    break;\n                default:\n                    characters += \"/\";\n            }\n            break;\n        // {\n        case 123 * variable:\n            points[index++] = strlen(characters) * ampersand;\n        // } ; \\0\n        case 125 * variable:\n        case 59:\n        case 0:\n            switch(character){\n                // \\0 }\n                case 0:\n                case 125:\n                    scanning = 0;\n                // ;\n                case 59 + offset:\n                    if (property > 0 && strlen(characters) - length) append(property > 32 ? declaration(characters + \";\", rule, parent, length - 1) : declaration(replace(characters, \" \", \"\") + \";\", rule, parent, length - 2), declarations);\n                    break;\n                // @ ;\n                case 59:\n                    characters += \";\";\n                // { rule/at-rule\n                default:\n                    append(reference = ruleset(characters, root, parent, index, offset, rules, points, type, props = [], children = [], length), rulesets);\n                    if (character === 123) if (offset === 0) parse(characters, root, reference, reference, props, rulesets, length, points, children);\n                    else switch(atrule === 99 && charat(characters, 3) === 110 ? 100 : atrule){\n                        // d m s\n                        case 100:\n                        case 109:\n                        case 115:\n                            parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length), children), rules, children, length, points, rule ? props : children);\n                            break;\n                        default:\n                            parse(characters, reference, reference, reference, [\n                                \"\"\n                            ], children, 0, points, children);\n                    }\n            }\n            index = offset = property = 0, variable = ampersand = 1, type = characters = \"\", length = pseudo;\n            break;\n        // :\n        case 58:\n            length = 1 + strlen(characters), property = previous;\n        default:\n            if (variable < 1) {\n                if (character == 123) --variable;\n                else if (character == 125 && variable++ == 0 && prev() == 125) continue;\n            }\n            switch(characters += from(character), character * variable){\n                // &\n                case 38:\n                    ampersand = offset > 0 ? 1 : (characters += \"\\f\", -1);\n                    break;\n                // ,\n                case 44:\n                    points[index++] = (strlen(characters) - 1) * ampersand, ampersand = 1;\n                    break;\n                // @\n                case 64:\n                    // -\n                    if (peek() === 45) characters += delimit(next());\n                    atrule = peek(), offset = length = strlen(type = characters += identifier(caret())), character++;\n                    break;\n                // -\n                case 45:\n                    if (previous === 45 && strlen(characters) == 2) variable = 0;\n            }\n    }\n    return rulesets;\n}\n/**\n * @param {string} value\n * @param {object} root\n * @param {object?} parent\n * @param {number} index\n * @param {number} offset\n * @param {string[]} rules\n * @param {number[]} points\n * @param {string} type\n * @param {string[]} props\n * @param {string[]} children\n * @param {number} length\n * @return {object}\n */ function ruleset(value, root, parent, index, offset, rules, points, type, props, children, length) {\n    var post = offset - 1;\n    var rule = offset === 0 ? rules : [\n        \"\"\n    ];\n    var size = sizeof(rule);\n    for(var i = 0, j = 0, k = 0; i < index; ++i)for(var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size; ++x)if (z = trim(j > 0 ? rule[x] + \" \" + y : replace(y, /&\\f/g, rule[x]))) props[k++] = z;\n    return node(value, root, parent, offset === 0 ? RULESET : type, props, children, length);\n}\n/**\n * @param {number} value\n * @param {object} root\n * @param {object?} parent\n * @return {object}\n */ function comment(value, root, parent) {\n    return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0);\n}\n/**\n * @param {string} value\n * @param {object} root\n * @param {object?} parent\n * @param {number} length\n * @return {object}\n */ function declaration(value, root, parent, length) {\n    return node(value, root, parent, DECLARATION, substr(value, 0, length), substr(value, length + 1, -1), length);\n}\n/**\n * @param {object[]} children\n * @param {function} callback\n * @return {string}\n */ function serialize(children, callback) {\n    var output = \"\";\n    var length = sizeof(children);\n    for(var i = 0; i < length; i++)output += callback(children[i], i, children, callback) || \"\";\n    return output;\n}\n/**\n * @param {object} element\n * @param {number} index\n * @param {object[]} children\n * @param {function} callback\n * @return {string}\n */ function stringify(element, index, children, callback) {\n    switch(element.type){\n        case IMPORT:\n        case DECLARATION:\n            return element.return = element.return || element.value;\n        case COMMENT:\n            return \"\";\n        case KEYFRAMES:\n            return element.return = element.value + \"{\" + serialize(element.children, callback) + \"}\";\n        case RULESET:\n            element.value = element.props.join(\",\");\n    }\n    return strlen(children = serialize(element.children, callback)) ? element.return = element.value + \"{\" + children + \"}\" : \"\";\n}\n/**\n * @param {function[]} collection\n * @return {function}\n */ function middleware(collection) {\n    var length = sizeof(collection);\n    return function(element, index, children, callback) {\n        var output = \"\";\n        for(var i = 0; i < length; i++)output += collection[i](element, index, children, callback) || \"\";\n        return output;\n    };\n}\n/**\n * @param {function} callback\n * @return {function}\n */ function rulesheet(callback) {\n    return function(element) {\n        if (!element.root) {\n            if (element = element.return) callback(element);\n        }\n    };\n}\nvar weakMemoize = function weakMemoize(func) {\n    // $FlowFixMe flow doesn't include all non-primitive types as allowed for weakmaps\n    var cache = new WeakMap();\n    return function(arg) {\n        if (cache.has(arg)) {\n            // $FlowFixMe\n            return cache.get(arg);\n        }\n        var ret = func(arg);\n        cache.set(arg, ret);\n        return ret;\n    };\n};\nvar identifierWithPointTracking = function identifierWithPointTracking(begin, points, index) {\n    var previous = 0;\n    var character = 0;\n    while(true){\n        previous = character;\n        character = peek(); // &\\f\n        if (previous === 38 && character === 12) {\n            points[index] = 1;\n        }\n        if (token(character)) {\n            break;\n        }\n        next();\n    }\n    return slice(begin, position);\n};\nvar toRules = function toRules(parsed, points) {\n    // pretend we've started with a comma\n    var index = -1;\n    var character = 44;\n    do {\n        switch(token(character)){\n            case 0:\n                // &\\f\n                if (character === 38 && peek() === 12) {\n                    // this is not 100% correct, we don't account for literal sequences here - like for example quoted strings\n                    // stylis inserts \\f after & to know when & where it should replace this sequence with the context selector\n                    // and when it should just concatenate the outer and inner selectors\n                    // it's very unlikely for this sequence to actually appear in a different context, so we just leverage this fact here\n                    points[index] = 1;\n                }\n                parsed[index] += identifierWithPointTracking(position - 1, points, index);\n                break;\n            case 2:\n                parsed[index] += delimit(character);\n                break;\n            case 4:\n                // comma\n                if (character === 44) {\n                    // colon\n                    parsed[++index] = peek() === 58 ? \"&\\f\" : \"\";\n                    points[index] = parsed[index].length;\n                    break;\n                }\n            // fallthrough\n            default:\n                parsed[index] += from(character);\n        }\n    }while (character = next());\n    return parsed;\n};\nvar getRules = function getRules(value, points) {\n    return dealloc(toRules(alloc(value), points));\n}; // WeakSet would be more appropriate, but only WeakMap is supported in IE11\nvar fixedElements = /* #__PURE__ */ new WeakMap();\nvar compat = function compat(element) {\n    if (element.type !== \"rule\" || !element.parent || // positive .length indicates that this rule contains pseudo\n    // negative .length indicates that this rule has been already prefixed\n    element.length < 1) {\n        return;\n    }\n    var value = element.value, parent = element.parent;\n    var isImplicitRule = element.column === parent.column && element.line === parent.line;\n    while(parent.type !== \"rule\"){\n        parent = parent.parent;\n        if (!parent) return;\n    } // short-circuit for the simplest case\n    if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {\n        return;\n    } // if this is an implicitly inserted rule (the one eagerly inserted at the each new nested level)\n    // then the props has already been manipulated beforehand as they that array is shared between it and its \"rule parent\"\n    if (isImplicitRule) {\n        return;\n    }\n    fixedElements.set(element, true);\n    var points = [];\n    var rules = getRules(value, points);\n    var parentRules = parent.props;\n    for(var i = 0, k = 0; i < rules.length; i++){\n        for(var j = 0; j < parentRules.length; j++, k++){\n            element.props[k] = points[i] ? rules[i].replace(/&\\f/g, parentRules[j]) : parentRules[j] + \" \" + rules[i];\n        }\n    }\n};\nvar removeLabel = function removeLabel(element) {\n    if (element.type === \"decl\") {\n        var value = element.value;\n        if (value.charCodeAt(0) === 108 && // charcode for b\n        value.charCodeAt(2) === 98) {\n            // this ignores label\n            element[\"return\"] = \"\";\n            element.value = \"\";\n        }\n    }\n};\nvar ignoreFlag = \"emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason\";\nvar isIgnoringComment = function isIgnoringComment(element) {\n    return element.type === \"comm\" && element.children.indexOf(ignoreFlag) > -1;\n};\nvar createUnsafeSelectorsAlarm = function createUnsafeSelectorsAlarm(cache) {\n    return function(element, index, children) {\n        if (element.type !== \"rule\" || cache.compat) return;\n        var unsafePseudoClasses = element.value.match(/(:first|:nth|:nth-last)-child/g);\n        if (unsafePseudoClasses) {\n            var isNested = element.parent === children[0]; // in nested rules comments become children of the \"auto-inserted\" rule\n            //\n            // considering this input:\n            // .a {\n            //   .b /* comm */ {}\n            //   color: hotpink;\n            // }\n            // we get output corresponding to this:\n            // .a {\n            //   & {\n            //     /* comm */\n            //     color: hotpink;\n            //   }\n            //   .b {}\n            // }\n            var commentContainer = isNested ? children[0].children : children;\n            for(var i = commentContainer.length - 1; i >= 0; i--){\n                var node = commentContainer[i];\n                if (node.line < element.line) {\n                    break;\n                } // it is quite weird but comments are *usually* put at `column: element.column - 1`\n                // so we seek *from the end* for the node that is earlier than the rule's `element` and check that\n                // this will also match inputs like this:\n                // .a {\n                //   /* comm */\n                //   .b {}\n                // }\n                //\n                // but that is fine\n                //\n                // it would be the easiest to change the placement of the comment to be the first child of the rule:\n                // .a {\n                //   .b { /* comm */ }\n                // }\n                // with such inputs we wouldn't have to search for the comment at all\n                // TODO: consider changing this comment placement in the next major version\n                if (node.column < element.column) {\n                    if (isIgnoringComment(node)) {\n                        return;\n                    }\n                    break;\n                }\n            }\n            unsafePseudoClasses.forEach(function(unsafePseudoClass) {\n                console.error('The pseudo class \"' + unsafePseudoClass + '\" is potentially unsafe when doing server-side rendering. Try changing it to \"' + unsafePseudoClass.split(\"-child\")[0] + '-of-type\".');\n            });\n        }\n    };\n};\nvar isImportRule = function isImportRule(element) {\n    return element.type.charCodeAt(1) === 105 && element.type.charCodeAt(0) === 64;\n};\nvar isPrependedWithRegularRules = function isPrependedWithRegularRules(index, children) {\n    for(var i = index - 1; i >= 0; i--){\n        if (!isImportRule(children[i])) {\n            return true;\n        }\n    }\n    return false;\n}; // use this to remove incorrect elements from further processing\n// so they don't get handed to the `sheet` (or anything else)\n// as that could potentially lead to additional logs which in turn could be overhelming to the user\nvar nullifyElement = function nullifyElement(element) {\n    element.type = \"\";\n    element.value = \"\";\n    element[\"return\"] = \"\";\n    element.children = \"\";\n    element.props = \"\";\n};\nvar incorrectImportAlarm = function incorrectImportAlarm(element, index, children) {\n    if (!isImportRule(element)) {\n        return;\n    }\n    if (element.parent) {\n        console.error(\"`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles.\");\n        nullifyElement(element);\n    } else if (isPrependedWithRegularRules(index, children)) {\n        console.error(\"`@import` rules can't be after other rules. Please put your `@import` rules before your other rules.\");\n        nullifyElement(element);\n    }\n};\n/* eslint-disable no-fallthrough */ function prefix(value, length) {\n    switch(hash$2(value, length)){\n        // color-adjust\n        case 5103:\n            return WEBKIT + \"print-\" + value + value;\n        // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)\n        case 5737:\n        case 4201:\n        case 3177:\n        case 3433:\n        case 1641:\n        case 4457:\n        case 2921:\n        case 5572:\n        case 6356:\n        case 5844:\n        case 3191:\n        case 6645:\n        case 3005:\n        case 6391:\n        case 5879:\n        case 5623:\n        case 6135:\n        case 4599:\n        case 4855:\n        case 4215:\n        case 6389:\n        case 5109:\n        case 5365:\n        case 5621:\n        case 3829:\n            return WEBKIT + value + value;\n        // appearance, user-select, transform, hyphens, text-size-adjust\n        case 5349:\n        case 4246:\n        case 4810:\n        case 6968:\n        case 2756:\n            return WEBKIT + value + MOZ + value + MS + value + value;\n        // flex, flex-direction\n        case 6828:\n        case 4268:\n            return WEBKIT + value + MS + value + value;\n        // order\n        case 6165:\n            return WEBKIT + value + MS + \"flex-\" + value + value;\n        // align-items\n        case 5187:\n            return WEBKIT + value + replace(value, /(\\w+).+(:[^]+)/, WEBKIT + \"box-$1$2\" + MS + \"flex-$1$2\") + value;\n        // align-self\n        case 5443:\n            return WEBKIT + value + MS + \"flex-item-\" + replace(value, /flex-|-self/, \"\") + value;\n        // align-content\n        case 4675:\n            return WEBKIT + value + MS + \"flex-line-pack\" + replace(value, /align-content|flex-|-self/, \"\") + value;\n        // flex-shrink\n        case 5548:\n            return WEBKIT + value + MS + replace(value, \"shrink\", \"negative\") + value;\n        // flex-basis\n        case 5292:\n            return WEBKIT + value + MS + replace(value, \"basis\", \"preferred-size\") + value;\n        // flex-grow\n        case 6060:\n            return WEBKIT + \"box-\" + replace(value, \"-grow\", \"\") + WEBKIT + value + MS + replace(value, \"grow\", \"positive\") + value;\n        // transition\n        case 4554:\n            return WEBKIT + replace(value, /([^-])(transform)/g, \"$1\" + WEBKIT + \"$2\") + value;\n        // cursor\n        case 6187:\n            return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + \"$1\"), /(image-set)/, WEBKIT + \"$1\"), value, \"\") + value;\n        // background, background-image\n        case 5495:\n        case 3959:\n            return replace(value, /(image-set\\([^]*)/, WEBKIT + \"$1\" + \"$`$1\");\n        // justify-content\n        case 4968:\n            return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + \"box-pack:$3\" + MS + \"flex-pack:$3\"), /s.+-b[^;]+/, \"justify\") + WEBKIT + value + value;\n        // (margin|padding)-inline-(start|end)\n        case 4095:\n        case 3583:\n        case 4068:\n        case 2532:\n            return replace(value, /(.+)-inline(.+)/, WEBKIT + \"$1$2\") + value;\n        // (min|max)?(width|height|inline-size|block-size)\n        case 8116:\n        case 7059:\n        case 5753:\n        case 5535:\n        case 5445:\n        case 5701:\n        case 4933:\n        case 4677:\n        case 5533:\n        case 5789:\n        case 5021:\n        case 4765:\n            // stretch, max-content, min-content, fill-available\n            if (strlen(value) - 1 - length > 6) switch(charat(value, length + 1)){\n                // (m)ax-content, (m)in-content\n                case 109:\n                    // -\n                    if (charat(value, length + 4) !== 45) break;\n                // (f)ill-available, (f)it-content\n                case 102:\n                    return replace(value, /(.+:)(.+)-([^]+)/, \"$1\" + WEBKIT + \"$2-$3\" + \"$1\" + MOZ + (charat(value, length + 3) == 108 ? \"$3\" : \"$2-$3\")) + value;\n                // (s)tretch\n                case 115:\n                    return ~indexof(value, \"stretch\") ? prefix(replace(value, \"stretch\", \"fill-available\"), length) + value : value;\n            }\n            break;\n        // position: sticky\n        case 4949:\n            // (s)ticky?\n            if (charat(value, length + 1) !== 115) break;\n        // display: (flex|inline-flex)\n        case 6444:\n            switch(charat(value, strlen(value) - 3 - (~indexof(value, \"!important\") && 10))){\n                // stic(k)y\n                case 107:\n                    return replace(value, \":\", \":\" + WEBKIT) + value;\n                // (inline-)?fl(e)x\n                case 101:\n                    return replace(value, /(.+:)([^;!]+)(;|!.+)?/, \"$1\" + WEBKIT + (charat(value, 14) === 45 ? \"inline-\" : \"\") + \"box$3\" + \"$1\" + WEBKIT + \"$2$3\" + \"$1\" + MS + \"$2box$3\") + value;\n            }\n            break;\n        // writing-mode\n        case 5936:\n            switch(charat(value, length + 11)){\n                // vertical-l(r)\n                case 114:\n                    return WEBKIT + value + MS + replace(value, /[svh]\\w+-[tblr]{2}/, \"tb\") + value;\n                // vertical-r(l)\n                case 108:\n                    return WEBKIT + value + MS + replace(value, /[svh]\\w+-[tblr]{2}/, \"tb-rl\") + value;\n                // horizontal(-)tb\n                case 45:\n                    return WEBKIT + value + MS + replace(value, /[svh]\\w+-[tblr]{2}/, \"lr\") + value;\n            }\n            return WEBKIT + value + MS + value + value;\n    }\n    return value;\n}\nvar prefixer = function prefixer(element, index, children, callback) {\n    if (element.length > -1) {\n        if (!element[\"return\"]) switch(element.type){\n            case DECLARATION:\n                element[\"return\"] = prefix(element.value, element.length);\n                break;\n            case KEYFRAMES:\n                return serialize([\n                    copy(element, {\n                        value: replace(element.value, \"@\", \"@\" + WEBKIT)\n                    })\n                ], callback);\n            case RULESET:\n                if (element.length) return combine(element.props, function(value) {\n                    switch(match(value, /(::plac\\w+|:read-\\w+)/)){\n                        // :read-(only|write)\n                        case \":read-only\":\n                        case \":read-write\":\n                            return serialize([\n                                copy(element, {\n                                    props: [\n                                        replace(value, /:(read-\\w+)/, \":\" + MOZ + \"$1\")\n                                    ]\n                                })\n                            ], callback);\n                        // :placeholder\n                        case \"::placeholder\":\n                            return serialize([\n                                copy(element, {\n                                    props: [\n                                        replace(value, /:(plac\\w+)/, \":\" + WEBKIT + \"input-$1\")\n                                    ]\n                                }),\n                                copy(element, {\n                                    props: [\n                                        replace(value, /:(plac\\w+)/, \":\" + MOZ + \"$1\")\n                                    ]\n                                }),\n                                copy(element, {\n                                    props: [\n                                        replace(value, /:(plac\\w+)/, MS + \"input-$1\")\n                                    ]\n                                })\n                            ], callback);\n                    }\n                    return \"\";\n                });\n        }\n    }\n};\nvar isBrowser$5 = typeof document !== \"undefined\";\nvar getServerStylisCache = isBrowser$5 ? undefined : weakMemoize(function() {\n    return memoize(function() {\n        var cache = {};\n        return function(name) {\n            return cache[name];\n        };\n    });\n});\nvar defaultStylisPlugins = [\n    prefixer\n];\nvar createCache = function createCache(options) {\n    var key = options.key;\n    if ( true && !key) {\n        throw new Error(\"You have to configure `key` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.\\n\" + 'If multiple caches share the same key they might \"fight\" for each other\\'s style elements.');\n    }\n    if (isBrowser$5 && key === \"css\") {\n        var ssrStyles = document.querySelectorAll(\"style[data-emotion]:not([data-s])\"); // get SSRed styles out of the way of React's hydration\n        // document.head is a safe place to move them to(though note document.head is not necessarily the last place they will be)\n        // note this very very intentionally targets all style elements regardless of the key to ensure\n        // that creating a cache works inside of render of a React component\n        Array.prototype.forEach.call(ssrStyles, function(node) {\n            // we want to only move elements which have a space in the data-emotion attribute value\n            // because that indicates that it is an Emotion 11 server-side rendered style elements\n            // while we will already ignore Emotion 11 client-side inserted styles because of the :not([data-s]) part in the selector\n            // Emotion 10 client-side inserted styles did not have data-s (but importantly did not have a space in their data-emotion attributes)\n            // so checking for the space ensures that loading Emotion 11 after Emotion 10 has inserted some styles\n            // will not result in the Emotion 10 styles being destroyed\n            var dataEmotionAttribute = node.getAttribute(\"data-emotion\");\n            if (dataEmotionAttribute.indexOf(\" \") === -1) {\n                return;\n            }\n            document.head.appendChild(node);\n            node.setAttribute(\"data-s\", \"\");\n        });\n    }\n    var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;\n    if (true) {\n        // $FlowFixMe\n        if (/[^a-z-]/.test(key)) {\n            throw new Error('Emotion key must only contain lower case alphabetical characters and - but \"' + key + '\" was passed');\n        }\n    }\n    var inserted = {};\n    var container;\n    var nodesToHydrate = [];\n    if (isBrowser$5) {\n        container = options.container || document.head;\n        Array.prototype.forEach.call(// means that the style elements we're looking at are only Emotion 11 server-rendered style elements\n        document.querySelectorAll('style[data-emotion^=\"' + key + ' \"]'), function(node) {\n            var attrib = node.getAttribute(\"data-emotion\").split(\" \"); // $FlowFixMe\n            for(var i = 1; i < attrib.length; i++){\n                inserted[attrib[i]] = true;\n            }\n            nodesToHydrate.push(node);\n        });\n    }\n    var _insert;\n    var omnipresentPlugins = [\n        compat,\n        removeLabel\n    ];\n    if (true) {\n        omnipresentPlugins.push(createUnsafeSelectorsAlarm({\n            get compat () {\n                return cache.compat;\n            }\n        }), incorrectImportAlarm);\n    }\n    if (isBrowser$5) {\n        var currentSheet;\n        var finalizingPlugins = [\n            stringify,\n             true ? function(element) {\n                if (!element.root) {\n                    if (element[\"return\"]) {\n                        currentSheet.insert(element[\"return\"]);\n                    } else if (element.value && element.type !== COMMENT) {\n                        // insert empty rule in non-production environments\n                        // so @emotion/jest can grab `key` from the (JS)DOM for caches without any rules inserted yet\n                        currentSheet.insert(element.value + \"{}\");\n                    }\n                }\n            } : 0\n        ];\n        var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));\n        var stylis = function stylis(styles) {\n            return serialize(compile(styles), serializer);\n        };\n        _insert = function insert(selector, serialized, sheet, shouldCache) {\n            currentSheet = sheet;\n            if ( true && serialized.map !== undefined) {\n                currentSheet = {\n                    insert: function insert(rule) {\n                        sheet.insert(rule + serialized.map);\n                    }\n                };\n            }\n            stylis(selector ? selector + \"{\" + serialized.styles + \"}\" : serialized.styles);\n            if (shouldCache) {\n                cache.inserted[serialized.name] = true;\n            }\n        };\n    } else {\n        var _finalizingPlugins = [\n            stringify\n        ];\n        var _serializer = middleware(omnipresentPlugins.concat(stylisPlugins, _finalizingPlugins));\n        var _stylis = function _stylis(styles) {\n            return serialize(compile(styles), _serializer);\n        }; // $FlowFixMe\n        var serverStylisCache = getServerStylisCache(stylisPlugins)(key);\n        var getRules = function getRules(selector, serialized) {\n            var name = serialized.name;\n            if (serverStylisCache[name] === undefined) {\n                serverStylisCache[name] = _stylis(selector ? selector + \"{\" + serialized.styles + \"}\" : serialized.styles);\n            }\n            return serverStylisCache[name];\n        };\n        _insert = function _insert(selector, serialized, sheet, shouldCache) {\n            var name = serialized.name;\n            var rules = getRules(selector, serialized);\n            if (cache.compat === undefined) {\n                // in regular mode, we don't set the styles on the inserted cache\n                // since we don't need to and that would be wasting memory\n                // we return them so that they are rendered in a style tag\n                if (shouldCache) {\n                    cache.inserted[name] = true;\n                }\n                if (// because if people do ssr in tests, the source maps showing up would be annoying\n                 true && serialized.map !== undefined) {\n                    return rules + serialized.map;\n                }\n                return rules;\n            } else {\n                // in compat mode, we put the styles on the inserted cache so\n                // that emotion-server can pull out the styles\n                // except when we don't want to cache it which was in Global but now\n                // is nowhere but we don't want to do a major right now\n                // and just in case we're going to leave the case here\n                // it's also not affecting client side bundle size\n                // so it's really not a big deal\n                if (shouldCache) {\n                    cache.inserted[name] = rules;\n                } else {\n                    return rules;\n                }\n            }\n        };\n    }\n    var cache = {\n        key: key,\n        sheet: new StyleSheet({\n            key: key,\n            container: container,\n            nonce: options.nonce,\n            speedy: options.speedy,\n            prepend: options.prepend,\n            insertionPoint: options.insertionPoint\n        }),\n        nonce: options.nonce,\n        inserted: inserted,\n        registered: {},\n        insert: _insert\n    };\n    cache.sheet.hydrate(nodesToHydrate);\n    return cache;\n};\nvar isBrowser$4 = typeof document !== \"undefined\";\nfunction getRegisteredStyles$1(registered, registeredStyles, classNames) {\n    var rawClassName = \"\";\n    classNames.split(\" \").forEach(function(className) {\n        if (registered[className] !== undefined) {\n            registeredStyles.push(registered[className] + \";\");\n        } else {\n            rawClassName += className + \" \";\n        }\n    });\n    return rawClassName;\n}\nvar registerStyles$1 = function registerStyles(cache, serialized, isStringTag) {\n    var className = cache.key + \"-\" + serialized.name;\n    if (// class name could be used further down\n    // the tree but if it's a string tag, we know it won't\n    // so we don't have to add it to registered cache.\n    // this improves memory usage since we can avoid storing the whole style string\n    (isStringTag === false || // we need to always store it if we're in compat mode and\n    // in node since emotion-server relies on whether a style is in\n    // the registered cache to know whether a style is global or not\n    // also, note that this check will be dead code eliminated in the browser\n    isBrowser$4 === false && cache.compat !== undefined) && cache.registered[className] === undefined) {\n        cache.registered[className] = serialized.styles;\n    }\n};\nvar insertStyles$1 = function insertStyles(cache, serialized, isStringTag) {\n    registerStyles$1(cache, serialized, isStringTag);\n    var className = cache.key + \"-\" + serialized.name;\n    if (cache.inserted[serialized.name] === undefined) {\n        var stylesForSSR = \"\";\n        var current = serialized;\n        do {\n            var maybeStyles = cache.insert(serialized === current ? \".\" + className : \"\", current, cache.sheet, true);\n            if (!isBrowser$4 && maybeStyles !== undefined) {\n                stylesForSSR += maybeStyles;\n            }\n            current = current.next;\n        }while (current !== undefined);\n        if (!isBrowser$4 && stylesForSSR.length !== 0) {\n            return stylesForSSR;\n        }\n    }\n};\n/* eslint-disable */ // Inspired by https://github.com/garycourt/murmurhash-js\n// Ported from https://github.com/aappleby/smhasher/blob/61a0530f28277f2e850bfc39600ce61d02b518de/src/MurmurHash2.cpp#L37-L86\nfunction murmur2$1(str) {\n    // 'm' and 'r' are mixing constants generated offline.\n    // They're not really 'magic', they just happen to work well.\n    // const m = 0x5bd1e995;\n    // const r = 24;\n    // Initialize the hash\n    var h = 0; // Mix 4 bytes at a time into the hash\n    var k, i = 0, len = str.length;\n    for(; len >= 4; ++i, len -= 4){\n        k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;\n        k = /* Math.imul(k, m): */ (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16);\n        k ^= /* k >>> r: */ k >>> 24;\n        h = /* Math.imul(k, m): */ (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16) ^ /* Math.imul(h, m): */ (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);\n    } // Handle the last few bytes of the input array\n    switch(len){\n        case 3:\n            h ^= (str.charCodeAt(i + 2) & 0xff) << 16;\n        case 2:\n            h ^= (str.charCodeAt(i + 1) & 0xff) << 8;\n        case 1:\n            h ^= str.charCodeAt(i) & 0xff;\n            h = /* Math.imul(h, m): */ (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);\n    } // Do a few final mixes of the hash to ensure the last few\n    // bytes are well-incorporated.\n    h ^= h >>> 13;\n    h = /* Math.imul(h, m): */ (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);\n    return ((h ^ h >>> 15) >>> 0).toString(36);\n}\nvar unitlessKeys$1 = {\n    animationIterationCount: 1,\n    borderImageOutset: 1,\n    borderImageSlice: 1,\n    borderImageWidth: 1,\n    boxFlex: 1,\n    boxFlexGroup: 1,\n    boxOrdinalGroup: 1,\n    columnCount: 1,\n    columns: 1,\n    flex: 1,\n    flexGrow: 1,\n    flexPositive: 1,\n    flexShrink: 1,\n    flexNegative: 1,\n    flexOrder: 1,\n    gridRow: 1,\n    gridRowEnd: 1,\n    gridRowSpan: 1,\n    gridRowStart: 1,\n    gridColumn: 1,\n    gridColumnEnd: 1,\n    gridColumnSpan: 1,\n    gridColumnStart: 1,\n    msGridRow: 1,\n    msGridRowSpan: 1,\n    msGridColumn: 1,\n    msGridColumnSpan: 1,\n    fontWeight: 1,\n    lineHeight: 1,\n    opacity: 1,\n    order: 1,\n    orphans: 1,\n    tabSize: 1,\n    widows: 1,\n    zIndex: 1,\n    zoom: 1,\n    WebkitLineClamp: 1,\n    // SVG-related properties\n    fillOpacity: 1,\n    floodOpacity: 1,\n    stopOpacity: 1,\n    strokeDasharray: 1,\n    strokeDashoffset: 1,\n    strokeMiterlimit: 1,\n    strokeOpacity: 1,\n    strokeWidth: 1\n};\nvar ILLEGAL_ESCAPE_SEQUENCE_ERROR$2 = \"You have illegal escape sequence in your template literal, most likely inside content's property value.\\nBecause you write your CSS inside a JavaScript string you actually have to do double escaping, so for example \\\"content: '\\\\00d7';\\\" should become \\\"content: '\\\\\\\\00d7';\\\".\\nYou can read more about this here:\\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences\";\nvar UNDEFINED_AS_OBJECT_KEY_ERROR$1 = \"You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).\";\nvar hyphenateRegex$1 = /[A-Z]|^ms/g;\nvar animationRegex$1 = /_EMO_([^_]+?)_([^]*?)_EMO_/g;\nvar isCustomProperty$1 = function isCustomProperty(property) {\n    return property.charCodeAt(1) === 45;\n};\nvar isProcessableValue$1 = function isProcessableValue(value) {\n    return value != null && typeof value !== \"boolean\";\n};\nvar processStyleName$1 = /* #__PURE__ */ memoize(function(styleName) {\n    return isCustomProperty$1(styleName) ? styleName : styleName.replace(hyphenateRegex$1, \"-$&\").toLowerCase();\n});\nvar processStyleValue$1 = function processStyleValue(key, value) {\n    switch(key){\n        case \"animation\":\n        case \"animationName\":\n            {\n                if (typeof value === \"string\") {\n                    return value.replace(animationRegex$1, function(match, p1, p2) {\n                        cursor$1 = {\n                            name: p1,\n                            styles: p2,\n                            next: cursor$1\n                        };\n                        return p1;\n                    });\n                }\n            }\n    }\n    if (unitlessKeys$1[key] !== 1 && !isCustomProperty$1(key) && typeof value === \"number\" && value !== 0) {\n        return value + \"px\";\n    }\n    return value;\n};\nif (true) {\n    var contentValuePattern$1 = /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\\(|(no-)?(open|close)-quote/;\n    var contentValues$1 = [\n        \"normal\",\n        \"none\",\n        \"initial\",\n        \"inherit\",\n        \"unset\"\n    ];\n    var oldProcessStyleValue$1 = processStyleValue$1;\n    var msPattern$1 = /^-ms-/;\n    var hyphenPattern$1 = /-(.)/g;\n    var hyphenatedCache$1 = {};\n    processStyleValue$1 = function processStyleValue(key, value) {\n        if (key === \"content\") {\n            if (typeof value !== \"string\" || contentValues$1.indexOf(value) === -1 && !contentValuePattern$1.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '\"' && value.charAt(0) !== \"'\")) {\n                throw new Error(\"You seem to be using a value for 'content' without quotes, try replacing it with `content: '\\\"\" + value + \"\\\"'`\");\n            }\n        }\n        var processed = oldProcessStyleValue$1(key, value);\n        if (processed !== \"\" && !isCustomProperty$1(key) && key.indexOf(\"-\") !== -1 && hyphenatedCache$1[key] === undefined) {\n            hyphenatedCache$1[key] = true;\n            console.error(\"Using kebab-case for css properties in objects is not supported. Did you mean \" + key.replace(msPattern$1, \"ms-\").replace(hyphenPattern$1, function(str, _char) {\n                return _char.toUpperCase();\n            }) + \"?\");\n        }\n        return processed;\n    };\n}\nvar noComponentSelectorMessage$1 = \"Component selectors can only be used in conjunction with \" + \"@emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware \" + \"compiler transform.\";\nfunction handleInterpolation$1(mergedProps, registered, interpolation) {\n    if (interpolation == null) {\n        return \"\";\n    }\n    if (interpolation.__emotion_styles !== undefined) {\n        if ( true && interpolation.toString() === \"NO_COMPONENT_SELECTOR\") {\n            throw new Error(noComponentSelectorMessage$1);\n        }\n        return interpolation;\n    }\n    switch(typeof interpolation){\n        case \"boolean\":\n            {\n                return \"\";\n            }\n        case \"object\":\n            {\n                if (interpolation.anim === 1) {\n                    cursor$1 = {\n                        name: interpolation.name,\n                        styles: interpolation.styles,\n                        next: cursor$1\n                    };\n                    return interpolation.name;\n                }\n                if (interpolation.styles !== undefined) {\n                    var next = interpolation.next;\n                    if (next !== undefined) {\n                        // not the most efficient thing ever but this is a pretty rare case\n                        // and there will be very few iterations of this generally\n                        while(next !== undefined){\n                            cursor$1 = {\n                                name: next.name,\n                                styles: next.styles,\n                                next: cursor$1\n                            };\n                            next = next.next;\n                        }\n                    }\n                    var styles = interpolation.styles + \";\";\n                    if ( true && interpolation.map !== undefined) {\n                        styles += interpolation.map;\n                    }\n                    return styles;\n                }\n                return createStringFromObject$1(mergedProps, registered, interpolation);\n            }\n        case \"function\":\n            {\n                if (mergedProps !== undefined) {\n                    var previousCursor = cursor$1;\n                    var result = interpolation(mergedProps);\n                    cursor$1 = previousCursor;\n                    return handleInterpolation$1(mergedProps, registered, result);\n                } else if (true) {\n                    console.error(\"Functions that are interpolated in css calls will be stringified.\\n\" + \"If you want to have a css call based on props, create a function that returns a css call like this\\n\" + \"let dynamicStyle = (props) => css`color: ${props.color}`\\n\" + \"It can be called directly with props or interpolated in a styled call like this\\n\" + \"let SomeComponent = styled('div')`${dynamicStyle}`\");\n                }\n                break;\n            }\n        case \"string\":\n            if (true) {\n                var matched = [];\n                var replaced = interpolation.replace(animationRegex$1, function(match, p1, p2) {\n                    var fakeVarName = \"animation\" + matched.length;\n                    matched.push(\"const \" + fakeVarName + \" = keyframes`\" + p2.replace(/^@keyframes animation-\\w+/, \"\") + \"`\");\n                    return \"${\" + fakeVarName + \"}\";\n                });\n                if (matched.length) {\n                    console.error(\"`keyframes` output got interpolated into plain string, please wrap it with `css`.\\n\\n\" + \"Instead of doing this:\\n\\n\" + [].concat(matched, [\n                        \"`\" + replaced + \"`\"\n                    ]).join(\"\\n\") + \"\\n\\nYou should wrap it with `css` like this:\\n\\n\" + (\"css`\" + replaced + \"`\"));\n                }\n            }\n            break;\n    } // finalize string values (regular strings and functions interpolated into css calls)\n    if (registered == null) {\n        return interpolation;\n    }\n    var cached = registered[interpolation];\n    return cached !== undefined ? cached : interpolation;\n}\nfunction createStringFromObject$1(mergedProps, registered, obj) {\n    var string = \"\";\n    if (Array.isArray(obj)) {\n        for(var i = 0; i < obj.length; i++){\n            string += handleInterpolation$1(mergedProps, registered, obj[i]) + \";\";\n        }\n    } else {\n        for(var _key in obj){\n            var value = obj[_key];\n            if (typeof value !== \"object\") {\n                if (registered != null && registered[value] !== undefined) {\n                    string += _key + \"{\" + registered[value] + \"}\";\n                } else if (isProcessableValue$1(value)) {\n                    string += processStyleName$1(_key) + \":\" + processStyleValue$1(_key, value) + \";\";\n                }\n            } else {\n                if (_key === \"NO_COMPONENT_SELECTOR\" && \"development\" !== \"production\") {\n                    throw new Error(noComponentSelectorMessage$1);\n                }\n                if (Array.isArray(value) && typeof value[0] === \"string\" && (registered == null || registered[value[0]] === undefined)) {\n                    for(var _i = 0; _i < value.length; _i++){\n                        if (isProcessableValue$1(value[_i])) {\n                            string += processStyleName$1(_key) + \":\" + processStyleValue$1(_key, value[_i]) + \";\";\n                        }\n                    }\n                } else {\n                    var interpolated = handleInterpolation$1(mergedProps, registered, value);\n                    switch(_key){\n                        case \"animation\":\n                        case \"animationName\":\n                            {\n                                string += processStyleName$1(_key) + \":\" + interpolated + \";\";\n                                break;\n                            }\n                        default:\n                            {\n                                if ( true && _key === \"undefined\") {\n                                    console.error(UNDEFINED_AS_OBJECT_KEY_ERROR$1);\n                                }\n                                string += _key + \"{\" + interpolated + \"}\";\n                            }\n                    }\n                }\n            }\n        }\n    }\n    return string;\n}\nvar labelPattern$1 = /label:\\s*([^\\s;\\n{]+)\\s*(;|$)/g;\nvar sourceMapPattern$1;\nif (true) {\n    sourceMapPattern$1 = /\\/\\*#\\ssourceMappingURL=data:application\\/json;\\S+\\s+\\*\\//g;\n} // this is the cursor for keyframes\n// keyframes are stored on the SerializedStyles object as a linked list\nvar cursor$1;\nvar serializeStyles$1 = function serializeStyles(args, registered, mergedProps) {\n    if (args.length === 1 && typeof args[0] === \"object\" && args[0] !== null && args[0].styles !== undefined) {\n        return args[0];\n    }\n    var stringMode = true;\n    var styles = \"\";\n    cursor$1 = undefined;\n    var strings = args[0];\n    if (strings == null || strings.raw === undefined) {\n        stringMode = false;\n        styles += handleInterpolation$1(mergedProps, registered, strings);\n    } else {\n        if ( true && strings[0] === undefined) {\n            console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR$2);\n        }\n        styles += strings[0];\n    } // we start at 1 since we've already handled the first arg\n    for(var i = 1; i < args.length; i++){\n        styles += handleInterpolation$1(mergedProps, registered, args[i]);\n        if (stringMode) {\n            if ( true && strings[i] === undefined) {\n                console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR$2);\n            }\n            styles += strings[i];\n        }\n    }\n    var sourceMap;\n    if (true) {\n        styles = styles.replace(sourceMapPattern$1, function(match) {\n            sourceMap = match;\n            return \"\";\n        });\n    } // using a global regex with .exec is stateful so lastIndex has to be reset each time\n    labelPattern$1.lastIndex = 0;\n    var identifierName = \"\";\n    var match; // https://esbench.com/bench/5b809c2cf2949800a0f61fb5\n    while((match = labelPattern$1.exec(styles)) !== null){\n        identifierName += \"-\" + // $FlowFixMe we know it's not null\n        match[1];\n    }\n    var name = murmur2$1(styles) + identifierName;\n    if (true) {\n        // $FlowFixMe SerializedStyles type doesn't have toString property (and we don't want to add it)\n        return {\n            name: name,\n            styles: styles,\n            map: sourceMap,\n            next: cursor$1,\n            toString: function toString() {\n                return \"You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).\";\n            }\n        };\n    }\n    return {\n        name: name,\n        styles: styles,\n        next: cursor$1\n    };\n};\nvar isBrowser$3 = typeof document !== \"undefined\";\nvar syncFallback = function syncFallback(create) {\n    return create();\n};\nvar useInsertionEffect = react__WEBPACK_IMPORTED_MODULE_0__[\"useInsertion\" + \"Effect\"] ? react__WEBPACK_IMPORTED_MODULE_0__[\"useInsertion\" + \"Effect\"] : false;\nvar useInsertionEffectAlwaysWithSyncFallback = !isBrowser$3 ? syncFallback : useInsertionEffect || syncFallback;\nvar isBrowser$2 = typeof document !== \"undefined\";\nvar hasOwnProperty = {}.hasOwnProperty;\nvar EmotionCacheContext = /* #__PURE__ */ /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(// because this module is primarily intended for the browser and node\n// but it's also required in react native and similar environments sometimes\n// and we could have a special build just for that\n// but this is much easier and the native packages\n// might use a different theme context in the future anyway\ntypeof HTMLElement !== \"undefined\" ? /* #__PURE__ */ createCache({\n    key: \"css\"\n}) : null);\nif (true) {\n    EmotionCacheContext.displayName = \"EmotionCacheContext\";\n}\nEmotionCacheContext.Provider;\nvar withEmotionCache = function withEmotionCache(func) {\n    var _s = $RefreshSig$();\n    // $FlowFixMe\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(_s(function(props, ref) {\n        _s();\n        // the cache will never be null in the browser\n        var cache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(EmotionCacheContext);\n        return func(props, cache, ref);\n    }, \"fZR2dUNhdavhp/yb1XDPaBFabgk=\"));\n};\nif (!isBrowser$2) {\n    withEmotionCache = function withEmotionCache(func) {\n        var _s = $RefreshSig$();\n        return _s(function(props) {\n            _s();\n            var cache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(EmotionCacheContext);\n            if (cache === null) {\n                // yes, we're potentially creating this on every render\n                // it doesn't actually matter though since it's only on the server\n                // so there will only every be a single render\n                // that could change in the future because of suspense and etc. but for now,\n                // this works and i don't want to optimise for a future thing that we aren't sure about\n                cache = createCache({\n                    key: \"css\"\n                });\n                return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(EmotionCacheContext.Provider, {\n                    value: cache\n                }, func(props, cache));\n            } else {\n                return func(props, cache);\n            }\n        }, \"fZR2dUNhdavhp/yb1XDPaBFabgk=\");\n    };\n}\nvar ThemeContext = /* #__PURE__ */ /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\nif (true) {\n    ThemeContext.displayName = \"EmotionThemeContext\";\n}\nvar typePropName = \"__EMOTION_TYPE_PLEASE_DO_NOT_USE__\";\nvar labelPropName = \"__EMOTION_LABEL_PLEASE_DO_NOT_USE__\";\nvar Insertion$1 = function Insertion(_ref) {\n    _s();\n    var cache = _ref.cache, serialized = _ref.serialized, isStringTag = _ref.isStringTag;\n    registerStyles$1(cache, serialized, isStringTag);\n    var rules = useInsertionEffectAlwaysWithSyncFallback(function() {\n        return insertStyles$1(cache, serialized, isStringTag);\n    });\n    if (!isBrowser$2 && rules !== undefined) {\n        var _ref2;\n        var serializedNames = serialized.name;\n        var next = serialized.next;\n        while(next !== undefined){\n            serializedNames += \" \" + next.name;\n            next = next.next;\n        }\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"style\", (_ref2 = {}, _ref2[\"data-emotion\"] = cache.key + \" \" + serializedNames, _ref2.dangerouslySetInnerHTML = {\n            __html: rules\n        }, _ref2.nonce = cache.sheet.nonce, _ref2));\n    }\n    return null;\n};\n_s(Insertion$1, \"XesGnel3nro7qu/fCWiNCAu7DJM=\", false, function() {\n    return [\n        useInsertionEffectAlwaysWithSyncFallback\n    ];\n});\n_c = Insertion$1;\nvar Emotion = /* #__PURE__ */ _s1(withEmotionCache(_c1 = _s1(function(props, cache, ref) {\n    _s1();\n    var cssProp = props.css; // so that using `css` from `emotion` and passing the result to the css prop works\n    // not passing the registered cache to serializeStyles because it would\n    // make certain babel optimisations not possible\n    if (typeof cssProp === \"string\" && cache.registered[cssProp] !== undefined) {\n        cssProp = cache.registered[cssProp];\n    }\n    var WrappedComponent = props[typePropName];\n    var registeredStyles = [\n        cssProp\n    ];\n    var className = \"\";\n    if (typeof props.className === \"string\") {\n        className = getRegisteredStyles$1(cache.registered, registeredStyles, props.className);\n    } else if (props.className != null) {\n        className = props.className + \" \";\n    }\n    var serialized = serializeStyles$1(registeredStyles, undefined, (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ThemeContext));\n    if ( true && serialized.name.indexOf(\"-\") === -1) {\n        var labelFromStack = props[labelPropName];\n        if (labelFromStack) {\n            serialized = serializeStyles$1([\n                serialized,\n                \"label:\" + labelFromStack + \";\"\n            ]);\n        }\n    }\n    className += cache.key + \"-\" + serialized.name;\n    var newProps = {};\n    for(var key in props){\n        if (hasOwnProperty.call(props, key) && key !== \"css\" && key !== typePropName && ( false || key !== labelPropName)) {\n            newProps[key] = props[key];\n        }\n    }\n    newProps.ref = ref;\n    newProps.className = className;\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Insertion$1, {\n        cache: cache,\n        serialized: serialized,\n        isStringTag: typeof WrappedComponent === \"string\"\n    }), /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(WrappedComponent, newProps));\n}, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\")), \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\n_c2 = Emotion;\nif (true) {\n    Emotion.displayName = \"EmotionCssPropInternal\";\n}\nvar isBrowser$1 = typeof document !== \"undefined\";\nfunction getRegisteredStyles(registered, registeredStyles, classNames) {\n    var rawClassName = \"\";\n    classNames.split(\" \").forEach(function(className) {\n        if (registered[className] !== undefined) {\n            registeredStyles.push(registered[className] + \";\");\n        } else {\n            rawClassName += className + \" \";\n        }\n    });\n    return rawClassName;\n}\nvar registerStyles = function registerStyles(cache, serialized, isStringTag) {\n    var className = cache.key + \"-\" + serialized.name;\n    if (// class name could be used further down\n    // the tree but if it's a string tag, we know it won't\n    // so we don't have to add it to registered cache.\n    // this improves memory usage since we can avoid storing the whole style string\n    (isStringTag === false || // we need to always store it if we're in compat mode and\n    // in node since emotion-server relies on whether a style is in\n    // the registered cache to know whether a style is global or not\n    // also, note that this check will be dead code eliminated in the browser\n    isBrowser$1 === false && cache.compat !== undefined) && cache.registered[className] === undefined) {\n        cache.registered[className] = serialized.styles;\n    }\n};\nvar insertStyles = function insertStyles(cache, serialized, isStringTag) {\n    registerStyles(cache, serialized, isStringTag);\n    var className = cache.key + \"-\" + serialized.name;\n    if (cache.inserted[serialized.name] === undefined) {\n        var stylesForSSR = \"\";\n        var current = serialized;\n        do {\n            var maybeStyles = cache.insert(serialized === current ? \".\" + className : \"\", current, cache.sheet, true);\n            if (!isBrowser$1 && maybeStyles !== undefined) {\n                stylesForSSR += maybeStyles;\n            }\n            current = current.next;\n        }while (current !== undefined);\n        if (!isBrowser$1 && stylesForSSR.length !== 0) {\n            return stylesForSSR;\n        }\n    }\n};\n/* eslint-disable */ // Inspired by https://github.com/garycourt/murmurhash-js\n// Ported from https://github.com/aappleby/smhasher/blob/61a0530f28277f2e850bfc39600ce61d02b518de/src/MurmurHash2.cpp#L37-L86\nfunction murmur2(str) {\n    // 'm' and 'r' are mixing constants generated offline.\n    // They're not really 'magic', they just happen to work well.\n    // const m = 0x5bd1e995;\n    // const r = 24;\n    // Initialize the hash\n    var h = 0; // Mix 4 bytes at a time into the hash\n    var k, i = 0, len = str.length;\n    for(; len >= 4; ++i, len -= 4){\n        k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;\n        k = /* Math.imul(k, m): */ (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16);\n        k ^= /* k >>> r: */ k >>> 24;\n        h = /* Math.imul(k, m): */ (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16) ^ /* Math.imul(h, m): */ (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);\n    } // Handle the last few bytes of the input array\n    switch(len){\n        case 3:\n            h ^= (str.charCodeAt(i + 2) & 0xff) << 16;\n        case 2:\n            h ^= (str.charCodeAt(i + 1) & 0xff) << 8;\n        case 1:\n            h ^= str.charCodeAt(i) & 0xff;\n            h = /* Math.imul(h, m): */ (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);\n    } // Do a few final mixes of the hash to ensure the last few\n    // bytes are well-incorporated.\n    h ^= h >>> 13;\n    h = /* Math.imul(h, m): */ (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);\n    return ((h ^ h >>> 15) >>> 0).toString(36);\n}\nvar unitlessKeys = {\n    animationIterationCount: 1,\n    borderImageOutset: 1,\n    borderImageSlice: 1,\n    borderImageWidth: 1,\n    boxFlex: 1,\n    boxFlexGroup: 1,\n    boxOrdinalGroup: 1,\n    columnCount: 1,\n    columns: 1,\n    flex: 1,\n    flexGrow: 1,\n    flexPositive: 1,\n    flexShrink: 1,\n    flexNegative: 1,\n    flexOrder: 1,\n    gridRow: 1,\n    gridRowEnd: 1,\n    gridRowSpan: 1,\n    gridRowStart: 1,\n    gridColumn: 1,\n    gridColumnEnd: 1,\n    gridColumnSpan: 1,\n    gridColumnStart: 1,\n    msGridRow: 1,\n    msGridRowSpan: 1,\n    msGridColumn: 1,\n    msGridColumnSpan: 1,\n    fontWeight: 1,\n    lineHeight: 1,\n    opacity: 1,\n    order: 1,\n    orphans: 1,\n    tabSize: 1,\n    widows: 1,\n    zIndex: 1,\n    zoom: 1,\n    WebkitLineClamp: 1,\n    // SVG-related properties\n    fillOpacity: 1,\n    floodOpacity: 1,\n    stopOpacity: 1,\n    strokeDasharray: 1,\n    strokeDashoffset: 1,\n    strokeMiterlimit: 1,\n    strokeOpacity: 1,\n    strokeWidth: 1\n};\nvar ILLEGAL_ESCAPE_SEQUENCE_ERROR$1 = \"You have illegal escape sequence in your template literal, most likely inside content's property value.\\nBecause you write your CSS inside a JavaScript string you actually have to do double escaping, so for example \\\"content: '\\\\00d7';\\\" should become \\\"content: '\\\\\\\\00d7';\\\".\\nYou can read more about this here:\\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences\";\nvar UNDEFINED_AS_OBJECT_KEY_ERROR = \"You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).\";\nvar hyphenateRegex = /[A-Z]|^ms/g;\nvar animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;\nvar isCustomProperty = function isCustomProperty(property) {\n    return property.charCodeAt(1) === 45;\n};\nvar isProcessableValue = function isProcessableValue(value) {\n    return value != null && typeof value !== \"boolean\";\n};\nvar processStyleName = /* #__PURE__ */ memoize(function(styleName) {\n    return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, \"-$&\").toLowerCase();\n});\nvar processStyleValue = function processStyleValue(key, value) {\n    switch(key){\n        case \"animation\":\n        case \"animationName\":\n            {\n                if (typeof value === \"string\") {\n                    return value.replace(animationRegex, function(match, p1, p2) {\n                        cursor = {\n                            name: p1,\n                            styles: p2,\n                            next: cursor\n                        };\n                        return p1;\n                    });\n                }\n            }\n    }\n    if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === \"number\" && value !== 0) {\n        return value + \"px\";\n    }\n    return value;\n};\nif (true) {\n    var contentValuePattern = /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\\(|(no-)?(open|close)-quote/;\n    var contentValues = [\n        \"normal\",\n        \"none\",\n        \"initial\",\n        \"inherit\",\n        \"unset\"\n    ];\n    var oldProcessStyleValue = processStyleValue;\n    var msPattern = /^-ms-/;\n    var hyphenPattern = /-(.)/g;\n    var hyphenatedCache = {};\n    processStyleValue = function processStyleValue(key, value) {\n        if (key === \"content\") {\n            if (typeof value !== \"string\" || contentValues.indexOf(value) === -1 && !contentValuePattern.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '\"' && value.charAt(0) !== \"'\")) {\n                throw new Error(\"You seem to be using a value for 'content' without quotes, try replacing it with `content: '\\\"\" + value + \"\\\"'`\");\n            }\n        }\n        var processed = oldProcessStyleValue(key, value);\n        if (processed !== \"\" && !isCustomProperty(key) && key.indexOf(\"-\") !== -1 && hyphenatedCache[key] === undefined) {\n            hyphenatedCache[key] = true;\n            console.error(\"Using kebab-case for css properties in objects is not supported. Did you mean \" + key.replace(msPattern, \"ms-\").replace(hyphenPattern, function(str, _char) {\n                return _char.toUpperCase();\n            }) + \"?\");\n        }\n        return processed;\n    };\n}\nvar noComponentSelectorMessage = \"Component selectors can only be used in conjunction with \" + \"@emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware \" + \"compiler transform.\";\nfunction handleInterpolation(mergedProps, registered, interpolation) {\n    if (interpolation == null) {\n        return \"\";\n    }\n    if (interpolation.__emotion_styles !== undefined) {\n        if ( true && interpolation.toString() === \"NO_COMPONENT_SELECTOR\") {\n            throw new Error(noComponentSelectorMessage);\n        }\n        return interpolation;\n    }\n    switch(typeof interpolation){\n        case \"boolean\":\n            {\n                return \"\";\n            }\n        case \"object\":\n            {\n                if (interpolation.anim === 1) {\n                    cursor = {\n                        name: interpolation.name,\n                        styles: interpolation.styles,\n                        next: cursor\n                    };\n                    return interpolation.name;\n                }\n                if (interpolation.styles !== undefined) {\n                    var next = interpolation.next;\n                    if (next !== undefined) {\n                        // not the most efficient thing ever but this is a pretty rare case\n                        // and there will be very few iterations of this generally\n                        while(next !== undefined){\n                            cursor = {\n                                name: next.name,\n                                styles: next.styles,\n                                next: cursor\n                            };\n                            next = next.next;\n                        }\n                    }\n                    var styles = interpolation.styles + \";\";\n                    if ( true && interpolation.map !== undefined) {\n                        styles += interpolation.map;\n                    }\n                    return styles;\n                }\n                return createStringFromObject(mergedProps, registered, interpolation);\n            }\n        case \"function\":\n            {\n                if (mergedProps !== undefined) {\n                    var previousCursor = cursor;\n                    var result = interpolation(mergedProps);\n                    cursor = previousCursor;\n                    return handleInterpolation(mergedProps, registered, result);\n                } else if (true) {\n                    console.error(\"Functions that are interpolated in css calls will be stringified.\\n\" + \"If you want to have a css call based on props, create a function that returns a css call like this\\n\" + \"let dynamicStyle = (props) => css`color: ${props.color}`\\n\" + \"It can be called directly with props or interpolated in a styled call like this\\n\" + \"let SomeComponent = styled('div')`${dynamicStyle}`\");\n                }\n                break;\n            }\n        case \"string\":\n            if (true) {\n                var matched = [];\n                var replaced = interpolation.replace(animationRegex, function(match, p1, p2) {\n                    var fakeVarName = \"animation\" + matched.length;\n                    matched.push(\"const \" + fakeVarName + \" = keyframes`\" + p2.replace(/^@keyframes animation-\\w+/, \"\") + \"`\");\n                    return \"${\" + fakeVarName + \"}\";\n                });\n                if (matched.length) {\n                    console.error(\"`keyframes` output got interpolated into plain string, please wrap it with `css`.\\n\\n\" + \"Instead of doing this:\\n\\n\" + [].concat(matched, [\n                        \"`\" + replaced + \"`\"\n                    ]).join(\"\\n\") + \"\\n\\nYou should wrap it with `css` like this:\\n\\n\" + (\"css`\" + replaced + \"`\"));\n                }\n            }\n            break;\n    } // finalize string values (regular strings and functions interpolated into css calls)\n    if (registered == null) {\n        return interpolation;\n    }\n    var cached = registered[interpolation];\n    return cached !== undefined ? cached : interpolation;\n}\nfunction createStringFromObject(mergedProps, registered, obj) {\n    var string = \"\";\n    if (Array.isArray(obj)) {\n        for(var i = 0; i < obj.length; i++){\n            string += handleInterpolation(mergedProps, registered, obj[i]) + \";\";\n        }\n    } else {\n        for(var _key in obj){\n            var value = obj[_key];\n            if (typeof value !== \"object\") {\n                if (registered != null && registered[value] !== undefined) {\n                    string += _key + \"{\" + registered[value] + \"}\";\n                } else if (isProcessableValue(value)) {\n                    string += processStyleName(_key) + \":\" + processStyleValue(_key, value) + \";\";\n                }\n            } else {\n                if (_key === \"NO_COMPONENT_SELECTOR\" && \"development\" !== \"production\") {\n                    throw new Error(noComponentSelectorMessage);\n                }\n                if (Array.isArray(value) && typeof value[0] === \"string\" && (registered == null || registered[value[0]] === undefined)) {\n                    for(var _i = 0; _i < value.length; _i++){\n                        if (isProcessableValue(value[_i])) {\n                            string += processStyleName(_key) + \":\" + processStyleValue(_key, value[_i]) + \";\";\n                        }\n                    }\n                } else {\n                    var interpolated = handleInterpolation(mergedProps, registered, value);\n                    switch(_key){\n                        case \"animation\":\n                        case \"animationName\":\n                            {\n                                string += processStyleName(_key) + \":\" + interpolated + \";\";\n                                break;\n                            }\n                        default:\n                            {\n                                if ( true && _key === \"undefined\") {\n                                    console.error(UNDEFINED_AS_OBJECT_KEY_ERROR);\n                                }\n                                string += _key + \"{\" + interpolated + \"}\";\n                            }\n                    }\n                }\n            }\n        }\n    }\n    return string;\n}\nvar labelPattern = /label:\\s*([^\\s;\\n{]+)\\s*(;|$)/g;\nvar sourceMapPattern;\nif (true) {\n    sourceMapPattern = /\\/\\*#\\ssourceMappingURL=data:application\\/json;\\S+\\s+\\*\\//g;\n} // this is the cursor for keyframes\n// keyframes are stored on the SerializedStyles object as a linked list\nvar cursor;\nvar serializeStyles = function serializeStyles(args, registered, mergedProps) {\n    if (args.length === 1 && typeof args[0] === \"object\" && args[0] !== null && args[0].styles !== undefined) {\n        return args[0];\n    }\n    var stringMode = true;\n    var styles = \"\";\n    cursor = undefined;\n    var strings = args[0];\n    if (strings == null || strings.raw === undefined) {\n        stringMode = false;\n        styles += handleInterpolation(mergedProps, registered, strings);\n    } else {\n        if ( true && strings[0] === undefined) {\n            console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR$1);\n        }\n        styles += strings[0];\n    } // we start at 1 since we've already handled the first arg\n    for(var i = 1; i < args.length; i++){\n        styles += handleInterpolation(mergedProps, registered, args[i]);\n        if (stringMode) {\n            if ( true && strings[i] === undefined) {\n                console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR$1);\n            }\n            styles += strings[i];\n        }\n    }\n    var sourceMap;\n    if (true) {\n        styles = styles.replace(sourceMapPattern, function(match) {\n            sourceMap = match;\n            return \"\";\n        });\n    } // using a global regex with .exec is stateful so lastIndex has to be reset each time\n    labelPattern.lastIndex = 0;\n    var identifierName = \"\";\n    var match; // https://esbench.com/bench/5b809c2cf2949800a0f61fb5\n    while((match = labelPattern.exec(styles)) !== null){\n        identifierName += \"-\" + // $FlowFixMe we know it's not null\n        match[1];\n    }\n    var name = murmur2(styles) + identifierName;\n    if (true) {\n        // $FlowFixMe SerializedStyles type doesn't have toString property (and we don't want to add it)\n        return {\n            name: name,\n            styles: styles,\n            map: sourceMap,\n            next: cursor,\n            toString: function toString() {\n                return \"You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).\";\n            }\n        };\n    }\n    return {\n        name: name,\n        styles: styles,\n        next: cursor\n    };\n};\nvar testOmitPropsOnStringTag = isPropValid;\nvar testOmitPropsOnComponent = function testOmitPropsOnComponent(key) {\n    return key !== \"theme\";\n};\nvar getDefaultShouldForwardProp = function getDefaultShouldForwardProp(tag) {\n    return typeof tag === \"string\" && // 96 is one less than the char code\n    // for \"a\" so this is checking that\n    // it's a lowercase character\n    tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;\n};\nvar composeShouldForwardProps = function composeShouldForwardProps(tag, options, isReal) {\n    var shouldForwardProp;\n    if (options) {\n        var optionsShouldForwardProp = options.shouldForwardProp;\n        shouldForwardProp = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {\n            return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);\n        } : optionsShouldForwardProp;\n    }\n    if (typeof shouldForwardProp !== \"function\" && isReal) {\n        shouldForwardProp = tag.__emotion_forwardProp;\n    }\n    return shouldForwardProp;\n};\nvar ILLEGAL_ESCAPE_SEQUENCE_ERROR = \"You have illegal escape sequence in your template literal, most likely inside content's property value.\\nBecause you write your CSS inside a JavaScript string you actually have to do double escaping, so for example \\\"content: '\\\\00d7';\\\" should become \\\"content: '\\\\\\\\00d7';\\\".\\nYou can read more about this here:\\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences\";\nvar isBrowser = typeof document !== \"undefined\";\nvar Insertion = function Insertion(_ref) {\n    _s2();\n    var cache = _ref.cache, serialized = _ref.serialized, isStringTag = _ref.isStringTag;\n    registerStyles(cache, serialized, isStringTag);\n    var rules = useInsertionEffectAlwaysWithSyncFallback(function() {\n        return insertStyles(cache, serialized, isStringTag);\n    });\n    if (!isBrowser && rules !== undefined) {\n        var _ref2;\n        var serializedNames = serialized.name;\n        var next = serialized.next;\n        while(next !== undefined){\n            serializedNames += \" \" + next.name;\n            next = next.next;\n        }\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"style\", (_ref2 = {}, _ref2[\"data-emotion\"] = cache.key + \" \" + serializedNames, _ref2.dangerouslySetInnerHTML = {\n            __html: rules\n        }, _ref2.nonce = cache.sheet.nonce, _ref2));\n    }\n    return null;\n};\n_s2(Insertion, \"XesGnel3nro7qu/fCWiNCAu7DJM=\", false, function() {\n    return [\n        useInsertionEffectAlwaysWithSyncFallback\n    ];\n});\n_c3 = Insertion;\nvar createStyled = function createStyled(tag, options) {\n    if (true) {\n        if (tag === undefined) {\n            throw new Error(\"You are trying to create a styled element with an undefined component.\\nYou may have forgotten to import it.\");\n        }\n    }\n    var isReal = tag.__emotion_real === tag;\n    var baseTag = isReal && tag.__emotion_base || tag;\n    var identifierName;\n    var targetClassName;\n    if (options !== undefined) {\n        identifierName = options.label;\n        targetClassName = options.target;\n    }\n    var shouldForwardProp = composeShouldForwardProps(tag, options, isReal);\n    var defaultShouldForwardProp = shouldForwardProp || getDefaultShouldForwardProp(baseTag);\n    var shouldUseAs = !defaultShouldForwardProp(\"as\");\n    return function() {\n        var args = arguments;\n        var styles = isReal && tag.__emotion_styles !== undefined ? tag.__emotion_styles.slice(0) : [];\n        if (identifierName !== undefined) {\n            styles.push(\"label:\" + identifierName + \";\");\n        }\n        if (args[0] == null || args[0].raw === undefined) {\n            styles.push.apply(styles, args);\n        } else {\n            if ( true && args[0][0] === undefined) {\n                console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);\n            }\n            styles.push(args[0][0]);\n            var len = args.length;\n            var i = 1;\n            for(; i < len; i++){\n                if ( true && args[0][i] === undefined) {\n                    console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);\n                }\n                styles.push(args[i], args[0][i]);\n            }\n        } // $FlowFixMe: we need to cast StatelessFunctionalComponent to our PrivateStyledComponent class\n        var Styled = withEmotionCache(function(props, cache, ref) {\n            var FinalTag = shouldUseAs && props.as || baseTag;\n            var className = \"\";\n            var classInterpolations = [];\n            var mergedProps = props;\n            if (props.theme == null) {\n                mergedProps = {};\n                for(var key in props){\n                    mergedProps[key] = props[key];\n                }\n                mergedProps.theme = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ThemeContext);\n            }\n            if (typeof props.className === \"string\") {\n                className = getRegisteredStyles(cache.registered, classInterpolations, props.className);\n            } else if (props.className != null) {\n                className = props.className + \" \";\n            }\n            var serialized = serializeStyles(styles.concat(classInterpolations), cache.registered, mergedProps);\n            className += cache.key + \"-\" + serialized.name;\n            if (targetClassName !== undefined) {\n                className += \" \" + targetClassName;\n            }\n            var finalShouldForwardProp = shouldUseAs && shouldForwardProp === undefined ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;\n            var newProps = {};\n            for(var _key in props){\n                if (shouldUseAs && _key === \"as\") continue;\n                if (finalShouldForwardProp(_key)) {\n                    newProps[_key] = props[_key];\n                }\n            }\n            newProps.className = className;\n            newProps.ref = ref;\n            return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Insertion, {\n                cache: cache,\n                serialized: serialized,\n                isStringTag: typeof FinalTag === \"string\"\n            }), /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(FinalTag, newProps));\n        });\n        Styled.displayName = identifierName !== undefined ? identifierName : \"Styled(\" + (typeof baseTag === \"string\" ? baseTag : baseTag.displayName || baseTag.name || \"Component\") + \")\";\n        Styled.defaultProps = tag.defaultProps;\n        Styled.__emotion_real = Styled;\n        Styled.__emotion_base = baseTag;\n        Styled.__emotion_styles = styles;\n        Styled.__emotion_forwardProp = shouldForwardProp;\n        Object.defineProperty(Styled, \"toString\", {\n            value: function value() {\n                if (targetClassName === undefined && \"development\" !== \"production\") {\n                    return \"NO_COMPONENT_SELECTOR\";\n                } // $FlowFixMe: coerce undefined to string\n                return \".\" + targetClassName;\n            }\n        });\n        Styled.withComponent = function(nextTag, nextOptions) {\n            return createStyled(nextTag, _extends({}, options, nextOptions, {\n                shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)\n            })).apply(void 0, styles);\n        };\n        return Styled;\n    };\n};\nvar tags = [\n    \"a\",\n    \"abbr\",\n    \"address\",\n    \"area\",\n    \"article\",\n    \"aside\",\n    \"audio\",\n    \"b\",\n    \"base\",\n    \"bdi\",\n    \"bdo\",\n    \"big\",\n    \"blockquote\",\n    \"body\",\n    \"br\",\n    \"button\",\n    \"canvas\",\n    \"caption\",\n    \"cite\",\n    \"code\",\n    \"col\",\n    \"colgroup\",\n    \"data\",\n    \"datalist\",\n    \"dd\",\n    \"del\",\n    \"details\",\n    \"dfn\",\n    \"dialog\",\n    \"div\",\n    \"dl\",\n    \"dt\",\n    \"em\",\n    \"embed\",\n    \"fieldset\",\n    \"figcaption\",\n    \"figure\",\n    \"footer\",\n    \"form\",\n    \"h1\",\n    \"h2\",\n    \"h3\",\n    \"h4\",\n    \"h5\",\n    \"h6\",\n    \"head\",\n    \"header\",\n    \"hgroup\",\n    \"hr\",\n    \"html\",\n    \"i\",\n    \"iframe\",\n    \"img\",\n    \"input\",\n    \"ins\",\n    \"kbd\",\n    \"keygen\",\n    \"label\",\n    \"legend\",\n    \"li\",\n    \"link\",\n    \"main\",\n    \"map\",\n    \"mark\",\n    \"marquee\",\n    \"menu\",\n    \"menuitem\",\n    \"meta\",\n    \"meter\",\n    \"nav\",\n    \"noscript\",\n    \"object\",\n    \"ol\",\n    \"optgroup\",\n    \"option\",\n    \"output\",\n    \"p\",\n    \"param\",\n    \"picture\",\n    \"pre\",\n    \"progress\",\n    \"q\",\n    \"rp\",\n    \"rt\",\n    \"ruby\",\n    \"s\",\n    \"samp\",\n    \"script\",\n    \"section\",\n    \"select\",\n    \"small\",\n    \"source\",\n    \"span\",\n    \"strong\",\n    \"style\",\n    \"sub\",\n    \"summary\",\n    \"sup\",\n    \"table\",\n    \"tbody\",\n    \"td\",\n    \"textarea\",\n    \"tfoot\",\n    \"th\",\n    \"thead\",\n    \"time\",\n    \"title\",\n    \"tr\",\n    \"track\",\n    \"u\",\n    \"ul\",\n    \"var\",\n    \"video\",\n    \"wbr\",\n    \"circle\",\n    \"clipPath\",\n    \"defs\",\n    \"ellipse\",\n    \"foreignObject\",\n    \"g\",\n    \"image\",\n    \"line\",\n    \"linearGradient\",\n    \"mask\",\n    \"path\",\n    \"pattern\",\n    \"polygon\",\n    \"polyline\",\n    \"radialGradient\",\n    \"rect\",\n    \"stop\",\n    \"svg\",\n    \"text\",\n    \"tspan\"\n];\nvar newStyled = createStyled.bind();\ntags.forEach(function(tagName) {\n    // $FlowFixMe: we can ignore this because its exposed type is defined by the CreateStyled type\n    newStyled[tagName] = newStyled(tagName);\n});\nvar classnames$1 = {\n    exports: {}\n};\n/*!\n\tCopyright (c) 2018 Jed Watson.\n\tLicensed under the MIT License (MIT), see\n\thttp://jedwatson.github.io/classnames\n*/ (function(module) {\n    /* global define */ (function() {\n        var hasOwn = {}.hasOwnProperty;\n        function classNames() {\n            var classes = [];\n            for(var i = 0; i < arguments.length; i++){\n                var arg = arguments[i];\n                if (!arg) continue;\n                var argType = typeof arg;\n                if (argType === \"string\" || argType === \"number\") {\n                    classes.push(arg);\n                } else if (Array.isArray(arg)) {\n                    if (arg.length) {\n                        var inner = classNames.apply(null, arg);\n                        if (inner) {\n                            classes.push(inner);\n                        }\n                    }\n                } else if (argType === \"object\") {\n                    if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes(\"[native code]\")) {\n                        classes.push(arg.toString());\n                        continue;\n                    }\n                    for(var key in arg){\n                        if (hasOwn.call(arg, key) && arg[key]) {\n                            classes.push(key);\n                        }\n                    }\n                }\n            }\n            return classes.join(\" \");\n        }\n        if (module.exports) {\n            classNames.default = classNames;\n            module.exports = classNames;\n        } else {\n            window.classNames = classNames;\n        }\n    })();\n})(classnames$1);\nvar classnames = classnames$1.exports;\nvar LegacySidebarContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(undefined);\nvar SidebarProvider = function(_a) {\n    _s3();\n    var children = _a.children;\n    var _b = react__WEBPACK_IMPORTED_MODULE_0___default().useState({\n        collapsed: false,\n        toggled: false,\n        broken: false,\n        rtl: false,\n        transitionDuration: 300\n    }), sidebarState = _b[0], setSidebarState = _b[1];\n    var updateSidebarState = react__WEBPACK_IMPORTED_MODULE_0___default().useCallback(function(values) {\n        setSidebarState(function(prevState) {\n            return __assign(__assign({}, prevState), values);\n        });\n    }, []);\n    var updateCollapseState = react__WEBPACK_IMPORTED_MODULE_0___default().useCallback(function() {\n        setSidebarState(function(prevState) {\n            return __assign(__assign({}, prevState), {\n                collapsed: !Boolean(prevState === null || prevState === void 0 ? void 0 : prevState.collapsed)\n            });\n        });\n    }, []);\n    var updateToggleState = react__WEBPACK_IMPORTED_MODULE_0___default().useCallback(function() {\n        setSidebarState(function(prevState) {\n            return __assign(__assign({}, prevState), {\n                toggled: !Boolean(prevState === null || prevState === void 0 ? void 0 : prevState.toggled)\n            });\n        });\n    }, []);\n    var providerValue = react__WEBPACK_IMPORTED_MODULE_0___default().useMemo(function() {\n        return __assign(__assign({}, sidebarState), {\n            updateSidebarState: updateSidebarState,\n            updateCollapseState: updateCollapseState,\n            updateToggleState: updateToggleState\n        });\n    }, [\n        sidebarState,\n        updateCollapseState,\n        updateSidebarState,\n        updateToggleState\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(LegacySidebarContext.Provider, {\n        value: providerValue\n    }, children);\n};\n_s3(SidebarProvider, \"9Q+0S9K+9Wufl4HsShqmCPmWvtE=\");\n_c4 = SidebarProvider;\nvar useLegacySidebar = function() {\n    _s4();\n    var context = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(LegacySidebarContext);\n    return context;\n};\n_s4(useLegacySidebar, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar useMediaQuery = function(breakpoint) {\n    _s5();\n    var _a = react__WEBPACK_IMPORTED_MODULE_0___default().useState(!!breakpoint && window.matchMedia(breakpoint).matches), matches = _a[0], setMatches = _a[1];\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        if (breakpoint) {\n            var media_1 = window.matchMedia(breakpoint);\n            var handleMatch_1 = function() {\n                if (media_1.matches !== matches) {\n                    setMatches(media_1.matches);\n                }\n            };\n            handleMatch_1();\n            media_1.addEventListener(\"change\", handleMatch_1);\n            return function() {\n                return media_1.removeEventListener(\"change\", handleMatch_1);\n            };\n        }\n    }, [\n        matches,\n        breakpoint\n    ]);\n    return matches;\n};\n_s5(useMediaQuery, \"OCjuM2gQsF3KLSb0nvH/2k7UH9g=\");\nvar sidebarClasses = {\n    root: \"ps-sidebar-root\",\n    container: \"ps-sidebar-container\",\n    image: \"ps-sidebar-image\",\n    backdrop: \"ps-sidebar-backdrop\",\n    collapsed: \"ps-collapsed\",\n    toggled: \"ps-toggled\",\n    rtl: \"ps-rtl\",\n    broken: \"ps-broken\"\n};\nvar menuClasses = {\n    root: \"ps-menu-root\",\n    menuItemRoot: \"ps-menuitem-root\",\n    subMenuRoot: \"ps-submenu-root\",\n    button: \"ps-menu-button\",\n    prefix: \"ps-menu-prefix\",\n    suffix: \"ps-menu-suffix\",\n    label: \"ps-menu-label\",\n    icon: \"ps-menu-icon\",\n    subMenuContent: \"ps-submenu-content\",\n    SubMenuExpandIcon: \"ps-submenu-expand-icon\",\n    disabled: \"ps-disabled\",\n    active: \"ps-active\",\n    open: \"ps-open\"\n};\nvar StyledBackdrop = newStyled.div(templateObject_1$b || (templateObject_1$b = __makeTemplateObject([\n    \"\\n  position: fixed;\\n  top: 0px;\\n  right: 0px;\\n  bottom: 0px;\\n  left: 0px;\\n  z-index: 1;\\n  background-color: rgb(0, 0, 0, 0.3);\\n\"\n], [\n    \"\\n  position: fixed;\\n  top: 0px;\\n  right: 0px;\\n  bottom: 0px;\\n  left: 0px;\\n  z-index: 1;\\n  background-color: rgb(0, 0, 0, 0.3);\\n\"\n])));\n_c5 = StyledBackdrop;\nvar templateObject_1$b;\nvar BREAK_POINTS = {\n    xs: \"480px\",\n    sm: \"576px\",\n    md: \"768px\",\n    lg: \"992px\",\n    xl: \"1200px\",\n    xxl: \"1600px\",\n    always: \"always\",\n    all: \"all\"\n};\nvar StyledSidebar = newStyled.aside(templateObject_1$a || (templateObject_1$a = __makeTemplateObject([\n    \"\\n  position: relative;\\n  border-right-width: 1px;\\n  border-right-style: solid;\\n  border-color: #efefef;\\n\\n  transition: \",\n    \";\\n\\n  width: \",\n    \";\\n  min-width: \",\n    \";\\n\\n  &.\",\n    \" {\\n    width: \",\n    \";\\n    min-width: \",\n    \";\\n  }\\n\\n  &.\",\n    \" {\\n    direction: rtl;\\n    border-right-width: none;\\n    border-left-width: 1px;\\n    border-right-style: none;\\n    border-left-style: solid;\\n  }\\n\\n  &.\",\n    \" {\\n    position: fixed;\\n    height: 100%;\\n    top: 0px;\\n    z-index: 100;\\n\\n    \",\n    \"\\n\\n    &.\",\n    \" {\\n      \",\n    \"\\n    }\\n\\n    &.\",\n    \" {\\n      \",\n    \"\\n    }\\n\\n    &.\",\n    \" {\\n      right: -\",\n    \";\\n\\n      &.\",\n    \" {\\n        right: -\",\n    \";\\n      }\\n\\n      &.\",\n    \" {\\n        right: 0;\\n      }\\n    }\\n  }\\n\\n  \",\n    \"\\n\"\n], [\n    \"\\n  position: relative;\\n  border-right-width: 1px;\\n  border-right-style: solid;\\n  border-color: #efefef;\\n\\n  transition: \",\n    \";\\n\\n  width: \",\n    \";\\n  min-width: \",\n    \";\\n\\n  &.\",\n    \" {\\n    width: \",\n    \";\\n    min-width: \",\n    \";\\n  }\\n\\n  &.\",\n    \" {\\n    direction: rtl;\\n    border-right-width: none;\\n    border-left-width: 1px;\\n    border-right-style: none;\\n    border-left-style: solid;\\n  }\\n\\n  &.\",\n    \" {\\n    position: fixed;\\n    height: 100%;\\n    top: 0px;\\n    z-index: 100;\\n\\n    \",\n    \"\\n\\n    &.\",\n    \" {\\n      \",\n    \"\\n    }\\n\\n    &.\",\n    \" {\\n      \",\n    \"\\n    }\\n\\n    &.\",\n    \" {\\n      right: -\",\n    \";\\n\\n      &.\",\n    \" {\\n        right: -\",\n    \";\\n      }\\n\\n      &.\",\n    \" {\\n        right: 0;\\n      }\\n    }\\n  }\\n\\n  \",\n    \"\\n\"\n])), function(_a) {\n    var transitionDuration = _a.transitionDuration;\n    return \"width, left, right, \".concat(transitionDuration, \"ms\");\n}, function(_a) {\n    var width = _a.width;\n    return width;\n}, function(_a) {\n    var width = _a.width;\n    return width;\n}, sidebarClasses.collapsed, function(_a) {\n    var collapsedWidth = _a.collapsedWidth;\n    return collapsedWidth;\n}, function(_a) {\n    var collapsedWidth = _a.collapsedWidth;\n    return collapsedWidth;\n}, sidebarClasses.rtl, sidebarClasses.broken, function(_a) {\n    var rtl = _a.rtl, width = _a.width;\n    return !rtl ? \"left: -\".concat(width, \";\") : \"\";\n}, sidebarClasses.collapsed, function(_a) {\n    var rtl = _a.rtl, collapsedWidth = _a.collapsedWidth;\n    return !rtl ? \"left: -\".concat(collapsedWidth, \"; \") : \"\";\n}, sidebarClasses.toggled, function(_a) {\n    var rtl = _a.rtl;\n    return !rtl ? \"left: 0;\" : \"\";\n}, sidebarClasses.rtl, function(_a) {\n    var width = _a.width;\n    return width;\n}, sidebarClasses.collapsed, function(_a) {\n    var collapsedWidth = _a.collapsedWidth;\n    return collapsedWidth;\n}, sidebarClasses.toggled, function(_a) {\n    var rootStyles = _a.rootStyles;\n    return rootStyles;\n});\n_c6 = StyledSidebar;\nvar StyledSidebarContainer = newStyled.div(templateObject_2$1 || (templateObject_2$1 = __makeTemplateObject([\n    \"\\n  position: relative;\\n  height: 100%;\\n  overflow-y: auto;\\n  overflow-x: hidden;\\n  z-index: 3;\\n\\n  \",\n    \"\\n\"\n], [\n    \"\\n  position: relative;\\n  height: 100%;\\n  overflow-y: auto;\\n  overflow-x: hidden;\\n  z-index: 3;\\n\\n  \",\n    \"\\n\"\n])), function(_a) {\n    var backgroundColor = _a.backgroundColor;\n    return backgroundColor ? \"background-color:\".concat(backgroundColor, \";\") : \"\";\n});\n_c7 = StyledSidebarContainer;\nvar StyledSidebarImage = newStyled.img(templateObject_3$1 || (templateObject_3$1 = __makeTemplateObject([\n    \"\\n  &.\",\n    \" {\\n    width: 100%;\\n    height: 100%;\\n    object-fit: cover;\\n    object-position: center;\\n    position: absolute;\\n    left: 0;\\n    top: 0;\\n    z-index: 2;\\n  }\\n\"\n], [\n    \"\\n  &.\",\n    \" {\\n    width: 100%;\\n    height: 100%;\\n    object-fit: cover;\\n    object-position: center;\\n    position: absolute;\\n    left: 0;\\n    top: 0;\\n    z-index: 2;\\n  }\\n\"\n])), sidebarClasses.image);\n_c8 = StyledSidebarImage;\nvar SidebarContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext({\n    collapsed: false,\n    toggled: false,\n    rtl: false,\n    transitionDuration: 300\n});\nvar Sidebar = /*#__PURE__*/ _s6(react__WEBPACK_IMPORTED_MODULE_0___default().forwardRef(_c9 = _s6(function(_a, ref) {\n    _s6();\n    var _b;\n    var collapsed = _a.collapsed, toggled = _a.toggled, onBackdropClick = _a.onBackdropClick, onBreakPoint = _a.onBreakPoint, _c = _a.width, width = _c === void 0 ? \"250px\" : _c, _d = _a.collapsedWidth, collapsedWidth = _d === void 0 ? \"80px\" : _d, defaultCollapsed = _a.defaultCollapsed, className = _a.className, children = _a.children, breakPoint = _a.breakPoint, customBreakPoint = _a.customBreakPoint, _e = _a.backgroundColor, backgroundColor = _e === void 0 ? \"rgb(249, 249, 249, 0.7)\" : _e, _f = _a.transitionDuration, transitionDuration = _f === void 0 ? 300 : _f, image = _a.image, rtl = _a.rtl, rootStyles = _a.rootStyles, rest = __rest(_a, [\n        \"collapsed\",\n        \"toggled\",\n        \"onBackdropClick\",\n        \"onBreakPoint\",\n        \"width\",\n        \"collapsedWidth\",\n        \"defaultCollapsed\",\n        \"className\",\n        \"children\",\n        \"breakPoint\",\n        \"customBreakPoint\",\n        \"backgroundColor\",\n        \"transitionDuration\",\n        \"image\",\n        \"rtl\",\n        \"rootStyles\"\n    ]);\n    var getBreakpointValue = function() {\n        if (customBreakPoint) {\n            return \"(max-width: \".concat(customBreakPoint, \")\");\n        }\n        if (breakPoint) {\n            if ([\n                \"xs\",\n                \"sm\",\n                \"md\",\n                \"lg\",\n                \"xl\",\n                \"xxl\"\n            ].includes(breakPoint)) {\n                return \"(max-width: \".concat(BREAK_POINTS[breakPoint], \")\");\n            }\n            if (breakPoint === \"always\" || breakPoint === \"all\") {\n                if (breakPoint === \"always\") {\n                    console.warn('The \"always\" breakPoint is deprecated and will be removed in future release. ' + 'Please use the \"all\" breakPoint instead.');\n                }\n                return \"screen\";\n            }\n            return \"(max-width: \".concat(breakPoint, \")\");\n        }\n    };\n    var breakpointCallbackFnRef = react__WEBPACK_IMPORTED_MODULE_0___default().useRef();\n    breakpointCallbackFnRef.current = function(broken) {\n        onBreakPoint === null || onBreakPoint === void 0 ? void 0 : onBreakPoint(broken);\n    };\n    var broken = useMediaQuery(getBreakpointValue());\n    var _g = react__WEBPACK_IMPORTED_MODULE_0___default().useState(false), mounted = _g[0], setMounted = _g[1];\n    var legacySidebarContext = useLegacySidebar();\n    var collapsedValue = collapsed !== null && collapsed !== void 0 ? collapsed : !mounted && defaultCollapsed ? true : legacySidebarContext === null || legacySidebarContext === void 0 ? void 0 : legacySidebarContext.collapsed;\n    var toggledValue = toggled !== null && toggled !== void 0 ? toggled : legacySidebarContext === null || legacySidebarContext === void 0 ? void 0 : legacySidebarContext.toggled;\n    var handleBackdropClick = function() {\n        onBackdropClick === null || onBackdropClick === void 0 ? void 0 : onBackdropClick();\n        legacySidebarContext === null || legacySidebarContext === void 0 ? void 0 : legacySidebarContext.updateSidebarState({\n            toggled: false\n        });\n    };\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        var _a;\n        (_a = breakpointCallbackFnRef.current) === null || _a === void 0 ? void 0 : _a.call(breakpointCallbackFnRef, broken);\n    }, [\n        broken\n    ]);\n    // TODO: remove in next major version\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        legacySidebarContext === null || legacySidebarContext === void 0 ? void 0 : legacySidebarContext.updateSidebarState({\n            broken: broken,\n            rtl: rtl,\n            transitionDuration: transitionDuration\n        });\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        broken,\n        legacySidebarContext === null || legacySidebarContext === void 0 ? void 0 : legacySidebarContext.updateSidebarState,\n        rtl,\n        transitionDuration\n    ]);\n    // TODO: remove in next major version\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        if (!mounted) {\n            legacySidebarContext === null || legacySidebarContext === void 0 ? void 0 : legacySidebarContext.updateSidebarState({\n                collapsed: defaultCollapsed\n            });\n            setMounted(true);\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        defaultCollapsed,\n        mounted,\n        legacySidebarContext === null || legacySidebarContext === void 0 ? void 0 : legacySidebarContext.updateSidebarState\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(SidebarContext.Provider, {\n        value: {\n            collapsed: collapsedValue,\n            toggled: toggledValue,\n            rtl: rtl,\n            transitionDuration: transitionDuration\n        }\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledSidebar, __assign({\n        ref: ref,\n        \"data-testid\": \"\".concat(sidebarClasses.root, \"-test-id\"),\n        rtl: rtl,\n        rootStyles: rootStyles,\n        width: width,\n        collapsedWidth: collapsedWidth,\n        transitionDuration: transitionDuration,\n        className: classnames(sidebarClasses.root, (_b = {}, _b[sidebarClasses.collapsed] = collapsedValue, _b[sidebarClasses.toggled] = toggledValue, _b[sidebarClasses.broken] = broken, _b[sidebarClasses.rtl] = rtl, _b), className)\n    }, rest), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledSidebarContainer, {\n        \"data-testid\": \"\".concat(sidebarClasses.container, \"-test-id\"),\n        className: sidebarClasses.container,\n        backgroundColor: backgroundColor\n    }, children), image && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledSidebarImage, {\n        \"data-testid\": \"\".concat(sidebarClasses.image, \"-test-id\"),\n        src: image,\n        alt: \"sidebar background\",\n        className: sidebarClasses.image\n    }), broken && toggledValue && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledBackdrop, {\n        \"data-testid\": \"\".concat(sidebarClasses.backdrop, \"-test-id\"),\n        role: \"button\",\n        tabIndex: 0,\n        \"aria-label\": \"backdrop\",\n        onClick: handleBackdropClick,\n        onKeyPress: handleBackdropClick,\n        className: sidebarClasses.backdrop\n    })));\n}, \"gfkO53xmmVUZ+gX2jBopV4LLVh4=\", false, function() {\n    return [\n        useMediaQuery,\n        useLegacySidebar\n    ];\n})), \"gfkO53xmmVUZ+gX2jBopV4LLVh4=\", false, function() {\n    return [\n        useMediaQuery,\n        useLegacySidebar\n    ];\n});\n_c10 = Sidebar;\nvar templateObject_1$a, templateObject_2$1, templateObject_3$1;\nvar StyledUl = newStyled.ul(templateObject_1$9 || (templateObject_1$9 = __makeTemplateObject([\n    \"\\n  list-style-type: none;\\n  padding: 0;\\n  margin: 0;\\n\"\n], [\n    \"\\n  list-style-type: none;\\n  padding: 0;\\n  margin: 0;\\n\"\n])));\n_c11 = StyledUl;\nvar templateObject_1$9;\nvar StyledMenu = newStyled.nav(templateObject_1$8 || (templateObject_1$8 = __makeTemplateObject([\n    \"\\n  &.\",\n    \" {\\n    \",\n    \"\\n  }\\n\"\n], [\n    \"\\n  &.\",\n    \" {\\n    \",\n    \"\\n  }\\n\"\n])), menuClasses.root, function(_a) {\n    var rootStyles = _a.rootStyles;\n    return rootStyles;\n});\n_c12 = StyledMenu;\nvar MenuContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(undefined);\nvar LevelContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(0);\nvar MenuFR = function(_a, ref) {\n    _s7();\n    var children = _a.children, className = _a.className, _b = _a.transitionDuration, transitionDuration = _b === void 0 ? 300 : _b, _c = _a.closeOnClick, closeOnClick = _c === void 0 ? false : _c, rootStyles = _a.rootStyles, menuItemStyles = _a.menuItemStyles, renderExpandIcon = _a.renderExpandIcon, rest = __rest(_a, [\n        \"children\",\n        \"className\",\n        \"transitionDuration\",\n        \"closeOnClick\",\n        \"rootStyles\",\n        \"menuItemStyles\",\n        \"renderExpandIcon\"\n    ]);\n    var providerValue = react__WEBPACK_IMPORTED_MODULE_0___default().useMemo(function() {\n        return {\n            transitionDuration: transitionDuration,\n            closeOnClick: closeOnClick,\n            menuItemStyles: menuItemStyles,\n            renderExpandIcon: renderExpandIcon\n        };\n    }, [\n        transitionDuration,\n        closeOnClick,\n        menuItemStyles,\n        renderExpandIcon\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(MenuContext.Provider, {\n        value: providerValue\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(LevelContext.Provider, {\n        value: 0\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledMenu, __assign({\n        ref: ref,\n        className: classnames(menuClasses.root, className),\n        rootStyles: rootStyles\n    }, rest), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledUl, null, children))));\n};\n_s7(MenuFR, \"4Yynjx1hqx+IWzMZIMxn+aTwOw8=\");\n_c13 = MenuFR;\nvar Menu = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().forwardRef(MenuFR);\n_c14 = Menu;\nvar templateObject_1$8;\nvar useMenu = function() {\n    _s8();\n    var context = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(MenuContext);\n    if (context === undefined) {\n        //TODO: set better error message\n        throw new Error(\"Menu Component is required!\");\n    }\n    return context;\n};\n_s8(useMenu, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar StyledSubMenuContent = newStyled.div(templateObject_1$7 || (templateObject_1$7 = __makeTemplateObject([\n    \"\\n  display: none;\\n  overflow: hidden;\\n  z-index: 999;\\n  transition: height \",\n    \"ms;\\n  box-sizing: border-box;\\n  background-color: white;\\n\\n  \",\n    \"\\n\\n  \",\n    \"\\n\\n  \",\n    \";\\n\\n  \",\n    \";\\n\"\n], [\n    \"\\n  display: none;\\n  overflow: hidden;\\n  z-index: 999;\\n  transition: height \",\n    \"ms;\\n  box-sizing: border-box;\\n  background-color: white;\\n\\n  \",\n    \"\\n\\n  \",\n    \"\\n\\n  \",\n    \";\\n\\n  \",\n    \";\\n\"\n])), function(_a) {\n    var transitionDuration = _a.transitionDuration;\n    return transitionDuration;\n}, function(_a) {\n    var firstLevel = _a.firstLevel, collapsed = _a.collapsed;\n    return firstLevel && collapsed && \"\\n     background-color: white;\\n     box-shadow: 0 3px 6px -4px #0000001f, 0 6px 16px #00000014, 0 9px 28px 8px #0000000d;\\n     \";\n}, function(_a) {\n    var defaultOpen = _a.defaultOpen;\n    return defaultOpen && \"height: auto;display: block;\";\n}, function(_a) {\n    var collapsed = _a.collapsed, firstLevel = _a.firstLevel, openWhenCollapsed = _a.openWhenCollapsed;\n    return collapsed && firstLevel ? \"\\n      position: fixed;\\n      padding-left: 0px;\\n      width: 200px;\\n      border-radius: 4px;\\n      height: auto!important;\\n      display: block!important;     \\n      transition: none!important;     \\n      visibility: \".concat(openWhenCollapsed ? \"visible\" : \"hidden\", \";\\n     \") : \"\\n      position: static!important;\\n      transform: none!important;\\n      \";\n}, function(_a) {\n    var rootStyles = _a.rootStyles;\n    return rootStyles;\n});\n_c15 = StyledSubMenuContent;\nvar SubMenuContentFR = function(_a, ref) {\n    _s9();\n    var children = _a.children, open = _a.open, openWhenCollapsed = _a.openWhenCollapsed, firstLevel = _a.firstLevel, collapsed = _a.collapsed, defaultOpen = _a.defaultOpen, rest = __rest(_a, [\n        \"children\",\n        \"open\",\n        \"openWhenCollapsed\",\n        \"firstLevel\",\n        \"collapsed\",\n        \"defaultOpen\"\n    ]);\n    var transitionDuration = useMenu().transitionDuration;\n    var defaultOpenState = react__WEBPACK_IMPORTED_MODULE_0___default().useState(defaultOpen)[0];\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledSubMenuContent, __assign({\n        \"data-testid\": \"\".concat(menuClasses.subMenuContent, \"-test-id\"),\n        ref: ref,\n        firstLevel: firstLevel,\n        collapsed: collapsed,\n        open: open,\n        openWhenCollapsed: openWhenCollapsed,\n        transitionDuration: transitionDuration,\n        defaultOpen: defaultOpenState\n    }, rest), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledUl, null, children));\n};\n_s9(SubMenuContentFR, \"jJVtbU6pGOOyJw3jEnXIcXJgjK0=\", false, function() {\n    return [\n        useMenu\n    ];\n});\n_c16 = SubMenuContentFR;\nvar SubMenuContent = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().forwardRef(SubMenuContentFR);\n_c17 = SubMenuContent;\nvar templateObject_1$7;\nvar StyledMenuLabel = newStyled.span(templateObject_1$6 || (templateObject_1$6 = __makeTemplateObject([\n    \"\\n  flex-grow: 1;\\n  overflow: hidden;\\n  text-overflow: ellipsis;\\n  white-space: nowrap;\\n\\n  \",\n    \";\\n\"\n], [\n    \"\\n  flex-grow: 1;\\n  overflow: hidden;\\n  text-overflow: ellipsis;\\n  white-space: nowrap;\\n\\n  \",\n    \";\\n\"\n])), function(_a) {\n    var rootStyles = _a.rootStyles;\n    return rootStyles;\n});\n_c18 = StyledMenuLabel;\nvar templateObject_1$6;\nvar StyledMenuIcon = newStyled.span(templateObject_1$5 || (templateObject_1$5 = __makeTemplateObject([\n    \"\\n  width: 35px;\\n  min-width: 35px;\\n  height: 35px;\\n  line-height: 35px;\\n  text-align: center;\\n  display: inline-block;\\n  border-radius: 2px;\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n\\n  \",\n    \"\\n\\n  \",\n    \";\\n\"\n], [\n    \"\\n  width: 35px;\\n  min-width: 35px;\\n  height: 35px;\\n  line-height: 35px;\\n  text-align: center;\\n  display: inline-block;\\n  border-radius: 2px;\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n\\n  \",\n    \"\\n\\n  \",\n    \";\\n\"\n])), function(_a) {\n    var rtl = _a.rtl;\n    return rtl ? \"margin-left: 10px;\" : \"margin-right: 10px;\";\n}, function(_a) {\n    var rootStyles = _a.rootStyles;\n    return rootStyles;\n});\n_c19 = StyledMenuIcon;\nvar templateObject_1$5;\nvar StyledMenuPrefix = newStyled.span(templateObject_1$4 || (templateObject_1$4 = __makeTemplateObject([\n    \"\\n  \",\n    \"\\n  opacity: \",\n    \";\\n  transition: opacity \",\n    \"ms;\\n\\n  \",\n    \";\\n\"\n], [\n    \"\\n  \",\n    \"\\n  opacity: \",\n    \";\\n  transition: opacity \",\n    \"ms;\\n\\n  \",\n    \";\\n\"\n])), function(_a) {\n    var rtl = _a.rtl;\n    return rtl ? \"margin-left: 5px;\" : \"margin-right: 5px;\";\n}, function(_a) {\n    var firstLevel = _a.firstLevel, collapsed = _a.collapsed;\n    return firstLevel && collapsed ? \"0\" : \"1\";\n}, function(_a) {\n    var transitionDuration = _a.transitionDuration;\n    return transitionDuration;\n}, function(_a) {\n    var rootStyles = _a.rootStyles;\n    return rootStyles;\n});\n_c20 = StyledMenuPrefix;\nvar templateObject_1$4;\nvar StyledMenuSuffix = newStyled.span(templateObject_1$3 || (templateObject_1$3 = __makeTemplateObject([\n    \"\\n  margin-right: 5px;\\n  margin-left: 5px;\\n  opacity: \",\n    \";\\n  transition: opacity \",\n    \"ms;\\n\\n  \",\n    \";\\n\"\n], [\n    \"\\n  margin-right: 5px;\\n  margin-left: 5px;\\n  opacity: \",\n    \";\\n  transition: opacity \",\n    \"ms;\\n\\n  \",\n    \";\\n\"\n])), function(_a) {\n    var firstLevel = _a.firstLevel, collapsed = _a.collapsed;\n    return firstLevel && collapsed ? \"0\" : \"1\";\n}, function(_a) {\n    var transitionDuration = _a.transitionDuration;\n    return transitionDuration;\n}, function(_a) {\n    var rootStyles = _a.rootStyles;\n    return rootStyles;\n});\n_c21 = StyledMenuSuffix;\nvar templateObject_1$3;\nvar StyledExpandIconWrapper = newStyled.span(templateObject_1$2 || (templateObject_1$2 = __makeTemplateObject([\n    \"\\n  \",\n    \"\\n\\n  \",\n    \";\\n\"\n], [\n    \"\\n  \",\n    \"\\n\\n  \",\n    \";\\n\"\n])), function(_a) {\n    var collapsed = _a.collapsed, level = _a.level, rtl = _a.rtl;\n    return collapsed && level === 0 && \"\\n    position: absolute;\\n    \".concat(rtl ? \"left: 10px;\" : \"right: 10px;\", \"\\n    top: 50%;\\n    transform: translateY(-50%);\\n    \\n    \");\n}, function(_a) {\n    var rootStyles = _a.rootStyles;\n    return rootStyles;\n});\n_c22 = StyledExpandIconWrapper;\nvar StyledExpandIcon = newStyled.span(templateObject_2 || (templateObject_2 = __makeTemplateObject([\n    \"\\n  display: inline-block;\\n  transition: transform 0.3s;\\n  \",\n    \"\\n\\n  width: 5px;\\n  height: 5px;\\n  transform: rotate(\",\n    \");\\n\"\n], [\n    \"\\n  display: inline-block;\\n  transition: transform 0.3s;\\n  \",\n    \"\\n\\n  width: 5px;\\n  height: 5px;\\n  transform: rotate(\",\n    \");\\n\"\n])), function(_a) {\n    var rtl = _a.rtl;\n    return rtl ? \"\\n          border-left: 2px solid currentcolor;\\n          border-top: 2px solid currentcolor;\\n        \" : \" border-right: 2px solid currentcolor;\\n          border-bottom: 2px solid currentcolor;\\n        \";\n}, function(_a) {\n    var open = _a.open, rtl = _a.rtl;\n    return open ? rtl ? \"-135deg\" : \"45deg\" : \"-45deg\";\n});\n_c23 = StyledExpandIcon;\nvar StyledExpandIconCollapsed = newStyled.span(templateObject_3 || (templateObject_3 = __makeTemplateObject([\n    \"\\n  width: 5px;\\n  height: 5px;\\n  background-color: currentcolor;\\n  border-radius: 50%;\\n  display: inline-block;\\n\"\n], [\n    \"\\n  width: 5px;\\n  height: 5px;\\n  background-color: currentcolor;\\n  border-radius: 50%;\\n  display: inline-block;\\n\"\n])));\n_c24 = StyledExpandIconCollapsed;\nvar templateObject_1$2, templateObject_2, templateObject_3;\nvar top = \"top\";\nvar bottom = \"bottom\";\nvar right = \"right\";\nvar left = \"left\";\nvar auto = \"auto\";\nvar basePlacements = [\n    top,\n    bottom,\n    right,\n    left\n];\nvar start = \"start\";\nvar end = \"end\";\nvar clippingParents = \"clippingParents\";\nvar viewport = \"viewport\";\nvar popper = \"popper\";\nvar reference = \"reference\";\nvar variationPlacements = /*#__PURE__*/ basePlacements.reduce(function(acc, placement) {\n    return acc.concat([\n        placement + \"-\" + start,\n        placement + \"-\" + end\n    ]);\n}, []);\nvar placements = /*#__PURE__*/ [].concat(basePlacements, [\n    auto\n]).reduce(function(acc, placement) {\n    return acc.concat([\n        placement,\n        placement + \"-\" + start,\n        placement + \"-\" + end\n    ]);\n}, []); // modifiers that need to read the DOM\nvar beforeRead = \"beforeRead\";\nvar read = \"read\";\nvar afterRead = \"afterRead\"; // pure-logic modifiers\nvar beforeMain = \"beforeMain\";\nvar main = \"main\";\nvar afterMain = \"afterMain\"; // modifier with the purpose to write to the DOM (or write into a framework state)\nvar beforeWrite = \"beforeWrite\";\nvar write = \"write\";\nvar afterWrite = \"afterWrite\";\nvar modifierPhases = [\n    beforeRead,\n    read,\n    afterRead,\n    beforeMain,\n    main,\n    afterMain,\n    beforeWrite,\n    write,\n    afterWrite\n];\nfunction getNodeName(element) {\n    return element ? (element.nodeName || \"\").toLowerCase() : null;\n}\nfunction getWindow(node) {\n    if (node == null) {\n        return window;\n    }\n    if (node.toString() !== \"[object Window]\") {\n        var ownerDocument = node.ownerDocument;\n        return ownerDocument ? ownerDocument.defaultView || window : window;\n    }\n    return node;\n}\nfunction isElement(node) {\n    var OwnElement = getWindow(node).Element;\n    return node instanceof OwnElement || node instanceof Element;\n}\nfunction isHTMLElement(node) {\n    var OwnElement = getWindow(node).HTMLElement;\n    return node instanceof OwnElement || node instanceof HTMLElement;\n}\nfunction isShadowRoot(node) {\n    // IE 11 has no ShadowRoot\n    if (typeof ShadowRoot === \"undefined\") {\n        return false;\n    }\n    var OwnElement = getWindow(node).ShadowRoot;\n    return node instanceof OwnElement || node instanceof ShadowRoot;\n}\n// and applies them to the HTMLElements such as popper and arrow\nfunction applyStyles(_ref) {\n    var state = _ref.state;\n    Object.keys(state.elements).forEach(function(name) {\n        var style = state.styles[name] || {};\n        var attributes = state.attributes[name] || {};\n        var element = state.elements[name]; // arrow is optional + virtual elements\n        if (!isHTMLElement(element) || !getNodeName(element)) {\n            return;\n        } // Flow doesn't support to extend this property, but it's the most\n        // effective way to apply styles to an HTMLElement\n        // $FlowFixMe[cannot-write]\n        Object.assign(element.style, style);\n        Object.keys(attributes).forEach(function(name) {\n            var value = attributes[name];\n            if (value === false) {\n                element.removeAttribute(name);\n            } else {\n                element.setAttribute(name, value === true ? \"\" : value);\n            }\n        });\n    });\n}\nfunction effect$2(_ref2) {\n    var state = _ref2.state;\n    var initialStyles = {\n        popper: {\n            position: state.options.strategy,\n            left: \"0\",\n            top: \"0\",\n            margin: \"0\"\n        },\n        arrow: {\n            position: \"absolute\"\n        },\n        reference: {}\n    };\n    Object.assign(state.elements.popper.style, initialStyles.popper);\n    state.styles = initialStyles;\n    if (state.elements.arrow) {\n        Object.assign(state.elements.arrow.style, initialStyles.arrow);\n    }\n    return function() {\n        Object.keys(state.elements).forEach(function(name) {\n            var element = state.elements[name];\n            var attributes = state.attributes[name] || {};\n            var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them\n            var style = styleProperties.reduce(function(style, property) {\n                style[property] = \"\";\n                return style;\n            }, {}); // arrow is optional + virtual elements\n            if (!isHTMLElement(element) || !getNodeName(element)) {\n                return;\n            }\n            Object.assign(element.style, style);\n            Object.keys(attributes).forEach(function(attribute) {\n                element.removeAttribute(attribute);\n            });\n        });\n    };\n} // eslint-disable-next-line import/no-unused-modules\nvar applyStyles$1 = {\n    name: \"applyStyles\",\n    enabled: true,\n    phase: \"write\",\n    fn: applyStyles,\n    effect: effect$2,\n    requires: [\n        \"computeStyles\"\n    ]\n};\nfunction getBasePlacement(placement) {\n    return placement.split(\"-\")[0];\n}\nvar max = Math.max;\nvar min = Math.min;\nvar round = Math.round;\nfunction getUAString() {\n    var uaData = navigator.userAgentData;\n    if (uaData != null && uaData.brands) {\n        return uaData.brands.map(function(item) {\n            return item.brand + \"/\" + item.version;\n        }).join(\" \");\n    }\n    return navigator.userAgent;\n}\nfunction isLayoutViewport() {\n    return !/^((?!chrome|android).)*safari/i.test(getUAString());\n}\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy) {\n    if (includeScale === void 0) {\n        includeScale = false;\n    }\n    if (isFixedStrategy === void 0) {\n        isFixedStrategy = false;\n    }\n    var clientRect = element.getBoundingClientRect();\n    var scaleX = 1;\n    var scaleY = 1;\n    if (includeScale && isHTMLElement(element)) {\n        scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\n        scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\n    }\n    var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;\n    var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n    var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;\n    var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;\n    var width = clientRect.width / scaleX;\n    var height = clientRect.height / scaleY;\n    return {\n        width: width,\n        height: height,\n        top: y,\n        right: x + width,\n        bottom: y + height,\n        left: x,\n        x: x,\n        y: y\n    };\n}\n// means it doesn't take into account transforms.\nfunction getLayoutRect(element) {\n    var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.\n    // Fixes https://github.com/popperjs/popper-core/issues/1223\n    var width = element.offsetWidth;\n    var height = element.offsetHeight;\n    if (Math.abs(clientRect.width - width) <= 1) {\n        width = clientRect.width;\n    }\n    if (Math.abs(clientRect.height - height) <= 1) {\n        height = clientRect.height;\n    }\n    return {\n        x: element.offsetLeft,\n        y: element.offsetTop,\n        width: width,\n        height: height\n    };\n}\nfunction contains(parent, child) {\n    var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method\n    if (parent.contains(child)) {\n        return true;\n    } else if (rootNode && isShadowRoot(rootNode)) {\n        var next = child;\n        do {\n            if (next && parent.isSameNode(next)) {\n                return true;\n            } // $FlowFixMe[prop-missing]: need a better way to handle this...\n            next = next.parentNode || next.host;\n        }while (next);\n    } // Give up, the result is false\n    return false;\n}\nfunction getComputedStyle(element) {\n    return getWindow(element).getComputedStyle(element);\n}\nfunction isTableElement(element) {\n    return [\n        \"table\",\n        \"td\",\n        \"th\"\n    ].indexOf(getNodeName(element)) >= 0;\n}\nfunction getDocumentElement(element) {\n    // $FlowFixMe[incompatible-return]: assume body is always available\n    return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;\n}\nfunction getParentNode(element) {\n    if (getNodeName(element) === \"html\") {\n        return element;\n    }\n    return(// $FlowFixMe[incompatible-return]\n    // $FlowFixMe[prop-missing]\n    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    element.parentNode || (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected\n    // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n    getDocumentElement(element) // fallback\n    );\n}\nfunction getTrueOffsetParent(element) {\n    if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837\n    getComputedStyle(element).position === \"fixed\") {\n        return null;\n    }\n    return element.offsetParent;\n} // `.offsetParent` reports `null` for fixed elements, while absolute elements\n// return the containing block\nfunction getContainingBlock(element) {\n    var isFirefox = /firefox/i.test(getUAString());\n    var isIE = /Trident/i.test(getUAString());\n    if (isIE && isHTMLElement(element)) {\n        // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport\n        var elementCss = getComputedStyle(element);\n        if (elementCss.position === \"fixed\") {\n            return null;\n        }\n    }\n    var currentNode = getParentNode(element);\n    if (isShadowRoot(currentNode)) {\n        currentNode = currentNode.host;\n    }\n    while(isHTMLElement(currentNode) && [\n        \"html\",\n        \"body\"\n    ].indexOf(getNodeName(currentNode)) < 0){\n        var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that\n        // create a containing block.\n        // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n        if (css.transform !== \"none\" || css.perspective !== \"none\" || css.contain === \"paint\" || [\n            \"transform\",\n            \"perspective\"\n        ].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === \"filter\" || isFirefox && css.filter && css.filter !== \"none\") {\n            return currentNode;\n        } else {\n            currentNode = currentNode.parentNode;\n        }\n    }\n    return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element) {\n    var window1 = getWindow(element);\n    var offsetParent = getTrueOffsetParent(element);\n    while(offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === \"static\"){\n        offsetParent = getTrueOffsetParent(offsetParent);\n    }\n    if (offsetParent && (getNodeName(offsetParent) === \"html\" || getNodeName(offsetParent) === \"body\" && getComputedStyle(offsetParent).position === \"static\")) {\n        return window1;\n    }\n    return offsetParent || getContainingBlock(element) || window1;\n}\nfunction getMainAxisFromPlacement(placement) {\n    return [\n        \"top\",\n        \"bottom\"\n    ].indexOf(placement) >= 0 ? \"x\" : \"y\";\n}\nfunction within(min$1, value, max$1) {\n    return max(min$1, min(value, max$1));\n}\nfunction withinMaxClamp(min, value, max) {\n    var v = within(min, value, max);\n    return v > max ? max : v;\n}\nfunction getFreshSideObject() {\n    return {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n    };\n}\nfunction mergePaddingObject(paddingObject) {\n    return Object.assign({}, getFreshSideObject(), paddingObject);\n}\nfunction expandToHashMap(value, keys) {\n    return keys.reduce(function(hashMap, key) {\n        hashMap[key] = value;\n        return hashMap;\n    }, {});\n}\nvar toPaddingObject = function toPaddingObject(padding, state) {\n    padding = typeof padding === \"function\" ? padding(Object.assign({}, state.rects, {\n        placement: state.placement\n    })) : padding;\n    return mergePaddingObject(typeof padding !== \"number\" ? padding : expandToHashMap(padding, basePlacements));\n};\nfunction arrow(_ref) {\n    var _state$modifiersData$;\n    var state = _ref.state, name = _ref.name, options = _ref.options;\n    var arrowElement = state.elements.arrow;\n    var popperOffsets = state.modifiersData.popperOffsets;\n    var basePlacement = getBasePlacement(state.placement);\n    var axis = getMainAxisFromPlacement(basePlacement);\n    var isVertical = [\n        left,\n        right\n    ].indexOf(basePlacement) >= 0;\n    var len = isVertical ? \"height\" : \"width\";\n    if (!arrowElement || !popperOffsets) {\n        return;\n    }\n    var paddingObject = toPaddingObject(options.padding, state);\n    var arrowRect = getLayoutRect(arrowElement);\n    var minProp = axis === \"y\" ? top : left;\n    var maxProp = axis === \"y\" ? bottom : right;\n    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\n    var startDiff = popperOffsets[axis] - state.rects.reference[axis];\n    var arrowOffsetParent = getOffsetParent(arrowElement);\n    var clientSize = arrowOffsetParent ? axis === \"y\" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n    var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is\n    // outside of the popper bounds\n    var min = paddingObject[minProp];\n    var max = clientSize - arrowRect[len] - paddingObject[maxProp];\n    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n    var offset = within(min, center, max); // Prevents breaking syntax highlighting...\n    var axisProp = axis;\n    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);\n}\nfunction effect$1(_ref2) {\n    var state = _ref2.state, options = _ref2.options;\n    var _options$element = options.element, arrowElement = _options$element === void 0 ? \"[data-popper-arrow]\" : _options$element;\n    if (arrowElement == null) {\n        return;\n    } // CSS selector\n    if (typeof arrowElement === \"string\") {\n        arrowElement = state.elements.popper.querySelector(arrowElement);\n        if (!arrowElement) {\n            return;\n        }\n    }\n    if (true) {\n        if (!isHTMLElement(arrowElement)) {\n            console.error([\n                'Popper: \"arrow\" element must be an HTMLElement (not an SVGElement).',\n                \"To use an SVG arrow, wrap it in an HTMLElement that will be used as\",\n                \"the arrow.\"\n            ].join(\" \"));\n        }\n    }\n    if (!contains(state.elements.popper, arrowElement)) {\n        if (true) {\n            console.error([\n                'Popper: \"arrow\" modifier\\'s `element` must be a child of the popper',\n                \"element.\"\n            ].join(\" \"));\n        }\n        return;\n    }\n    state.elements.arrow = arrowElement;\n} // eslint-disable-next-line import/no-unused-modules\nvar arrow$1 = {\n    name: \"arrow\",\n    enabled: true,\n    phase: \"main\",\n    fn: arrow,\n    effect: effect$1,\n    requires: [\n        \"popperOffsets\"\n    ],\n    requiresIfExists: [\n        \"preventOverflow\"\n    ]\n};\nfunction getVariation(placement) {\n    return placement.split(\"-\")[1];\n}\nvar unsetSides = {\n    top: \"auto\",\n    right: \"auto\",\n    bottom: \"auto\",\n    left: \"auto\"\n}; // Round the offsets to the nearest suitable subpixel based on the DPR.\n// Zooming can change the DPR, but it seems to report a value that will\n// cleanly divide the values into the appropriate subpixels.\nfunction roundOffsetsByDPR(_ref) {\n    var x = _ref.x, y = _ref.y;\n    var win = window;\n    var dpr = win.devicePixelRatio || 1;\n    return {\n        x: round(x * dpr) / dpr || 0,\n        y: round(y * dpr) / dpr || 0\n    };\n}\nfunction mapToStyles(_ref2) {\n    var _Object$assign2;\n    var popper = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;\n    var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;\n    var _ref3 = typeof roundOffsets === \"function\" ? roundOffsets({\n        x: x,\n        y: y\n    }) : {\n        x: x,\n        y: y\n    };\n    x = _ref3.x;\n    y = _ref3.y;\n    var hasX = offsets.hasOwnProperty(\"x\");\n    var hasY = offsets.hasOwnProperty(\"y\");\n    var sideX = left;\n    var sideY = top;\n    var win = window;\n    if (adaptive) {\n        var offsetParent = getOffsetParent(popper);\n        var heightProp = \"clientHeight\";\n        var widthProp = \"clientWidth\";\n        if (offsetParent === getWindow(popper)) {\n            offsetParent = getDocumentElement(popper);\n            if (getComputedStyle(offsetParent).position !== \"static\" && position === \"absolute\") {\n                heightProp = \"scrollHeight\";\n                widthProp = \"scrollWidth\";\n            }\n        } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\n        offsetParent = offsetParent;\n        if (placement === top || (placement === left || placement === right) && variation === end) {\n            sideY = bottom;\n            var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];\n            y -= offsetY - popperRect.height;\n            y *= gpuAcceleration ? 1 : -1;\n        }\n        if (placement === left || (placement === top || placement === bottom) && variation === end) {\n            sideX = right;\n            var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];\n            x -= offsetX - popperRect.width;\n            x *= gpuAcceleration ? 1 : -1;\n        }\n    }\n    var commonStyles = Object.assign({\n        position: position\n    }, adaptive && unsetSides);\n    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({\n        x: x,\n        y: y\n    }) : {\n        x: x,\n        y: y\n    };\n    x = _ref4.x;\n    y = _ref4.y;\n    if (gpuAcceleration) {\n        var _Object$assign;\n        return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? \"0\" : \"\", _Object$assign[sideX] = hasX ? \"0\" : \"\", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? \"translate(\" + x + \"px, \" + y + \"px)\" : \"translate3d(\" + x + \"px, \" + y + \"px, 0)\", _Object$assign));\n    }\n    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + \"px\" : \"\", _Object$assign2[sideX] = hasX ? x + \"px\" : \"\", _Object$assign2.transform = \"\", _Object$assign2));\n}\nfunction computeStyles(_ref5) {\n    var state = _ref5.state, options = _ref5.options;\n    var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;\n    if (true) {\n        var transitionProperty = getComputedStyle(state.elements.popper).transitionProperty || \"\";\n        if (adaptive && [\n            \"transform\",\n            \"top\",\n            \"right\",\n            \"bottom\",\n            \"left\"\n        ].some(function(property) {\n            return transitionProperty.indexOf(property) >= 0;\n        })) {\n            console.warn([\n                \"Popper: Detected CSS transitions on at least one of the following\",\n                'CSS properties: \"transform\", \"top\", \"right\", \"bottom\", \"left\".',\n                \"\\n\\n\",\n                'Disable the \"computeStyles\" modifier\\'s `adaptive` option to allow',\n                \"for smooth transitions, or remove these properties from the CSS\",\n                \"transition declaration on the popper element if only transitioning\",\n                \"opacity or background-color for example.\",\n                \"\\n\\n\",\n                \"We recommend using the popper element as a wrapper around an inner\",\n                \"element that can have any CSS property transitioned for animations.\"\n            ].join(\" \"));\n        }\n    }\n    var commonStyles = {\n        placement: getBasePlacement(state.placement),\n        variation: getVariation(state.placement),\n        popper: state.elements.popper,\n        popperRect: state.rects.popper,\n        gpuAcceleration: gpuAcceleration,\n        isFixed: state.options.strategy === \"fixed\"\n    };\n    if (state.modifiersData.popperOffsets != null) {\n        state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {\n            offsets: state.modifiersData.popperOffsets,\n            position: state.options.strategy,\n            adaptive: adaptive,\n            roundOffsets: roundOffsets\n        })));\n    }\n    if (state.modifiersData.arrow != null) {\n        state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {\n            offsets: state.modifiersData.arrow,\n            position: \"absolute\",\n            adaptive: false,\n            roundOffsets: roundOffsets\n        })));\n    }\n    state.attributes.popper = Object.assign({}, state.attributes.popper, {\n        \"data-popper-placement\": state.placement\n    });\n} // eslint-disable-next-line import/no-unused-modules\nvar computeStyles$1 = {\n    name: \"computeStyles\",\n    enabled: true,\n    phase: \"beforeWrite\",\n    fn: computeStyles,\n    data: {}\n};\nvar passive = {\n    passive: true\n};\nfunction effect(_ref) {\n    var state = _ref.state, instance = _ref.instance, options = _ref.options;\n    var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;\n    var window1 = getWindow(state.elements.popper);\n    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\n    if (scroll) {\n        scrollParents.forEach(function(scrollParent) {\n            scrollParent.addEventListener(\"scroll\", instance.update, passive);\n        });\n    }\n    if (resize) {\n        window1.addEventListener(\"resize\", instance.update, passive);\n    }\n    return function() {\n        if (scroll) {\n            scrollParents.forEach(function(scrollParent) {\n                scrollParent.removeEventListener(\"scroll\", instance.update, passive);\n            });\n        }\n        if (resize) {\n            window1.removeEventListener(\"resize\", instance.update, passive);\n        }\n    };\n} // eslint-disable-next-line import/no-unused-modules\nvar eventListeners = {\n    name: \"eventListeners\",\n    enabled: true,\n    phase: \"write\",\n    fn: function fn() {},\n    effect: effect,\n    data: {}\n};\nvar hash$1 = {\n    left: \"right\",\n    right: \"left\",\n    bottom: \"top\",\n    top: \"bottom\"\n};\nfunction getOppositePlacement(placement) {\n    return placement.replace(/left|right|bottom|top/g, function(matched) {\n        return hash$1[matched];\n    });\n}\nvar hash = {\n    start: \"end\",\n    end: \"start\"\n};\nfunction getOppositeVariationPlacement(placement) {\n    return placement.replace(/start|end/g, function(matched) {\n        return hash[matched];\n    });\n}\nfunction getWindowScroll(node) {\n    var win = getWindow(node);\n    var scrollLeft = win.pageXOffset;\n    var scrollTop = win.pageYOffset;\n    return {\n        scrollLeft: scrollLeft,\n        scrollTop: scrollTop\n    };\n}\nfunction getWindowScrollBarX(element) {\n    // If <html> has a CSS width greater than the viewport, then this will be\n    // incorrect for RTL.\n    // Popper 1 is broken in this case and never had a bug report so let's assume\n    // it's not an issue. I don't think anyone ever specifies width on <html>\n    // anyway.\n    // Browsers where the left scrollbar doesn't cause an issue report `0` for\n    // this (e.g. Edge 2019, IE11, Safari)\n    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;\n}\nfunction getViewportRect(element, strategy) {\n    var win = getWindow(element);\n    var html = getDocumentElement(element);\n    var visualViewport = win.visualViewport;\n    var width = html.clientWidth;\n    var height = html.clientHeight;\n    var x = 0;\n    var y = 0;\n    if (visualViewport) {\n        width = visualViewport.width;\n        height = visualViewport.height;\n        var layoutViewport = isLayoutViewport();\n        if (layoutViewport || !layoutViewport && strategy === \"fixed\") {\n            x = visualViewport.offsetLeft;\n            y = visualViewport.offsetTop;\n        }\n    }\n    return {\n        width: width,\n        height: height,\n        x: x + getWindowScrollBarX(element),\n        y: y\n    };\n}\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\nfunction getDocumentRect(element) {\n    var _element$ownerDocumen;\n    var html = getDocumentElement(element);\n    var winScroll = getWindowScroll(element);\n    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n    var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n    var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n    var x = -winScroll.scrollLeft + getWindowScrollBarX(element);\n    var y = -winScroll.scrollTop;\n    if (getComputedStyle(body || html).direction === \"rtl\") {\n        x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n    }\n    return {\n        width: width,\n        height: height,\n        x: x,\n        y: y\n    };\n}\nfunction isScrollParent(element) {\n    // Firefox wants us to check `-x` and `-y` variations as well\n    var _getComputedStyle = getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;\n    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}\nfunction getScrollParent(node) {\n    if ([\n        \"html\",\n        \"body\",\n        \"#document\"\n    ].indexOf(getNodeName(node)) >= 0) {\n        // $FlowFixMe[incompatible-return]: assume body is always available\n        return node.ownerDocument.body;\n    }\n    if (isHTMLElement(node) && isScrollParent(node)) {\n        return node;\n    }\n    return getScrollParent(getParentNode(node));\n}\n/*\ngiven a DOM element, return the list of all scroll parents, up the list of ancesors\nuntil we get to the top window object. This list is what we attach scroll listeners\nto, because if any of these parent elements scroll, we'll need to re-calculate the\nreference element's position.\n*/ function listScrollParents(element, list) {\n    var _element$ownerDocumen;\n    if (list === void 0) {\n        list = [];\n    }\n    var scrollParent = getScrollParent(element);\n    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);\n    var win = getWindow(scrollParent);\n    var target = isBody ? [\n        win\n    ].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;\n    var updatedList = list.concat(target);\n    return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));\n}\nfunction rectToClientRect(rect) {\n    return Object.assign({}, rect, {\n        left: rect.x,\n        top: rect.y,\n        right: rect.x + rect.width,\n        bottom: rect.y + rect.height\n    });\n}\nfunction getInnerBoundingClientRect(element, strategy) {\n    var rect = getBoundingClientRect(element, false, strategy === \"fixed\");\n    rect.top = rect.top + element.clientTop;\n    rect.left = rect.left + element.clientLeft;\n    rect.bottom = rect.top + element.clientHeight;\n    rect.right = rect.left + element.clientWidth;\n    rect.width = element.clientWidth;\n    rect.height = element.clientHeight;\n    rect.x = rect.left;\n    rect.y = rect.top;\n    return rect;\n}\nfunction getClientRectFromMixedType(element, clippingParent, strategy) {\n    return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping parent\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\nfunction getClippingParents(element) {\n    var clippingParents = listScrollParents(getParentNode(element));\n    var canEscapeClipping = [\n        \"absolute\",\n        \"fixed\"\n    ].indexOf(getComputedStyle(element).position) >= 0;\n    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n    if (!isElement(clipperElement)) {\n        return [];\n    } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414\n    return clippingParents.filter(function(clippingParent) {\n        return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== \"body\";\n    });\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping parents\nfunction getClippingRect(element, boundary, rootBoundary, strategy) {\n    var mainClippingParents = boundary === \"clippingParents\" ? getClippingParents(element) : [].concat(boundary);\n    var clippingParents = [].concat(mainClippingParents, [\n        rootBoundary\n    ]);\n    var firstClippingParent = clippingParents[0];\n    var clippingRect = clippingParents.reduce(function(accRect, clippingParent) {\n        var rect = getClientRectFromMixedType(element, clippingParent, strategy);\n        accRect.top = max(rect.top, accRect.top);\n        accRect.right = min(rect.right, accRect.right);\n        accRect.bottom = min(rect.bottom, accRect.bottom);\n        accRect.left = max(rect.left, accRect.left);\n        return accRect;\n    }, getClientRectFromMixedType(element, firstClippingParent, strategy));\n    clippingRect.width = clippingRect.right - clippingRect.left;\n    clippingRect.height = clippingRect.bottom - clippingRect.top;\n    clippingRect.x = clippingRect.left;\n    clippingRect.y = clippingRect.top;\n    return clippingRect;\n}\nfunction computeOffsets(_ref) {\n    var reference = _ref.reference, element = _ref.element, placement = _ref.placement;\n    var basePlacement = placement ? getBasePlacement(placement) : null;\n    var variation = placement ? getVariation(placement) : null;\n    var commonX = reference.x + reference.width / 2 - element.width / 2;\n    var commonY = reference.y + reference.height / 2 - element.height / 2;\n    var offsets;\n    switch(basePlacement){\n        case top:\n            offsets = {\n                x: commonX,\n                y: reference.y - element.height\n            };\n            break;\n        case bottom:\n            offsets = {\n                x: commonX,\n                y: reference.y + reference.height\n            };\n            break;\n        case right:\n            offsets = {\n                x: reference.x + reference.width,\n                y: commonY\n            };\n            break;\n        case left:\n            offsets = {\n                x: reference.x - element.width,\n                y: commonY\n            };\n            break;\n        default:\n            offsets = {\n                x: reference.x,\n                y: reference.y\n            };\n    }\n    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;\n    if (mainAxis != null) {\n        var len = mainAxis === \"y\" ? \"height\" : \"width\";\n        switch(variation){\n            case start:\n                offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);\n                break;\n            case end:\n                offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);\n                break;\n        }\n    }\n    return offsets;\n}\nfunction detectOverflow(state, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;\n    var paddingObject = mergePaddingObject(typeof padding !== \"number\" ? padding : expandToHashMap(padding, basePlacements));\n    var altContext = elementContext === popper ? reference : popper;\n    var popperRect = state.rects.popper;\n    var element = state.elements[altBoundary ? altContext : elementContext];\n    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);\n    var referenceClientRect = getBoundingClientRect(state.elements.reference);\n    var popperOffsets = computeOffsets({\n        reference: referenceClientRect,\n        element: popperRect,\n        strategy: \"absolute\",\n        placement: placement\n    });\n    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));\n    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect\n    // 0 or negative = within the clipping rect\n    var overflowOffsets = {\n        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n        right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n    };\n    var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element\n    if (elementContext === popper && offsetData) {\n        var offset = offsetData[placement];\n        Object.keys(overflowOffsets).forEach(function(key) {\n            var multiply = [\n                right,\n                bottom\n            ].indexOf(key) >= 0 ? 1 : -1;\n            var axis = [\n                top,\n                bottom\n            ].indexOf(key) >= 0 ? \"y\" : \"x\";\n            overflowOffsets[key] += offset[axis] * multiply;\n        });\n    }\n    return overflowOffsets;\n}\nfunction computeAutoPlacement(state, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;\n    var variation = getVariation(placement);\n    var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement) {\n        return getVariation(placement) === variation;\n    }) : basePlacements;\n    var allowedPlacements = placements$1.filter(function(placement) {\n        return allowedAutoPlacements.indexOf(placement) >= 0;\n    });\n    if (allowedPlacements.length === 0) {\n        allowedPlacements = placements$1;\n        if (true) {\n            console.error([\n                \"Popper: The `allowedAutoPlacements` option did not allow any\",\n                \"placements. Ensure the `placement` option matches the variation\",\n                \"of the allowed placements.\",\n                'For example, \"auto\" cannot be used to allow \"bottom-start\".',\n                'Use \"auto-start\" instead.'\n            ].join(\" \"));\n        }\n    } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...\n    var overflows = allowedPlacements.reduce(function(acc, placement) {\n        acc[placement] = detectOverflow(state, {\n            placement: placement,\n            boundary: boundary,\n            rootBoundary: rootBoundary,\n            padding: padding\n        })[getBasePlacement(placement)];\n        return acc;\n    }, {});\n    return Object.keys(overflows).sort(function(a, b) {\n        return overflows[a] - overflows[b];\n    });\n}\nfunction getExpandedFallbackPlacements(placement) {\n    if (getBasePlacement(placement) === auto) {\n        return [];\n    }\n    var oppositePlacement = getOppositePlacement(placement);\n    return [\n        getOppositeVariationPlacement(placement),\n        oppositePlacement,\n        getOppositeVariationPlacement(oppositePlacement)\n    ];\n}\nfunction flip(_ref) {\n    var state = _ref.state, options = _ref.options, name = _ref.name;\n    if (state.modifiersData[name]._skip) {\n        return;\n    }\n    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;\n    var preferredPlacement = state.options.placement;\n    var basePlacement = getBasePlacement(preferredPlacement);\n    var isBasePlacement = basePlacement === preferredPlacement;\n    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [\n        getOppositePlacement(preferredPlacement)\n    ] : getExpandedFallbackPlacements(preferredPlacement));\n    var placements = [\n        preferredPlacement\n    ].concat(fallbackPlacements).reduce(function(acc, placement) {\n        return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {\n            placement: placement,\n            boundary: boundary,\n            rootBoundary: rootBoundary,\n            padding: padding,\n            flipVariations: flipVariations,\n            allowedAutoPlacements: allowedAutoPlacements\n        }) : placement);\n    }, []);\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var checksMap = new Map();\n    var makeFallbackChecks = true;\n    var firstFittingPlacement = placements[0];\n    for(var i = 0; i < placements.length; i++){\n        var placement = placements[i];\n        var _basePlacement = getBasePlacement(placement);\n        var isStartVariation = getVariation(placement) === start;\n        var isVertical = [\n            top,\n            bottom\n        ].indexOf(_basePlacement) >= 0;\n        var len = isVertical ? \"width\" : \"height\";\n        var overflow = detectOverflow(state, {\n            placement: placement,\n            boundary: boundary,\n            rootBoundary: rootBoundary,\n            altBoundary: altBoundary,\n            padding: padding\n        });\n        var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;\n        if (referenceRect[len] > popperRect[len]) {\n            mainVariationSide = getOppositePlacement(mainVariationSide);\n        }\n        var altVariationSide = getOppositePlacement(mainVariationSide);\n        var checks = [];\n        if (checkMainAxis) {\n            checks.push(overflow[_basePlacement] <= 0);\n        }\n        if (checkAltAxis) {\n            checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n        }\n        if (checks.every(function(check) {\n            return check;\n        })) {\n            firstFittingPlacement = placement;\n            makeFallbackChecks = false;\n            break;\n        }\n        checksMap.set(placement, checks);\n    }\n    if (makeFallbackChecks) {\n        // `2` may be desired in some cases – research later\n        var numberOfChecks = flipVariations ? 3 : 1;\n        var _loop = function _loop(_i) {\n            var fittingPlacement = placements.find(function(placement) {\n                var checks = checksMap.get(placement);\n                if (checks) {\n                    return checks.slice(0, _i).every(function(check) {\n                        return check;\n                    });\n                }\n            });\n            if (fittingPlacement) {\n                firstFittingPlacement = fittingPlacement;\n                return \"break\";\n            }\n        };\n        for(var _i = numberOfChecks; _i > 0; _i--){\n            var _ret = _loop(_i);\n            if (_ret === \"break\") break;\n        }\n    }\n    if (state.placement !== firstFittingPlacement) {\n        state.modifiersData[name]._skip = true;\n        state.placement = firstFittingPlacement;\n        state.reset = true;\n    }\n} // eslint-disable-next-line import/no-unused-modules\nvar flip$1 = {\n    name: \"flip\",\n    enabled: true,\n    phase: \"main\",\n    fn: flip,\n    requiresIfExists: [\n        \"offset\"\n    ],\n    data: {\n        _skip: false\n    }\n};\nfunction getSideOffsets(overflow, rect, preventedOffsets) {\n    if (preventedOffsets === void 0) {\n        preventedOffsets = {\n            x: 0,\n            y: 0\n        };\n    }\n    return {\n        top: overflow.top - rect.height - preventedOffsets.y,\n        right: overflow.right - rect.width + preventedOffsets.x,\n        bottom: overflow.bottom - rect.height + preventedOffsets.y,\n        left: overflow.left - rect.width - preventedOffsets.x\n    };\n}\nfunction isAnySideFullyClipped(overflow) {\n    return [\n        top,\n        right,\n        bottom,\n        left\n    ].some(function(side) {\n        return overflow[side] >= 0;\n    });\n}\nfunction hide(_ref) {\n    var state = _ref.state, name = _ref.name;\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var preventedOffsets = state.modifiersData.preventOverflow;\n    var referenceOverflow = detectOverflow(state, {\n        elementContext: \"reference\"\n    });\n    var popperAltOverflow = detectOverflow(state, {\n        altBoundary: true\n    });\n    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);\n    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);\n    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);\n    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\n    state.modifiersData[name] = {\n        referenceClippingOffsets: referenceClippingOffsets,\n        popperEscapeOffsets: popperEscapeOffsets,\n        isReferenceHidden: isReferenceHidden,\n        hasPopperEscaped: hasPopperEscaped\n    };\n    state.attributes.popper = Object.assign({}, state.attributes.popper, {\n        \"data-popper-reference-hidden\": isReferenceHidden,\n        \"data-popper-escaped\": hasPopperEscaped\n    });\n} // eslint-disable-next-line import/no-unused-modules\nvar hide$1 = {\n    name: \"hide\",\n    enabled: true,\n    phase: \"main\",\n    requiresIfExists: [\n        \"preventOverflow\"\n    ],\n    fn: hide\n};\nfunction distanceAndSkiddingToXY(placement, rects, offset) {\n    var basePlacement = getBasePlacement(placement);\n    var invertDistance = [\n        left,\n        top\n    ].indexOf(basePlacement) >= 0 ? -1 : 1;\n    var _ref = typeof offset === \"function\" ? offset(Object.assign({}, rects, {\n        placement: placement\n    })) : offset, skidding = _ref[0], distance = _ref[1];\n    skidding = skidding || 0;\n    distance = (distance || 0) * invertDistance;\n    return [\n        left,\n        right\n    ].indexOf(basePlacement) >= 0 ? {\n        x: distance,\n        y: skidding\n    } : {\n        x: skidding,\n        y: distance\n    };\n}\nfunction offset(_ref2) {\n    var state = _ref2.state, options = _ref2.options, name = _ref2.name;\n    var _options$offset = options.offset, offset = _options$offset === void 0 ? [\n        0,\n        0\n    ] : _options$offset;\n    var data = placements.reduce(function(acc, placement) {\n        acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);\n        return acc;\n    }, {});\n    var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;\n    if (state.modifiersData.popperOffsets != null) {\n        state.modifiersData.popperOffsets.x += x;\n        state.modifiersData.popperOffsets.y += y;\n    }\n    state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\nvar offset$1 = {\n    name: \"offset\",\n    enabled: true,\n    phase: \"main\",\n    requires: [\n        \"popperOffsets\"\n    ],\n    fn: offset\n};\nfunction popperOffsets(_ref) {\n    var state = _ref.state, name = _ref.name;\n    // Offsets are the actual position the popper needs to have to be\n    // properly positioned near its reference element\n    // This is the most basic placement, and will be adjusted by\n    // the modifiers in the next step\n    state.modifiersData[name] = computeOffsets({\n        reference: state.rects.reference,\n        element: state.rects.popper,\n        strategy: \"absolute\",\n        placement: state.placement\n    });\n} // eslint-disable-next-line import/no-unused-modules\nvar popperOffsets$1 = {\n    name: \"popperOffsets\",\n    enabled: true,\n    phase: \"read\",\n    fn: popperOffsets,\n    data: {}\n};\nfunction getAltAxis(axis) {\n    return axis === \"x\" ? \"y\" : \"x\";\n}\nfunction preventOverflow(_ref) {\n    var state = _ref.state, options = _ref.options, name = _ref.name;\n    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n    var overflow = detectOverflow(state, {\n        boundary: boundary,\n        rootBoundary: rootBoundary,\n        padding: padding,\n        altBoundary: altBoundary\n    });\n    var basePlacement = getBasePlacement(state.placement);\n    var variation = getVariation(state.placement);\n    var isBasePlacement = !variation;\n    var mainAxis = getMainAxisFromPlacement(basePlacement);\n    var altAxis = getAltAxis(mainAxis);\n    var popperOffsets = state.modifiersData.popperOffsets;\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var tetherOffsetValue = typeof tetherOffset === \"function\" ? tetherOffset(Object.assign({}, state.rects, {\n        placement: state.placement\n    })) : tetherOffset;\n    var normalizedTetherOffsetValue = typeof tetherOffsetValue === \"number\" ? {\n        mainAxis: tetherOffsetValue,\n        altAxis: tetherOffsetValue\n    } : Object.assign({\n        mainAxis: 0,\n        altAxis: 0\n    }, tetherOffsetValue);\n    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;\n    var data = {\n        x: 0,\n        y: 0\n    };\n    if (!popperOffsets) {\n        return;\n    }\n    if (checkMainAxis) {\n        var _offsetModifierState$;\n        var mainSide = mainAxis === \"y\" ? top : left;\n        var altSide = mainAxis === \"y\" ? bottom : right;\n        var len = mainAxis === \"y\" ? \"height\" : \"width\";\n        var offset = popperOffsets[mainAxis];\n        var min$1 = offset + overflow[mainSide];\n        var max$1 = offset - overflow[altSide];\n        var additive = tether ? -popperRect[len] / 2 : 0;\n        var minLen = variation === start ? referenceRect[len] : popperRect[len];\n        var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\n        // outside the reference bounds\n        var arrowElement = state.elements.arrow;\n        var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n            width: 0,\n            height: 0\n        };\n        var arrowPaddingObject = state.modifiersData[\"arrow#persistent\"] ? state.modifiersData[\"arrow#persistent\"].padding : getFreshSideObject();\n        var arrowPaddingMin = arrowPaddingObject[mainSide];\n        var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\n        // to include its full size in the calculation. If the reference is small\n        // and near the edge of a boundary, the popper can overflow even if the\n        // reference is not overflowing as well (e.g. virtual elements with no\n        // width or height)\n        var arrowLen = within(0, referenceRect[len], arrowRect[len]);\n        var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;\n        var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;\n        var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n        var clientOffset = arrowOffsetParent ? mainAxis === \"y\" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n        var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;\n        var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;\n        var tetherMax = offset + maxOffset - offsetModifierValue;\n        var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);\n        popperOffsets[mainAxis] = preventedOffset;\n        data[mainAxis] = preventedOffset - offset;\n    }\n    if (checkAltAxis) {\n        var _offsetModifierState$2;\n        var _mainSide = mainAxis === \"x\" ? top : left;\n        var _altSide = mainAxis === \"x\" ? bottom : right;\n        var _offset = popperOffsets[altAxis];\n        var _len = altAxis === \"y\" ? \"height\" : \"width\";\n        var _min = _offset + overflow[_mainSide];\n        var _max = _offset - overflow[_altSide];\n        var isOriginSide = [\n            top,\n            left\n        ].indexOf(basePlacement) !== -1;\n        var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;\n        var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;\n        var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;\n        var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);\n        popperOffsets[altAxis] = _preventedOffset;\n        data[altAxis] = _preventedOffset - _offset;\n    }\n    state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\nvar preventOverflow$1 = {\n    name: \"preventOverflow\",\n    enabled: true,\n    phase: \"main\",\n    fn: preventOverflow,\n    requiresIfExists: [\n        \"offset\"\n    ]\n};\nfunction getHTMLElementScroll(element) {\n    return {\n        scrollLeft: element.scrollLeft,\n        scrollTop: element.scrollTop\n    };\n}\nfunction getNodeScroll(node) {\n    if (node === getWindow(node) || !isHTMLElement(node)) {\n        return getWindowScroll(node);\n    } else {\n        return getHTMLElementScroll(node);\n    }\n}\nfunction isElementScaled(element) {\n    var rect = element.getBoundingClientRect();\n    var scaleX = round(rect.width) / element.offsetWidth || 1;\n    var scaleY = round(rect.height) / element.offsetHeight || 1;\n    return scaleX !== 1 || scaleY !== 1;\n} // Returns the composite rect of an element relative to its offsetParent.\n// Composite means it takes into account transforms as well as layout.\nfunction getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\n    if (isFixed === void 0) {\n        isFixed = false;\n    }\n    var isOffsetParentAnElement = isHTMLElement(offsetParent);\n    var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);\n    var documentElement = getDocumentElement(offsetParent);\n    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);\n    var scroll = {\n        scrollLeft: 0,\n        scrollTop: 0\n    };\n    var offsets = {\n        x: 0,\n        y: 0\n    };\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n        if (getNodeName(offsetParent) !== \"body\" || // https://github.com/popperjs/popper-core/issues/1078\n        isScrollParent(documentElement)) {\n            scroll = getNodeScroll(offsetParent);\n        }\n        if (isHTMLElement(offsetParent)) {\n            offsets = getBoundingClientRect(offsetParent, true);\n            offsets.x += offsetParent.clientLeft;\n            offsets.y += offsetParent.clientTop;\n        } else if (documentElement) {\n            offsets.x = getWindowScrollBarX(documentElement);\n        }\n    }\n    return {\n        x: rect.left + scroll.scrollLeft - offsets.x,\n        y: rect.top + scroll.scrollTop - offsets.y,\n        width: rect.width,\n        height: rect.height\n    };\n}\nfunction order(modifiers) {\n    var map = new Map();\n    var visited = new Set();\n    var result = [];\n    modifiers.forEach(function(modifier) {\n        map.set(modifier.name, modifier);\n    }); // On visiting object, check for its dependencies and visit them recursively\n    function sort(modifier) {\n        visited.add(modifier.name);\n        var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\n        requires.forEach(function(dep) {\n            if (!visited.has(dep)) {\n                var depModifier = map.get(dep);\n                if (depModifier) {\n                    sort(depModifier);\n                }\n            }\n        });\n        result.push(modifier);\n    }\n    modifiers.forEach(function(modifier) {\n        if (!visited.has(modifier.name)) {\n            // check for visited object\n            sort(modifier);\n        }\n    });\n    return result;\n}\nfunction orderModifiers(modifiers) {\n    // order based on dependencies\n    var orderedModifiers = order(modifiers); // order based on phase\n    return modifierPhases.reduce(function(acc, phase) {\n        return acc.concat(orderedModifiers.filter(function(modifier) {\n            return modifier.phase === phase;\n        }));\n    }, []);\n}\nfunction debounce(fn) {\n    var pending;\n    return function() {\n        if (!pending) {\n            pending = new Promise(function(resolve) {\n                Promise.resolve().then(function() {\n                    pending = undefined;\n                    resolve(fn());\n                });\n            });\n        }\n        return pending;\n    };\n}\nfunction format(str) {\n    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        args[_key - 1] = arguments[_key];\n    }\n    return [].concat(args).reduce(function(p, c) {\n        return p.replace(/%s/, c);\n    }, str);\n}\nvar INVALID_MODIFIER_ERROR = 'Popper: modifier \"%s\" provided an invalid %s property, expected %s but got %s';\nvar MISSING_DEPENDENCY_ERROR = 'Popper: modifier \"%s\" requires \"%s\", but \"%s\" modifier is not available';\nvar VALID_PROPERTIES = [\n    \"name\",\n    \"enabled\",\n    \"phase\",\n    \"fn\",\n    \"effect\",\n    \"requires\",\n    \"options\"\n];\nfunction validateModifiers(modifiers) {\n    modifiers.forEach(function(modifier) {\n        [].concat(Object.keys(modifier), VALID_PROPERTIES) // IE11-compatible replacement for `new Set(iterable)`\n        .filter(function(value, index, self) {\n            return self.indexOf(value) === index;\n        }).forEach(function(key) {\n            switch(key){\n                case \"name\":\n                    if (typeof modifier.name !== \"string\") {\n                        console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '\"name\"', '\"string\"', '\"' + String(modifier.name) + '\"'));\n                    }\n                    break;\n                case \"enabled\":\n                    if (typeof modifier.enabled !== \"boolean\") {\n                        console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"enabled\"', '\"boolean\"', '\"' + String(modifier.enabled) + '\"'));\n                    }\n                    break;\n                case \"phase\":\n                    if (modifierPhases.indexOf(modifier.phase) < 0) {\n                        console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"phase\"', \"either \" + modifierPhases.join(\", \"), '\"' + String(modifier.phase) + '\"'));\n                    }\n                    break;\n                case \"fn\":\n                    if (typeof modifier.fn !== \"function\") {\n                        console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"fn\"', '\"function\"', '\"' + String(modifier.fn) + '\"'));\n                    }\n                    break;\n                case \"effect\":\n                    if (modifier.effect != null && typeof modifier.effect !== \"function\") {\n                        console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"effect\"', '\"function\"', '\"' + String(modifier.fn) + '\"'));\n                    }\n                    break;\n                case \"requires\":\n                    if (modifier.requires != null && !Array.isArray(modifier.requires)) {\n                        console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"requires\"', '\"array\"', '\"' + String(modifier.requires) + '\"'));\n                    }\n                    break;\n                case \"requiresIfExists\":\n                    if (!Array.isArray(modifier.requiresIfExists)) {\n                        console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"requiresIfExists\"', '\"array\"', '\"' + String(modifier.requiresIfExists) + '\"'));\n                    }\n                    break;\n                case \"options\":\n                case \"data\":\n                    break;\n                default:\n                    console.error('PopperJS: an invalid property has been provided to the \"' + modifier.name + '\" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s) {\n                        return '\"' + s + '\"';\n                    }).join(\", \") + '; but \"' + key + '\" was provided.');\n            }\n            modifier.requires && modifier.requires.forEach(function(requirement) {\n                if (modifiers.find(function(mod) {\n                    return mod.name === requirement;\n                }) == null) {\n                    console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));\n                }\n            });\n        });\n    });\n}\nfunction uniqueBy(arr, fn) {\n    var identifiers = new Set();\n    return arr.filter(function(item) {\n        var identifier = fn(item);\n        if (!identifiers.has(identifier)) {\n            identifiers.add(identifier);\n            return true;\n        }\n    });\n}\nfunction mergeByName(modifiers) {\n    var merged = modifiers.reduce(function(merged, current) {\n        var existing = merged[current.name];\n        merged[current.name] = existing ? Object.assign({}, existing, current, {\n            options: Object.assign({}, existing.options, current.options),\n            data: Object.assign({}, existing.data, current.data)\n        }) : current;\n        return merged;\n    }, {}); // IE11 does not support Object.values\n    return Object.keys(merged).map(function(key) {\n        return merged[key];\n    });\n}\nvar INVALID_ELEMENT_ERROR = \"Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.\";\nvar INFINITE_LOOP_ERROR = \"Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.\";\nvar DEFAULT_OPTIONS = {\n    placement: \"bottom\",\n    modifiers: [],\n    strategy: \"absolute\"\n};\nfunction areValidElements() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    return !args.some(function(element) {\n        return !(element && typeof element.getBoundingClientRect === \"function\");\n    });\n}\nfunction popperGenerator(generatorOptions) {\n    if (generatorOptions === void 0) {\n        generatorOptions = {};\n    }\n    var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n    return function createPopper(reference, popper, options) {\n        if (options === void 0) {\n            options = defaultOptions;\n        }\n        var state = {\n            placement: \"bottom\",\n            orderedModifiers: [],\n            options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),\n            modifiersData: {},\n            elements: {\n                reference: reference,\n                popper: popper\n            },\n            attributes: {},\n            styles: {}\n        };\n        var effectCleanupFns = [];\n        var isDestroyed = false;\n        var instance = {\n            state: state,\n            setOptions: function setOptions(setOptionsAction) {\n                var options = typeof setOptionsAction === \"function\" ? setOptionsAction(state.options) : setOptionsAction;\n                cleanupModifierEffects();\n                state.options = Object.assign({}, defaultOptions, state.options, options);\n                state.scrollParents = {\n                    reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],\n                    popper: listScrollParents(popper)\n                }; // Orders the modifiers based on their dependencies and `phase`\n                // properties\n                var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\n                state.orderedModifiers = orderedModifiers.filter(function(m) {\n                    return m.enabled;\n                }); // Validate the provided modifiers so that the consumer will get warned\n                // if one of the modifiers is invalid for any reason\n                if (true) {\n                    var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {\n                        var name = _ref.name;\n                        return name;\n                    });\n                    validateModifiers(modifiers);\n                    if (getBasePlacement(state.options.placement) === auto) {\n                        var flipModifier = state.orderedModifiers.find(function(_ref2) {\n                            var name = _ref2.name;\n                            return name === \"flip\";\n                        });\n                        if (!flipModifier) {\n                            console.error([\n                                'Popper: \"auto\" placements require the \"flip\" modifier be',\n                                \"present and enabled to work.\"\n                            ].join(\" \"));\n                        }\n                    }\n                    var _getComputedStyle = getComputedStyle(popper), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can\n                    // cause bugs with positioning, so we'll warn the consumer\n                    if ([\n                        marginTop,\n                        marginRight,\n                        marginBottom,\n                        marginLeft\n                    ].some(function(margin) {\n                        return parseFloat(margin);\n                    })) {\n                        console.warn([\n                            'Popper: CSS \"margin\" styles cannot be used to apply padding',\n                            \"between the popper and its reference element or boundary.\",\n                            \"To replicate margin, use the `offset` modifier, as well as\",\n                            \"the `padding` option in the `preventOverflow` and `flip`\",\n                            \"modifiers.\"\n                        ].join(\" \"));\n                    }\n                }\n                runModifierEffects();\n                return instance.update();\n            },\n            // Sync update – it will always be executed, even if not necessary. This\n            // is useful for low frequency updates where sync behavior simplifies the\n            // logic.\n            // For high frequency updates (e.g. `resize` and `scroll` events), always\n            // prefer the async Popper#update method\n            forceUpdate: function forceUpdate() {\n                if (isDestroyed) {\n                    return;\n                }\n                var _state$elements = state.elements, reference = _state$elements.reference, popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\n                // anymore\n                if (!areValidElements(reference, popper)) {\n                    if (true) {\n                        console.error(INVALID_ELEMENT_ERROR);\n                    }\n                    return;\n                } // Store the reference and popper rects to be read by modifiers\n                state.rects = {\n                    reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === \"fixed\"),\n                    popper: getLayoutRect(popper)\n                }; // Modifiers have the ability to reset the current update cycle. The\n                // most common use case for this is the `flip` modifier changing the\n                // placement, which then needs to re-run all the modifiers, because the\n                // logic was previously ran for the previous placement and is therefore\n                // stale/incorrect\n                state.reset = false;\n                state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n                // is filled with the initial data specified by the modifier. This means\n                // it doesn't persist and is fresh on each update.\n                // To ensure persistent data, use `${name}#persistent`\n                state.orderedModifiers.forEach(function(modifier) {\n                    return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n                });\n                var __debug_loops__ = 0;\n                for(var index = 0; index < state.orderedModifiers.length; index++){\n                    if (true) {\n                        __debug_loops__ += 1;\n                        if (__debug_loops__ > 100) {\n                            console.error(INFINITE_LOOP_ERROR);\n                            break;\n                        }\n                    }\n                    if (state.reset === true) {\n                        state.reset = false;\n                        index = -1;\n                        continue;\n                    }\n                    var _state$orderedModifie = state.orderedModifiers[index], fn = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;\n                    if (typeof fn === \"function\") {\n                        state = fn({\n                            state: state,\n                            options: _options,\n                            name: name,\n                            instance: instance\n                        }) || state;\n                    }\n                }\n            },\n            // Async and optimistically optimized update – it will not be executed if\n            // not necessary (debounced to run at most once-per-tick)\n            update: debounce(function() {\n                return new Promise(function(resolve) {\n                    instance.forceUpdate();\n                    resolve(state);\n                });\n            }),\n            destroy: function destroy() {\n                cleanupModifierEffects();\n                isDestroyed = true;\n            }\n        };\n        if (!areValidElements(reference, popper)) {\n            if (true) {\n                console.error(INVALID_ELEMENT_ERROR);\n            }\n            return instance;\n        }\n        instance.setOptions(options).then(function(state) {\n            if (!isDestroyed && options.onFirstUpdate) {\n                options.onFirstUpdate(state);\n            }\n        }); // Modifiers have the ability to execute arbitrary code before the first\n        // update cycle runs. They will be executed in the same order as the update\n        // cycle. This is useful when a modifier adds some persistent data that\n        // other modifiers need to use, but the modifier is run after the dependent\n        // one.\n        function runModifierEffects() {\n            state.orderedModifiers.forEach(function(_ref3) {\n                var name = _ref3.name, _ref3$options = _ref3.options, options = _ref3$options === void 0 ? {} : _ref3$options, effect = _ref3.effect;\n                if (typeof effect === \"function\") {\n                    var cleanupFn = effect({\n                        state: state,\n                        name: name,\n                        instance: instance,\n                        options: options\n                    });\n                    var noopFn = function noopFn() {};\n                    effectCleanupFns.push(cleanupFn || noopFn);\n                }\n            });\n        }\n        function cleanupModifierEffects() {\n            effectCleanupFns.forEach(function(fn) {\n                return fn();\n            });\n            effectCleanupFns = [];\n        }\n        return instance;\n    };\n}\nvar defaultModifiers = [\n    eventListeners,\n    popperOffsets$1,\n    computeStyles$1,\n    applyStyles$1,\n    offset$1,\n    flip$1,\n    preventOverflow$1,\n    arrow$1,\n    hide$1\n];\nvar createPopper = /*#__PURE__*/ popperGenerator({\n    defaultModifiers: defaultModifiers\n}); // eslint-disable-next-line import/no-unused-modules\nvar usePopper = function(options) {\n    _s10();\n    var level = options.level, buttonRef = options.buttonRef, contentRef = options.contentRef;\n    var _a = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(SidebarContext), collapsed = _a.collapsed, toggled = _a.toggled, transitionDuration = _a.transitionDuration;\n    var popperInstanceRef = react__WEBPACK_IMPORTED_MODULE_0___default().useRef();\n    /**\r\n     * create popper instance only on first level submenu components and when sidebar is collapsed\r\n     */ react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        if (level === 0 && collapsed && contentRef.current && buttonRef.current) {\n            popperInstanceRef.current = createPopper(buttonRef.current, contentRef.current, {\n                placement: \"right\",\n                strategy: \"fixed\",\n                modifiers: [\n                    {\n                        name: \"offset\",\n                        options: {\n                            offset: [\n                                0,\n                                5\n                            ]\n                        }\n                    }\n                ]\n            });\n        }\n        return function() {\n            var _a;\n            return (_a = popperInstanceRef.current) === null || _a === void 0 ? void 0 : _a.destroy();\n        };\n    }, [\n        level,\n        collapsed,\n        contentRef,\n        buttonRef\n    ]);\n    /**\r\n     * update popper instance (position) when buttonRef or contentRef changes\r\n     */ react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        if (contentRef.current && buttonRef.current) {\n            var ro = new ResizeObserver(function() {\n                var _a;\n                (_a = popperInstanceRef.current) === null || _a === void 0 ? void 0 : _a.update();\n            });\n            ro.observe(contentRef.current);\n            ro.observe(buttonRef.current);\n        }\n        setTimeout(function() {\n            var _a;\n            (_a = popperInstanceRef.current) === null || _a === void 0 ? void 0 : _a.update();\n        }, transitionDuration);\n    }, [\n        transitionDuration,\n        toggled,\n        contentRef,\n        buttonRef\n    ]);\n    return {\n        popperInstance: popperInstanceRef.current\n    };\n};\n_s10(usePopper, \"tT6mQdtPDhet3blJBpJ/0aEKqZA=\");\nvar menuButtonStyles = function(props) {\n    var rtl = props.rtl, level = props.level, collapsed = props.collapsed, disabled = props.disabled, active = props.active;\n    return \"\\n    display: flex;\\n    align-items: center;\\n    height: 50px;\\n    text-decoration: none;\\n    color: inherit;\\n    box-sizing: border-box;\\n    cursor: pointer;\\n\\n    \".concat(rtl ? \"padding-left: 20px;\\n           padding-right: \".concat(level === 0 ? 20 : (collapsed ? level : level + 1) * 20, \"px;\\n            \") : \"padding-right: 20px;\\n           padding-left: \".concat(level === 0 ? 20 : (collapsed ? level : level + 1) * 20, \"px;\\n           \"), \"\\n\\n    &:hover {\\n      background-color: #f3f3f3;\\n    }\\n\\n    \").concat(disabled && \" \\n      pointer-events: none;\\n      cursor: default;\\n      color:#adadad;\\n        \", \"\\n\\n    \").concat(active && \"background-color: #e2eef9;\", \"\\n  \\n  \");\n};\nvar MenuButtonRef = function(_a, ref) {\n    var className = _a.className, component = _a.component, children = _a.children, rest = __rest(_a, [\n        \"className\",\n        \"component\",\n        \"children\"\n    ]);\n    if (component) {\n        if (typeof component === \"string\") {\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(component, __assign(__assign({\n                className: classnames(className)\n            }, rest), {\n                ref: ref\n            }), children);\n        } else {\n            var _b = component.props, classNameProp = _b.className, props = __rest(_b, [\n                \"className\"\n            ]);\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().cloneElement(component, __assign(__assign(__assign({\n                className: classnames(className, classNameProp)\n            }, rest), props), {\n                ref: ref\n            }), children);\n        }\n    } else {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"a\", __assign({\n            ref: ref,\n            className: classnames(className)\n        }, rest), children);\n    }\n};\n_c25 = MenuButtonRef;\nvar MenuButton = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().forwardRef(MenuButtonRef);\n_c26 = MenuButton;\nvar StyledSubMenu = newStyled.li(templateObject_1$1 || (templateObject_1$1 = __makeTemplateObject([\n    \"\\n  position: relative;\\n  width: 100%;\\n\\n  \",\n    \";\\n\\n  \",\n    \";\\n\\n  > .\",\n    \" {\\n    \",\n    \";\\n\\n    \",\n    \";\\n  }\\n\"\n], [\n    \"\\n  position: relative;\\n  width: 100%;\\n\\n  \",\n    \";\\n\\n  \",\n    \";\\n\\n  > .\",\n    \" {\\n    \",\n    \";\\n\\n    \",\n    \";\\n  }\\n\"\n])), function(_a) {\n    var menuItemStyles = _a.menuItemStyles;\n    return menuItemStyles;\n}, function(_a) {\n    var rootStyles = _a.rootStyles;\n    return rootStyles;\n}, menuClasses.button, function(_a) {\n    var level = _a.level, disabled = _a.disabled, active = _a.active, collapsed = _a.collapsed, rtl = _a.rtl;\n    return menuButtonStyles({\n        level: level,\n        disabled: disabled,\n        active: active,\n        collapsed: collapsed,\n        rtl: rtl\n    });\n}, function(_a) {\n    var buttonStyles = _a.buttonStyles;\n    return buttonStyles;\n});\n_c27 = StyledSubMenu;\nvar SubMenuFR = function(_a, ref) {\n    _s11();\n    var _b;\n    var children = _a.children, className = _a.className, label = _a.label, icon = _a.icon, title = _a.title, prefix = _a.prefix, suffix = _a.suffix, openControlled = _a.open, defaultOpen = _a.defaultOpen, _c = _a.active, active = _c === void 0 ? false : _c, _d = _a.disabled, disabled = _d === void 0 ? false : _d, rootStyles = _a.rootStyles, component = _a.component, onOpenChange = _a.onOpenChange, onClick = _a.onClick, onKeyUp = _a.onKeyUp, rest = __rest(_a, [\n        \"children\",\n        \"className\",\n        \"label\",\n        \"icon\",\n        \"title\",\n        \"prefix\",\n        \"suffix\",\n        \"open\",\n        \"defaultOpen\",\n        \"active\",\n        \"disabled\",\n        \"rootStyles\",\n        \"component\",\n        \"onOpenChange\",\n        \"onClick\",\n        \"onKeyUp\"\n    ]);\n    var level = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(LevelContext);\n    var _e = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(SidebarContext), collapsed = _e.collapsed, rtl = _e.rtl, sidebarTransitionDuration = _e.transitionDuration;\n    var _f = useMenu(), renderExpandIcon = _f.renderExpandIcon, closeOnClick = _f.closeOnClick, menuItemStyles = _f.menuItemStyles, transitionDuration = _f.transitionDuration;\n    var _g = react__WEBPACK_IMPORTED_MODULE_0___default().useState(!!defaultOpen), open = _g[0], setOpen = _g[1];\n    var _h = react__WEBPACK_IMPORTED_MODULE_0___default().useState(false), openWhenCollapsed = _h[0], setOpenWhenCollapsed = _h[1];\n    var _j = react__WEBPACK_IMPORTED_MODULE_0___default().useState(false), mounted = _j[0], setMounted = _j[1];\n    var buttonRef = react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null);\n    var contentRef = react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null);\n    var timer = react__WEBPACK_IMPORTED_MODULE_0___default().useRef();\n    var popperInstance = usePopper({\n        level: level,\n        buttonRef: buttonRef,\n        contentRef: contentRef\n    }).popperInstance;\n    var slideUp = function() {\n        var target = contentRef.current;\n        if (target) {\n            target.style.display = \"block\";\n            target.style.overflow = \"hidden\";\n            target.style.height = \"auto\";\n            var height = target.offsetHeight;\n            target.style.height = \"0px\";\n            target.offsetHeight;\n            target.style.height = \"\".concat(height, \"px\");\n            timer.current = setTimeout(function() {\n                target.style.overflow = \"auto\";\n                target.style.height = \"auto\";\n            }, transitionDuration);\n        }\n    };\n    var slideDown = function() {\n        var target = contentRef.current;\n        if (target) {\n            target.style.overflow = \"hidden\";\n            target.style.height = \"\".concat(target.offsetHeight, \"px\");\n            target.offsetHeight;\n            target.style.height = \"0px\";\n            timer.current = setTimeout(function() {\n                target.style.overflow = \"auto\";\n                target.style.display = \"none\";\n            }, transitionDuration);\n        }\n    };\n    var handleSlideToggle = function() {\n        if (!(level === 0 && collapsed)) {\n            clearTimeout(Number(timer.current));\n            var openValue = openControlled !== null && openControlled !== void 0 ? openControlled : open;\n            openValue ? slideDown() : slideUp();\n            onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(!openValue);\n            typeof openControlled === \"undefined\" && setOpen(!open);\n        }\n    };\n    var handleOnClick = function(event) {\n        onClick === null || onClick === void 0 ? void 0 : onClick(event);\n        handleSlideToggle();\n    };\n    var handleOnKeyUp = function(event) {\n        onKeyUp === null || onKeyUp === void 0 ? void 0 : onKeyUp(event);\n        if (event.key === \"Enter\") {\n            handleSlideToggle();\n        }\n    };\n    var getSubMenuItemStyles = function(element) {\n        if (menuItemStyles) {\n            var params = {\n                level: level,\n                disabled: disabled,\n                active: active,\n                isSubmenu: true,\n                open: openControlled !== null && openControlled !== void 0 ? openControlled : open\n            };\n            var rootElStyles = menuItemStyles.root, buttonElStyles = menuItemStyles.button, labelElStyles = menuItemStyles.label, iconElStyles = menuItemStyles.icon, prefixElStyles = menuItemStyles.prefix, suffixElStyles = menuItemStyles.suffix, subMenuContentElStyles = menuItemStyles.subMenuContent, SubMenuExpandIconElStyles = menuItemStyles.SubMenuExpandIcon;\n            switch(element){\n                case \"root\":\n                    return typeof rootElStyles === \"function\" ? rootElStyles(params) : rootElStyles;\n                case \"button\":\n                    return typeof buttonElStyles === \"function\" ? buttonElStyles(params) : buttonElStyles;\n                case \"label\":\n                    return typeof labelElStyles === \"function\" ? labelElStyles(params) : labelElStyles;\n                case \"icon\":\n                    return typeof iconElStyles === \"function\" ? iconElStyles(params) : iconElStyles;\n                case \"prefix\":\n                    return typeof prefixElStyles === \"function\" ? prefixElStyles(params) : prefixElStyles;\n                case \"suffix\":\n                    return typeof suffixElStyles === \"function\" ? suffixElStyles(params) : suffixElStyles;\n                case \"SubMenuExpandIcon\":\n                    return typeof SubMenuExpandIconElStyles === \"function\" ? SubMenuExpandIconElStyles(params) : SubMenuExpandIconElStyles;\n                case \"subMenuContent\":\n                    return typeof subMenuContentElStyles === \"function\" ? subMenuContentElStyles(params) : subMenuContentElStyles;\n                default:\n                    return undefined;\n            }\n        }\n    };\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        setTimeout(function() {\n            return popperInstance === null || popperInstance === void 0 ? void 0 : popperInstance.update();\n        }, sidebarTransitionDuration);\n        if (collapsed && level === 0) {\n            setOpenWhenCollapsed(false);\n        // ? if its useful to close first level submenus on collapse sidebar uncomment the code below\n        // setOpen(false);\n        }\n    }, [\n        collapsed,\n        level,\n        rtl,\n        sidebarTransitionDuration,\n        popperInstance\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        var handleTogglePopper = function(target) {\n            var _a, _b, _c;\n            if (!openWhenCollapsed && ((_a = buttonRef.current) === null || _a === void 0 ? void 0 : _a.contains(target))) setOpenWhenCollapsed(true);\n            else if (closeOnClick && !((_b = target.closest(\".\".concat(menuClasses.menuItemRoot))) === null || _b === void 0 ? void 0 : _b.classList.contains(menuClasses.subMenuRoot)) || !((_c = contentRef.current) === null || _c === void 0 ? void 0 : _c.contains(target)) && openWhenCollapsed) {\n                setOpenWhenCollapsed(false);\n            }\n        };\n        var handleDocumentClick = function(event) {\n            handleTogglePopper(event.target);\n        };\n        var handleDocumentKeyUp = function(event) {\n            if (event.key === \"Enter\") {\n                handleTogglePopper(event.target);\n            } else if (event.key === \"Escape\") {\n                setOpenWhenCollapsed(false);\n            }\n        };\n        var removeEventListeners = function() {\n            document.removeEventListener(\"click\", handleDocumentClick);\n            document.removeEventListener(\"keyup\", handleDocumentKeyUp);\n        };\n        removeEventListeners();\n        if (collapsed && level === 0) {\n            document.addEventListener(\"click\", handleDocumentClick, false);\n            document.addEventListener(\"keyup\", handleDocumentKeyUp, false);\n        }\n        return function() {\n            removeEventListeners();\n        };\n    }, [\n        collapsed,\n        level,\n        closeOnClick,\n        openWhenCollapsed\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        setMounted(true);\n    }, []);\n    var sharedClasses = (_b = {}, _b[menuClasses.active] = active, _b[menuClasses.disabled] = disabled, _b[menuClasses.open] = openControlled !== null && openControlled !== void 0 ? openControlled : open, _b);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledSubMenu, {\n        ref: ref,\n        className: classnames(menuClasses.menuItemRoot, menuClasses.subMenuRoot, sharedClasses, className),\n        menuItemStyles: getSubMenuItemStyles(\"root\"),\n        level: level,\n        collapsed: collapsed,\n        rtl: rtl,\n        disabled: disabled,\n        active: active,\n        buttonStyles: getSubMenuItemStyles(\"button\"),\n        rootStyles: rootStyles\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(MenuButton, __assign({\n        \"data-testid\": \"\".concat(menuClasses.button, \"-test-id\"),\n        ref: buttonRef,\n        title: title,\n        className: classnames(menuClasses.button, sharedClasses),\n        onClick: handleOnClick,\n        onKeyUp: handleOnKeyUp,\n        component: component,\n        tabIndex: 0\n    }, rest), icon && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledMenuIcon, {\n        rtl: rtl,\n        className: classnames(menuClasses.icon, sharedClasses),\n        rootStyles: getSubMenuItemStyles(\"icon\")\n    }, icon), prefix && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledMenuPrefix, {\n        collapsed: collapsed,\n        transitionDuration: sidebarTransitionDuration,\n        firstLevel: level === 0,\n        className: classnames(menuClasses.prefix, sharedClasses),\n        rtl: rtl,\n        rootStyles: getSubMenuItemStyles(\"prefix\")\n    }, prefix), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledMenuLabel, {\n        className: classnames(menuClasses.label, sharedClasses),\n        rootStyles: getSubMenuItemStyles(\"label\")\n    }, label), suffix && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledMenuSuffix, {\n        collapsed: collapsed,\n        transitionDuration: sidebarTransitionDuration,\n        firstLevel: level === 0,\n        className: classnames(menuClasses.suffix, sharedClasses),\n        rootStyles: getSubMenuItemStyles(\"suffix\")\n    }, suffix), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledExpandIconWrapper, {\n        rtl: rtl,\n        className: classnames(menuClasses.SubMenuExpandIcon, sharedClasses),\n        collapsed: collapsed,\n        level: level,\n        rootStyles: getSubMenuItemStyles(\"SubMenuExpandIcon\")\n    }, renderExpandIcon ? renderExpandIcon({\n        level: level,\n        disabled: disabled,\n        active: active,\n        open: openControlled !== null && openControlled !== void 0 ? openControlled : open\n    }) : collapsed && level === 0 ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledExpandIconCollapsed, null) : /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledExpandIcon, {\n        rtl: rtl,\n        open: openControlled !== null && openControlled !== void 0 ? openControlled : open\n    }))), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(SubMenuContent, {\n        ref: contentRef,\n        openWhenCollapsed: openWhenCollapsed,\n        open: openControlled !== null && openControlled !== void 0 ? openControlled : open,\n        firstLevel: level === 0,\n        collapsed: collapsed,\n        defaultOpen: openControlled && !mounted || defaultOpen,\n        className: classnames(menuClasses.subMenuContent, sharedClasses),\n        rootStyles: getSubMenuItemStyles(\"subMenuContent\")\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(LevelContext.Provider, {\n        value: level + 1\n    }, children)));\n};\n_s11(SubMenuFR, \"lyJU/i8dohr6UdNApWdYjuIUPGA=\", false, function() {\n    return [\n        useMenu,\n        useMenu,\n        useMenu,\n        useMenu,\n        useMenu,\n        usePopper\n    ];\n});\n_c28 = SubMenuFR;\nvar SubMenu = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().forwardRef(SubMenuFR);\n_c29 = SubMenu;\nvar templateObject_1$1;\nvar StyledMenuItem = newStyled.li(templateObject_1 || (templateObject_1 = __makeTemplateObject([\n    \"\\n  width: 100%;\\n  position: relative;\\n\\n  \",\n    \";\\n\\n  \",\n    \";\\n\\n  > .\",\n    \" {\\n    \",\n    \";\\n\\n    \",\n    \";\\n  }\\n\"\n], [\n    \"\\n  width: 100%;\\n  position: relative;\\n\\n  \",\n    \";\\n\\n  \",\n    \";\\n\\n  > .\",\n    \" {\\n    \",\n    \";\\n\\n    \",\n    \";\\n  }\\n\"\n])), function(_a) {\n    var menuItemStyles = _a.menuItemStyles;\n    return menuItemStyles;\n}, function(_a) {\n    var rootStyles = _a.rootStyles;\n    return rootStyles;\n}, menuClasses.button, function(_a) {\n    var level = _a.level, disabled = _a.disabled, active = _a.active, collapsed = _a.collapsed, rtl = _a.rtl;\n    return menuButtonStyles({\n        level: level,\n        disabled: disabled,\n        active: active,\n        collapsed: collapsed,\n        rtl: rtl\n    });\n}, function(_a) {\n    var buttonStyles = _a.buttonStyles;\n    return buttonStyles;\n});\n_c30 = StyledMenuItem;\nvar MenuItemFR = function(_a, ref) {\n    _s12();\n    var _b;\n    var children = _a.children, icon = _a.icon, className = _a.className, prefix = _a.prefix, suffix = _a.suffix, _c = _a.active, active = _c === void 0 ? false : _c, _d = _a.disabled, disabled = _d === void 0 ? false : _d, component = _a.component, rootStyles = _a.rootStyles, rest = __rest(_a, [\n        \"children\",\n        \"icon\",\n        \"className\",\n        \"prefix\",\n        \"suffix\",\n        \"active\",\n        \"disabled\",\n        \"component\",\n        \"rootStyles\"\n    ]);\n    var level = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(LevelContext);\n    var _e = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(SidebarContext), collapsed = _e.collapsed, rtl = _e.rtl, transitionDuration = _e.transitionDuration;\n    var menuItemStyles = useMenu().menuItemStyles;\n    var getMenuItemStyles = function(element) {\n        if (menuItemStyles) {\n            var params = {\n                level: level,\n                disabled: disabled,\n                active: active,\n                isSubmenu: false\n            };\n            var rootElStyles = menuItemStyles.root, buttonElStyles = menuItemStyles.button, labelElStyles = menuItemStyles.label, iconElStyles = menuItemStyles.icon, prefixElStyles = menuItemStyles.prefix, suffixElStyles = menuItemStyles.suffix;\n            switch(element){\n                case \"root\":\n                    return typeof rootElStyles === \"function\" ? rootElStyles(params) : rootElStyles;\n                case \"button\":\n                    return typeof buttonElStyles === \"function\" ? buttonElStyles(params) : buttonElStyles;\n                case \"label\":\n                    return typeof labelElStyles === \"function\" ? labelElStyles(params) : labelElStyles;\n                case \"icon\":\n                    return typeof iconElStyles === \"function\" ? iconElStyles(params) : iconElStyles;\n                case \"prefix\":\n                    return typeof prefixElStyles === \"function\" ? prefixElStyles(params) : prefixElStyles;\n                case \"suffix\":\n                    return typeof suffixElStyles === \"function\" ? suffixElStyles(params) : suffixElStyles;\n                default:\n                    return undefined;\n            }\n        }\n    };\n    var sharedClasses = (_b = {}, _b[menuClasses.active] = active, _b[menuClasses.disabled] = disabled, _b);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledMenuItem, {\n        ref: ref,\n        className: classnames(menuClasses.menuItemRoot, sharedClasses, className),\n        menuItemStyles: getMenuItemStyles(\"root\"),\n        level: level,\n        collapsed: collapsed,\n        rtl: rtl,\n        disabled: disabled,\n        active: active,\n        buttonStyles: getMenuItemStyles(\"button\"),\n        rootStyles: rootStyles\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(MenuButton, __assign({\n        className: classnames(menuClasses.button, sharedClasses),\n        \"data-testid\": \"\".concat(menuClasses.button, \"-test-id\"),\n        component: component,\n        tabIndex: 0\n    }, rest), icon && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledMenuIcon, {\n        rtl: rtl,\n        className: classnames(menuClasses.icon, sharedClasses),\n        rootStyles: getMenuItemStyles(\"icon\")\n    }, icon), prefix && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledMenuPrefix, {\n        collapsed: collapsed,\n        transitionDuration: transitionDuration,\n        firstLevel: level === 0,\n        className: classnames(menuClasses.prefix, sharedClasses),\n        rtl: rtl,\n        rootStyles: getMenuItemStyles(\"prefix\")\n    }, prefix), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledMenuLabel, {\n        className: classnames(menuClasses.label, sharedClasses),\n        rootStyles: getMenuItemStyles(\"label\")\n    }, children), suffix && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledMenuSuffix, {\n        collapsed: collapsed,\n        transitionDuration: transitionDuration,\n        firstLevel: level === 0,\n        className: classnames(menuClasses.suffix, sharedClasses),\n        rootStyles: getMenuItemStyles(\"suffix\")\n    }, suffix)));\n};\n_s12(MenuItemFR, \"Jzpvl5TSB7KuLjyKYrsLZ+5oAvc=\", false, function() {\n    return [\n        useMenu\n    ];\n});\n_c31 = MenuItemFR;\nvar MenuItem = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().forwardRef(MenuItemFR);\n_c32 = MenuItem;\nvar templateObject_1;\n/**\r\n * @deprecated\r\n * `ProSidebarProvider` is deprecated and will be removed in the next major release.\r\n */ var ProSidebarProvider = function(_a) {\n    var children = _a.children;\n    console.warn(\"ProSidebarProvider is deprecated and will be removed in the next major release.\");\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(SidebarProvider, null, children);\n};\n_c33 = ProSidebarProvider;\n/**\r\n * @deprecated\r\n * `useProSidebar` is deprecated and will be removed in the next major release.\r\n *  please use Sidebar props instead.\r\n */ var useProSidebar = function() {\n    _s13();\n    var legacySidebarContext = useLegacySidebar();\n    if (legacySidebarContext === undefined) {\n        throw new Error(\"useProSidebar must be used within a ProSidebarProvider. Please wrap your component with a ProSidebarProvider to use this hook.\");\n    }\n    var collapseSidebar = react__WEBPACK_IMPORTED_MODULE_0___default().useCallback(function(value) {\n        if (value === undefined) legacySidebarContext.updateCollapseState();\n        else legacySidebarContext.updateSidebarState({\n            collapsed: value\n        });\n    }, // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        legacySidebarContext.updateCollapseState,\n        legacySidebarContext.updateSidebarState\n    ]);\n    var toggleSidebar = react__WEBPACK_IMPORTED_MODULE_0___default().useCallback(function(value) {\n        if (value === undefined) legacySidebarContext.updateToggleState();\n        else legacySidebarContext.updateSidebarState({\n            toggled: value\n        });\n    }, // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        legacySidebarContext.updateToggleState,\n        legacySidebarContext.updateSidebarState\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        console.warn(\"useProSidebar is deprecated and will be removed in the next major release. Please use Sidebar props instead.\");\n    }, []);\n    return {\n        collapseSidebar: collapseSidebar,\n        toggleSidebar: toggleSidebar,\n        collapsed: !!legacySidebarContext.collapsed,\n        broken: !!legacySidebarContext.broken,\n        toggled: !!legacySidebarContext.toggled,\n        rtl: !!legacySidebarContext.rtl\n    };\n};\n_s13(useProSidebar, \"pu5JjpMWvRh8PSpXkWSJjUfsDl4=\", false, function() {\n    return [\n        useLegacySidebar\n    ];\n});\n\nvar _c, _c1, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9, _c10, _c11, _c12, _c13, _c14, _c15, _c16, _c17, _c18, _c19, _c20, _c21, _c22, _c23, _c24, _c25, _c26, _c27, _c28, _c29, _c30, _c31, _c32, _c33;\n$RefreshReg$(_c, \"Insertion$1\");\n$RefreshReg$(_c1, \"Emotion$withEmotionCache\");\n$RefreshReg$(_c2, \"Emotion\");\n$RefreshReg$(_c3, \"Insertion\");\n$RefreshReg$(_c4, \"SidebarProvider\");\n$RefreshReg$(_c5, \"StyledBackdrop\");\n$RefreshReg$(_c6, \"StyledSidebar\");\n$RefreshReg$(_c7, \"StyledSidebarContainer\");\n$RefreshReg$(_c8, \"StyledSidebarImage\");\n$RefreshReg$(_c9, \"Sidebar$React__default.forwardRef\");\n$RefreshReg$(_c10, \"Sidebar\");\n$RefreshReg$(_c11, \"StyledUl\");\n$RefreshReg$(_c12, \"StyledMenu\");\n$RefreshReg$(_c13, \"MenuFR\");\n$RefreshReg$(_c14, \"Menu\");\n$RefreshReg$(_c15, \"StyledSubMenuContent\");\n$RefreshReg$(_c16, \"SubMenuContentFR\");\n$RefreshReg$(_c17, \"SubMenuContent\");\n$RefreshReg$(_c18, \"StyledMenuLabel\");\n$RefreshReg$(_c19, \"StyledMenuIcon\");\n$RefreshReg$(_c20, \"StyledMenuPrefix\");\n$RefreshReg$(_c21, \"StyledMenuSuffix\");\n$RefreshReg$(_c22, \"StyledExpandIconWrapper\");\n$RefreshReg$(_c23, \"StyledExpandIcon\");\n$RefreshReg$(_c24, \"StyledExpandIconCollapsed\");\n$RefreshReg$(_c25, \"MenuButtonRef\");\n$RefreshReg$(_c26, \"MenuButton\");\n$RefreshReg$(_c27, \"StyledSubMenu\");\n$RefreshReg$(_c28, \"SubMenuFR\");\n$RefreshReg$(_c29, \"SubMenu\");\n$RefreshReg$(_c30, \"StyledMenuItem\");\n$RefreshReg$(_c31, \"MenuItemFR\");\n$RefreshReg$(_c32, \"MenuItem\");\n$RefreshReg$(_c33, \"ProSidebarProvider\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wcm8tc2lkZWJhci9kaXN0L2luZGV4LmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0I7QUFDd0U7QUFFdkc7Ozs7Ozs7Ozs7Ozs7OEVBYThFLEdBRTlFLElBQUlPLFdBQVc7SUFDWEEsV0FBV0MsT0FBT0MsTUFBTSxJQUFJLFNBQVNGLFNBQVNHLENBQUM7UUFDM0MsSUFBSyxJQUFJQyxHQUFHQyxJQUFJLEdBQUdDLElBQUlDLFVBQVVDLE1BQU0sRUFBRUgsSUFBSUMsR0FBR0QsSUFBSztZQUNqREQsSUFBSUcsU0FBUyxDQUFDRixFQUFFO1lBQ2hCLElBQUssSUFBSUksS0FBS0wsRUFBRyxJQUFJSCxPQUFPUyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDUixHQUFHSyxJQUFJTixDQUFDLENBQUNNLEVBQUUsR0FBR0wsQ0FBQyxDQUFDSyxFQUFFO1FBQ2hGO1FBQ0EsT0FBT047SUFDWDtJQUNBLE9BQU9ILFNBQVNhLEtBQUssQ0FBQyxJQUFJLEVBQUVOO0FBQ2hDO0FBRUEsU0FBU08sT0FBT1YsQ0FBQyxFQUFFVyxDQUFDO0lBQ2hCLElBQUlaLElBQUksQ0FBQztJQUNULElBQUssSUFBSU0sS0FBS0wsRUFBRyxJQUFJSCxPQUFPUyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDUixHQUFHSyxNQUFNTSxFQUFFQyxPQUFPLENBQUNQLEtBQUssR0FDOUVOLENBQUMsQ0FBQ00sRUFBRSxHQUFHTCxDQUFDLENBQUNLLEVBQUU7SUFDZixJQUFJTCxLQUFLLFFBQVEsT0FBT0gsT0FBT2dCLHFCQUFxQixLQUFLLFlBQ3JELElBQUssSUFBSVosSUFBSSxHQUFHSSxJQUFJUixPQUFPZ0IscUJBQXFCLENBQUNiLElBQUlDLElBQUlJLEVBQUVELE1BQU0sRUFBRUgsSUFBSztRQUNwRSxJQUFJVSxFQUFFQyxPQUFPLENBQUNQLENBQUMsQ0FBQ0osRUFBRSxJ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UTBjLElBQUksQ0FBQztJQUNqQixHQUFHLEVBQUU7SUFDTCxPQUFPO1FBQ0graUIsaUJBQWlCQTtRQUNqQkMsZUFBZUE7UUFDZi9uQixXQUFXLENBQUMsQ0FBQ3FGLHFCQUFxQnJGLFNBQVM7UUFDM0NFLFFBQVEsQ0FBQyxDQUFDbUYscUJBQXFCbkYsTUFBTTtRQUNyQ0QsU0FBUyxDQUFDLENBQUNvRixxQkFBcUJwRixPQUFPO1FBQ3ZDRSxLQUFLLENBQUMsQ0FBQ2tGLHFCQUFxQmxGLEdBQUc7SUFDbkM7QUFDSjtLQWhDSTBuQjs7UUFDMkI3bUI7OztBQWlDK0kiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXByby1zaWRlYmFyL2Rpc3QvaW5kZXguZXMuanM/NzM4MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RfX2RlZmF1bHQsIHsgZm9yd2FyZFJlZiwgdXNlQ29udGV4dCwgY3JlYXRlRWxlbWVudCwgY3JlYXRlQ29udGV4dCwgRnJhZ21lbnQgfSBmcm9tICdyZWFjdCc7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn1cblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIG1lbW9pemUoZm4pIHtcbiAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhcmcpIHtcbiAgICBpZiAoY2FjaGVbYXJnXSA9PT0gdW5kZWZpbmVkKSBjYWNoZVthcmddID0gZm4oYXJnKTtcbiAgICByZXR1cm4gY2FjaGVbYXJnXTtcbiAgfTtcbn1cblxudmFyIHJlYWN0UHJvcHNSZWdleCA9IC9eKChjaGlsZHJlbnxkYW5nZXJvdXNseVNldElubmVySFRNTHxrZXl8cmVmfGF1dG9Gb2N1c3xkZWZhdWx0VmFsdWV8ZGVmYXVsdENoZWNrZWR8aW5uZXJIVE1MfHN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ3xzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmd8dmFsdWVMaW5rfGFiYnJ8YWNjZXB0fGFjY2VwdENoYXJzZXR8YWNjZXNzS2V5fGFjdGlvbnxhbGxvd3xhbGxvd1VzZXJNZWRpYXxhbGxvd1BheW1lbnRSZXF1ZXN0fGFsbG93RnVsbFNjcmVlbnxhbGxvd1RyYW5zcGFyZW5jeXxhbHR8YXN5bmN8YXV0b0NvbXBsZXRlfGF1dG9QbGF5fGNhcHR1cmV8Y2VsbFBhZGRpbmd8Y2VsbFNwYWNpbmd8Y2hhbGxlbmdlfGNoYXJTZXR8Y2hlY2tlZHxjaXRlfGNsYXNzSUR8Y2xhc3NOYW1lfGNvbHN8Y29sU3Bhbnxjb250ZW50fGNvbnRlbnRFZGl0YWJsZXxjb250ZXh0TWVudXxjb250cm9sc3xjb250cm9sc0xpc3R8Y29vcmRzfGNyb3NzT3JpZ2lufGRhdGF8ZGF0ZVRpbWV8ZGVjb2Rpbmd8ZGVmYXVsdHxkZWZlcnxkaXJ8ZGlzYWJsZWR8ZGlzYWJsZVBpY3R1cmVJblBpY3R1cmV8ZG93bmxvYWR8ZHJhZ2dhYmxlfGVuY1R5cGV8ZW50ZXJLZXlIaW50fGZvcm18Zm9ybUFjdGlvbnxmb3JtRW5jVHlwZXxmb3JtTWV0aG9kfGZvcm1Ob1ZhbGlkYXRlfGZvcm1UYXJnZXR8ZnJhbWVCb3JkZXJ8aGVhZGVyc3xoZWlnaHR8aGlkZGVufGhpZ2h8aHJlZnxocmVmTGFuZ3xodG1sRm9yfGh0dHBFcXVpdnxpZHxpbnB1dE1vZGV8aW50ZWdyaXR5fGlzfGtleVBhcmFtc3xrZXlUeXBlfGtpbmR8bGFiZWx8bGFuZ3xsaXN0fGxvYWRpbmd8bG9vcHxsb3d8bWFyZ2luSGVpZ2h0fG1hcmdpbldpZHRofG1heHxtYXhMZW5ndGh8bWVkaWF8bWVkaWFHcm91cHxtZXRob2R8bWlufG1pbkxlbmd0aHxtdWx0aXBsZXxtdXRlZHxuYW1lfG5vbmNlfG5vVmFsaWRhdGV8b3BlbnxvcHRpbXVtfHBhdHRlcm58cGxhY2Vob2xkZXJ8cGxheXNJbmxpbmV8cG9zdGVyfHByZWxvYWR8cHJvZmlsZXxyYWRpb0dyb3VwfHJlYWRPbmx5fHJlZmVycmVyUG9saWN5fHJlbHxyZXF1aXJlZHxyZXZlcnNlZHxyb2xlfHJvd3N8cm93U3BhbnxzYW5kYm94fHNjb3BlfHNjb3BlZHxzY3JvbGxpbmd8c2VhbWxlc3N8c2VsZWN0ZWR8c2hhcGV8c2l6ZXxzaXplc3xzbG90fHNwYW58c3BlbGxDaGVja3xzcmN8c3JjRG9jfHNyY0xhbmd8c3JjU2V0fHN0YXJ0fHN0ZXB8c3R5bGV8c3VtbWFyeXx0YWJJbmRleHx0YXJnZXR8dGl0bGV8dHJhbnNsYXRlfHR5cGV8dXNlTWFwfHZhbHVlfHdpZHRofHdtb2RlfHdyYXB8YWJvdXR8ZGF0YXR5cGV8aW5saXN0fHByZWZpeHxwcm9wZXJ0eXxyZXNvdXJjZXx0eXBlb2Z8dm9jYWJ8YXV0b0NhcGl0YWxpemV8YXV0b0NvcnJlY3R8YXV0b1NhdmV8Y29sb3J8aW5jcmVtZW50YWx8ZmFsbGJhY2t8aW5lcnR8aXRlbVByb3B8aXRlbVNjb3BlfGl0ZW1UeXBlfGl0ZW1JRHxpdGVtUmVmfG9ufG9wdGlvbnxyZXN1bHRzfHNlY3VyaXR5fHVuc2VsZWN0YWJsZXxhY2NlbnRIZWlnaHR8YWNjdW11bGF0ZXxhZGRpdGl2ZXxhbGlnbm1lbnRCYXNlbGluZXxhbGxvd1Jlb3JkZXJ8YWxwaGFiZXRpY3xhbXBsaXR1ZGV8YXJhYmljRm9ybXxhc2NlbnR8YXR0cmlidXRlTmFtZXxhdHRyaWJ1dGVUeXBlfGF1dG9SZXZlcnNlfGF6aW11dGh8YmFzZUZyZXF1ZW5jeXxiYXNlbGluZVNoaWZ0fGJhc2VQcm9maWxlfGJib3h8YmVnaW58Ymlhc3xieXxjYWxjTW9kZXxjYXBIZWlnaHR8Y2xpcHxjbGlwUGF0aFVuaXRzfGNsaXBQYXRofGNsaXBSdWxlfGNvbG9ySW50ZXJwb2xhdGlvbnxjb2xvckludGVycG9sYXRpb25GaWx0ZXJzfGNvbG9yUHJvZmlsZXxjb2xvclJlbmRlcmluZ3xjb250ZW50U2NyaXB0VHlwZXxjb250ZW50U3R5bGVUeXBlfGN1cnNvcnxjeHxjeXxkfGRlY2VsZXJhdGV8ZGVzY2VudHxkaWZmdXNlQ29uc3RhbnR8ZGlyZWN0aW9ufGRpc3BsYXl8ZGl2aXNvcnxkb21pbmFudEJhc2VsaW5lfGR1cnxkeHxkeXxlZGdlTW9kZXxlbGV2YXRpb258ZW5hYmxlQmFja2dyb3VuZHxlbmR8ZXhwb25lbnR8ZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZHxmaWxsfGZpbGxPcGFjaXR5fGZpbGxSdWxlfGZpbHRlcnxmaWx0ZXJSZXN8ZmlsdGVyVW5pdHN8Zmxvb2RDb2xvcnxmbG9vZE9wYWNpdHl8Zm9jdXNhYmxlfGZvbnRGYW1pbHl8Zm9udFNpemV8Zm9udFNpemVBZGp1c3R8Zm9udFN0cmV0Y2h8Zm9udFN0eWxlfGZvbnRWYXJpYW50fGZvbnRXZWlnaHR8Zm9ybWF0fGZyb218ZnJ8Znh8Znl8ZzF8ZzJ8Z2x5cGhOYW1lfGdseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsfGdseXBoT3JpZW50YXRpb25WZXJ0aWNhbHxnbHlwaFJlZnxncmFkaWVudFRyYW5zZm9ybXxncmFkaWVudFVuaXRzfGhhbmdpbmd8aG9yaXpBZHZYfGhvcml6T3JpZ2luWHxpZGVvZ3JhcGhpY3xpbWFnZVJlbmRlcmluZ3xpbnxpbjJ8aW50ZXJjZXB0fGt8azF8azJ8azN8azR8a2VybmVsTWF0cml4fGtlcm5lbFVuaXRMZW5ndGh8a2VybmluZ3xrZXlQb2ludHN8a2V5U3BsaW5lc3xrZXlUaW1lc3xsZW5ndGhBZGp1c3R8bGV0dGVyU3BhY2luZ3xsaWdodGluZ0NvbG9yfGxpbWl0aW5nQ29uZUFuZ2xlfGxvY2FsfG1hcmtlckVuZHxtYXJrZXJNaWR8bWFya2VyU3RhcnR8bWFya2VySGVpZ2h0fG1hcmtlclVuaXRzfG1hcmtlcldpZHRofG1hc2t8bWFza0NvbnRlbnRVbml0c3xtYXNrVW5pdHN8bWF0aGVtYXRpY2FsfG1vZGV8bnVtT2N0YXZlc3xvZmZzZXR8b3BhY2l0eXxvcGVyYXRvcnxvcmRlcnxvcmllbnR8b3JpZW50YXRpb258b3JpZ2lufG92ZXJmbG93fG92ZXJsaW5lUG9zaXRpb258b3ZlcmxpbmVUaGlja25lc3N8cGFub3NlMXxwYWludE9yZGVyfHBhdGhMZW5ndGh8cGF0dGVybkNvbnRlbnRVbml0c3xwYXR0ZXJuVHJhbnNmb3JtfHBhdHRlcm5Vbml0c3xwb2ludGVyRXZlbnRzfHBvaW50c3xwb2ludHNBdFh8cG9pbnRzQXRZfHBvaW50c0F0WnxwcmVzZXJ2ZUFscGhhfHByZXNlcnZlQXNwZWN0UmF0aW98cHJpbWl0aXZlVW5pdHN8cnxyYWRpdXN8cmVmWHxyZWZZfHJlbmRlcmluZ0ludGVudHxyZXBlYXRDb3VudHxyZXBlYXREdXJ8cmVxdWlyZWRFeHRlbnNpb25zfHJlcXVpcmVkRmVhdHVyZXN8cmVzdGFydHxyZXN1bHR8cm90YXRlfHJ4fHJ5fHNjYWxlfHNlZWR8c2hhcGVSZW5kZXJpbmd8c2xvcGV8c3BhY2luZ3xzcGVjdWxhckNvbnN0YW50fHNwZWN1bGFyRXhwb25lbnR8c3BlZWR8c3ByZWFkTWV0aG9kfHN0YXJ0T2Zmc2V0fHN0ZERldmlhdGlvbnxzdGVtaHxzdGVtdnxzdGl0Y2hUaWxlc3xzdG9wQ29sb3J8c3RvcE9wYWNpdHl8c3RyaWtldGhyb3VnaFBvc2l0aW9ufHN0cmlrZXRocm91Z2hUaGlja25lc3N8c3RyaW5nfHN0cm9rZXxzdHJva2VEYXNoYXJyYXl8c3Ryb2tlRGFzaG9mZnNldHxzdHJva2VMaW5lY2FwfHN0cm9rZUxpbmVqb2lufHN0cm9rZU1pdGVybGltaXR8c3Ryb2tlT3BhY2l0eXxzdHJva2VXaWR0aHxzdXJmYWNlU2NhbGV8c3lzdGVtTGFuZ3VhZ2V8dGFibGVWYWx1ZXN8dGFyZ2V0WHx0YXJnZXRZfHRleHRBbmNob3J8dGV4dERlY29yYXRpb258dGV4dFJlbmRlcmluZ3x0ZXh0TGVuZ3RofHRvfHRyYW5zZm9ybXx1MXx1Mnx1bmRlcmxpbmVQb3NpdGlvbnx1bmRlcmxpbmVUaGlja25lc3N8dW5pY29kZXx1bmljb2RlQmlkaXx1bmljb2RlUmFuZ2V8dW5pdHNQZXJFbXx2QWxwaGFiZXRpY3x2SGFuZ2luZ3x2SWRlb2dyYXBoaWN8dk1hdGhlbWF0aWNhbHx2YWx1ZXN8dmVjdG9yRWZmZWN0fHZlcnNpb258dmVydEFkdll8dmVydE9yaWdpblh8dmVydE9yaWdpbll8dmlld0JveHx2aWV3VGFyZ2V0fHZpc2liaWxpdHl8d2lkdGhzfHdvcmRTcGFjaW5nfHdyaXRpbmdNb2RlfHh8eEhlaWdodHx4MXx4Mnx4Q2hhbm5lbFNlbGVjdG9yfHhsaW5rQWN0dWF0ZXx4bGlua0FyY3JvbGV8eGxpbmtIcmVmfHhsaW5rUm9sZXx4bGlua1Nob3d8eGxpbmtUaXRsZXx4bGlua1R5cGV8eG1sQmFzZXx4bWxuc3x4bWxuc1hsaW5rfHhtbExhbmd8eG1sU3BhY2V8eXx5MXx5Mnx5Q2hhbm5lbFNlbGVjdG9yfHp8em9vbUFuZFBhbnxmb3J8Y2xhc3N8YXV0b2ZvY3VzKXwoKFtEZF1bQWFdW1R0XVtBYV18W0FhXVtScl1bSWldW0FhXXx4KS0uKikpJC87IC8vIGh0dHBzOi8vZXNiZW5jaC5jb20vYmVuY2gvNWJmZWU2OGE0Y2Q3ZTYwMDllZjYxZDIzXG5cbnZhciBpc1Byb3BWYWxpZCA9IC8qICNfX1BVUkVfXyAqL21lbW9pemUoZnVuY3Rpb24gKHByb3ApIHtcbiAgcmV0dXJuIHJlYWN0UHJvcHNSZWdleC50ZXN0KHByb3ApIHx8IHByb3AuY2hhckNvZGVBdCgwKSA9PT0gMTExXG4gIC8qIG8gKi9cbiAgJiYgcHJvcC5jaGFyQ29kZUF0KDEpID09PSAxMTBcbiAgLyogbiAqL1xuICAmJiBwcm9wLmNoYXJDb2RlQXQoMikgPCA5MTtcbn1cbi8qIForMSAqL1xuKTtcblxuLypcblxuQmFzZWQgb2ZmIGdsYW1vcidzIFN0eWxlU2hlZXQsIHRoYW5rcyBTdW5pbCDinaTvuI9cblxuaGlnaCBwZXJmb3JtYW5jZSBTdHlsZVNoZWV0IGZvciBjc3MtaW4tanMgc3lzdGVtc1xuXG4tIHVzZXMgbXVsdGlwbGUgc3R5bGUgdGFncyBiZWhpbmQgdGhlIHNjZW5lcyBmb3IgbWlsbGlvbnMgb2YgcnVsZXNcbi0gdXNlcyBgaW5zZXJ0UnVsZWAgZm9yIGFwcGVuZGluZyBpbiBwcm9kdWN0aW9uIGZvciAqbXVjaCogZmFzdGVyIHBlcmZvcm1hbmNlXG5cbi8vIHVzYWdlXG5cbmltcG9ydCB7IFN0eWxlU2hlZXQgfSBmcm9tICdAZW1vdGlvbi9zaGVldCdcblxubGV0IHN0eWxlU2hlZXQgPSBuZXcgU3R5bGVTaGVldCh7IGtleTogJycsIGNvbnRhaW5lcjogZG9jdW1lbnQuaGVhZCB9KVxuXG5zdHlsZVNoZWV0Lmluc2VydCgnI2JveCB7IGJvcmRlcjogMXB4IHNvbGlkIHJlZDsgfScpXG4tIGFwcGVuZHMgYSBjc3MgcnVsZSBpbnRvIHRoZSBzdHlsZXNoZWV0XG5cbnN0eWxlU2hlZXQuZmx1c2goKVxuLSBlbXB0aWVzIHRoZSBzdHlsZXNoZWV0IG9mIGFsbCBpdHMgY29udGVudHNcblxuKi9cbi8vICRGbG93Rml4TWVcbmZ1bmN0aW9uIHNoZWV0Rm9yVGFnKHRhZykge1xuICBpZiAodGFnLnNoZWV0KSB7XG4gICAgLy8gJEZsb3dGaXhNZVxuICAgIHJldHVybiB0YWcuc2hlZXQ7XG4gIH0gLy8gdGhpcyB3ZWlyZG5lc3MgYnJvdWdodCB0byB5b3UgYnkgZmlyZWZveFxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRvY3VtZW50LnN0eWxlU2hlZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGRvY3VtZW50LnN0eWxlU2hlZXRzW2ldLm93bmVyTm9kZSA9PT0gdGFnKSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICByZXR1cm4gZG9jdW1lbnQuc3R5bGVTaGVldHNbaV07XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSB7XG4gIHZhciB0YWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICB0YWcuc2V0QXR0cmlidXRlKCdkYXRhLWVtb3Rpb24nLCBvcHRpb25zLmtleSk7XG5cbiAgaWYgKG9wdGlvbnMubm9uY2UgIT09IHVuZGVmaW5lZCkge1xuICAgIHRhZy5zZXRBdHRyaWJ1dGUoJ25vbmNlJywgb3B0aW9ucy5ub25jZSk7XG4gIH1cblxuICB0YWcuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpKTtcbiAgdGFnLnNldEF0dHJpYnV0ZSgnZGF0YS1zJywgJycpO1xuICByZXR1cm4gdGFnO1xufVxuXG52YXIgU3R5bGVTaGVldCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8vIFVzaW5nIE5vZGUgaW5zdGVhZCBvZiBIVE1MRWxlbWVudCBzaW5jZSBjb250YWluZXIgbWF5IGJlIGEgU2hhZG93Um9vdFxuICBmdW5jdGlvbiBTdHlsZVNoZWV0KG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5faW5zZXJ0VGFnID0gZnVuY3Rpb24gKHRhZykge1xuICAgICAgdmFyIGJlZm9yZTtcblxuICAgICAgaWYgKF90aGlzLnRhZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlmIChfdGhpcy5pbnNlcnRpb25Qb2ludCkge1xuICAgICAgICAgIGJlZm9yZSA9IF90aGlzLmluc2VydGlvblBvaW50Lm5leHRTaWJsaW5nO1xuICAgICAgICB9IGVsc2UgaWYgKF90aGlzLnByZXBlbmQpIHtcbiAgICAgICAgICBiZWZvcmUgPSBfdGhpcy5jb250YWluZXIuZmlyc3RDaGlsZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBiZWZvcmUgPSBfdGhpcy5iZWZvcmU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJlZm9yZSA9IF90aGlzLnRhZ3NbX3RoaXMudGFncy5sZW5ndGggLSAxXS5uZXh0U2libGluZztcbiAgICAgIH1cblxuICAgICAgX3RoaXMuY29udGFpbmVyLmluc2VydEJlZm9yZSh0YWcsIGJlZm9yZSk7XG5cbiAgICAgIF90aGlzLnRhZ3MucHVzaCh0YWcpO1xuICAgIH07XG5cbiAgICB0aGlzLmlzU3BlZWR5ID0gb3B0aW9ucy5zcGVlZHkgPT09IHVuZGVmaW5lZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgOiBvcHRpb25zLnNwZWVkeTtcbiAgICB0aGlzLnRhZ3MgPSBbXTtcbiAgICB0aGlzLmN0ciA9IDA7XG4gICAgdGhpcy5ub25jZSA9IG9wdGlvbnMubm9uY2U7IC8vIGtleSBpcyB0aGUgdmFsdWUgb2YgdGhlIGRhdGEtZW1vdGlvbiBhdHRyaWJ1dGUsIGl0J3MgdXNlZCB0byBpZGVudGlmeSBkaWZmZXJlbnQgc2hlZXRzXG5cbiAgICB0aGlzLmtleSA9IG9wdGlvbnMua2V5O1xuICAgIHRoaXMuY29udGFpbmVyID0gb3B0aW9ucy5jb250YWluZXI7XG4gICAgdGhpcy5wcmVwZW5kID0gb3B0aW9ucy5wcmVwZW5kO1xuICAgIHRoaXMuaW5zZXJ0aW9uUG9pbnQgPSBvcHRpb25zLmluc2VydGlvblBvaW50O1xuICAgIHRoaXMuYmVmb3JlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBTdHlsZVNoZWV0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uaHlkcmF0ZSA9IGZ1bmN0aW9uIGh5ZHJhdGUobm9kZXMpIHtcbiAgICBub2Rlcy5mb3JFYWNoKHRoaXMuX2luc2VydFRhZyk7XG4gIH07XG5cbiAgX3Byb3RvLmluc2VydCA9IGZ1bmN0aW9uIGluc2VydChydWxlKSB7XG4gICAgLy8gdGhlIG1heCBsZW5ndGggaXMgaG93IG1hbnkgcnVsZXMgd2UgaGF2ZSBwZXIgc3R5bGUgdGFnLCBpdCdzIDY1MDAwIGluIHNwZWVkeSBtb2RlXG4gICAgLy8gaXQncyAxIGluIGRldiBiZWNhdXNlIHdlIGluc2VydCBzb3VyY2UgbWFwcyB0aGF0IG1hcCBhIHNpbmdsZSBydWxlIHRvIGEgbG9jYXRpb25cbiAgICAvLyBhbmQgeW91IGNhbiBvbmx5IGhhdmUgb25lIHNvdXJjZSBtYXAgcGVyIHN0eWxlIHRhZ1xuICAgIGlmICh0aGlzLmN0ciAlICh0aGlzLmlzU3BlZWR5ID8gNjUwMDAgOiAxKSA9PT0gMCkge1xuICAgICAgdGhpcy5faW5zZXJ0VGFnKGNyZWF0ZVN0eWxlRWxlbWVudCh0aGlzKSk7XG4gICAgfVxuXG4gICAgdmFyIHRhZyA9IHRoaXMudGFnc1t0aGlzLnRhZ3MubGVuZ3RoIC0gMV07XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGlzSW1wb3J0UnVsZSA9IHJ1bGUuY2hhckNvZGVBdCgwKSA9PT0gNjQgJiYgcnVsZS5jaGFyQ29kZUF0KDEpID09PSAxMDU7XG5cbiAgICAgIGlmIChpc0ltcG9ydFJ1bGUgJiYgdGhpcy5fYWxyZWFkeUluc2VydGVkT3JkZXJJbnNlbnNpdGl2ZVJ1bGUpIHtcbiAgICAgICAgLy8gdGhpcyB3b3VsZCBvbmx5IGNhdXNlIHByb2JsZW0gaW4gc3BlZWR5IG1vZGVcbiAgICAgICAgLy8gYnV0IHdlIGRvbid0IHdhbnQgZW5hYmxpbmcgc3BlZWR5IHRvIGFmZmVjdCB0aGUgb2JzZXJ2YWJsZSBiZWhhdmlvclxuICAgICAgICAvLyBzbyB3ZSByZXBvcnQgdGhpcyBlcnJvciBhdCBhbGwgdGltZXNcbiAgICAgICAgY29uc29sZS5lcnJvcihcIllvdSdyZSBhdHRlbXB0aW5nIHRvIGluc2VydCB0aGUgZm9sbG93aW5nIHJ1bGU6XFxuXCIgKyBydWxlICsgJ1xcblxcbmBAaW1wb3J0YCBydWxlcyBtdXN0IGJlIGJlZm9yZSBhbGwgb3RoZXIgdHlwZXMgb2YgcnVsZXMgaW4gYSBzdHlsZXNoZWV0IGJ1dCBvdGhlciBydWxlcyBoYXZlIGFscmVhZHkgYmVlbiBpbnNlcnRlZC4gUGxlYXNlIGVuc3VyZSB0aGF0IGBAaW1wb3J0YCBydWxlcyBhcmUgYmVmb3JlIGFsbCBvdGhlciBydWxlcy4nKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FscmVhZHlJbnNlcnRlZE9yZGVySW5zZW5zaXRpdmVSdWxlID0gdGhpcy5fYWxyZWFkeUluc2VydGVkT3JkZXJJbnNlbnNpdGl2ZVJ1bGUgfHwgIWlzSW1wb3J0UnVsZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc1NwZWVkeSkge1xuICAgICAgdmFyIHNoZWV0ID0gc2hlZXRGb3JUYWcodGFnKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgdWx0cmFmYXN0IHZlcnNpb24sIHdvcmtzIGFjcm9zcyBicm93c2Vyc1xuICAgICAgICAvLyB0aGUgYmlnIGRyYXdiYWNrIGlzIHRoYXQgdGhlIGNzcyB3b24ndCBiZSBlZGl0YWJsZSBpbiBkZXZ0b29sc1xuICAgICAgICBzaGVldC5pbnNlcnRSdWxlKHJ1bGUsIHNoZWV0LmNzc1J1bGVzLmxlbmd0aCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICEvOigtbW96LXBsYWNlaG9sZGVyfC1tb3otZm9jdXMtaW5uZXJ8LW1vei1mb2N1c3Jpbmd8LW1zLWlucHV0LXBsYWNlaG9sZGVyfC1tb3otcmVhZC13cml0ZXwtbW96LXJlYWQtb25seXwtbXMtY2xlYXJ8LW1zLWV4cGFuZHwtbXMtcmV2ZWFsKXsvLnRlc3QocnVsZSkpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVGhlcmUgd2FzIGEgcHJvYmxlbSBpbnNlcnRpbmcgdGhlIGZvbGxvd2luZyBydWxlOiBcXFwiXCIgKyBydWxlICsgXCJcXFwiXCIsIGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhZy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShydWxlKSk7XG4gICAgfVxuXG4gICAgdGhpcy5jdHIrKztcbiAgfTtcblxuICBfcHJvdG8uZmx1c2ggPSBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAvLyAkRmxvd0ZpeE1lXG4gICAgdGhpcy50YWdzLmZvckVhY2goZnVuY3Rpb24gKHRhZykge1xuICAgICAgcmV0dXJuIHRhZy5wYXJlbnROb2RlICYmIHRhZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRhZyk7XG4gICAgfSk7XG4gICAgdGhpcy50YWdzID0gW107XG4gICAgdGhpcy5jdHIgPSAwO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHRoaXMuX2FscmVhZHlJbnNlcnRlZE9yZGVySW5zZW5zaXRpdmVSdWxlID0gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBTdHlsZVNoZWV0O1xufSgpO1xuXG52YXIgTVMgPSAnLW1zLSc7XG52YXIgTU9aID0gJy1tb3otJztcbnZhciBXRUJLSVQgPSAnLXdlYmtpdC0nO1xuXG52YXIgQ09NTUVOVCA9ICdjb21tJztcbnZhciBSVUxFU0VUID0gJ3J1bGUnO1xudmFyIERFQ0xBUkFUSU9OID0gJ2RlY2wnO1xudmFyIElNUE9SVCA9ICdAaW1wb3J0JztcbnZhciBLRVlGUkFNRVMgPSAnQGtleWZyYW1lcyc7XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbnZhciBhYnMgPSBNYXRoLmFicztcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn1cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xudmFyIGZyb20gPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gaGFzaCQyICh2YWx1ZSwgbGVuZ3RoKSB7XG5cdHJldHVybiBjaGFyYXQodmFsdWUsIDApIF4gNDUgPyAoKCgoKCgobGVuZ3RoIDw8IDIpIF4gY2hhcmF0KHZhbHVlLCAwKSkgPDwgMikgXiBjaGFyYXQodmFsdWUsIDEpKSA8PCAyKSBeIGNoYXJhdCh2YWx1ZSwgMikpIDw8IDIpIF4gY2hhcmF0KHZhbHVlLCAzKSA6IDBcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gdHJpbSAodmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlLnRyaW0oKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHBhcmFtIHtSZWdFeHB9IHBhdHRlcm5cbiAqIEByZXR1cm4ge3N0cmluZz99XG4gKi9cbmZ1bmN0aW9uIG1hdGNoICh2YWx1ZSwgcGF0dGVybikge1xuXHRyZXR1cm4gKHZhbHVlID0gcGF0dGVybi5leGVjKHZhbHVlKSkgPyB2YWx1ZVswXSA6IHZhbHVlXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0geyhzdHJpbmd8UmVnRXhwKX0gcGF0dGVyblxuICogQHBhcmFtIHtzdHJpbmd9IHJlcGxhY2VtZW50XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHJlcGxhY2UgKHZhbHVlLCBwYXR0ZXJuLCByZXBsYWNlbWVudCkge1xuXHRyZXR1cm4gdmFsdWUucmVwbGFjZShwYXR0ZXJuLCByZXBsYWNlbWVudClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWFyY2hcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gaW5kZXhvZiAodmFsdWUsIHNlYXJjaCkge1xuXHRyZXR1cm4gdmFsdWUuaW5kZXhPZihzZWFyY2gpXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gY2hhcmF0ICh2YWx1ZSwgaW5kZXgpIHtcblx0cmV0dXJuIHZhbHVlLmNoYXJDb2RlQXQoaW5kZXgpIHwgMFxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IGJlZ2luXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHN1YnN0ciAodmFsdWUsIGJlZ2luLCBlbmQpIHtcblx0cmV0dXJuIHZhbHVlLnNsaWNlKGJlZ2luLCBlbmQpXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIHN0cmxlbiAodmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlLmxlbmd0aFxufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55W119IHZhbHVlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIHNpemVvZiAodmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlLmxlbmd0aFxufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHBhcmFtIHthbnlbXX0gYXJyYXlcbiAqIEByZXR1cm4ge2FueX1cbiAqL1xuZnVuY3Rpb24gYXBwZW5kICh2YWx1ZSwgYXJyYXkpIHtcblx0cmV0dXJuIGFycmF5LnB1c2godmFsdWUpLCB2YWx1ZVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nW119IGFycmF5XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjb21iaW5lIChhcnJheSwgY2FsbGJhY2spIHtcblx0cmV0dXJuIGFycmF5Lm1hcChjYWxsYmFjaykuam9pbignJylcbn1cblxudmFyIGxpbmUgPSAxO1xudmFyIGNvbHVtbiA9IDE7XG52YXIgbGVuZ3RoID0gMDtcbnZhciBwb3NpdGlvbiA9IDA7XG52YXIgY2hhcmFjdGVyID0gMDtcbnZhciBjaGFyYWN0ZXJzID0gJyc7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0ge29iamVjdCB8IG51bGx9IHJvb3RcbiAqIEBwYXJhbSB7b2JqZWN0IHwgbnVsbH0gcGFyZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtzdHJpbmdbXSB8IHN0cmluZ30gcHJvcHNcbiAqIEBwYXJhbSB7b2JqZWN0W10gfCBzdHJpbmd9IGNoaWxkcmVuXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gKi9cbmZ1bmN0aW9uIG5vZGUgKHZhbHVlLCByb290LCBwYXJlbnQsIHR5cGUsIHByb3BzLCBjaGlsZHJlbiwgbGVuZ3RoKSB7XG5cdHJldHVybiB7dmFsdWU6IHZhbHVlLCByb290OiByb290LCBwYXJlbnQ6IHBhcmVudCwgdHlwZTogdHlwZSwgcHJvcHM6IHByb3BzLCBjaGlsZHJlbjogY2hpbGRyZW4sIGxpbmU6IGxpbmUsIGNvbHVtbjogY29sdW1uLCBsZW5ndGg6IGxlbmd0aCwgcmV0dXJuOiAnJ31cbn1cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gcm9vdFxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGNvcHkgKHJvb3QsIHByb3BzKSB7XG5cdHJldHVybiBhc3NpZ24obm9kZSgnJywgbnVsbCwgbnVsbCwgJycsIG51bGwsIG51bGwsIDApLCByb290LCB7bGVuZ3RoOiAtcm9vdC5sZW5ndGh9LCBwcm9wcylcbn1cblxuLyoqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGNoYXIgKCkge1xuXHRyZXR1cm4gY2hhcmFjdGVyXG59XG5cbi8qKlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBwcmV2ICgpIHtcblx0Y2hhcmFjdGVyID0gcG9zaXRpb24gPiAwID8gY2hhcmF0KGNoYXJhY3RlcnMsIC0tcG9zaXRpb24pIDogMDtcblxuXHRpZiAoY29sdW1uLS0sIGNoYXJhY3RlciA9PT0gMTApXG5cdFx0Y29sdW1uID0gMSwgbGluZS0tO1xuXG5cdHJldHVybiBjaGFyYWN0ZXJcbn1cblxuLyoqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIG5leHQgKCkge1xuXHRjaGFyYWN0ZXIgPSBwb3NpdGlvbiA8IGxlbmd0aCA/IGNoYXJhdChjaGFyYWN0ZXJzLCBwb3NpdGlvbisrKSA6IDA7XG5cblx0aWYgKGNvbHVtbisrLCBjaGFyYWN0ZXIgPT09IDEwKVxuXHRcdGNvbHVtbiA9IDEsIGxpbmUrKztcblxuXHRyZXR1cm4gY2hhcmFjdGVyXG59XG5cbi8qKlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBwZWVrICgpIHtcblx0cmV0dXJuIGNoYXJhdChjaGFyYWN0ZXJzLCBwb3NpdGlvbilcbn1cblxuLyoqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGNhcmV0ICgpIHtcblx0cmV0dXJuIHBvc2l0aW9uXG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGJlZ2luXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHNsaWNlIChiZWdpbiwgZW5kKSB7XG5cdHJldHVybiBzdWJzdHIoY2hhcmFjdGVycywgYmVnaW4sIGVuZClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdHlwZVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiB0b2tlbiAodHlwZSkge1xuXHRzd2l0Y2ggKHR5cGUpIHtcblx0XHQvLyBcXDAgXFx0IFxcbiBcXHIgXFxzIHdoaXRlc3BhY2UgdG9rZW5cblx0XHRjYXNlIDA6IGNhc2UgOTogY2FzZSAxMDogY2FzZSAxMzogY2FzZSAzMjpcblx0XHRcdHJldHVybiA1XG5cdFx0Ly8gISArICwgLyA+IEAgfiBpc29sYXRlIHRva2VuXG5cdFx0Y2FzZSAzMzogY2FzZSA0MzogY2FzZSA0NDogY2FzZSA0NzogY2FzZSA2MjogY2FzZSA2NDogY2FzZSAxMjY6XG5cdFx0Ly8gOyB7IH0gYnJlYWtwb2ludCB0b2tlblxuXHRcdGNhc2UgNTk6IGNhc2UgMTIzOiBjYXNlIDEyNTpcblx0XHRcdHJldHVybiA0XG5cdFx0Ly8gOiBhY2NvbXBhbmllZCB0b2tlblxuXHRcdGNhc2UgNTg6XG5cdFx0XHRyZXR1cm4gM1xuXHRcdC8vIFwiICcgKCBbIG9wZW5pbmcgZGVsaW1pdCB0b2tlblxuXHRcdGNhc2UgMzQ6IGNhc2UgMzk6IGNhc2UgNDA6IGNhc2UgOTE6XG5cdFx0XHRyZXR1cm4gMlxuXHRcdC8vICkgXSBjbG9zaW5nIGRlbGltaXQgdG9rZW5cblx0XHRjYXNlIDQxOiBjYXNlIDkzOlxuXHRcdFx0cmV0dXJuIDFcblx0fVxuXG5cdHJldHVybiAwXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJuIHthbnlbXX1cbiAqL1xuZnVuY3Rpb24gYWxsb2MgKHZhbHVlKSB7XG5cdHJldHVybiBsaW5lID0gY29sdW1uID0gMSwgbGVuZ3RoID0gc3RybGVuKGNoYXJhY3RlcnMgPSB2YWx1ZSksIHBvc2l0aW9uID0gMCwgW11cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEByZXR1cm4ge2FueX1cbiAqL1xuZnVuY3Rpb24gZGVhbGxvYyAodmFsdWUpIHtcblx0cmV0dXJuIGNoYXJhY3RlcnMgPSAnJywgdmFsdWVcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdHlwZVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBkZWxpbWl0ICh0eXBlKSB7XG5cdHJldHVybiB0cmltKHNsaWNlKHBvc2l0aW9uIC0gMSwgZGVsaW1pdGVyKHR5cGUgPT09IDkxID8gdHlwZSArIDIgOiB0eXBlID09PSA0MCA/IHR5cGUgKyAxIDogdHlwZSkpKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHdoaXRlc3BhY2UgKHR5cGUpIHtcblx0d2hpbGUgKGNoYXJhY3RlciA9IHBlZWsoKSlcblx0XHRpZiAoY2hhcmFjdGVyIDwgMzMpXG5cdFx0XHRuZXh0KCk7XG5cdFx0ZWxzZVxuXHRcdFx0YnJlYWtcblxuXHRyZXR1cm4gdG9rZW4odHlwZSkgPiAyIHx8IHRva2VuKGNoYXJhY3RlcikgPiAzID8gJycgOiAnICdcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlc2NhcGluZyAoaW5kZXgsIGNvdW50KSB7XG5cdHdoaWxlICgtLWNvdW50ICYmIG5leHQoKSlcblx0XHQvLyBub3QgMC05IEEtRiBhLWZcblx0XHRpZiAoY2hhcmFjdGVyIDwgNDggfHwgY2hhcmFjdGVyID4gMTAyIHx8IChjaGFyYWN0ZXIgPiA1NyAmJiBjaGFyYWN0ZXIgPCA2NSkgfHwgKGNoYXJhY3RlciA+IDcwICYmIGNoYXJhY3RlciA8IDk3KSlcblx0XHRcdGJyZWFrXG5cblx0cmV0dXJuIHNsaWNlKGluZGV4LCBjYXJldCgpICsgKGNvdW50IDwgNiAmJiBwZWVrKCkgPT0gMzIgJiYgbmV4dCgpID09IDMyKSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdHlwZVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBkZWxpbWl0ZXIgKHR5cGUpIHtcblx0d2hpbGUgKG5leHQoKSlcblx0XHRzd2l0Y2ggKGNoYXJhY3Rlcikge1xuXHRcdFx0Ly8gXSApIFwiICdcblx0XHRcdGNhc2UgdHlwZTpcblx0XHRcdFx0cmV0dXJuIHBvc2l0aW9uXG5cdFx0XHQvLyBcIiAnXG5cdFx0XHRjYXNlIDM0OiBjYXNlIDM5OlxuXHRcdFx0XHRpZiAodHlwZSAhPT0gMzQgJiYgdHlwZSAhPT0gMzkpXG5cdFx0XHRcdFx0ZGVsaW1pdGVyKGNoYXJhY3Rlcik7XG5cdFx0XHRcdGJyZWFrXG5cdFx0XHQvLyAoXG5cdFx0XHRjYXNlIDQwOlxuXHRcdFx0XHRpZiAodHlwZSA9PT0gNDEpXG5cdFx0XHRcdFx0ZGVsaW1pdGVyKHR5cGUpO1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Ly8gXFxcblx0XHRcdGNhc2UgOTI6XG5cdFx0XHRcdG5leHQoKTtcblx0XHRcdFx0YnJlYWtcblx0XHR9XG5cblx0cmV0dXJuIHBvc2l0aW9uXG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHR5cGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBjb21tZW50ZXIgKHR5cGUsIGluZGV4KSB7XG5cdHdoaWxlIChuZXh0KCkpXG5cdFx0Ly8gLy9cblx0XHRpZiAodHlwZSArIGNoYXJhY3RlciA9PT0gNDcgKyAxMClcblx0XHRcdGJyZWFrXG5cdFx0Ly8gLypcblx0XHRlbHNlIGlmICh0eXBlICsgY2hhcmFjdGVyID09PSA0MiArIDQyICYmIHBlZWsoKSA9PT0gNDcpXG5cdFx0XHRicmVha1xuXG5cdHJldHVybiAnLyonICsgc2xpY2UoaW5kZXgsIHBvc2l0aW9uIC0gMSkgKyAnKicgKyBmcm9tKHR5cGUgPT09IDQ3ID8gdHlwZSA6IG5leHQoKSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaWRlbnRpZmllciAoaW5kZXgpIHtcblx0d2hpbGUgKCF0b2tlbihwZWVrKCkpKVxuXHRcdG5leHQoKTtcblxuXHRyZXR1cm4gc2xpY2UoaW5kZXgsIHBvc2l0aW9uKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybiB7b2JqZWN0W119XG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGUgKHZhbHVlKSB7XG5cdHJldHVybiBkZWFsbG9jKHBhcnNlKCcnLCBudWxsLCBudWxsLCBudWxsLCBbJyddLCB2YWx1ZSA9IGFsbG9jKHZhbHVlKSwgMCwgWzBdLCB2YWx1ZSkpXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0ge29iamVjdH0gcm9vdFxuICogQHBhcmFtIHtvYmplY3Q/fSBwYXJlbnRcbiAqIEBwYXJhbSB7c3RyaW5nW119IHJ1bGVcbiAqIEBwYXJhbSB7c3RyaW5nW119IHJ1bGVzXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBydWxlc2V0c1xuICogQHBhcmFtIHtudW1iZXJbXX0gcHNldWRvXG4gKiBAcGFyYW0ge251bWJlcltdfSBwb2ludHNcbiAqIEBwYXJhbSB7c3RyaW5nW119IGRlY2xhcmF0aW9uc1xuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBwYXJzZSAodmFsdWUsIHJvb3QsIHBhcmVudCwgcnVsZSwgcnVsZXMsIHJ1bGVzZXRzLCBwc2V1ZG8sIHBvaW50cywgZGVjbGFyYXRpb25zKSB7XG5cdHZhciBpbmRleCA9IDA7XG5cdHZhciBvZmZzZXQgPSAwO1xuXHR2YXIgbGVuZ3RoID0gcHNldWRvO1xuXHR2YXIgYXRydWxlID0gMDtcblx0dmFyIHByb3BlcnR5ID0gMDtcblx0dmFyIHByZXZpb3VzID0gMDtcblx0dmFyIHZhcmlhYmxlID0gMTtcblx0dmFyIHNjYW5uaW5nID0gMTtcblx0dmFyIGFtcGVyc2FuZCA9IDE7XG5cdHZhciBjaGFyYWN0ZXIgPSAwO1xuXHR2YXIgdHlwZSA9ICcnO1xuXHR2YXIgcHJvcHMgPSBydWxlcztcblx0dmFyIGNoaWxkcmVuID0gcnVsZXNldHM7XG5cdHZhciByZWZlcmVuY2UgPSBydWxlO1xuXHR2YXIgY2hhcmFjdGVycyA9IHR5cGU7XG5cblx0d2hpbGUgKHNjYW5uaW5nKVxuXHRcdHN3aXRjaCAocHJldmlvdXMgPSBjaGFyYWN0ZXIsIGNoYXJhY3RlciA9IG5leHQoKSkge1xuXHRcdFx0Ly8gKFxuXHRcdFx0Y2FzZSA0MDpcblx0XHRcdFx0aWYgKHByZXZpb3VzICE9IDEwOCAmJiBjaGFyYXQoY2hhcmFjdGVycywgbGVuZ3RoIC0gMSkgPT0gNTgpIHtcblx0XHRcdFx0XHRpZiAoaW5kZXhvZihjaGFyYWN0ZXJzICs9IHJlcGxhY2UoZGVsaW1pdChjaGFyYWN0ZXIpLCAnJicsICcmXFxmJyksICcmXFxmJykgIT0gLTEpXG5cdFx0XHRcdFx0XHRhbXBlcnNhbmQgPSAtMTtcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHR9XG5cdFx0XHQvLyBcIiAnIFtcblx0XHRcdGNhc2UgMzQ6IGNhc2UgMzk6IGNhc2UgOTE6XG5cdFx0XHRcdGNoYXJhY3RlcnMgKz0gZGVsaW1pdChjaGFyYWN0ZXIpO1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Ly8gXFx0IFxcbiBcXHIgXFxzXG5cdFx0XHRjYXNlIDk6IGNhc2UgMTA6IGNhc2UgMTM6IGNhc2UgMzI6XG5cdFx0XHRcdGNoYXJhY3RlcnMgKz0gd2hpdGVzcGFjZShwcmV2aW91cyk7XG5cdFx0XHRcdGJyZWFrXG5cdFx0XHQvLyBcXFxuXHRcdFx0Y2FzZSA5Mjpcblx0XHRcdFx0Y2hhcmFjdGVycyArPSBlc2NhcGluZyhjYXJldCgpIC0gMSwgNyk7XG5cdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHQvLyAvXG5cdFx0XHRjYXNlIDQ3OlxuXHRcdFx0XHRzd2l0Y2ggKHBlZWsoKSkge1xuXHRcdFx0XHRcdGNhc2UgNDI6IGNhc2UgNDc6XG5cdFx0XHRcdFx0XHRhcHBlbmQoY29tbWVudChjb21tZW50ZXIobmV4dCgpLCBjYXJldCgpKSwgcm9vdCwgcGFyZW50KSwgZGVjbGFyYXRpb25zKTtcblx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGNoYXJhY3RlcnMgKz0gJy8nO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrXG5cdFx0XHQvLyB7XG5cdFx0XHRjYXNlIDEyMyAqIHZhcmlhYmxlOlxuXHRcdFx0XHRwb2ludHNbaW5kZXgrK10gPSBzdHJsZW4oY2hhcmFjdGVycykgKiBhbXBlcnNhbmQ7XG5cdFx0XHQvLyB9IDsgXFwwXG5cdFx0XHRjYXNlIDEyNSAqIHZhcmlhYmxlOiBjYXNlIDU5OiBjYXNlIDA6XG5cdFx0XHRcdHN3aXRjaCAoY2hhcmFjdGVyKSB7XG5cdFx0XHRcdFx0Ly8gXFwwIH1cblx0XHRcdFx0XHRjYXNlIDA6IGNhc2UgMTI1OiBzY2FubmluZyA9IDA7XG5cdFx0XHRcdFx0Ly8gO1xuXHRcdFx0XHRcdGNhc2UgNTkgKyBvZmZzZXQ6XG5cdFx0XHRcdFx0XHRpZiAocHJvcGVydHkgPiAwICYmIChzdHJsZW4oY2hhcmFjdGVycykgLSBsZW5ndGgpKVxuXHRcdFx0XHRcdFx0XHRhcHBlbmQocHJvcGVydHkgPiAzMiA/IGRlY2xhcmF0aW9uKGNoYXJhY3RlcnMgKyAnOycsIHJ1bGUsIHBhcmVudCwgbGVuZ3RoIC0gMSkgOiBkZWNsYXJhdGlvbihyZXBsYWNlKGNoYXJhY3RlcnMsICcgJywgJycpICsgJzsnLCBydWxlLCBwYXJlbnQsIGxlbmd0aCAtIDIpLCBkZWNsYXJhdGlvbnMpO1xuXHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHQvLyBAIDtcblx0XHRcdFx0XHRjYXNlIDU5OiBjaGFyYWN0ZXJzICs9ICc7Jztcblx0XHRcdFx0XHQvLyB7IHJ1bGUvYXQtcnVsZVxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRhcHBlbmQocmVmZXJlbmNlID0gcnVsZXNldChjaGFyYWN0ZXJzLCByb290LCBwYXJlbnQsIGluZGV4LCBvZmZzZXQsIHJ1bGVzLCBwb2ludHMsIHR5cGUsIHByb3BzID0gW10sIGNoaWxkcmVuID0gW10sIGxlbmd0aCksIHJ1bGVzZXRzKTtcblxuXHRcdFx0XHRcdFx0aWYgKGNoYXJhY3RlciA9PT0gMTIzKVxuXHRcdFx0XHRcdFx0XHRpZiAob2Zmc2V0ID09PSAwKVxuXHRcdFx0XHRcdFx0XHRcdHBhcnNlKGNoYXJhY3RlcnMsIHJvb3QsIHJlZmVyZW5jZSwgcmVmZXJlbmNlLCBwcm9wcywgcnVsZXNldHMsIGxlbmd0aCwgcG9pbnRzLCBjaGlsZHJlbik7XG5cdFx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0XHRzd2l0Y2ggKGF0cnVsZSA9PT0gOTkgJiYgY2hhcmF0KGNoYXJhY3RlcnMsIDMpID09PSAxMTAgPyAxMDAgOiBhdHJ1bGUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGQgbSBzXG5cdFx0XHRcdFx0XHRcdFx0XHRjYXNlIDEwMDogY2FzZSAxMDk6IGNhc2UgMTE1OlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZSh2YWx1ZSwgcmVmZXJlbmNlLCByZWZlcmVuY2UsIHJ1bGUgJiYgYXBwZW5kKHJ1bGVzZXQodmFsdWUsIHJlZmVyZW5jZSwgcmVmZXJlbmNlLCAwLCAwLCBydWxlcywgcG9pbnRzLCB0eXBlLCBydWxlcywgcHJvcHMgPSBbXSwgbGVuZ3RoKSwgY2hpbGRyZW4pLCBydWxlcywgY2hpbGRyZW4sIGxlbmd0aCwgcG9pbnRzLCBydWxlID8gcHJvcHMgOiBjaGlsZHJlbik7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZShjaGFyYWN0ZXJzLCByZWZlcmVuY2UsIHJlZmVyZW5jZSwgcmVmZXJlbmNlLCBbJyddLCBjaGlsZHJlbiwgMCwgcG9pbnRzLCBjaGlsZHJlbik7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aW5kZXggPSBvZmZzZXQgPSBwcm9wZXJ0eSA9IDAsIHZhcmlhYmxlID0gYW1wZXJzYW5kID0gMSwgdHlwZSA9IGNoYXJhY3RlcnMgPSAnJywgbGVuZ3RoID0gcHNldWRvO1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Ly8gOlxuXHRcdFx0Y2FzZSA1ODpcblx0XHRcdFx0bGVuZ3RoID0gMSArIHN0cmxlbihjaGFyYWN0ZXJzKSwgcHJvcGVydHkgPSBwcmV2aW91cztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdGlmICh2YXJpYWJsZSA8IDEpXG5cdFx0XHRcdFx0aWYgKGNoYXJhY3RlciA9PSAxMjMpXG5cdFx0XHRcdFx0XHQtLXZhcmlhYmxlO1xuXHRcdFx0XHRcdGVsc2UgaWYgKGNoYXJhY3RlciA9PSAxMjUgJiYgdmFyaWFibGUrKyA9PSAwICYmIHByZXYoKSA9PSAxMjUpXG5cdFx0XHRcdFx0XHRjb250aW51ZVxuXG5cdFx0XHRcdHN3aXRjaCAoY2hhcmFjdGVycyArPSBmcm9tKGNoYXJhY3RlciksIGNoYXJhY3RlciAqIHZhcmlhYmxlKSB7XG5cdFx0XHRcdFx0Ly8gJlxuXHRcdFx0XHRcdGNhc2UgMzg6XG5cdFx0XHRcdFx0XHRhbXBlcnNhbmQgPSBvZmZzZXQgPiAwID8gMSA6IChjaGFyYWN0ZXJzICs9ICdcXGYnLCAtMSk7XG5cdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdC8vICxcblx0XHRcdFx0XHRjYXNlIDQ0OlxuXHRcdFx0XHRcdFx0cG9pbnRzW2luZGV4KytdID0gKHN0cmxlbihjaGFyYWN0ZXJzKSAtIDEpICogYW1wZXJzYW5kLCBhbXBlcnNhbmQgPSAxO1xuXHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHQvLyBAXG5cdFx0XHRcdFx0Y2FzZSA2NDpcblx0XHRcdFx0XHRcdC8vIC1cblx0XHRcdFx0XHRcdGlmIChwZWVrKCkgPT09IDQ1KVxuXHRcdFx0XHRcdFx0XHRjaGFyYWN0ZXJzICs9IGRlbGltaXQobmV4dCgpKTtcblxuXHRcdFx0XHRcdFx0YXRydWxlID0gcGVlaygpLCBvZmZzZXQgPSBsZW5ndGggPSBzdHJsZW4odHlwZSA9IGNoYXJhY3RlcnMgKz0gaWRlbnRpZmllcihjYXJldCgpKSksIGNoYXJhY3RlcisrO1xuXHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHQvLyAtXG5cdFx0XHRcdFx0Y2FzZSA0NTpcblx0XHRcdFx0XHRcdGlmIChwcmV2aW91cyA9PT0gNDUgJiYgc3RybGVuKGNoYXJhY3RlcnMpID09IDIpXG5cdFx0XHRcdFx0XHRcdHZhcmlhYmxlID0gMDtcblx0XHRcdFx0fVxuXHRcdH1cblxuXHRyZXR1cm4gcnVsZXNldHNcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7b2JqZWN0fSByb290XG4gKiBAcGFyYW0ge29iamVjdD99IHBhcmVudFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBydWxlc1xuICogQHBhcmFtIHtudW1iZXJbXX0gcG9pbnRzXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtzdHJpbmdbXX0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nW119IGNoaWxkcmVuXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIHJ1bGVzZXQgKHZhbHVlLCByb290LCBwYXJlbnQsIGluZGV4LCBvZmZzZXQsIHJ1bGVzLCBwb2ludHMsIHR5cGUsIHByb3BzLCBjaGlsZHJlbiwgbGVuZ3RoKSB7XG5cdHZhciBwb3N0ID0gb2Zmc2V0IC0gMTtcblx0dmFyIHJ1bGUgPSBvZmZzZXQgPT09IDAgPyBydWxlcyA6IFsnJ107XG5cdHZhciBzaXplID0gc2l6ZW9mKHJ1bGUpO1xuXG5cdGZvciAodmFyIGkgPSAwLCBqID0gMCwgayA9IDA7IGkgPCBpbmRleDsgKytpKVxuXHRcdGZvciAodmFyIHggPSAwLCB5ID0gc3Vic3RyKHZhbHVlLCBwb3N0ICsgMSwgcG9zdCA9IGFicyhqID0gcG9pbnRzW2ldKSksIHogPSB2YWx1ZTsgeCA8IHNpemU7ICsreClcblx0XHRcdGlmICh6ID0gdHJpbShqID4gMCA/IHJ1bGVbeF0gKyAnICcgKyB5IDogcmVwbGFjZSh5LCAvJlxcZi9nLCBydWxlW3hdKSkpXG5cdFx0XHRcdHByb3BzW2srK10gPSB6O1xuXG5cdHJldHVybiBub2RlKHZhbHVlLCByb290LCBwYXJlbnQsIG9mZnNldCA9PT0gMCA/IFJVTEVTRVQgOiB0eXBlLCBwcm9wcywgY2hpbGRyZW4sIGxlbmd0aClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7b2JqZWN0fSByb290XG4gKiBAcGFyYW0ge29iamVjdD99IHBhcmVudFxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBjb21tZW50ICh2YWx1ZSwgcm9vdCwgcGFyZW50KSB7XG5cdHJldHVybiBub2RlKHZhbHVlLCByb290LCBwYXJlbnQsIENPTU1FTlQsIGZyb20oY2hhcigpKSwgc3Vic3RyKHZhbHVlLCAyLCAtMiksIDApXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0ge29iamVjdH0gcm9vdFxuICogQHBhcmFtIHtvYmplY3Q/fSBwYXJlbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZGVjbGFyYXRpb24gKHZhbHVlLCByb290LCBwYXJlbnQsIGxlbmd0aCkge1xuXHRyZXR1cm4gbm9kZSh2YWx1ZSwgcm9vdCwgcGFyZW50LCBERUNMQVJBVElPTiwgc3Vic3RyKHZhbHVlLCAwLCBsZW5ndGgpLCBzdWJzdHIodmFsdWUsIGxlbmd0aCArIDEsIC0xKSwgbGVuZ3RoKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0W119IGNoaWxkcmVuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBzZXJpYWxpemUgKGNoaWxkcmVuLCBjYWxsYmFjaykge1xuXHR2YXIgb3V0cHV0ID0gJyc7XG5cdHZhciBsZW5ndGggPSBzaXplb2YoY2hpbGRyZW4pO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG5cdFx0b3V0cHV0ICs9IGNhbGxiYWNrKGNoaWxkcmVuW2ldLCBpLCBjaGlsZHJlbiwgY2FsbGJhY2spIHx8ICcnO1xuXG5cdHJldHVybiBvdXRwdXRcbn1cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZWxlbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0ge29iamVjdFtdfSBjaGlsZHJlblxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gc3RyaW5naWZ5IChlbGVtZW50LCBpbmRleCwgY2hpbGRyZW4sIGNhbGxiYWNrKSB7XG5cdHN3aXRjaCAoZWxlbWVudC50eXBlKSB7XG5cdFx0Y2FzZSBJTVBPUlQ6IGNhc2UgREVDTEFSQVRJT046IHJldHVybiBlbGVtZW50LnJldHVybiA9IGVsZW1lbnQucmV0dXJuIHx8IGVsZW1lbnQudmFsdWVcblx0XHRjYXNlIENPTU1FTlQ6IHJldHVybiAnJ1xuXHRcdGNhc2UgS0VZRlJBTUVTOiByZXR1cm4gZWxlbWVudC5yZXR1cm4gPSBlbGVtZW50LnZhbHVlICsgJ3snICsgc2VyaWFsaXplKGVsZW1lbnQuY2hpbGRyZW4sIGNhbGxiYWNrKSArICd9J1xuXHRcdGNhc2UgUlVMRVNFVDogZWxlbWVudC52YWx1ZSA9IGVsZW1lbnQucHJvcHMuam9pbignLCcpO1xuXHR9XG5cblx0cmV0dXJuIHN0cmxlbihjaGlsZHJlbiA9IHNlcmlhbGl6ZShlbGVtZW50LmNoaWxkcmVuLCBjYWxsYmFjaykpID8gZWxlbWVudC5yZXR1cm4gPSBlbGVtZW50LnZhbHVlICsgJ3snICsgY2hpbGRyZW4gKyAnfScgOiAnJ1xufVxuXG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb25bXX0gY29sbGVjdGlvblxuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIG1pZGRsZXdhcmUgKGNvbGxlY3Rpb24pIHtcblx0dmFyIGxlbmd0aCA9IHNpemVvZihjb2xsZWN0aW9uKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGVsZW1lbnQsIGluZGV4LCBjaGlsZHJlbiwgY2FsbGJhY2spIHtcblx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuXHRcdFx0b3V0cHV0ICs9IGNvbGxlY3Rpb25baV0oZWxlbWVudCwgaW5kZXgsIGNoaWxkcmVuLCBjYWxsYmFjaykgfHwgJyc7XG5cblx0XHRyZXR1cm4gb3V0cHV0XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIHJ1bGVzaGVldCAoY2FsbGJhY2spIHtcblx0cmV0dXJuIGZ1bmN0aW9uIChlbGVtZW50KSB7XG5cdFx0aWYgKCFlbGVtZW50LnJvb3QpXG5cdFx0XHRpZiAoZWxlbWVudCA9IGVsZW1lbnQucmV0dXJuKVxuXHRcdFx0XHRjYWxsYmFjayhlbGVtZW50KTtcblx0fVxufVxuXG52YXIgd2Vha01lbW9pemUgPSBmdW5jdGlvbiB3ZWFrTWVtb2l6ZShmdW5jKSB7XG4gIC8vICRGbG93Rml4TWUgZmxvdyBkb2Vzbid0IGluY2x1ZGUgYWxsIG5vbi1wcmltaXRpdmUgdHlwZXMgYXMgYWxsb3dlZCBmb3Igd2Vha21hcHNcbiAgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhcmcpIHtcbiAgICBpZiAoY2FjaGUuaGFzKGFyZykpIHtcbiAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgIHJldHVybiBjYWNoZS5nZXQoYXJnKTtcbiAgICB9XG5cbiAgICB2YXIgcmV0ID0gZnVuYyhhcmcpO1xuICAgIGNhY2hlLnNldChhcmcsIHJldCk7XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcbn07XG5cbnZhciBpZGVudGlmaWVyV2l0aFBvaW50VHJhY2tpbmcgPSBmdW5jdGlvbiBpZGVudGlmaWVyV2l0aFBvaW50VHJhY2tpbmcoYmVnaW4sIHBvaW50cywgaW5kZXgpIHtcbiAgdmFyIHByZXZpb3VzID0gMDtcbiAgdmFyIGNoYXJhY3RlciA9IDA7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBwcmV2aW91cyA9IGNoYXJhY3RlcjtcbiAgICBjaGFyYWN0ZXIgPSBwZWVrKCk7IC8vICZcXGZcblxuICAgIGlmIChwcmV2aW91cyA9PT0gMzggJiYgY2hhcmFjdGVyID09PSAxMikge1xuICAgICAgcG9pbnRzW2luZGV4XSA9IDE7XG4gICAgfVxuXG4gICAgaWYgKHRva2VuKGNoYXJhY3RlcikpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIG5leHQoKTtcbiAgfVxuXG4gIHJldHVybiBzbGljZShiZWdpbiwgcG9zaXRpb24pO1xufTtcblxudmFyIHRvUnVsZXMgPSBmdW5jdGlvbiB0b1J1bGVzKHBhcnNlZCwgcG9pbnRzKSB7XG4gIC8vIHByZXRlbmQgd2UndmUgc3RhcnRlZCB3aXRoIGEgY29tbWFcbiAgdmFyIGluZGV4ID0gLTE7XG4gIHZhciBjaGFyYWN0ZXIgPSA0NDtcblxuICBkbyB7XG4gICAgc3dpdGNoICh0b2tlbihjaGFyYWN0ZXIpKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIC8vICZcXGZcbiAgICAgICAgaWYgKGNoYXJhY3RlciA9PT0gMzggJiYgcGVlaygpID09PSAxMikge1xuICAgICAgICAgIC8vIHRoaXMgaXMgbm90IDEwMCUgY29ycmVjdCwgd2UgZG9uJ3QgYWNjb3VudCBmb3IgbGl0ZXJhbCBzZXF1ZW5jZXMgaGVyZSAtIGxpa2UgZm9yIGV4YW1wbGUgcXVvdGVkIHN0cmluZ3NcbiAgICAgICAgICAvLyBzdHlsaXMgaW5zZXJ0cyBcXGYgYWZ0ZXIgJiB0byBrbm93IHdoZW4gJiB3aGVyZSBpdCBzaG91bGQgcmVwbGFjZSB0aGlzIHNlcXVlbmNlIHdpdGggdGhlIGNvbnRleHQgc2VsZWN0b3JcbiAgICAgICAgICAvLyBhbmQgd2hlbiBpdCBzaG91bGQganVzdCBjb25jYXRlbmF0ZSB0aGUgb3V0ZXIgYW5kIGlubmVyIHNlbGVjdG9yc1xuICAgICAgICAgIC8vIGl0J3MgdmVyeSB1bmxpa2VseSBmb3IgdGhpcyBzZXF1ZW5jZSB0byBhY3R1YWxseSBhcHBlYXIgaW4gYSBkaWZmZXJlbnQgY29udGV4dCwgc28gd2UganVzdCBsZXZlcmFnZSB0aGlzIGZhY3QgaGVyZVxuICAgICAgICAgIHBvaW50c1tpbmRleF0gPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyc2VkW2luZGV4XSArPSBpZGVudGlmaWVyV2l0aFBvaW50VHJhY2tpbmcocG9zaXRpb24gLSAxLCBwb2ludHMsIGluZGV4KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcGFyc2VkW2luZGV4XSArPSBkZWxpbWl0KGNoYXJhY3Rlcik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDQ6XG4gICAgICAgIC8vIGNvbW1hXG4gICAgICAgIGlmIChjaGFyYWN0ZXIgPT09IDQ0KSB7XG4gICAgICAgICAgLy8gY29sb25cbiAgICAgICAgICBwYXJzZWRbKytpbmRleF0gPSBwZWVrKCkgPT09IDU4ID8gJyZcXGYnIDogJyc7XG4gICAgICAgICAgcG9pbnRzW2luZGV4XSA9IHBhcnNlZFtpbmRleF0ubGVuZ3RoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIC8vIGZhbGx0aHJvdWdoXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHBhcnNlZFtpbmRleF0gKz0gZnJvbShjaGFyYWN0ZXIpO1xuICAgIH1cbiAgfSB3aGlsZSAoY2hhcmFjdGVyID0gbmV4dCgpKTtcblxuICByZXR1cm4gcGFyc2VkO1xufTtcblxudmFyIGdldFJ1bGVzID0gZnVuY3Rpb24gZ2V0UnVsZXModmFsdWUsIHBvaW50cykge1xuICByZXR1cm4gZGVhbGxvYyh0b1J1bGVzKGFsbG9jKHZhbHVlKSwgcG9pbnRzKSk7XG59OyAvLyBXZWFrU2V0IHdvdWxkIGJlIG1vcmUgYXBwcm9wcmlhdGUsIGJ1dCBvbmx5IFdlYWtNYXAgaXMgc3VwcG9ydGVkIGluIElFMTFcblxuXG52YXIgZml4ZWRFbGVtZW50cyA9IC8qICNfX1BVUkVfXyAqL25ldyBXZWFrTWFwKCk7XG52YXIgY29tcGF0ID0gZnVuY3Rpb24gY29tcGF0KGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQudHlwZSAhPT0gJ3J1bGUnIHx8ICFlbGVtZW50LnBhcmVudCB8fCAvLyBwb3NpdGl2ZSAubGVuZ3RoIGluZGljYXRlcyB0aGF0IHRoaXMgcnVsZSBjb250YWlucyBwc2V1ZG9cbiAgLy8gbmVnYXRpdmUgLmxlbmd0aCBpbmRpY2F0ZXMgdGhhdCB0aGlzIHJ1bGUgaGFzIGJlZW4gYWxyZWFkeSBwcmVmaXhlZFxuICBlbGVtZW50Lmxlbmd0aCA8IDEpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdmFsdWUgPSBlbGVtZW50LnZhbHVlLFxuICAgICAgcGFyZW50ID0gZWxlbWVudC5wYXJlbnQ7XG4gIHZhciBpc0ltcGxpY2l0UnVsZSA9IGVsZW1lbnQuY29sdW1uID09PSBwYXJlbnQuY29sdW1uICYmIGVsZW1lbnQubGluZSA9PT0gcGFyZW50LmxpbmU7XG5cbiAgd2hpbGUgKHBhcmVudC50eXBlICE9PSAncnVsZScpIHtcbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIGlmICghcGFyZW50KSByZXR1cm47XG4gIH0gLy8gc2hvcnQtY2lyY3VpdCBmb3IgdGhlIHNpbXBsZXN0IGNhc2VcblxuXG4gIGlmIChlbGVtZW50LnByb3BzLmxlbmd0aCA9PT0gMSAmJiB2YWx1ZS5jaGFyQ29kZUF0KDApICE9PSA1OFxuICAvKiBjb2xvbiAqL1xuICAmJiAhZml4ZWRFbGVtZW50cy5nZXQocGFyZW50KSkge1xuICAgIHJldHVybjtcbiAgfSAvLyBpZiB0aGlzIGlzIGFuIGltcGxpY2l0bHkgaW5zZXJ0ZWQgcnVsZSAodGhlIG9uZSBlYWdlcmx5IGluc2VydGVkIGF0IHRoZSBlYWNoIG5ldyBuZXN0ZWQgbGV2ZWwpXG4gIC8vIHRoZW4gdGhlIHByb3BzIGhhcyBhbHJlYWR5IGJlZW4gbWFuaXB1bGF0ZWQgYmVmb3JlaGFuZCBhcyB0aGV5IHRoYXQgYXJyYXkgaXMgc2hhcmVkIGJldHdlZW4gaXQgYW5kIGl0cyBcInJ1bGUgcGFyZW50XCJcblxuXG4gIGlmIChpc0ltcGxpY2l0UnVsZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZpeGVkRWxlbWVudHMuc2V0KGVsZW1lbnQsIHRydWUpO1xuICB2YXIgcG9pbnRzID0gW107XG4gIHZhciBydWxlcyA9IGdldFJ1bGVzKHZhbHVlLCBwb2ludHMpO1xuICB2YXIgcGFyZW50UnVsZXMgPSBwYXJlbnQucHJvcHM7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGsgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBhcmVudFJ1bGVzLmxlbmd0aDsgaisrLCBrKyspIHtcbiAgICAgIGVsZW1lbnQucHJvcHNba10gPSBwb2ludHNbaV0gPyBydWxlc1tpXS5yZXBsYWNlKC8mXFxmL2csIHBhcmVudFJ1bGVzW2pdKSA6IHBhcmVudFJ1bGVzW2pdICsgXCIgXCIgKyBydWxlc1tpXTtcbiAgICB9XG4gIH1cbn07XG52YXIgcmVtb3ZlTGFiZWwgPSBmdW5jdGlvbiByZW1vdmVMYWJlbChlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50LnR5cGUgPT09ICdkZWNsJykge1xuICAgIHZhciB2YWx1ZSA9IGVsZW1lbnQudmFsdWU7XG5cbiAgICBpZiAoIC8vIGNoYXJjb2RlIGZvciBsXG4gICAgdmFsdWUuY2hhckNvZGVBdCgwKSA9PT0gMTA4ICYmIC8vIGNoYXJjb2RlIGZvciBiXG4gICAgdmFsdWUuY2hhckNvZGVBdCgyKSA9PT0gOTgpIHtcbiAgICAgIC8vIHRoaXMgaWdub3JlcyBsYWJlbFxuICAgICAgZWxlbWVudFtcInJldHVyblwiXSA9ICcnO1xuICAgICAgZWxlbWVudC52YWx1ZSA9ICcnO1xuICAgIH1cbiAgfVxufTtcbnZhciBpZ25vcmVGbGFnID0gJ2Vtb3Rpb24tZGlzYWJsZS1zZXJ2ZXItcmVuZGVyaW5nLXVuc2FmZS1zZWxlY3Rvci13YXJuaW5nLXBsZWFzZS1kby1ub3QtdXNlLXRoaXMtdGhlLXdhcm5pbmctZXhpc3RzLWZvci1hLXJlYXNvbic7XG5cbnZhciBpc0lnbm9yaW5nQ29tbWVudCA9IGZ1bmN0aW9uIGlzSWdub3JpbmdDb21tZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQudHlwZSA9PT0gJ2NvbW0nICYmIGVsZW1lbnQuY2hpbGRyZW4uaW5kZXhPZihpZ25vcmVGbGFnKSA+IC0xO1xufTtcblxudmFyIGNyZWF0ZVVuc2FmZVNlbGVjdG9yc0FsYXJtID0gZnVuY3Rpb24gY3JlYXRlVW5zYWZlU2VsZWN0b3JzQWxhcm0oY2FjaGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtZW50LCBpbmRleCwgY2hpbGRyZW4pIHtcbiAgICBpZiAoZWxlbWVudC50eXBlICE9PSAncnVsZScgfHwgY2FjaGUuY29tcGF0KSByZXR1cm47XG4gICAgdmFyIHVuc2FmZVBzZXVkb0NsYXNzZXMgPSBlbGVtZW50LnZhbHVlLm1hdGNoKC8oOmZpcnN0fDpudGh8Om50aC1sYXN0KS1jaGlsZC9nKTtcblxuICAgIGlmICh1bnNhZmVQc2V1ZG9DbGFzc2VzKSB7XG4gICAgICB2YXIgaXNOZXN0ZWQgPSBlbGVtZW50LnBhcmVudCA9PT0gY2hpbGRyZW5bMF07IC8vIGluIG5lc3RlZCBydWxlcyBjb21tZW50cyBiZWNvbWUgY2hpbGRyZW4gb2YgdGhlIFwiYXV0by1pbnNlcnRlZFwiIHJ1bGVcbiAgICAgIC8vXG4gICAgICAvLyBjb25zaWRlcmluZyB0aGlzIGlucHV0OlxuICAgICAgLy8gLmEge1xuICAgICAgLy8gICAuYiAvKiBjb21tICovIHt9XG4gICAgICAvLyAgIGNvbG9yOiBob3RwaW5rO1xuICAgICAgLy8gfVxuICAgICAgLy8gd2UgZ2V0IG91dHB1dCBjb3JyZXNwb25kaW5nIHRvIHRoaXM6XG4gICAgICAvLyAuYSB7XG4gICAgICAvLyAgICYge1xuICAgICAgLy8gICAgIC8qIGNvbW0gKi9cbiAgICAgIC8vICAgICBjb2xvcjogaG90cGluaztcbiAgICAgIC8vICAgfVxuICAgICAgLy8gICAuYiB7fVxuICAgICAgLy8gfVxuXG4gICAgICB2YXIgY29tbWVudENvbnRhaW5lciA9IGlzTmVzdGVkID8gY2hpbGRyZW5bMF0uY2hpbGRyZW4gOiAvLyBnbG9iYWwgcnVsZSBhdCB0aGUgcm9vdCBsZXZlbFxuICAgICAgY2hpbGRyZW47XG5cbiAgICAgIGZvciAodmFyIGkgPSBjb21tZW50Q29udGFpbmVyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBub2RlID0gY29tbWVudENvbnRhaW5lcltpXTtcblxuICAgICAgICBpZiAobm9kZS5saW5lIDwgZWxlbWVudC5saW5lKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gLy8gaXQgaXMgcXVpdGUgd2VpcmQgYnV0IGNvbW1lbnRzIGFyZSAqdXN1YWxseSogcHV0IGF0IGBjb2x1bW46IGVsZW1lbnQuY29sdW1uIC0gMWBcbiAgICAgICAgLy8gc28gd2Ugc2VlayAqZnJvbSB0aGUgZW5kKiBmb3IgdGhlIG5vZGUgdGhhdCBpcyBlYXJsaWVyIHRoYW4gdGhlIHJ1bGUncyBgZWxlbWVudGAgYW5kIGNoZWNrIHRoYXRcbiAgICAgICAgLy8gdGhpcyB3aWxsIGFsc28gbWF0Y2ggaW5wdXRzIGxpa2UgdGhpczpcbiAgICAgICAgLy8gLmEge1xuICAgICAgICAvLyAgIC8qIGNvbW0gKi9cbiAgICAgICAgLy8gICAuYiB7fVxuICAgICAgICAvLyB9XG4gICAgICAgIC8vXG4gICAgICAgIC8vIGJ1dCB0aGF0IGlzIGZpbmVcbiAgICAgICAgLy9cbiAgICAgICAgLy8gaXQgd291bGQgYmUgdGhlIGVhc2llc3QgdG8gY2hhbmdlIHRoZSBwbGFjZW1lbnQgb2YgdGhlIGNvbW1lbnQgdG8gYmUgdGhlIGZpcnN0IGNoaWxkIG9mIHRoZSBydWxlOlxuICAgICAgICAvLyAuYSB7XG4gICAgICAgIC8vICAgLmIgeyAvKiBjb21tICovIH1cbiAgICAgICAgLy8gfVxuICAgICAgICAvLyB3aXRoIHN1Y2ggaW5wdXRzIHdlIHdvdWxkbid0IGhhdmUgdG8gc2VhcmNoIGZvciB0aGUgY29tbWVudCBhdCBhbGxcbiAgICAgICAgLy8gVE9ETzogY29uc2lkZXIgY2hhbmdpbmcgdGhpcyBjb21tZW50IHBsYWNlbWVudCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uXG5cblxuICAgICAgICBpZiAobm9kZS5jb2x1bW4gPCBlbGVtZW50LmNvbHVtbikge1xuICAgICAgICAgIGlmIChpc0lnbm9yaW5nQ29tbWVudChub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHVuc2FmZVBzZXVkb0NsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAodW5zYWZlUHNldWRvQ2xhc3MpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlRoZSBwc2V1ZG8gY2xhc3MgXFxcIlwiICsgdW5zYWZlUHNldWRvQ2xhc3MgKyBcIlxcXCIgaXMgcG90ZW50aWFsbHkgdW5zYWZlIHdoZW4gZG9pbmcgc2VydmVyLXNpZGUgcmVuZGVyaW5nLiBUcnkgY2hhbmdpbmcgaXQgdG8gXFxcIlwiICsgdW5zYWZlUHNldWRvQ2xhc3Muc3BsaXQoJy1jaGlsZCcpWzBdICsgXCItb2YtdHlwZVxcXCIuXCIpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufTtcblxudmFyIGlzSW1wb3J0UnVsZSA9IGZ1bmN0aW9uIGlzSW1wb3J0UnVsZShlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50LnR5cGUuY2hhckNvZGVBdCgxKSA9PT0gMTA1ICYmIGVsZW1lbnQudHlwZS5jaGFyQ29kZUF0KDApID09PSA2NDtcbn07XG5cbnZhciBpc1ByZXBlbmRlZFdpdGhSZWd1bGFyUnVsZXMgPSBmdW5jdGlvbiBpc1ByZXBlbmRlZFdpdGhSZWd1bGFyUnVsZXMoaW5kZXgsIGNoaWxkcmVuKSB7XG4gIGZvciAodmFyIGkgPSBpbmRleCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKCFpc0ltcG9ydFJ1bGUoY2hpbGRyZW5baV0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59OyAvLyB1c2UgdGhpcyB0byByZW1vdmUgaW5jb3JyZWN0IGVsZW1lbnRzIGZyb20gZnVydGhlciBwcm9jZXNzaW5nXG4vLyBzbyB0aGV5IGRvbid0IGdldCBoYW5kZWQgdG8gdGhlIGBzaGVldGAgKG9yIGFueXRoaW5nIGVsc2UpXG4vLyBhcyB0aGF0IGNvdWxkIHBvdGVudGlhbGx5IGxlYWQgdG8gYWRkaXRpb25hbCBsb2dzIHdoaWNoIGluIHR1cm4gY291bGQgYmUgb3ZlcmhlbG1pbmcgdG8gdGhlIHVzZXJcblxuXG52YXIgbnVsbGlmeUVsZW1lbnQgPSBmdW5jdGlvbiBudWxsaWZ5RWxlbWVudChlbGVtZW50KSB7XG4gIGVsZW1lbnQudHlwZSA9ICcnO1xuICBlbGVtZW50LnZhbHVlID0gJyc7XG4gIGVsZW1lbnRbXCJyZXR1cm5cIl0gPSAnJztcbiAgZWxlbWVudC5jaGlsZHJlbiA9ICcnO1xuICBlbGVtZW50LnByb3BzID0gJyc7XG59O1xuXG52YXIgaW5jb3JyZWN0SW1wb3J0QWxhcm0gPSBmdW5jdGlvbiBpbmNvcnJlY3RJbXBvcnRBbGFybShlbGVtZW50LCBpbmRleCwgY2hpbGRyZW4pIHtcbiAgaWYgKCFpc0ltcG9ydFJ1bGUoZWxlbWVudCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZWxlbWVudC5wYXJlbnQpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiYEBpbXBvcnRgIHJ1bGVzIGNhbid0IGJlIG5lc3RlZCBpbnNpZGUgb3RoZXIgcnVsZXMuIFBsZWFzZSBtb3ZlIGl0IHRvIHRoZSB0b3AgbGV2ZWwgYW5kIHB1dCBpdCBiZWZvcmUgcmVndWxhciBydWxlcy4gS2VlcCBpbiBtaW5kIHRoYXQgdGhleSBjYW4gb25seSBiZSB1c2VkIHdpdGhpbiBnbG9iYWwgc3R5bGVzLlwiKTtcbiAgICBudWxsaWZ5RWxlbWVudChlbGVtZW50KTtcbiAgfSBlbHNlIGlmIChpc1ByZXBlbmRlZFdpdGhSZWd1bGFyUnVsZXMoaW5kZXgsIGNoaWxkcmVuKSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJgQGltcG9ydGAgcnVsZXMgY2FuJ3QgYmUgYWZ0ZXIgb3RoZXIgcnVsZXMuIFBsZWFzZSBwdXQgeW91ciBgQGltcG9ydGAgcnVsZXMgYmVmb3JlIHlvdXIgb3RoZXIgcnVsZXMuXCIpO1xuICAgIG51bGxpZnlFbGVtZW50KGVsZW1lbnQpO1xuICB9XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1mYWxsdGhyb3VnaCAqL1xuXG5mdW5jdGlvbiBwcmVmaXgodmFsdWUsIGxlbmd0aCkge1xuICBzd2l0Y2ggKGhhc2gkMih2YWx1ZSwgbGVuZ3RoKSkge1xuICAgIC8vIGNvbG9yLWFkanVzdFxuICAgIGNhc2UgNTEwMzpcbiAgICAgIHJldHVybiBXRUJLSVQgKyAncHJpbnQtJyArIHZhbHVlICsgdmFsdWU7XG4gICAgLy8gYW5pbWF0aW9uLCBhbmltYXRpb24tKGRlbGF5fGRpcmVjdGlvbnxkdXJhdGlvbnxmaWxsLW1vZGV8aXRlcmF0aW9uLWNvdW50fG5hbWV8cGxheS1zdGF0ZXx0aW1pbmctZnVuY3Rpb24pXG5cbiAgICBjYXNlIDU3Mzc6XG4gICAgY2FzZSA0MjAxOlxuICAgIGNhc2UgMzE3NzpcbiAgICBjYXNlIDM0MzM6XG4gICAgY2FzZSAxNjQxOlxuICAgIGNhc2UgNDQ1NzpcbiAgICBjYXNlIDI5MjE6IC8vIHRleHQtZGVjb3JhdGlvbiwgZmlsdGVyLCBjbGlwLXBhdGgsIGJhY2tmYWNlLXZpc2liaWxpdHksIGNvbHVtbiwgYm94LWRlY29yYXRpb24tYnJlYWtcblxuICAgIGNhc2UgNTU3MjpcbiAgICBjYXNlIDYzNTY6XG4gICAgY2FzZSA1ODQ0OlxuICAgIGNhc2UgMzE5MTpcbiAgICBjYXNlIDY2NDU6XG4gICAgY2FzZSAzMDA1OiAvLyBtYXNrLCBtYXNrLWltYWdlLCBtYXNrLShtb2RlfGNsaXB8c2l6ZSksIG1hc2stKHJlcGVhdHxvcmlnaW4pLCBtYXNrLXBvc2l0aW9uLCBtYXNrLWNvbXBvc2l0ZSxcblxuICAgIGNhc2UgNjM5MTpcbiAgICBjYXNlIDU4Nzk6XG4gICAgY2FzZSA1NjIzOlxuICAgIGNhc2UgNjEzNTpcbiAgICBjYXNlIDQ1OTk6XG4gICAgY2FzZSA0ODU1OiAvLyBiYWNrZ3JvdW5kLWNsaXAsIGNvbHVtbnMsIGNvbHVtbi0oY291bnR8ZmlsbHxnYXB8cnVsZXxydWxlLWNvbG9yfHJ1bGUtc3R5bGV8cnVsZS13aWR0aHxzcGFufHdpZHRoKVxuXG4gICAgY2FzZSA0MjE1OlxuICAgIGNhc2UgNjM4OTpcbiAgICBjYXNlIDUxMDk6XG4gICAgY2FzZSA1MzY1OlxuICAgIGNhc2UgNTYyMTpcbiAgICBjYXNlIDM4Mjk6XG4gICAgICByZXR1cm4gV0VCS0lUICsgdmFsdWUgKyB2YWx1ZTtcbiAgICAvLyBhcHBlYXJhbmNlLCB1c2VyLXNlbGVjdCwgdHJhbnNmb3JtLCBoeXBoZW5zLCB0ZXh0LXNpemUtYWRqdXN0XG5cbiAgICBjYXNlIDUzNDk6XG4gICAgY2FzZSA0MjQ2OlxuICAgIGNhc2UgNDgxMDpcbiAgICBjYXNlIDY5Njg6XG4gICAgY2FzZSAyNzU2OlxuICAgICAgcmV0dXJuIFdFQktJVCArIHZhbHVlICsgTU9aICsgdmFsdWUgKyBNUyArIHZhbHVlICsgdmFsdWU7XG4gICAgLy8gZmxleCwgZmxleC1kaXJlY3Rpb25cblxuICAgIGNhc2UgNjgyODpcbiAgICBjYXNlIDQyNjg6XG4gICAgICByZXR1cm4gV0VCS0lUICsgdmFsdWUgKyBNUyArIHZhbHVlICsgdmFsdWU7XG4gICAgLy8gb3JkZXJcblxuICAgIGNhc2UgNjE2NTpcbiAgICAgIHJldHVybiBXRUJLSVQgKyB2YWx1ZSArIE1TICsgJ2ZsZXgtJyArIHZhbHVlICsgdmFsdWU7XG4gICAgLy8gYWxpZ24taXRlbXNcblxuICAgIGNhc2UgNTE4NzpcbiAgICAgIHJldHVybiBXRUJLSVQgKyB2YWx1ZSArIHJlcGxhY2UodmFsdWUsIC8oXFx3KykuKyg6W15dKykvLCBXRUJLSVQgKyAnYm94LSQxJDInICsgTVMgKyAnZmxleC0kMSQyJykgKyB2YWx1ZTtcbiAgICAvLyBhbGlnbi1zZWxmXG5cbiAgICBjYXNlIDU0NDM6XG4gICAgICByZXR1cm4gV0VCS0lUICsgdmFsdWUgKyBNUyArICdmbGV4LWl0ZW0tJyArIHJlcGxhY2UodmFsdWUsIC9mbGV4LXwtc2VsZi8sICcnKSArIHZhbHVlO1xuICAgIC8vIGFsaWduLWNvbnRlbnRcblxuICAgIGNhc2UgNDY3NTpcbiAgICAgIHJldHVybiBXRUJLSVQgKyB2YWx1ZSArIE1TICsgJ2ZsZXgtbGluZS1wYWNrJyArIHJlcGxhY2UodmFsdWUsIC9hbGlnbi1jb250ZW50fGZsZXgtfC1zZWxmLywgJycpICsgdmFsdWU7XG4gICAgLy8gZmxleC1zaHJpbmtcblxuICAgIGNhc2UgNTU0ODpcbiAgICAgIHJldHVybiBXRUJLSVQgKyB2YWx1ZSArIE1TICsgcmVwbGFjZSh2YWx1ZSwgJ3NocmluaycsICduZWdhdGl2ZScpICsgdmFsdWU7XG4gICAgLy8gZmxleC1iYXNpc1xuXG4gICAgY2FzZSA1MjkyOlxuICAgICAgcmV0dXJuIFdFQktJVCArIHZhbHVlICsgTVMgKyByZXBsYWNlKHZhbHVlLCAnYmFzaXMnLCAncHJlZmVycmVkLXNpemUnKSArIHZhbHVlO1xuICAgIC8vIGZsZXgtZ3Jvd1xuXG4gICAgY2FzZSA2MDYwOlxuICAgICAgcmV0dXJuIFdFQktJVCArICdib3gtJyArIHJlcGxhY2UodmFsdWUsICctZ3JvdycsICcnKSArIFdFQktJVCArIHZhbHVlICsgTVMgKyByZXBsYWNlKHZhbHVlLCAnZ3JvdycsICdwb3NpdGl2ZScpICsgdmFsdWU7XG4gICAgLy8gdHJhbnNpdGlvblxuXG4gICAgY2FzZSA0NTU0OlxuICAgICAgcmV0dXJuIFdFQktJVCArIHJlcGxhY2UodmFsdWUsIC8oW14tXSkodHJhbnNmb3JtKS9nLCAnJDEnICsgV0VCS0lUICsgJyQyJykgKyB2YWx1ZTtcbiAgICAvLyBjdXJzb3JcblxuICAgIGNhc2UgNjE4NzpcbiAgICAgIHJldHVybiByZXBsYWNlKHJlcGxhY2UocmVwbGFjZSh2YWx1ZSwgLyh6b29tLXxncmFiKS8sIFdFQktJVCArICckMScpLCAvKGltYWdlLXNldCkvLCBXRUJLSVQgKyAnJDEnKSwgdmFsdWUsICcnKSArIHZhbHVlO1xuICAgIC8vIGJhY2tncm91bmQsIGJhY2tncm91bmQtaW1hZ2VcblxuICAgIGNhc2UgNTQ5NTpcbiAgICBjYXNlIDM5NTk6XG4gICAgICByZXR1cm4gcmVwbGFjZSh2YWx1ZSwgLyhpbWFnZS1zZXRcXChbXl0qKS8sIFdFQktJVCArICckMScgKyAnJGAkMScpO1xuICAgIC8vIGp1c3RpZnktY29udGVudFxuXG4gICAgY2FzZSA0OTY4OlxuICAgICAgcmV0dXJuIHJlcGxhY2UocmVwbGFjZSh2YWx1ZSwgLyguKzopKGZsZXgtKT8oLiopLywgV0VCS0lUICsgJ2JveC1wYWNrOiQzJyArIE1TICsgJ2ZsZXgtcGFjazokMycpLCAvcy4rLWJbXjtdKy8sICdqdXN0aWZ5JykgKyBXRUJLSVQgKyB2YWx1ZSArIHZhbHVlO1xuICAgIC8vIChtYXJnaW58cGFkZGluZyktaW5saW5lLShzdGFydHxlbmQpXG5cbiAgICBjYXNlIDQwOTU6XG4gICAgY2FzZSAzNTgzOlxuICAgIGNhc2UgNDA2ODpcbiAgICBjYXNlIDI1MzI6XG4gICAgICByZXR1cm4gcmVwbGFjZSh2YWx1ZSwgLyguKyktaW5saW5lKC4rKS8sIFdFQktJVCArICckMSQyJykgKyB2YWx1ZTtcbiAgICAvLyAobWlufG1heCk/KHdpZHRofGhlaWdodHxpbmxpbmUtc2l6ZXxibG9jay1zaXplKVxuXG4gICAgY2FzZSA4MTE2OlxuICAgIGNhc2UgNzA1OTpcbiAgICBjYXNlIDU3NTM6XG4gICAgY2FzZSA1NTM1OlxuICAgIGNhc2UgNTQ0NTpcbiAgICBjYXNlIDU3MDE6XG4gICAgY2FzZSA0OTMzOlxuICAgIGNhc2UgNDY3NzpcbiAgICBjYXNlIDU1MzM6XG4gICAgY2FzZSA1Nzg5OlxuICAgIGNhc2UgNTAyMTpcbiAgICBjYXNlIDQ3NjU6XG4gICAgICAvLyBzdHJldGNoLCBtYXgtY29udGVudCwgbWluLWNvbnRlbnQsIGZpbGwtYXZhaWxhYmxlXG4gICAgICBpZiAoc3RybGVuKHZhbHVlKSAtIDEgLSBsZW5ndGggPiA2KSBzd2l0Y2ggKGNoYXJhdCh2YWx1ZSwgbGVuZ3RoICsgMSkpIHtcbiAgICAgICAgLy8gKG0pYXgtY29udGVudCwgKG0paW4tY29udGVudFxuICAgICAgICBjYXNlIDEwOTpcbiAgICAgICAgICAvLyAtXG4gICAgICAgICAgaWYgKGNoYXJhdCh2YWx1ZSwgbGVuZ3RoICsgNCkgIT09IDQ1KSBicmVhaztcbiAgICAgICAgLy8gKGYpaWxsLWF2YWlsYWJsZSwgKGYpaXQtY29udGVudFxuXG4gICAgICAgIGNhc2UgMTAyOlxuICAgICAgICAgIHJldHVybiByZXBsYWNlKHZhbHVlLCAvKC4rOikoLispLShbXl0rKS8sICckMScgKyBXRUJLSVQgKyAnJDItJDMnICsgJyQxJyArIE1PWiArIChjaGFyYXQodmFsdWUsIGxlbmd0aCArIDMpID09IDEwOCA/ICckMycgOiAnJDItJDMnKSkgKyB2YWx1ZTtcbiAgICAgICAgLy8gKHMpdHJldGNoXG5cbiAgICAgICAgY2FzZSAxMTU6XG4gICAgICAgICAgcmV0dXJuIH5pbmRleG9mKHZhbHVlLCAnc3RyZXRjaCcpID8gcHJlZml4KHJlcGxhY2UodmFsdWUsICdzdHJldGNoJywgJ2ZpbGwtYXZhaWxhYmxlJyksIGxlbmd0aCkgKyB2YWx1ZSA6IHZhbHVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgLy8gcG9zaXRpb246IHN0aWNreVxuXG4gICAgY2FzZSA0OTQ5OlxuICAgICAgLy8gKHMpdGlja3k/XG4gICAgICBpZiAoY2hhcmF0KHZhbHVlLCBsZW5ndGggKyAxKSAhPT0gMTE1KSBicmVhaztcbiAgICAvLyBkaXNwbGF5OiAoZmxleHxpbmxpbmUtZmxleClcblxuICAgIGNhc2UgNjQ0NDpcbiAgICAgIHN3aXRjaCAoY2hhcmF0KHZhbHVlLCBzdHJsZW4odmFsdWUpIC0gMyAtICh+aW5kZXhvZih2YWx1ZSwgJyFpbXBvcnRhbnQnKSAmJiAxMCkpKSB7XG4gICAgICAgIC8vIHN0aWMoayl5XG4gICAgICAgIGNhc2UgMTA3OlxuICAgICAgICAgIHJldHVybiByZXBsYWNlKHZhbHVlLCAnOicsICc6JyArIFdFQktJVCkgKyB2YWx1ZTtcbiAgICAgICAgLy8gKGlubGluZS0pP2ZsKGUpeFxuXG4gICAgICAgIGNhc2UgMTAxOlxuICAgICAgICAgIHJldHVybiByZXBsYWNlKHZhbHVlLCAvKC4rOikoW147IV0rKSg7fCEuKyk/LywgJyQxJyArIFdFQktJVCArIChjaGFyYXQodmFsdWUsIDE0KSA9PT0gNDUgPyAnaW5saW5lLScgOiAnJykgKyAnYm94JDMnICsgJyQxJyArIFdFQktJVCArICckMiQzJyArICckMScgKyBNUyArICckMmJveCQzJykgKyB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgLy8gd3JpdGluZy1tb2RlXG5cbiAgICBjYXNlIDU5MzY6XG4gICAgICBzd2l0Y2ggKGNoYXJhdCh2YWx1ZSwgbGVuZ3RoICsgMTEpKSB7XG4gICAgICAgIC8vIHZlcnRpY2FsLWwocilcbiAgICAgICAgY2FzZSAxMTQ6XG4gICAgICAgICAgcmV0dXJuIFdFQktJVCArIHZhbHVlICsgTVMgKyByZXBsYWNlKHZhbHVlLCAvW3N2aF1cXHcrLVt0YmxyXXsyfS8sICd0YicpICsgdmFsdWU7XG4gICAgICAgIC8vIHZlcnRpY2FsLXIobClcblxuICAgICAgICBjYXNlIDEwODpcbiAgICAgICAgICByZXR1cm4gV0VCS0lUICsgdmFsdWUgKyBNUyArIHJlcGxhY2UodmFsdWUsIC9bc3ZoXVxcdystW3RibHJdezJ9LywgJ3RiLXJsJykgKyB2YWx1ZTtcbiAgICAgICAgLy8gaG9yaXpvbnRhbCgtKXRiXG5cbiAgICAgICAgY2FzZSA0NTpcbiAgICAgICAgICByZXR1cm4gV0VCS0lUICsgdmFsdWUgKyBNUyArIHJlcGxhY2UodmFsdWUsIC9bc3ZoXVxcdystW3RibHJdezJ9LywgJ2xyJykgKyB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFdFQktJVCArIHZhbHVlICsgTVMgKyB2YWx1ZSArIHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG52YXIgcHJlZml4ZXIgPSBmdW5jdGlvbiBwcmVmaXhlcihlbGVtZW50LCBpbmRleCwgY2hpbGRyZW4sIGNhbGxiYWNrKSB7XG4gIGlmIChlbGVtZW50Lmxlbmd0aCA+IC0xKSBpZiAoIWVsZW1lbnRbXCJyZXR1cm5cIl0pIHN3aXRjaCAoZWxlbWVudC50eXBlKSB7XG4gICAgY2FzZSBERUNMQVJBVElPTjpcbiAgICAgIGVsZW1lbnRbXCJyZXR1cm5cIl0gPSBwcmVmaXgoZWxlbWVudC52YWx1ZSwgZWxlbWVudC5sZW5ndGgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIEtFWUZSQU1FUzpcbiAgICAgIHJldHVybiBzZXJpYWxpemUoW2NvcHkoZWxlbWVudCwge1xuICAgICAgICB2YWx1ZTogcmVwbGFjZShlbGVtZW50LnZhbHVlLCAnQCcsICdAJyArIFdFQktJVClcbiAgICAgIH0pXSwgY2FsbGJhY2spO1xuXG4gICAgY2FzZSBSVUxFU0VUOlxuICAgICAgaWYgKGVsZW1lbnQubGVuZ3RoKSByZXR1cm4gY29tYmluZShlbGVtZW50LnByb3BzLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgc3dpdGNoIChtYXRjaCh2YWx1ZSwgLyg6OnBsYWNcXHcrfDpyZWFkLVxcdyspLykpIHtcbiAgICAgICAgICAvLyA6cmVhZC0ob25seXx3cml0ZSlcbiAgICAgICAgICBjYXNlICc6cmVhZC1vbmx5JzpcbiAgICAgICAgICBjYXNlICc6cmVhZC13cml0ZSc6XG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplKFtjb3B5KGVsZW1lbnQsIHtcbiAgICAgICAgICAgICAgcHJvcHM6IFtyZXBsYWNlKHZhbHVlLCAvOihyZWFkLVxcdyspLywgJzonICsgTU9aICsgJyQxJyldXG4gICAgICAgICAgICB9KV0sIGNhbGxiYWNrKTtcbiAgICAgICAgICAvLyA6cGxhY2Vob2xkZXJcblxuICAgICAgICAgIGNhc2UgJzo6cGxhY2Vob2xkZXInOlxuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZShbY29weShlbGVtZW50LCB7XG4gICAgICAgICAgICAgIHByb3BzOiBbcmVwbGFjZSh2YWx1ZSwgLzoocGxhY1xcdyspLywgJzonICsgV0VCS0lUICsgJ2lucHV0LSQxJyldXG4gICAgICAgICAgICB9KSwgY29weShlbGVtZW50LCB7XG4gICAgICAgICAgICAgIHByb3BzOiBbcmVwbGFjZSh2YWx1ZSwgLzoocGxhY1xcdyspLywgJzonICsgTU9aICsgJyQxJyldXG4gICAgICAgICAgICB9KSwgY29weShlbGVtZW50LCB7XG4gICAgICAgICAgICAgIHByb3BzOiBbcmVwbGFjZSh2YWx1ZSwgLzoocGxhY1xcdyspLywgTVMgKyAnaW5wdXQtJDEnKV1cbiAgICAgICAgICAgIH0pXSwgY2FsbGJhY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfSk7XG4gIH1cbn07XG5cbnZhciBpc0Jyb3dzZXIkNSA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgZ2V0U2VydmVyU3R5bGlzQ2FjaGUgPSBpc0Jyb3dzZXIkNSA/IHVuZGVmaW5lZCA6IHdlYWtNZW1vaXplKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG1lbW9pemUoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYWNoZSA9IHt9O1xuICAgIHJldHVybiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIGNhY2hlW25hbWVdO1xuICAgIH07XG4gIH0pO1xufSk7XG52YXIgZGVmYXVsdFN0eWxpc1BsdWdpbnMgPSBbcHJlZml4ZXJdO1xuXG52YXIgY3JlYXRlQ2FjaGUgPSBmdW5jdGlvbiBjcmVhdGVDYWNoZShvcHRpb25zKSB7XG4gIHZhciBrZXkgPSBvcHRpb25zLmtleTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAha2V5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGhhdmUgdG8gY29uZmlndXJlIGBrZXlgIGZvciB5b3VyIGNhY2hlLiBQbGVhc2UgbWFrZSBzdXJlIGl0J3MgdW5pcXVlIChhbmQgbm90IGVxdWFsIHRvICdjc3MnKSBhcyBpdCdzIHVzZWQgZm9yIGxpbmtpbmcgc3R5bGVzIHRvIHlvdXIgY2FjaGUuXFxuXCIgKyBcIklmIG11bHRpcGxlIGNhY2hlcyBzaGFyZSB0aGUgc2FtZSBrZXkgdGhleSBtaWdodCBcXFwiZmlnaHRcXFwiIGZvciBlYWNoIG90aGVyJ3Mgc3R5bGUgZWxlbWVudHMuXCIpO1xuICB9XG5cbiAgaWYgKGlzQnJvd3NlciQ1ICYmIGtleSA9PT0gJ2NzcycpIHtcbiAgICB2YXIgc3NyU3R5bGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcInN0eWxlW2RhdGEtZW1vdGlvbl06bm90KFtkYXRhLXNdKVwiKTsgLy8gZ2V0IFNTUmVkIHN0eWxlcyBvdXQgb2YgdGhlIHdheSBvZiBSZWFjdCdzIGh5ZHJhdGlvblxuICAgIC8vIGRvY3VtZW50LmhlYWQgaXMgYSBzYWZlIHBsYWNlIHRvIG1vdmUgdGhlbSB0byh0aG91Z2ggbm90ZSBkb2N1bWVudC5oZWFkIGlzIG5vdCBuZWNlc3NhcmlseSB0aGUgbGFzdCBwbGFjZSB0aGV5IHdpbGwgYmUpXG4gICAgLy8gbm90ZSB0aGlzIHZlcnkgdmVyeSBpbnRlbnRpb25hbGx5IHRhcmdldHMgYWxsIHN0eWxlIGVsZW1lbnRzIHJlZ2FyZGxlc3Mgb2YgdGhlIGtleSB0byBlbnN1cmVcbiAgICAvLyB0aGF0IGNyZWF0aW5nIGEgY2FjaGUgd29ya3MgaW5zaWRlIG9mIHJlbmRlciBvZiBhIFJlYWN0IGNvbXBvbmVudFxuXG4gICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChzc3JTdHlsZXMsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAvLyB3ZSB3YW50IHRvIG9ubHkgbW92ZSBlbGVtZW50cyB3aGljaCBoYXZlIGEgc3BhY2UgaW4gdGhlIGRhdGEtZW1vdGlvbiBhdHRyaWJ1dGUgdmFsdWVcbiAgICAgIC8vIGJlY2F1c2UgdGhhdCBpbmRpY2F0ZXMgdGhhdCBpdCBpcyBhbiBFbW90aW9uIDExIHNlcnZlci1zaWRlIHJlbmRlcmVkIHN0eWxlIGVsZW1lbnRzXG4gICAgICAvLyB3aGlsZSB3ZSB3aWxsIGFscmVhZHkgaWdub3JlIEVtb3Rpb24gMTEgY2xpZW50LXNpZGUgaW5zZXJ0ZWQgc3R5bGVzIGJlY2F1c2Ugb2YgdGhlIDpub3QoW2RhdGEtc10pIHBhcnQgaW4gdGhlIHNlbGVjdG9yXG4gICAgICAvLyBFbW90aW9uIDEwIGNsaWVudC1zaWRlIGluc2VydGVkIHN0eWxlcyBkaWQgbm90IGhhdmUgZGF0YS1zIChidXQgaW1wb3J0YW50bHkgZGlkIG5vdCBoYXZlIGEgc3BhY2UgaW4gdGhlaXIgZGF0YS1lbW90aW9uIGF0dHJpYnV0ZXMpXG4gICAgICAvLyBzbyBjaGVja2luZyBmb3IgdGhlIHNwYWNlIGVuc3VyZXMgdGhhdCBsb2FkaW5nIEVtb3Rpb24gMTEgYWZ0ZXIgRW1vdGlvbiAxMCBoYXMgaW5zZXJ0ZWQgc29tZSBzdHlsZXNcbiAgICAgIC8vIHdpbGwgbm90IHJlc3VsdCBpbiB0aGUgRW1vdGlvbiAxMCBzdHlsZXMgYmVpbmcgZGVzdHJveWVkXG4gICAgICB2YXIgZGF0YUVtb3Rpb25BdHRyaWJ1dGUgPSBub2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1lbW90aW9uJyk7XG5cbiAgICAgIGlmIChkYXRhRW1vdGlvbkF0dHJpYnV0ZS5pbmRleE9mKCcgJykgPT09IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZSgnZGF0YS1zJywgJycpO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIHN0eWxpc1BsdWdpbnMgPSBvcHRpb25zLnN0eWxpc1BsdWdpbnMgfHwgZGVmYXVsdFN0eWxpc1BsdWdpbnM7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyAkRmxvd0ZpeE1lXG4gICAgaWYgKC9bXmEtei1dLy50ZXN0KGtleSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVtb3Rpb24ga2V5IG11c3Qgb25seSBjb250YWluIGxvd2VyIGNhc2UgYWxwaGFiZXRpY2FsIGNoYXJhY3RlcnMgYW5kIC0gYnV0IFxcXCJcIiArIGtleSArIFwiXFxcIiB3YXMgcGFzc2VkXCIpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpbnNlcnRlZCA9IHt9O1xuICB2YXIgY29udGFpbmVyO1xuICB2YXIgbm9kZXNUb0h5ZHJhdGUgPSBbXTtcblxuICBpZiAoaXNCcm93c2VyJDUpIHtcbiAgICBjb250YWluZXIgPSBvcHRpb25zLmNvbnRhaW5lciB8fCBkb2N1bWVudC5oZWFkO1xuICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoIC8vIHRoaXMgbWVhbnMgd2Ugd2lsbCBpZ25vcmUgZWxlbWVudHMgd2hpY2ggZG9uJ3QgaGF2ZSBhIHNwYWNlIGluIHRoZW0gd2hpY2hcbiAgICAvLyBtZWFucyB0aGF0IHRoZSBzdHlsZSBlbGVtZW50cyB3ZSdyZSBsb29raW5nIGF0IGFyZSBvbmx5IEVtb3Rpb24gMTEgc2VydmVyLXJlbmRlcmVkIHN0eWxlIGVsZW1lbnRzXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcInN0eWxlW2RhdGEtZW1vdGlvbl49XFxcIlwiICsga2V5ICsgXCIgXFxcIl1cIiksIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICB2YXIgYXR0cmliID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWVtb3Rpb25cIikuc3BsaXQoJyAnKTsgLy8gJEZsb3dGaXhNZVxuXG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGF0dHJpYi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpbnNlcnRlZFthdHRyaWJbaV1dID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgbm9kZXNUb0h5ZHJhdGUucHVzaChub2RlKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBfaW5zZXJ0O1xuXG4gIHZhciBvbW5pcHJlc2VudFBsdWdpbnMgPSBbY29tcGF0LCByZW1vdmVMYWJlbF07XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBvbW5pcHJlc2VudFBsdWdpbnMucHVzaChjcmVhdGVVbnNhZmVTZWxlY3RvcnNBbGFybSh7XG4gICAgICBnZXQgY29tcGF0KCkge1xuICAgICAgICByZXR1cm4gY2FjaGUuY29tcGF0O1xuICAgICAgfVxuXG4gICAgfSksIGluY29ycmVjdEltcG9ydEFsYXJtKTtcbiAgfVxuXG4gIGlmIChpc0Jyb3dzZXIkNSkge1xuICAgIHZhciBjdXJyZW50U2hlZXQ7XG4gICAgdmFyIGZpbmFsaXppbmdQbHVnaW5zID0gW3N0cmluZ2lmeSwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICBpZiAoIWVsZW1lbnQucm9vdCkge1xuICAgICAgICBpZiAoZWxlbWVudFtcInJldHVyblwiXSkge1xuICAgICAgICAgIGN1cnJlbnRTaGVldC5pbnNlcnQoZWxlbWVudFtcInJldHVyblwiXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC52YWx1ZSAmJiBlbGVtZW50LnR5cGUgIT09IENPTU1FTlQpIHtcbiAgICAgICAgICAvLyBpbnNlcnQgZW1wdHkgcnVsZSBpbiBub24tcHJvZHVjdGlvbiBlbnZpcm9ubWVudHNcbiAgICAgICAgICAvLyBzbyBAZW1vdGlvbi9qZXN0IGNhbiBncmFiIGBrZXlgIGZyb20gdGhlIChKUylET00gZm9yIGNhY2hlcyB3aXRob3V0IGFueSBydWxlcyBpbnNlcnRlZCB5ZXRcbiAgICAgICAgICBjdXJyZW50U2hlZXQuaW5zZXJ0KGVsZW1lbnQudmFsdWUgKyBcInt9XCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSA6IHJ1bGVzaGVldChmdW5jdGlvbiAocnVsZSkge1xuICAgICAgY3VycmVudFNoZWV0Lmluc2VydChydWxlKTtcbiAgICB9KV07XG4gICAgdmFyIHNlcmlhbGl6ZXIgPSBtaWRkbGV3YXJlKG9tbmlwcmVzZW50UGx1Z2lucy5jb25jYXQoc3R5bGlzUGx1Z2lucywgZmluYWxpemluZ1BsdWdpbnMpKTtcblxuICAgIHZhciBzdHlsaXMgPSBmdW5jdGlvbiBzdHlsaXMoc3R5bGVzKSB7XG4gICAgICByZXR1cm4gc2VyaWFsaXplKGNvbXBpbGUoc3R5bGVzKSwgc2VyaWFsaXplcik7XG4gICAgfTtcblxuICAgIF9pbnNlcnQgPSBmdW5jdGlvbiBpbnNlcnQoc2VsZWN0b3IsIHNlcmlhbGl6ZWQsIHNoZWV0LCBzaG91bGRDYWNoZSkge1xuICAgICAgY3VycmVudFNoZWV0ID0gc2hlZXQ7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHNlcmlhbGl6ZWQubWFwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY3VycmVudFNoZWV0ID0ge1xuICAgICAgICAgIGluc2VydDogZnVuY3Rpb24gaW5zZXJ0KHJ1bGUpIHtcbiAgICAgICAgICAgIHNoZWV0Lmluc2VydChydWxlICsgc2VyaWFsaXplZC5tYXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgc3R5bGlzKHNlbGVjdG9yID8gc2VsZWN0b3IgKyBcIntcIiArIHNlcmlhbGl6ZWQuc3R5bGVzICsgXCJ9XCIgOiBzZXJpYWxpemVkLnN0eWxlcyk7XG5cbiAgICAgIGlmIChzaG91bGRDYWNoZSkge1xuICAgICAgICBjYWNoZS5pbnNlcnRlZFtzZXJpYWxpemVkLm5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHZhciBfZmluYWxpemluZ1BsdWdpbnMgPSBbc3RyaW5naWZ5XTtcblxuICAgIHZhciBfc2VyaWFsaXplciA9IG1pZGRsZXdhcmUob21uaXByZXNlbnRQbHVnaW5zLmNvbmNhdChzdHlsaXNQbHVnaW5zLCBfZmluYWxpemluZ1BsdWdpbnMpKTtcblxuICAgIHZhciBfc3R5bGlzID0gZnVuY3Rpb24gX3N0eWxpcyhzdHlsZXMpIHtcbiAgICAgIHJldHVybiBzZXJpYWxpemUoY29tcGlsZShzdHlsZXMpLCBfc2VyaWFsaXplcik7XG4gICAgfTsgLy8gJEZsb3dGaXhNZVxuXG5cbiAgICB2YXIgc2VydmVyU3R5bGlzQ2FjaGUgPSBnZXRTZXJ2ZXJTdHlsaXNDYWNoZShzdHlsaXNQbHVnaW5zKShrZXkpO1xuXG4gICAgdmFyIGdldFJ1bGVzID0gZnVuY3Rpb24gZ2V0UnVsZXMoc2VsZWN0b3IsIHNlcmlhbGl6ZWQpIHtcbiAgICAgIHZhciBuYW1lID0gc2VyaWFsaXplZC5uYW1lO1xuXG4gICAgICBpZiAoc2VydmVyU3R5bGlzQ2FjaGVbbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZXJ2ZXJTdHlsaXNDYWNoZVtuYW1lXSA9IF9zdHlsaXMoc2VsZWN0b3IgPyBzZWxlY3RvciArIFwie1wiICsgc2VyaWFsaXplZC5zdHlsZXMgKyBcIn1cIiA6IHNlcmlhbGl6ZWQuc3R5bGVzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlcnZlclN0eWxpc0NhY2hlW25hbWVdO1xuICAgIH07XG5cbiAgICBfaW5zZXJ0ID0gZnVuY3Rpb24gX2luc2VydChzZWxlY3Rvciwgc2VyaWFsaXplZCwgc2hlZXQsIHNob3VsZENhY2hlKSB7XG4gICAgICB2YXIgbmFtZSA9IHNlcmlhbGl6ZWQubmFtZTtcbiAgICAgIHZhciBydWxlcyA9IGdldFJ1bGVzKHNlbGVjdG9yLCBzZXJpYWxpemVkKTtcblxuICAgICAgaWYgKGNhY2hlLmNvbXBhdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGluIHJlZ3VsYXIgbW9kZSwgd2UgZG9uJ3Qgc2V0IHRoZSBzdHlsZXMgb24gdGhlIGluc2VydGVkIGNhY2hlXG4gICAgICAgIC8vIHNpbmNlIHdlIGRvbid0IG5lZWQgdG8gYW5kIHRoYXQgd291bGQgYmUgd2FzdGluZyBtZW1vcnlcbiAgICAgICAgLy8gd2UgcmV0dXJuIHRoZW0gc28gdGhhdCB0aGV5IGFyZSByZW5kZXJlZCBpbiBhIHN0eWxlIHRhZ1xuICAgICAgICBpZiAoc2hvdWxkQ2FjaGUpIHtcbiAgICAgICAgICBjYWNoZS5pbnNlcnRlZFtuYW1lXSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIC8vIHVzaW5nID09PSBkZXZlbG9wbWVudCBpbnN0ZWFkIG9mICE9PSBwcm9kdWN0aW9uXG4gICAgICAgIC8vIGJlY2F1c2UgaWYgcGVvcGxlIGRvIHNzciBpbiB0ZXN0cywgdGhlIHNvdXJjZSBtYXBzIHNob3dpbmcgdXAgd291bGQgYmUgYW5ub3lpbmdcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgc2VyaWFsaXplZC5tYXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBydWxlcyArIHNlcmlhbGl6ZWQubWFwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJ1bGVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaW4gY29tcGF0IG1vZGUsIHdlIHB1dCB0aGUgc3R5bGVzIG9uIHRoZSBpbnNlcnRlZCBjYWNoZSBzb1xuICAgICAgICAvLyB0aGF0IGVtb3Rpb24tc2VydmVyIGNhbiBwdWxsIG91dCB0aGUgc3R5bGVzXG4gICAgICAgIC8vIGV4Y2VwdCB3aGVuIHdlIGRvbid0IHdhbnQgdG8gY2FjaGUgaXQgd2hpY2ggd2FzIGluIEdsb2JhbCBidXQgbm93XG4gICAgICAgIC8vIGlzIG5vd2hlcmUgYnV0IHdlIGRvbid0IHdhbnQgdG8gZG8gYSBtYWpvciByaWdodCBub3dcbiAgICAgICAgLy8gYW5kIGp1c3QgaW4gY2FzZSB3ZSdyZSBnb2luZyB0byBsZWF2ZSB0aGUgY2FzZSBoZXJlXG4gICAgICAgIC8vIGl0J3MgYWxzbyBub3QgYWZmZWN0aW5nIGNsaWVudCBzaWRlIGJ1bmRsZSBzaXplXG4gICAgICAgIC8vIHNvIGl0J3MgcmVhbGx5IG5vdCBhIGJpZyBkZWFsXG4gICAgICAgIGlmIChzaG91bGRDYWNoZSkge1xuICAgICAgICAgIGNhY2hlLmluc2VydGVkW25hbWVdID0gcnVsZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHJ1bGVzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHZhciBjYWNoZSA9IHtcbiAgICBrZXk6IGtleSxcbiAgICBzaGVldDogbmV3IFN0eWxlU2hlZXQoe1xuICAgICAga2V5OiBrZXksXG4gICAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgIG5vbmNlOiBvcHRpb25zLm5vbmNlLFxuICAgICAgc3BlZWR5OiBvcHRpb25zLnNwZWVkeSxcbiAgICAgIHByZXBlbmQ6IG9wdGlvbnMucHJlcGVuZCxcbiAgICAgIGluc2VydGlvblBvaW50OiBvcHRpb25zLmluc2VydGlvblBvaW50XG4gICAgfSksXG4gICAgbm9uY2U6IG9wdGlvbnMubm9uY2UsXG4gICAgaW5zZXJ0ZWQ6IGluc2VydGVkLFxuICAgIHJlZ2lzdGVyZWQ6IHt9LFxuICAgIGluc2VydDogX2luc2VydFxuICB9O1xuICBjYWNoZS5zaGVldC5oeWRyYXRlKG5vZGVzVG9IeWRyYXRlKTtcbiAgcmV0dXJuIGNhY2hlO1xufTtcblxudmFyIGlzQnJvd3NlciQ0ID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbmZ1bmN0aW9uIGdldFJlZ2lzdGVyZWRTdHlsZXMkMShyZWdpc3RlcmVkLCByZWdpc3RlcmVkU3R5bGVzLCBjbGFzc05hbWVzKSB7XG4gIHZhciByYXdDbGFzc05hbWUgPSAnJztcbiAgY2xhc3NOYW1lcy5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgIGlmIChyZWdpc3RlcmVkW2NsYXNzTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVnaXN0ZXJlZFN0eWxlcy5wdXNoKHJlZ2lzdGVyZWRbY2xhc3NOYW1lXSArIFwiO1wiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmF3Q2xhc3NOYW1lICs9IGNsYXNzTmFtZSArIFwiIFwiO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByYXdDbGFzc05hbWU7XG59XG52YXIgcmVnaXN0ZXJTdHlsZXMkMSA9IGZ1bmN0aW9uIHJlZ2lzdGVyU3R5bGVzKGNhY2hlLCBzZXJpYWxpemVkLCBpc1N0cmluZ1RhZykge1xuICB2YXIgY2xhc3NOYW1lID0gY2FjaGUua2V5ICsgXCItXCIgKyBzZXJpYWxpemVkLm5hbWU7XG5cbiAgaWYgKCAvLyB3ZSBvbmx5IG5lZWQgdG8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIHJlZ2lzdGVyZWQgY2FjaGUgaWYgdGhlXG4gIC8vIGNsYXNzIG5hbWUgY291bGQgYmUgdXNlZCBmdXJ0aGVyIGRvd25cbiAgLy8gdGhlIHRyZWUgYnV0IGlmIGl0J3MgYSBzdHJpbmcgdGFnLCB3ZSBrbm93IGl0IHdvbid0XG4gIC8vIHNvIHdlIGRvbid0IGhhdmUgdG8gYWRkIGl0IHRvIHJlZ2lzdGVyZWQgY2FjaGUuXG4gIC8vIHRoaXMgaW1wcm92ZXMgbWVtb3J5IHVzYWdlIHNpbmNlIHdlIGNhbiBhdm9pZCBzdG9yaW5nIHRoZSB3aG9sZSBzdHlsZSBzdHJpbmdcbiAgKGlzU3RyaW5nVGFnID09PSBmYWxzZSB8fCAvLyB3ZSBuZWVkIHRvIGFsd2F5cyBzdG9yZSBpdCBpZiB3ZSdyZSBpbiBjb21wYXQgbW9kZSBhbmRcbiAgLy8gaW4gbm9kZSBzaW5jZSBlbW90aW9uLXNlcnZlciByZWxpZXMgb24gd2hldGhlciBhIHN0eWxlIGlzIGluXG4gIC8vIHRoZSByZWdpc3RlcmVkIGNhY2hlIHRvIGtub3cgd2hldGhlciBhIHN0eWxlIGlzIGdsb2JhbCBvciBub3RcbiAgLy8gYWxzbywgbm90ZSB0aGF0IHRoaXMgY2hlY2sgd2lsbCBiZSBkZWFkIGNvZGUgZWxpbWluYXRlZCBpbiB0aGUgYnJvd3NlclxuICBpc0Jyb3dzZXIkNCA9PT0gZmFsc2UgJiYgY2FjaGUuY29tcGF0ICE9PSB1bmRlZmluZWQpICYmIGNhY2hlLnJlZ2lzdGVyZWRbY2xhc3NOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2FjaGUucmVnaXN0ZXJlZFtjbGFzc05hbWVdID0gc2VyaWFsaXplZC5zdHlsZXM7XG4gIH1cbn07XG52YXIgaW5zZXJ0U3R5bGVzJDEgPSBmdW5jdGlvbiBpbnNlcnRTdHlsZXMoY2FjaGUsIHNlcmlhbGl6ZWQsIGlzU3RyaW5nVGFnKSB7XG4gIHJlZ2lzdGVyU3R5bGVzJDEoY2FjaGUsIHNlcmlhbGl6ZWQsIGlzU3RyaW5nVGFnKTtcbiAgdmFyIGNsYXNzTmFtZSA9IGNhY2hlLmtleSArIFwiLVwiICsgc2VyaWFsaXplZC5uYW1lO1xuXG4gIGlmIChjYWNoZS5pbnNlcnRlZFtzZXJpYWxpemVkLm5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgc3R5bGVzRm9yU1NSID0gJyc7XG4gICAgdmFyIGN1cnJlbnQgPSBzZXJpYWxpemVkO1xuXG4gICAgZG8ge1xuICAgICAgdmFyIG1heWJlU3R5bGVzID0gY2FjaGUuaW5zZXJ0KHNlcmlhbGl6ZWQgPT09IGN1cnJlbnQgPyBcIi5cIiArIGNsYXNzTmFtZSA6ICcnLCBjdXJyZW50LCBjYWNoZS5zaGVldCwgdHJ1ZSk7XG5cbiAgICAgIGlmICghaXNCcm93c2VyJDQgJiYgbWF5YmVTdHlsZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzdHlsZXNGb3JTU1IgKz0gbWF5YmVTdHlsZXM7XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgfSB3aGlsZSAoY3VycmVudCAhPT0gdW5kZWZpbmVkKTtcblxuICAgIGlmICghaXNCcm93c2VyJDQgJiYgc3R5bGVzRm9yU1NSLmxlbmd0aCAhPT0gMCkge1xuICAgICAgcmV0dXJuIHN0eWxlc0ZvclNTUjtcbiAgICB9XG4gIH1cbn07XG5cbi8qIGVzbGludC1kaXNhYmxlICovXG4vLyBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vZ2FyeWNvdXJ0L211cm11cmhhc2gtanNcbi8vIFBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9hYXBwbGVieS9zbWhhc2hlci9ibG9iLzYxYTA1MzBmMjgyNzdmMmU4NTBiZmMzOTYwMGNlNjFkMDJiNTE4ZGUvc3JjL011cm11ckhhc2gyLmNwcCNMMzctTDg2XG5mdW5jdGlvbiBtdXJtdXIyJDEoc3RyKSB7XG4gIC8vICdtJyBhbmQgJ3InIGFyZSBtaXhpbmcgY29uc3RhbnRzIGdlbmVyYXRlZCBvZmZsaW5lLlxuICAvLyBUaGV5J3JlIG5vdCByZWFsbHkgJ21hZ2ljJywgdGhleSBqdXN0IGhhcHBlbiB0byB3b3JrIHdlbGwuXG4gIC8vIGNvbnN0IG0gPSAweDViZDFlOTk1O1xuICAvLyBjb25zdCByID0gMjQ7XG4gIC8vIEluaXRpYWxpemUgdGhlIGhhc2hcbiAgdmFyIGggPSAwOyAvLyBNaXggNCBieXRlcyBhdCBhIHRpbWUgaW50byB0aGUgaGFzaFxuXG4gIHZhciBrLFxuICAgICAgaSA9IDAsXG4gICAgICBsZW4gPSBzdHIubGVuZ3RoO1xuXG4gIGZvciAoOyBsZW4gPj0gNDsgKytpLCBsZW4gLT0gNCkge1xuICAgIGsgPSBzdHIuY2hhckNvZGVBdChpKSAmIDB4ZmYgfCAoc3RyLmNoYXJDb2RlQXQoKytpKSAmIDB4ZmYpIDw8IDggfCAoc3RyLmNoYXJDb2RlQXQoKytpKSAmIDB4ZmYpIDw8IDE2IHwgKHN0ci5jaGFyQ29kZUF0KCsraSkgJiAweGZmKSA8PCAyNDtcbiAgICBrID1cbiAgICAvKiBNYXRoLmltdWwoaywgbSk6ICovXG4gICAgKGsgJiAweGZmZmYpICogMHg1YmQxZTk5NSArICgoayA+Pj4gMTYpICogMHhlOTk1IDw8IDE2KTtcbiAgICBrIF49XG4gICAgLyogayA+Pj4gcjogKi9cbiAgICBrID4+PiAyNDtcbiAgICBoID1cbiAgICAvKiBNYXRoLmltdWwoaywgbSk6ICovXG4gICAgKGsgJiAweGZmZmYpICogMHg1YmQxZTk5NSArICgoayA+Pj4gMTYpICogMHhlOTk1IDw8IDE2KSBeXG4gICAgLyogTWF0aC5pbXVsKGgsIG0pOiAqL1xuICAgIChoICYgMHhmZmZmKSAqIDB4NWJkMWU5OTUgKyAoKGggPj4+IDE2KSAqIDB4ZTk5NSA8PCAxNik7XG4gIH0gLy8gSGFuZGxlIHRoZSBsYXN0IGZldyBieXRlcyBvZiB0aGUgaW5wdXQgYXJyYXlcblxuXG4gIHN3aXRjaCAobGVuKSB7XG4gICAgY2FzZSAzOlxuICAgICAgaCBePSAoc3RyLmNoYXJDb2RlQXQoaSArIDIpICYgMHhmZikgPDwgMTY7XG5cbiAgICBjYXNlIDI6XG4gICAgICBoIF49IChzdHIuY2hhckNvZGVBdChpICsgMSkgJiAweGZmKSA8PCA4O1xuXG4gICAgY2FzZSAxOlxuICAgICAgaCBePSBzdHIuY2hhckNvZGVBdChpKSAmIDB4ZmY7XG4gICAgICBoID1cbiAgICAgIC8qIE1hdGguaW11bChoLCBtKTogKi9cbiAgICAgIChoICYgMHhmZmZmKSAqIDB4NWJkMWU5OTUgKyAoKGggPj4+IDE2KSAqIDB4ZTk5NSA8PCAxNik7XG4gIH0gLy8gRG8gYSBmZXcgZmluYWwgbWl4ZXMgb2YgdGhlIGhhc2ggdG8gZW5zdXJlIHRoZSBsYXN0IGZld1xuICAvLyBieXRlcyBhcmUgd2VsbC1pbmNvcnBvcmF0ZWQuXG5cblxuICBoIF49IGggPj4+IDEzO1xuICBoID1cbiAgLyogTWF0aC5pbXVsKGgsIG0pOiAqL1xuICAoaCAmIDB4ZmZmZikgKiAweDViZDFlOTk1ICsgKChoID4+PiAxNikgKiAweGU5OTUgPDwgMTYpO1xuICByZXR1cm4gKChoIF4gaCA+Pj4gMTUpID4+PiAwKS50b1N0cmluZygzNik7XG59XG5cbnZhciB1bml0bGVzc0tleXMkMSA9IHtcbiAgYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6IDEsXG4gIGJvcmRlckltYWdlT3V0c2V0OiAxLFxuICBib3JkZXJJbWFnZVNsaWNlOiAxLFxuICBib3JkZXJJbWFnZVdpZHRoOiAxLFxuICBib3hGbGV4OiAxLFxuICBib3hGbGV4R3JvdXA6IDEsXG4gIGJveE9yZGluYWxHcm91cDogMSxcbiAgY29sdW1uQ291bnQ6IDEsXG4gIGNvbHVtbnM6IDEsXG4gIGZsZXg6IDEsXG4gIGZsZXhHcm93OiAxLFxuICBmbGV4UG9zaXRpdmU6IDEsXG4gIGZsZXhTaHJpbms6IDEsXG4gIGZsZXhOZWdhdGl2ZTogMSxcbiAgZmxleE9yZGVyOiAxLFxuICBncmlkUm93OiAxLFxuICBncmlkUm93RW5kOiAxLFxuICBncmlkUm93U3BhbjogMSxcbiAgZ3JpZFJvd1N0YXJ0OiAxLFxuICBncmlkQ29sdW1uOiAxLFxuICBncmlkQ29sdW1uRW5kOiAxLFxuICBncmlkQ29sdW1uU3BhbjogMSxcbiAgZ3JpZENvbHVtblN0YXJ0OiAxLFxuICBtc0dyaWRSb3c6IDEsXG4gIG1zR3JpZFJvd1NwYW46IDEsXG4gIG1zR3JpZENvbHVtbjogMSxcbiAgbXNHcmlkQ29sdW1uU3BhbjogMSxcbiAgZm9udFdlaWdodDogMSxcbiAgbGluZUhlaWdodDogMSxcbiAgb3BhY2l0eTogMSxcbiAgb3JkZXI6IDEsXG4gIG9ycGhhbnM6IDEsXG4gIHRhYlNpemU6IDEsXG4gIHdpZG93czogMSxcbiAgekluZGV4OiAxLFxuICB6b29tOiAxLFxuICBXZWJraXRMaW5lQ2xhbXA6IDEsXG4gIC8vIFNWRy1yZWxhdGVkIHByb3BlcnRpZXNcbiAgZmlsbE9wYWNpdHk6IDEsXG4gIGZsb29kT3BhY2l0eTogMSxcbiAgc3RvcE9wYWNpdHk6IDEsXG4gIHN0cm9rZURhc2hhcnJheTogMSxcbiAgc3Ryb2tlRGFzaG9mZnNldDogMSxcbiAgc3Ryb2tlTWl0ZXJsaW1pdDogMSxcbiAgc3Ryb2tlT3BhY2l0eTogMSxcbiAgc3Ryb2tlV2lkdGg6IDFcbn07XG5cbnZhciBJTExFR0FMX0VTQ0FQRV9TRVFVRU5DRV9FUlJPUiQyID0gXCJZb3UgaGF2ZSBpbGxlZ2FsIGVzY2FwZSBzZXF1ZW5jZSBpbiB5b3VyIHRlbXBsYXRlIGxpdGVyYWwsIG1vc3QgbGlrZWx5IGluc2lkZSBjb250ZW50J3MgcHJvcGVydHkgdmFsdWUuXFxuQmVjYXVzZSB5b3Ugd3JpdGUgeW91ciBDU1MgaW5zaWRlIGEgSmF2YVNjcmlwdCBzdHJpbmcgeW91IGFjdHVhbGx5IGhhdmUgdG8gZG8gZG91YmxlIGVzY2FwaW5nLCBzbyBmb3IgZXhhbXBsZSBcXFwiY29udGVudDogJ1xcXFwwMGQ3JztcXFwiIHNob3VsZCBiZWNvbWUgXFxcImNvbnRlbnQ6ICdcXFxcXFxcXDAwZDcnO1xcXCIuXFxuWW91IGNhbiByZWFkIG1vcmUgYWJvdXQgdGhpcyBoZXJlOlxcbmh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL1RlbXBsYXRlX2xpdGVyYWxzI0VTMjAxOF9yZXZpc2lvbl9vZl9pbGxlZ2FsX2VzY2FwZV9zZXF1ZW5jZXNcIjtcbnZhciBVTkRFRklORURfQVNfT0JKRUNUX0tFWV9FUlJPUiQxID0gXCJZb3UgaGF2ZSBwYXNzZWQgaW4gZmFsc3kgdmFsdWUgYXMgc3R5bGUgb2JqZWN0J3Mga2V5IChjYW4gaGFwcGVuIHdoZW4gaW4gZXhhbXBsZSB5b3UgcGFzcyB1bmV4cG9ydGVkIGNvbXBvbmVudCBhcyBjb21wdXRlZCBrZXkpLlwiO1xudmFyIGh5cGhlbmF0ZVJlZ2V4JDEgPSAvW0EtWl18Xm1zL2c7XG52YXIgYW5pbWF0aW9uUmVnZXgkMSA9IC9fRU1PXyhbXl9dKz8pXyhbXl0qPylfRU1PXy9nO1xuXG52YXIgaXNDdXN0b21Qcm9wZXJ0eSQxID0gZnVuY3Rpb24gaXNDdXN0b21Qcm9wZXJ0eShwcm9wZXJ0eSkge1xuICByZXR1cm4gcHJvcGVydHkuY2hhckNvZGVBdCgxKSA9PT0gNDU7XG59O1xuXG52YXIgaXNQcm9jZXNzYWJsZVZhbHVlJDEgPSBmdW5jdGlvbiBpc1Byb2Nlc3NhYmxlVmFsdWUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbic7XG59O1xuXG52YXIgcHJvY2Vzc1N0eWxlTmFtZSQxID0gLyogI19fUFVSRV9fICovbWVtb2l6ZShmdW5jdGlvbiAoc3R5bGVOYW1lKSB7XG4gIHJldHVybiBpc0N1c3RvbVByb3BlcnR5JDEoc3R5bGVOYW1lKSA/IHN0eWxlTmFtZSA6IHN0eWxlTmFtZS5yZXBsYWNlKGh5cGhlbmF0ZVJlZ2V4JDEsICctJCYnKS50b0xvd2VyQ2FzZSgpO1xufSk7XG5cbnZhciBwcm9jZXNzU3R5bGVWYWx1ZSQxID0gZnVuY3Rpb24gcHJvY2Vzc1N0eWxlVmFsdWUoa2V5LCB2YWx1ZSkge1xuICBzd2l0Y2ggKGtleSkge1xuICAgIGNhc2UgJ2FuaW1hdGlvbic6XG4gICAgY2FzZSAnYW5pbWF0aW9uTmFtZSc6XG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoYW5pbWF0aW9uUmVnZXgkMSwgZnVuY3Rpb24gKG1hdGNoLCBwMSwgcDIpIHtcbiAgICAgICAgICAgIGN1cnNvciQxID0ge1xuICAgICAgICAgICAgICBuYW1lOiBwMSxcbiAgICAgICAgICAgICAgc3R5bGVzOiBwMixcbiAgICAgICAgICAgICAgbmV4dDogY3Vyc29yJDFcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gcDE7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgfVxuXG4gIGlmICh1bml0bGVzc0tleXMkMVtrZXldICE9PSAxICYmICFpc0N1c3RvbVByb3BlcnR5JDEoa2V5KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHZhbHVlICE9PSAwKSB7XG4gICAgcmV0dXJuIHZhbHVlICsgJ3B4JztcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBjb250ZW50VmFsdWVQYXR0ZXJuJDEgPSAvKHZhcnxhdHRyfGNvdW50ZXJzP3x1cmx8ZWxlbWVudHwoKChyZXBlYXRpbmctKT8obGluZWFyfHJhZGlhbCkpfGNvbmljKS1ncmFkaWVudClcXCh8KG5vLSk/KG9wZW58Y2xvc2UpLXF1b3RlLztcbiAgdmFyIGNvbnRlbnRWYWx1ZXMkMSA9IFsnbm9ybWFsJywgJ25vbmUnLCAnaW5pdGlhbCcsICdpbmhlcml0JywgJ3Vuc2V0J107XG4gIHZhciBvbGRQcm9jZXNzU3R5bGVWYWx1ZSQxID0gcHJvY2Vzc1N0eWxlVmFsdWUkMTtcbiAgdmFyIG1zUGF0dGVybiQxID0gL14tbXMtLztcbiAgdmFyIGh5cGhlblBhdHRlcm4kMSA9IC8tKC4pL2c7XG4gIHZhciBoeXBoZW5hdGVkQ2FjaGUkMSA9IHt9O1xuXG4gIHByb2Nlc3NTdHlsZVZhbHVlJDEgPSBmdW5jdGlvbiBwcm9jZXNzU3R5bGVWYWx1ZShrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSA9PT0gJ2NvbnRlbnQnKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyB8fCBjb250ZW50VmFsdWVzJDEuaW5kZXhPZih2YWx1ZSkgPT09IC0xICYmICFjb250ZW50VmFsdWVQYXR0ZXJuJDEudGVzdCh2YWx1ZSkgJiYgKHZhbHVlLmNoYXJBdCgwKSAhPT0gdmFsdWUuY2hhckF0KHZhbHVlLmxlbmd0aCAtIDEpIHx8IHZhbHVlLmNoYXJBdCgwKSAhPT0gJ1wiJyAmJiB2YWx1ZS5jaGFyQXQoMCkgIT09IFwiJ1wiKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3Ugc2VlbSB0byBiZSB1c2luZyBhIHZhbHVlIGZvciAnY29udGVudCcgd2l0aG91dCBxdW90ZXMsIHRyeSByZXBsYWNpbmcgaXQgd2l0aCBgY29udGVudDogJ1xcXCJcIiArIHZhbHVlICsgXCJcXFwiJ2BcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByb2Nlc3NlZCA9IG9sZFByb2Nlc3NTdHlsZVZhbHVlJDEoa2V5LCB2YWx1ZSk7XG5cbiAgICBpZiAocHJvY2Vzc2VkICE9PSAnJyAmJiAhaXNDdXN0b21Qcm9wZXJ0eSQxKGtleSkgJiYga2V5LmluZGV4T2YoJy0nKSAhPT0gLTEgJiYgaHlwaGVuYXRlZENhY2hlJDFba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBoeXBoZW5hdGVkQ2FjaGUkMVtrZXldID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJVc2luZyBrZWJhYi1jYXNlIGZvciBjc3MgcHJvcGVydGllcyBpbiBvYmplY3RzIGlzIG5vdCBzdXBwb3J0ZWQuIERpZCB5b3UgbWVhbiBcIiArIGtleS5yZXBsYWNlKG1zUGF0dGVybiQxLCAnbXMtJykucmVwbGFjZShoeXBoZW5QYXR0ZXJuJDEsIGZ1bmN0aW9uIChzdHIsIF9jaGFyKSB7XG4gICAgICAgIHJldHVybiBfY2hhci50b1VwcGVyQ2FzZSgpO1xuICAgICAgfSkgKyBcIj9cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb2Nlc3NlZDtcbiAgfTtcbn1cblxudmFyIG5vQ29tcG9uZW50U2VsZWN0b3JNZXNzYWdlJDEgPSAnQ29tcG9uZW50IHNlbGVjdG9ycyBjYW4gb25seSBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggJyArICdAZW1vdGlvbi9iYWJlbC1wbHVnaW4sIHRoZSBzd2MgRW1vdGlvbiBwbHVnaW4sIG9yIGFub3RoZXIgRW1vdGlvbi1hd2FyZSAnICsgJ2NvbXBpbGVyIHRyYW5zZm9ybS4nO1xuXG5mdW5jdGlvbiBoYW5kbGVJbnRlcnBvbGF0aW9uJDEobWVyZ2VkUHJvcHMsIHJlZ2lzdGVyZWQsIGludGVycG9sYXRpb24pIHtcbiAgaWYgKGludGVycG9sYXRpb24gPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmIChpbnRlcnBvbGF0aW9uLl9fZW1vdGlvbl9zdHlsZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGludGVycG9sYXRpb24udG9TdHJpbmcoKSA9PT0gJ05PX0NPTVBPTkVOVF9TRUxFQ1RPUicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihub0NvbXBvbmVudFNlbGVjdG9yTWVzc2FnZSQxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZXJwb2xhdGlvbjtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZW9mIGludGVycG9sYXRpb24pIHtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuXG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHtcbiAgICAgICAgaWYgKGludGVycG9sYXRpb24uYW5pbSA9PT0gMSkge1xuICAgICAgICAgIGN1cnNvciQxID0ge1xuICAgICAgICAgICAgbmFtZTogaW50ZXJwb2xhdGlvbi5uYW1lLFxuICAgICAgICAgICAgc3R5bGVzOiBpbnRlcnBvbGF0aW9uLnN0eWxlcyxcbiAgICAgICAgICAgIG5leHQ6IGN1cnNvciQxXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGlvbi5uYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGludGVycG9sYXRpb24uc3R5bGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IGludGVycG9sYXRpb24ubmV4dDtcblxuICAgICAgICAgIGlmIChuZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIG5vdCB0aGUgbW9zdCBlZmZpY2llbnQgdGhpbmcgZXZlciBidXQgdGhpcyBpcyBhIHByZXR0eSByYXJlIGNhc2VcbiAgICAgICAgICAgIC8vIGFuZCB0aGVyZSB3aWxsIGJlIHZlcnkgZmV3IGl0ZXJhdGlvbnMgb2YgdGhpcyBnZW5lcmFsbHlcbiAgICAgICAgICAgIHdoaWxlIChuZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY3Vyc29yJDEgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogbmV4dC5uYW1lLFxuICAgICAgICAgICAgICAgIHN0eWxlczogbmV4dC5zdHlsZXMsXG4gICAgICAgICAgICAgICAgbmV4dDogY3Vyc29yJDFcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgbmV4dCA9IG5leHQubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc3R5bGVzID0gaW50ZXJwb2xhdGlvbi5zdHlsZXMgKyBcIjtcIjtcblxuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGludGVycG9sYXRpb24ubWFwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0eWxlcyArPSBpbnRlcnBvbGF0aW9uLm1hcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3R5bGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNyZWF0ZVN0cmluZ0Zyb21PYmplY3QkMShtZXJnZWRQcm9wcywgcmVnaXN0ZXJlZCwgaW50ZXJwb2xhdGlvbik7XG4gICAgICB9XG5cbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICB7XG4gICAgICAgIGlmIChtZXJnZWRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIHByZXZpb3VzQ3Vyc29yID0gY3Vyc29yJDE7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGludGVycG9sYXRpb24obWVyZ2VkUHJvcHMpO1xuICAgICAgICAgIGN1cnNvciQxID0gcHJldmlvdXNDdXJzb3I7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZUludGVycG9sYXRpb24kMShtZXJnZWRQcm9wcywgcmVnaXN0ZXJlZCwgcmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRnVuY3Rpb25zIHRoYXQgYXJlIGludGVycG9sYXRlZCBpbiBjc3MgY2FsbHMgd2lsbCBiZSBzdHJpbmdpZmllZC5cXG4nICsgJ0lmIHlvdSB3YW50IHRvIGhhdmUgYSBjc3MgY2FsbCBiYXNlZCBvbiBwcm9wcywgY3JlYXRlIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgY3NzIGNhbGwgbGlrZSB0aGlzXFxuJyArICdsZXQgZHluYW1pY1N0eWxlID0gKHByb3BzKSA9PiBjc3NgY29sb3I6ICR7cHJvcHMuY29sb3J9YFxcbicgKyAnSXQgY2FuIGJlIGNhbGxlZCBkaXJlY3RseSB3aXRoIHByb3BzIG9yIGludGVycG9sYXRlZCBpbiBhIHN0eWxlZCBjYWxsIGxpa2UgdGhpc1xcbicgKyBcImxldCBTb21lQ29tcG9uZW50ID0gc3R5bGVkKCdkaXYnKWAke2R5bmFtaWNTdHlsZX1gXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIG1hdGNoZWQgPSBbXTtcbiAgICAgICAgdmFyIHJlcGxhY2VkID0gaW50ZXJwb2xhdGlvbi5yZXBsYWNlKGFuaW1hdGlvblJlZ2V4JDEsIGZ1bmN0aW9uIChtYXRjaCwgcDEsIHAyKSB7XG4gICAgICAgICAgdmFyIGZha2VWYXJOYW1lID0gXCJhbmltYXRpb25cIiArIG1hdGNoZWQubGVuZ3RoO1xuICAgICAgICAgIG1hdGNoZWQucHVzaChcImNvbnN0IFwiICsgZmFrZVZhck5hbWUgKyBcIiA9IGtleWZyYW1lc2BcIiArIHAyLnJlcGxhY2UoL15Aa2V5ZnJhbWVzIGFuaW1hdGlvbi1cXHcrLywgJycpICsgXCJgXCIpO1xuICAgICAgICAgIHJldHVybiBcIiR7XCIgKyBmYWtlVmFyTmFtZSArIFwifVwiO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobWF0Y2hlZC5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdga2V5ZnJhbWVzYCBvdXRwdXQgZ290IGludGVycG9sYXRlZCBpbnRvIHBsYWluIHN0cmluZywgcGxlYXNlIHdyYXAgaXQgd2l0aCBgY3NzYC5cXG5cXG4nICsgJ0luc3RlYWQgb2YgZG9pbmcgdGhpczpcXG5cXG4nICsgW10uY29uY2F0KG1hdGNoZWQsIFtcImBcIiArIHJlcGxhY2VkICsgXCJgXCJdKS5qb2luKCdcXG4nKSArICdcXG5cXG5Zb3Ugc2hvdWxkIHdyYXAgaXQgd2l0aCBgY3NzYCBsaWtlIHRoaXM6XFxuXFxuJyArIChcImNzc2BcIiArIHJlcGxhY2VkICsgXCJgXCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgfSAvLyBmaW5hbGl6ZSBzdHJpbmcgdmFsdWVzIChyZWd1bGFyIHN0cmluZ3MgYW5kIGZ1bmN0aW9ucyBpbnRlcnBvbGF0ZWQgaW50byBjc3MgY2FsbHMpXG5cblxuICBpZiAocmVnaXN0ZXJlZCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGludGVycG9sYXRpb247XG4gIH1cblxuICB2YXIgY2FjaGVkID0gcmVnaXN0ZXJlZFtpbnRlcnBvbGF0aW9uXTtcbiAgcmV0dXJuIGNhY2hlZCAhPT0gdW5kZWZpbmVkID8gY2FjaGVkIDogaW50ZXJwb2xhdGlvbjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU3RyaW5nRnJvbU9iamVjdCQxKG1lcmdlZFByb3BzLCByZWdpc3RlcmVkLCBvYmopIHtcbiAgdmFyIHN0cmluZyA9ICcnO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgc3RyaW5nICs9IGhhbmRsZUludGVycG9sYXRpb24kMShtZXJnZWRQcm9wcywgcmVnaXN0ZXJlZCwgb2JqW2ldKSArIFwiO1wiO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBfa2V5IGluIG9iaikge1xuICAgICAgdmFyIHZhbHVlID0gb2JqW19rZXldO1xuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAocmVnaXN0ZXJlZCAhPSBudWxsICYmIHJlZ2lzdGVyZWRbdmFsdWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzdHJpbmcgKz0gX2tleSArIFwie1wiICsgcmVnaXN0ZXJlZFt2YWx1ZV0gKyBcIn1cIjtcbiAgICAgICAgfSBlbHNlIGlmIChpc1Byb2Nlc3NhYmxlVmFsdWUkMSh2YWx1ZSkpIHtcbiAgICAgICAgICBzdHJpbmcgKz0gcHJvY2Vzc1N0eWxlTmFtZSQxKF9rZXkpICsgXCI6XCIgKyBwcm9jZXNzU3R5bGVWYWx1ZSQxKF9rZXksIHZhbHVlKSArIFwiO1wiO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoX2tleSA9PT0gJ05PX0NPTVBPTkVOVF9TRUxFQ1RPUicgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihub0NvbXBvbmVudFNlbGVjdG9yTWVzc2FnZSQxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWVbMF0gPT09ICdzdHJpbmcnICYmIChyZWdpc3RlcmVkID09IG51bGwgfHwgcmVnaXN0ZXJlZFt2YWx1ZVswXV0gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdmFsdWUubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBpZiAoaXNQcm9jZXNzYWJsZVZhbHVlJDEodmFsdWVbX2ldKSkge1xuICAgICAgICAgICAgICBzdHJpbmcgKz0gcHJvY2Vzc1N0eWxlTmFtZSQxKF9rZXkpICsgXCI6XCIgKyBwcm9jZXNzU3R5bGVWYWx1ZSQxKF9rZXksIHZhbHVlW19pXSkgKyBcIjtcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGludGVycG9sYXRlZCA9IGhhbmRsZUludGVycG9sYXRpb24kMShtZXJnZWRQcm9wcywgcmVnaXN0ZXJlZCwgdmFsdWUpO1xuXG4gICAgICAgICAgc3dpdGNoIChfa2V5KSB7XG4gICAgICAgICAgICBjYXNlICdhbmltYXRpb24nOlxuICAgICAgICAgICAgY2FzZSAnYW5pbWF0aW9uTmFtZSc6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gcHJvY2Vzc1N0eWxlTmFtZSQxKF9rZXkpICsgXCI6XCIgKyBpbnRlcnBvbGF0ZWQgKyBcIjtcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgX2tleSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoVU5ERUZJTkVEX0FTX09CSkVDVF9LRVlfRVJST1IkMSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3RyaW5nICs9IF9rZXkgKyBcIntcIiArIGludGVycG9sYXRlZCArIFwifVwiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0cmluZztcbn1cblxudmFyIGxhYmVsUGF0dGVybiQxID0gL2xhYmVsOlxccyooW15cXHM7XFxue10rKVxccyooO3wkKS9nO1xudmFyIHNvdXJjZU1hcFBhdHRlcm4kMTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgc291cmNlTWFwUGF0dGVybiQxID0gL1xcL1xcKiNcXHNzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb25cXC9qc29uO1xcUytcXHMrXFwqXFwvL2c7XG59IC8vIHRoaXMgaXMgdGhlIGN1cnNvciBmb3Iga2V5ZnJhbWVzXG4vLyBrZXlmcmFtZXMgYXJlIHN0b3JlZCBvbiB0aGUgU2VyaWFsaXplZFN0eWxlcyBvYmplY3QgYXMgYSBsaW5rZWQgbGlzdFxuXG5cbnZhciBjdXJzb3IkMTtcbnZhciBzZXJpYWxpemVTdHlsZXMkMSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZVN0eWxlcyhhcmdzLCByZWdpc3RlcmVkLCBtZXJnZWRQcm9wcykge1xuICBpZiAoYXJncy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGFyZ3NbMF0gPT09ICdvYmplY3QnICYmIGFyZ3NbMF0gIT09IG51bGwgJiYgYXJnc1swXS5zdHlsZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBhcmdzWzBdO1xuICB9XG5cbiAgdmFyIHN0cmluZ01vZGUgPSB0cnVlO1xuICB2YXIgc3R5bGVzID0gJyc7XG4gIGN1cnNvciQxID0gdW5kZWZpbmVkO1xuICB2YXIgc3RyaW5ncyA9IGFyZ3NbMF07XG5cbiAgaWYgKHN0cmluZ3MgPT0gbnVsbCB8fCBzdHJpbmdzLnJhdyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RyaW5nTW9kZSA9IGZhbHNlO1xuICAgIHN0eWxlcyArPSBoYW5kbGVJbnRlcnBvbGF0aW9uJDEobWVyZ2VkUHJvcHMsIHJlZ2lzdGVyZWQsIHN0cmluZ3MpO1xuICB9IGVsc2Uge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHN0cmluZ3NbMF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc29sZS5lcnJvcihJTExFR0FMX0VTQ0FQRV9TRVFVRU5DRV9FUlJPUiQyKTtcbiAgICB9XG5cbiAgICBzdHlsZXMgKz0gc3RyaW5nc1swXTtcbiAgfSAvLyB3ZSBzdGFydCBhdCAxIHNpbmNlIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgZmlyc3QgYXJnXG5cblxuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBzdHlsZXMgKz0gaGFuZGxlSW50ZXJwb2xhdGlvbiQxKG1lcmdlZFByb3BzLCByZWdpc3RlcmVkLCBhcmdzW2ldKTtcblxuICAgIGlmIChzdHJpbmdNb2RlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzdHJpbmdzW2ldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihJTExFR0FMX0VTQ0FQRV9TRVFVRU5DRV9FUlJPUiQyKTtcbiAgICAgIH1cblxuICAgICAgc3R5bGVzICs9IHN0cmluZ3NbaV07XG4gICAgfVxuICB9XG5cbiAgdmFyIHNvdXJjZU1hcDtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHN0eWxlcyA9IHN0eWxlcy5yZXBsYWNlKHNvdXJjZU1hcFBhdHRlcm4kMSwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICBzb3VyY2VNYXAgPSBtYXRjaDtcbiAgICAgIHJldHVybiAnJztcbiAgICB9KTtcbiAgfSAvLyB1c2luZyBhIGdsb2JhbCByZWdleCB3aXRoIC5leGVjIGlzIHN0YXRlZnVsIHNvIGxhc3RJbmRleCBoYXMgdG8gYmUgcmVzZXQgZWFjaCB0aW1lXG5cblxuICBsYWJlbFBhdHRlcm4kMS5sYXN0SW5kZXggPSAwO1xuICB2YXIgaWRlbnRpZmllck5hbWUgPSAnJztcbiAgdmFyIG1hdGNoOyAvLyBodHRwczovL2VzYmVuY2guY29tL2JlbmNoLzViODA5YzJjZjI5NDk4MDBhMGY2MWZiNVxuXG4gIHdoaWxlICgobWF0Y2ggPSBsYWJlbFBhdHRlcm4kMS5leGVjKHN0eWxlcykpICE9PSBudWxsKSB7XG4gICAgaWRlbnRpZmllck5hbWUgKz0gJy0nICsgLy8gJEZsb3dGaXhNZSB3ZSBrbm93IGl0J3Mgbm90IG51bGxcbiAgICBtYXRjaFsxXTtcbiAgfVxuXG4gIHZhciBuYW1lID0gbXVybXVyMiQxKHN0eWxlcykgKyBpZGVudGlmaWVyTmFtZTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vICRGbG93Rml4TWUgU2VyaWFsaXplZFN0eWxlcyB0eXBlIGRvZXNuJ3QgaGF2ZSB0b1N0cmluZyBwcm9wZXJ0eSAoYW5kIHdlIGRvbid0IHdhbnQgdG8gYWRkIGl0KVxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgc3R5bGVzOiBzdHlsZXMsXG4gICAgICBtYXA6IHNvdXJjZU1hcCxcbiAgICAgIG5leHQ6IGN1cnNvciQxLFxuICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gXCJZb3UgaGF2ZSB0cmllZCB0byBzdHJpbmdpZnkgb2JqZWN0IHJldHVybmVkIGZyb20gYGNzc2AgZnVuY3Rpb24uIEl0IGlzbid0IHN1cHBvc2VkIHRvIGJlIHVzZWQgZGlyZWN0bHkgKGUuZy4gYXMgdmFsdWUgb2YgdGhlIGBjbGFzc05hbWVgIHByb3ApLCBidXQgcmF0aGVyIGhhbmRlZCB0byBlbW90aW9uIHNvIGl0IGNhbiBoYW5kbGUgaXQgKGUuZy4gYXMgdmFsdWUgb2YgYGNzc2AgcHJvcCkuXCI7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBzdHlsZXM6IHN0eWxlcyxcbiAgICBuZXh0OiBjdXJzb3IkMVxuICB9O1xufTtcblxudmFyIGlzQnJvd3NlciQzID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcblxudmFyIHN5bmNGYWxsYmFjayA9IGZ1bmN0aW9uIHN5bmNGYWxsYmFjayhjcmVhdGUpIHtcbiAgcmV0dXJuIGNyZWF0ZSgpO1xufTtcblxudmFyIHVzZUluc2VydGlvbkVmZmVjdCA9IFJlYWN0Wyd1c2VJbnNlcnRpb24nICsgJ0VmZmVjdCddID8gUmVhY3RbJ3VzZUluc2VydGlvbicgKyAnRWZmZWN0J10gOiBmYWxzZTtcbnZhciB1c2VJbnNlcnRpb25FZmZlY3RBbHdheXNXaXRoU3luY0ZhbGxiYWNrID0gIWlzQnJvd3NlciQzID8gc3luY0ZhbGxiYWNrIDogdXNlSW5zZXJ0aW9uRWZmZWN0IHx8IHN5bmNGYWxsYmFjaztcblxudmFyIGlzQnJvd3NlciQyID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xuXG52YXIgRW1vdGlvbkNhY2hlQ29udGV4dCA9IC8qICNfX1BVUkVfXyAqL2NyZWF0ZUNvbnRleHQoIC8vIHdlJ3JlIGRvaW5nIHRoaXMgdG8gYXZvaWQgcHJlY29uc3RydWN0J3MgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIGluIHRoaXMgb25lIGNhc2Vcbi8vIGJlY2F1c2UgdGhpcyBtb2R1bGUgaXMgcHJpbWFyaWx5IGludGVuZGVkIGZvciB0aGUgYnJvd3NlciBhbmQgbm9kZVxuLy8gYnV0IGl0J3MgYWxzbyByZXF1aXJlZCBpbiByZWFjdCBuYXRpdmUgYW5kIHNpbWlsYXIgZW52aXJvbm1lbnRzIHNvbWV0aW1lc1xuLy8gYW5kIHdlIGNvdWxkIGhhdmUgYSBzcGVjaWFsIGJ1aWxkIGp1c3QgZm9yIHRoYXRcbi8vIGJ1dCB0aGlzIGlzIG11Y2ggZWFzaWVyIGFuZCB0aGUgbmF0aXZlIHBhY2thZ2VzXG4vLyBtaWdodCB1c2UgYSBkaWZmZXJlbnQgdGhlbWUgY29udGV4dCBpbiB0aGUgZnV0dXJlIGFueXdheVxudHlwZW9mIEhUTUxFbGVtZW50ICE9PSAndW5kZWZpbmVkJyA/IC8qICNfX1BVUkVfXyAqL2NyZWF0ZUNhY2hlKHtcbiAga2V5OiAnY3NzJ1xufSkgOiBudWxsKTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgRW1vdGlvbkNhY2hlQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdFbW90aW9uQ2FjaGVDb250ZXh0Jztcbn1cblxuRW1vdGlvbkNhY2hlQ29udGV4dC5Qcm92aWRlcjtcblxudmFyIHdpdGhFbW90aW9uQ2FjaGUgPSBmdW5jdGlvbiB3aXRoRW1vdGlvbkNhY2hlKGZ1bmMpIHtcbiAgLy8gJEZsb3dGaXhNZVxuICByZXR1cm4gLyojX19QVVJFX18qL2ZvcndhcmRSZWYoZnVuY3Rpb24gKHByb3BzLCByZWYpIHtcbiAgICAvLyB0aGUgY2FjaGUgd2lsbCBuZXZlciBiZSBudWxsIGluIHRoZSBicm93c2VyXG4gICAgdmFyIGNhY2hlID0gdXNlQ29udGV4dChFbW90aW9uQ2FjaGVDb250ZXh0KTtcbiAgICByZXR1cm4gZnVuYyhwcm9wcywgY2FjaGUsIHJlZik7XG4gIH0pO1xufTtcblxuaWYgKCFpc0Jyb3dzZXIkMikge1xuICB3aXRoRW1vdGlvbkNhY2hlID0gZnVuY3Rpb24gd2l0aEVtb3Rpb25DYWNoZShmdW5jKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgdmFyIGNhY2hlID0gdXNlQ29udGV4dChFbW90aW9uQ2FjaGVDb250ZXh0KTtcblxuICAgICAgaWYgKGNhY2hlID09PSBudWxsKSB7XG4gICAgICAgIC8vIHllcywgd2UncmUgcG90ZW50aWFsbHkgY3JlYXRpbmcgdGhpcyBvbiBldmVyeSByZW5kZXJcbiAgICAgICAgLy8gaXQgZG9lc24ndCBhY3R1YWxseSBtYXR0ZXIgdGhvdWdoIHNpbmNlIGl0J3Mgb25seSBvbiB0aGUgc2VydmVyXG4gICAgICAgIC8vIHNvIHRoZXJlIHdpbGwgb25seSBldmVyeSBiZSBhIHNpbmdsZSByZW5kZXJcbiAgICAgICAgLy8gdGhhdCBjb3VsZCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZSBiZWNhdXNlIG9mIHN1c3BlbnNlIGFuZCBldGMuIGJ1dCBmb3Igbm93LFxuICAgICAgICAvLyB0aGlzIHdvcmtzIGFuZCBpIGRvbid0IHdhbnQgdG8gb3B0aW1pc2UgZm9yIGEgZnV0dXJlIHRoaW5nIHRoYXQgd2UgYXJlbid0IHN1cmUgYWJvdXRcbiAgICAgICAgY2FjaGUgPSBjcmVhdGVDYWNoZSh7XG4gICAgICAgICAga2V5OiAnY3NzJ1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9jcmVhdGVFbGVtZW50KEVtb3Rpb25DYWNoZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgICB2YWx1ZTogY2FjaGVcbiAgICAgICAgfSwgZnVuYyhwcm9wcywgY2FjaGUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmdW5jKHByb3BzLCBjYWNoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbn1cblxudmFyIFRoZW1lQ29udGV4dCA9IC8qICNfX1BVUkVfXyAqL2NyZWF0ZUNvbnRleHQoe30pO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBUaGVtZUNvbnRleHQuZGlzcGxheU5hbWUgPSAnRW1vdGlvblRoZW1lQ29udGV4dCc7XG59XG5cbnZhciB0eXBlUHJvcE5hbWUgPSAnX19FTU9USU9OX1RZUEVfUExFQVNFX0RPX05PVF9VU0VfXyc7XG52YXIgbGFiZWxQcm9wTmFtZSA9ICdfX0VNT1RJT05fTEFCRUxfUExFQVNFX0RPX05PVF9VU0VfXyc7XG5cbnZhciBJbnNlcnRpb24kMSA9IGZ1bmN0aW9uIEluc2VydGlvbihfcmVmKSB7XG4gIHZhciBjYWNoZSA9IF9yZWYuY2FjaGUsXG4gICAgICBzZXJpYWxpemVkID0gX3JlZi5zZXJpYWxpemVkLFxuICAgICAgaXNTdHJpbmdUYWcgPSBfcmVmLmlzU3RyaW5nVGFnO1xuICByZWdpc3RlclN0eWxlcyQxKGNhY2hlLCBzZXJpYWxpemVkLCBpc1N0cmluZ1RhZyk7XG4gIHZhciBydWxlcyA9IHVzZUluc2VydGlvbkVmZmVjdEFsd2F5c1dpdGhTeW5jRmFsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpbnNlcnRTdHlsZXMkMShjYWNoZSwgc2VyaWFsaXplZCwgaXNTdHJpbmdUYWcpO1xuICB9KTtcblxuICBpZiAoIWlzQnJvd3NlciQyICYmIHJ1bGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgX3JlZjI7XG5cbiAgICB2YXIgc2VyaWFsaXplZE5hbWVzID0gc2VyaWFsaXplZC5uYW1lO1xuICAgIHZhciBuZXh0ID0gc2VyaWFsaXplZC5uZXh0O1xuXG4gICAgd2hpbGUgKG5leHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc2VyaWFsaXplZE5hbWVzICs9ICcgJyArIG5leHQubmFtZTtcbiAgICAgIG5leHQgPSBuZXh0Lm5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9jcmVhdGVFbGVtZW50KFwic3R5bGVcIiwgKF9yZWYyID0ge30sIF9yZWYyW1wiZGF0YS1lbW90aW9uXCJdID0gY2FjaGUua2V5ICsgXCIgXCIgKyBzZXJpYWxpemVkTmFtZXMsIF9yZWYyLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID0ge1xuICAgICAgX19odG1sOiBydWxlc1xuICAgIH0sIF9yZWYyLm5vbmNlID0gY2FjaGUuc2hlZXQubm9uY2UsIF9yZWYyKSk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbnZhciBFbW90aW9uID0gLyogI19fUFVSRV9fICovd2l0aEVtb3Rpb25DYWNoZShmdW5jdGlvbiAocHJvcHMsIGNhY2hlLCByZWYpIHtcbiAgdmFyIGNzc1Byb3AgPSBwcm9wcy5jc3M7IC8vIHNvIHRoYXQgdXNpbmcgYGNzc2AgZnJvbSBgZW1vdGlvbmAgYW5kIHBhc3NpbmcgdGhlIHJlc3VsdCB0byB0aGUgY3NzIHByb3Agd29ya3NcbiAgLy8gbm90IHBhc3NpbmcgdGhlIHJlZ2lzdGVyZWQgY2FjaGUgdG8gc2VyaWFsaXplU3R5bGVzIGJlY2F1c2UgaXQgd291bGRcbiAgLy8gbWFrZSBjZXJ0YWluIGJhYmVsIG9wdGltaXNhdGlvbnMgbm90IHBvc3NpYmxlXG5cbiAgaWYgKHR5cGVvZiBjc3NQcm9wID09PSAnc3RyaW5nJyAmJiBjYWNoZS5yZWdpc3RlcmVkW2Nzc1Byb3BdICE9PSB1bmRlZmluZWQpIHtcbiAgICBjc3NQcm9wID0gY2FjaGUucmVnaXN0ZXJlZFtjc3NQcm9wXTtcbiAgfVxuXG4gIHZhciBXcmFwcGVkQ29tcG9uZW50ID0gcHJvcHNbdHlwZVByb3BOYW1lXTtcbiAgdmFyIHJlZ2lzdGVyZWRTdHlsZXMgPSBbY3NzUHJvcF07XG4gIHZhciBjbGFzc05hbWUgPSAnJztcblxuICBpZiAodHlwZW9mIHByb3BzLmNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICBjbGFzc05hbWUgPSBnZXRSZWdpc3RlcmVkU3R5bGVzJDEoY2FjaGUucmVnaXN0ZXJlZCwgcmVnaXN0ZXJlZFN0eWxlcywgcHJvcHMuY2xhc3NOYW1lKTtcbiAgfSBlbHNlIGlmIChwcm9wcy5jbGFzc05hbWUgIT0gbnVsbCkge1xuICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSArIFwiIFwiO1xuICB9XG5cbiAgdmFyIHNlcmlhbGl6ZWQgPSBzZXJpYWxpemVTdHlsZXMkMShyZWdpc3RlcmVkU3R5bGVzLCB1bmRlZmluZWQsIHVzZUNvbnRleHQoVGhlbWVDb250ZXh0KSk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc2VyaWFsaXplZC5uYW1lLmluZGV4T2YoJy0nKSA9PT0gLTEpIHtcbiAgICB2YXIgbGFiZWxGcm9tU3RhY2sgPSBwcm9wc1tsYWJlbFByb3BOYW1lXTtcblxuICAgIGlmIChsYWJlbEZyb21TdGFjaykge1xuICAgICAgc2VyaWFsaXplZCA9IHNlcmlhbGl6ZVN0eWxlcyQxKFtzZXJpYWxpemVkLCAnbGFiZWw6JyArIGxhYmVsRnJvbVN0YWNrICsgJzsnXSk7XG4gICAgfVxuICB9XG5cbiAgY2xhc3NOYW1lICs9IGNhY2hlLmtleSArIFwiLVwiICsgc2VyaWFsaXplZC5uYW1lO1xuICB2YXIgbmV3UHJvcHMgPSB7fTtcblxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywga2V5KSAmJiBrZXkgIT09ICdjc3MnICYmIGtleSAhPT0gdHlwZVByb3BOYW1lICYmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nIHx8IGtleSAhPT0gbGFiZWxQcm9wTmFtZSkpIHtcbiAgICAgIG5ld1Byb3BzW2tleV0gPSBwcm9wc1trZXldO1xuICAgIH1cbiAgfVxuXG4gIG5ld1Byb3BzLnJlZiA9IHJlZjtcbiAgbmV3UHJvcHMuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICByZXR1cm4gLyojX19QVVJFX18qL2NyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi9jcmVhdGVFbGVtZW50KEluc2VydGlvbiQxLCB7XG4gICAgY2FjaGU6IGNhY2hlLFxuICAgIHNlcmlhbGl6ZWQ6IHNlcmlhbGl6ZWQsXG4gICAgaXNTdHJpbmdUYWc6IHR5cGVvZiBXcmFwcGVkQ29tcG9uZW50ID09PSAnc3RyaW5nJ1xuICB9KSwgLyojX19QVVJFX18qL2NyZWF0ZUVsZW1lbnQoV3JhcHBlZENvbXBvbmVudCwgbmV3UHJvcHMpKTtcbn0pO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBFbW90aW9uLmRpc3BsYXlOYW1lID0gJ0Vtb3Rpb25Dc3NQcm9wSW50ZXJuYWwnO1xufVxuXG52YXIgaXNCcm93c2VyJDEgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuZnVuY3Rpb24gZ2V0UmVnaXN0ZXJlZFN0eWxlcyhyZWdpc3RlcmVkLCByZWdpc3RlcmVkU3R5bGVzLCBjbGFzc05hbWVzKSB7XG4gIHZhciByYXdDbGFzc05hbWUgPSAnJztcbiAgY2xhc3NOYW1lcy5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgIGlmIChyZWdpc3RlcmVkW2NsYXNzTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVnaXN0ZXJlZFN0eWxlcy5wdXNoKHJlZ2lzdGVyZWRbY2xhc3NOYW1lXSArIFwiO1wiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmF3Q2xhc3NOYW1lICs9IGNsYXNzTmFtZSArIFwiIFwiO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByYXdDbGFzc05hbWU7XG59XG52YXIgcmVnaXN0ZXJTdHlsZXMgPSBmdW5jdGlvbiByZWdpc3RlclN0eWxlcyhjYWNoZSwgc2VyaWFsaXplZCwgaXNTdHJpbmdUYWcpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IGNhY2hlLmtleSArIFwiLVwiICsgc2VyaWFsaXplZC5uYW1lO1xuXG4gIGlmICggLy8gd2Ugb25seSBuZWVkIHRvIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSByZWdpc3RlcmVkIGNhY2hlIGlmIHRoZVxuICAvLyBjbGFzcyBuYW1lIGNvdWxkIGJlIHVzZWQgZnVydGhlciBkb3duXG4gIC8vIHRoZSB0cmVlIGJ1dCBpZiBpdCdzIGEgc3RyaW5nIHRhZywgd2Uga25vdyBpdCB3b24ndFxuICAvLyBzbyB3ZSBkb24ndCBoYXZlIHRvIGFkZCBpdCB0byByZWdpc3RlcmVkIGNhY2hlLlxuICAvLyB0aGlzIGltcHJvdmVzIG1lbW9yeSB1c2FnZSBzaW5jZSB3ZSBjYW4gYXZvaWQgc3RvcmluZyB0aGUgd2hvbGUgc3R5bGUgc3RyaW5nXG4gIChpc1N0cmluZ1RhZyA9PT0gZmFsc2UgfHwgLy8gd2UgbmVlZCB0byBhbHdheXMgc3RvcmUgaXQgaWYgd2UncmUgaW4gY29tcGF0IG1vZGUgYW5kXG4gIC8vIGluIG5vZGUgc2luY2UgZW1vdGlvbi1zZXJ2ZXIgcmVsaWVzIG9uIHdoZXRoZXIgYSBzdHlsZSBpcyBpblxuICAvLyB0aGUgcmVnaXN0ZXJlZCBjYWNoZSB0byBrbm93IHdoZXRoZXIgYSBzdHlsZSBpcyBnbG9iYWwgb3Igbm90XG4gIC8vIGFsc28sIG5vdGUgdGhhdCB0aGlzIGNoZWNrIHdpbGwgYmUgZGVhZCBjb2RlIGVsaW1pbmF0ZWQgaW4gdGhlIGJyb3dzZXJcbiAgaXNCcm93c2VyJDEgPT09IGZhbHNlICYmIGNhY2hlLmNvbXBhdCAhPT0gdW5kZWZpbmVkKSAmJiBjYWNoZS5yZWdpc3RlcmVkW2NsYXNzTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgIGNhY2hlLnJlZ2lzdGVyZWRbY2xhc3NOYW1lXSA9IHNlcmlhbGl6ZWQuc3R5bGVzO1xuICB9XG59O1xudmFyIGluc2VydFN0eWxlcyA9IGZ1bmN0aW9uIGluc2VydFN0eWxlcyhjYWNoZSwgc2VyaWFsaXplZCwgaXNTdHJpbmdUYWcpIHtcbiAgcmVnaXN0ZXJTdHlsZXMoY2FjaGUsIHNlcmlhbGl6ZWQsIGlzU3RyaW5nVGFnKTtcbiAgdmFyIGNsYXNzTmFtZSA9IGNhY2hlLmtleSArIFwiLVwiICsgc2VyaWFsaXplZC5uYW1lO1xuXG4gIGlmIChjYWNoZS5pbnNlcnRlZFtzZXJpYWxpemVkLm5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgc3R5bGVzRm9yU1NSID0gJyc7XG4gICAgdmFyIGN1cnJlbnQgPSBzZXJpYWxpemVkO1xuXG4gICAgZG8ge1xuICAgICAgdmFyIG1heWJlU3R5bGVzID0gY2FjaGUuaW5zZXJ0KHNlcmlhbGl6ZWQgPT09IGN1cnJlbnQgPyBcIi5cIiArIGNsYXNzTmFtZSA6ICcnLCBjdXJyZW50LCBjYWNoZS5zaGVldCwgdHJ1ZSk7XG5cbiAgICAgIGlmICghaXNCcm93c2VyJDEgJiYgbWF5YmVTdHlsZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzdHlsZXNGb3JTU1IgKz0gbWF5YmVTdHlsZXM7XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgfSB3aGlsZSAoY3VycmVudCAhPT0gdW5kZWZpbmVkKTtcblxuICAgIGlmICghaXNCcm93c2VyJDEgJiYgc3R5bGVzRm9yU1NSLmxlbmd0aCAhPT0gMCkge1xuICAgICAgcmV0dXJuIHN0eWxlc0ZvclNTUjtcbiAgICB9XG4gIH1cbn07XG5cbi8qIGVzbGludC1kaXNhYmxlICovXG4vLyBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vZ2FyeWNvdXJ0L211cm11cmhhc2gtanNcbi8vIFBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9hYXBwbGVieS9zbWhhc2hlci9ibG9iLzYxYTA1MzBmMjgyNzdmMmU4NTBiZmMzOTYwMGNlNjFkMDJiNTE4ZGUvc3JjL011cm11ckhhc2gyLmNwcCNMMzctTDg2XG5mdW5jdGlvbiBtdXJtdXIyKHN0cikge1xuICAvLyAnbScgYW5kICdyJyBhcmUgbWl4aW5nIGNvbnN0YW50cyBnZW5lcmF0ZWQgb2ZmbGluZS5cbiAgLy8gVGhleSdyZSBub3QgcmVhbGx5ICdtYWdpYycsIHRoZXkganVzdCBoYXBwZW4gdG8gd29yayB3ZWxsLlxuICAvLyBjb25zdCBtID0gMHg1YmQxZTk5NTtcbiAgLy8gY29uc3QgciA9IDI0O1xuICAvLyBJbml0aWFsaXplIHRoZSBoYXNoXG4gIHZhciBoID0gMDsgLy8gTWl4IDQgYnl0ZXMgYXQgYSB0aW1lIGludG8gdGhlIGhhc2hcblxuICB2YXIgayxcbiAgICAgIGkgPSAwLFxuICAgICAgbGVuID0gc3RyLmxlbmd0aDtcblxuICBmb3IgKDsgbGVuID49IDQ7ICsraSwgbGVuIC09IDQpIHtcbiAgICBrID0gc3RyLmNoYXJDb2RlQXQoaSkgJiAweGZmIHwgKHN0ci5jaGFyQ29kZUF0KCsraSkgJiAweGZmKSA8PCA4IHwgKHN0ci5jaGFyQ29kZUF0KCsraSkgJiAweGZmKSA8PCAxNiB8IChzdHIuY2hhckNvZGVBdCgrK2kpICYgMHhmZikgPDwgMjQ7XG4gICAgayA9XG4gICAgLyogTWF0aC5pbXVsKGssIG0pOiAqL1xuICAgIChrICYgMHhmZmZmKSAqIDB4NWJkMWU5OTUgKyAoKGsgPj4+IDE2KSAqIDB4ZTk5NSA8PCAxNik7XG4gICAgayBePVxuICAgIC8qIGsgPj4+IHI6ICovXG4gICAgayA+Pj4gMjQ7XG4gICAgaCA9XG4gICAgLyogTWF0aC5pbXVsKGssIG0pOiAqL1xuICAgIChrICYgMHhmZmZmKSAqIDB4NWJkMWU5OTUgKyAoKGsgPj4+IDE2KSAqIDB4ZTk5NSA8PCAxNikgXlxuICAgIC8qIE1hdGguaW11bChoLCBtKTogKi9cbiAgICAoaCAmIDB4ZmZmZikgKiAweDViZDFlOTk1ICsgKChoID4+PiAxNikgKiAweGU5OTUgPDwgMTYpO1xuICB9IC8vIEhhbmRsZSB0aGUgbGFzdCBmZXcgYnl0ZXMgb2YgdGhlIGlucHV0IGFycmF5XG5cblxuICBzd2l0Y2ggKGxlbikge1xuICAgIGNhc2UgMzpcbiAgICAgIGggXj0gKHN0ci5jaGFyQ29kZUF0KGkgKyAyKSAmIDB4ZmYpIDw8IDE2O1xuXG4gICAgY2FzZSAyOlxuICAgICAgaCBePSAoc3RyLmNoYXJDb2RlQXQoaSArIDEpICYgMHhmZikgPDwgODtcblxuICAgIGNhc2UgMTpcbiAgICAgIGggXj0gc3RyLmNoYXJDb2RlQXQoaSkgJiAweGZmO1xuICAgICAgaCA9XG4gICAgICAvKiBNYXRoLmltdWwoaCwgbSk6ICovXG4gICAgICAoaCAmIDB4ZmZmZikgKiAweDViZDFlOTk1ICsgKChoID4+PiAxNikgKiAweGU5OTUgPDwgMTYpO1xuICB9IC8vIERvIGEgZmV3IGZpbmFsIG1peGVzIG9mIHRoZSBoYXNoIHRvIGVuc3VyZSB0aGUgbGFzdCBmZXdcbiAgLy8gYnl0ZXMgYXJlIHdlbGwtaW5jb3Jwb3JhdGVkLlxuXG5cbiAgaCBePSBoID4+PiAxMztcbiAgaCA9XG4gIC8qIE1hdGguaW11bChoLCBtKTogKi9cbiAgKGggJiAweGZmZmYpICogMHg1YmQxZTk5NSArICgoaCA+Pj4gMTYpICogMHhlOTk1IDw8IDE2KTtcbiAgcmV0dXJuICgoaCBeIGggPj4+IDE1KSA+Pj4gMCkudG9TdHJpbmcoMzYpO1xufVxuXG52YXIgdW5pdGxlc3NLZXlzID0ge1xuICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogMSxcbiAgYm9yZGVySW1hZ2VPdXRzZXQ6IDEsXG4gIGJvcmRlckltYWdlU2xpY2U6IDEsXG4gIGJvcmRlckltYWdlV2lkdGg6IDEsXG4gIGJveEZsZXg6IDEsXG4gIGJveEZsZXhHcm91cDogMSxcbiAgYm94T3JkaW5hbEdyb3VwOiAxLFxuICBjb2x1bW5Db3VudDogMSxcbiAgY29sdW1uczogMSxcbiAgZmxleDogMSxcbiAgZmxleEdyb3c6IDEsXG4gIGZsZXhQb3NpdGl2ZTogMSxcbiAgZmxleFNocmluazogMSxcbiAgZmxleE5lZ2F0aXZlOiAxLFxuICBmbGV4T3JkZXI6IDEsXG4gIGdyaWRSb3c6IDEsXG4gIGdyaWRSb3dFbmQ6IDEsXG4gIGdyaWRSb3dTcGFuOiAxLFxuICBncmlkUm93U3RhcnQ6IDEsXG4gIGdyaWRDb2x1bW46IDEsXG4gIGdyaWRDb2x1bW5FbmQ6IDEsXG4gIGdyaWRDb2x1bW5TcGFuOiAxLFxuICBncmlkQ29sdW1uU3RhcnQ6IDEsXG4gIG1zR3JpZFJvdzogMSxcbiAgbXNHcmlkUm93U3BhbjogMSxcbiAgbXNHcmlkQ29sdW1uOiAxLFxuICBtc0dyaWRDb2x1bW5TcGFuOiAxLFxuICBmb250V2VpZ2h0OiAxLFxuICBsaW5lSGVpZ2h0OiAxLFxuICBvcGFjaXR5OiAxLFxuICBvcmRlcjogMSxcbiAgb3JwaGFuczogMSxcbiAgdGFiU2l6ZTogMSxcbiAgd2lkb3dzOiAxLFxuICB6SW5kZXg6IDEsXG4gIHpvb206IDEsXG4gIFdlYmtpdExpbmVDbGFtcDogMSxcbiAgLy8gU1ZHLXJlbGF0ZWQgcHJvcGVydGllc1xuICBmaWxsT3BhY2l0eTogMSxcbiAgZmxvb2RPcGFjaXR5OiAxLFxuICBzdG9wT3BhY2l0eTogMSxcbiAgc3Ryb2tlRGFzaGFycmF5OiAxLFxuICBzdHJva2VEYXNob2Zmc2V0OiAxLFxuICBzdHJva2VNaXRlcmxpbWl0OiAxLFxuICBzdHJva2VPcGFjaXR5OiAxLFxuICBzdHJva2VXaWR0aDogMVxufTtcblxudmFyIElMTEVHQUxfRVNDQVBFX1NFUVVFTkNFX0VSUk9SJDEgPSBcIllvdSBoYXZlIGlsbGVnYWwgZXNjYXBlIHNlcXVlbmNlIGluIHlvdXIgdGVtcGxhdGUgbGl0ZXJhbCwgbW9zdCBsaWtlbHkgaW5zaWRlIGNvbnRlbnQncyBwcm9wZXJ0eSB2YWx1ZS5cXG5CZWNhdXNlIHlvdSB3cml0ZSB5b3VyIENTUyBpbnNpZGUgYSBKYXZhU2NyaXB0IHN0cmluZyB5b3UgYWN0dWFsbHkgaGF2ZSB0byBkbyBkb3VibGUgZXNjYXBpbmcsIHNvIGZvciBleGFtcGxlIFxcXCJjb250ZW50OiAnXFxcXDAwZDcnO1xcXCIgc2hvdWxkIGJlY29tZSBcXFwiY29udGVudDogJ1xcXFxcXFxcMDBkNyc7XFxcIi5cXG5Zb3UgY2FuIHJlYWQgbW9yZSBhYm91dCB0aGlzIGhlcmU6XFxuaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvVGVtcGxhdGVfbGl0ZXJhbHMjRVMyMDE4X3JldmlzaW9uX29mX2lsbGVnYWxfZXNjYXBlX3NlcXVlbmNlc1wiO1xudmFyIFVOREVGSU5FRF9BU19PQkpFQ1RfS0VZX0VSUk9SID0gXCJZb3UgaGF2ZSBwYXNzZWQgaW4gZmFsc3kgdmFsdWUgYXMgc3R5bGUgb2JqZWN0J3Mga2V5IChjYW4gaGFwcGVuIHdoZW4gaW4gZXhhbXBsZSB5b3UgcGFzcyB1bmV4cG9ydGVkIGNvbXBvbmVudCBhcyBjb21wdXRlZCBrZXkpLlwiO1xudmFyIGh5cGhlbmF0ZVJlZ2V4ID0gL1tBLVpdfF5tcy9nO1xudmFyIGFuaW1hdGlvblJlZ2V4ID0gL19FTU9fKFteX10rPylfKFteXSo/KV9FTU9fL2c7XG5cbnZhciBpc0N1c3RvbVByb3BlcnR5ID0gZnVuY3Rpb24gaXNDdXN0b21Qcm9wZXJ0eShwcm9wZXJ0eSkge1xuICByZXR1cm4gcHJvcGVydHkuY2hhckNvZGVBdCgxKSA9PT0gNDU7XG59O1xuXG52YXIgaXNQcm9jZXNzYWJsZVZhbHVlID0gZnVuY3Rpb24gaXNQcm9jZXNzYWJsZVZhbHVlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nO1xufTtcblxudmFyIHByb2Nlc3NTdHlsZU5hbWUgPSAvKiAjX19QVVJFX18gKi9tZW1vaXplKGZ1bmN0aW9uIChzdHlsZU5hbWUpIHtcbiAgcmV0dXJuIGlzQ3VzdG9tUHJvcGVydHkoc3R5bGVOYW1lKSA/IHN0eWxlTmFtZSA6IHN0eWxlTmFtZS5yZXBsYWNlKGh5cGhlbmF0ZVJlZ2V4LCAnLSQmJykudG9Mb3dlckNhc2UoKTtcbn0pO1xuXG52YXIgcHJvY2Vzc1N0eWxlVmFsdWUgPSBmdW5jdGlvbiBwcm9jZXNzU3R5bGVWYWx1ZShrZXksIHZhbHVlKSB7XG4gIHN3aXRjaCAoa2V5KSB7XG4gICAgY2FzZSAnYW5pbWF0aW9uJzpcbiAgICBjYXNlICdhbmltYXRpb25OYW1lJzpcbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUucmVwbGFjZShhbmltYXRpb25SZWdleCwgZnVuY3Rpb24gKG1hdGNoLCBwMSwgcDIpIHtcbiAgICAgICAgICAgIGN1cnNvciA9IHtcbiAgICAgICAgICAgICAgbmFtZTogcDEsXG4gICAgICAgICAgICAgIHN0eWxlczogcDIsXG4gICAgICAgICAgICAgIG5leHQ6IGN1cnNvclxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBwMTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICB9XG5cbiAgaWYgKHVuaXRsZXNzS2V5c1trZXldICE9PSAxICYmICFpc0N1c3RvbVByb3BlcnR5KGtleSkgJiYgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiB2YWx1ZSAhPT0gMCkge1xuICAgIHJldHVybiB2YWx1ZSArICdweCc7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgY29udGVudFZhbHVlUGF0dGVybiA9IC8odmFyfGF0dHJ8Y291bnRlcnM/fHVybHxlbGVtZW50fCgoKHJlcGVhdGluZy0pPyhsaW5lYXJ8cmFkaWFsKSl8Y29uaWMpLWdyYWRpZW50KVxcKHwobm8tKT8ob3BlbnxjbG9zZSktcXVvdGUvO1xuICB2YXIgY29udGVudFZhbHVlcyA9IFsnbm9ybWFsJywgJ25vbmUnLCAnaW5pdGlhbCcsICdpbmhlcml0JywgJ3Vuc2V0J107XG4gIHZhciBvbGRQcm9jZXNzU3R5bGVWYWx1ZSA9IHByb2Nlc3NTdHlsZVZhbHVlO1xuICB2YXIgbXNQYXR0ZXJuID0gL14tbXMtLztcbiAgdmFyIGh5cGhlblBhdHRlcm4gPSAvLSguKS9nO1xuICB2YXIgaHlwaGVuYXRlZENhY2hlID0ge307XG5cbiAgcHJvY2Vzc1N0eWxlVmFsdWUgPSBmdW5jdGlvbiBwcm9jZXNzU3R5bGVWYWx1ZShrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSA9PT0gJ2NvbnRlbnQnKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyB8fCBjb250ZW50VmFsdWVzLmluZGV4T2YodmFsdWUpID09PSAtMSAmJiAhY29udGVudFZhbHVlUGF0dGVybi50ZXN0KHZhbHVlKSAmJiAodmFsdWUuY2hhckF0KDApICE9PSB2YWx1ZS5jaGFyQXQodmFsdWUubGVuZ3RoIC0gMSkgfHwgdmFsdWUuY2hhckF0KDApICE9PSAnXCInICYmIHZhbHVlLmNoYXJBdCgwKSAhPT0gXCInXCIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBzZWVtIHRvIGJlIHVzaW5nIGEgdmFsdWUgZm9yICdjb250ZW50JyB3aXRob3V0IHF1b3RlcywgdHJ5IHJlcGxhY2luZyBpdCB3aXRoIGBjb250ZW50OiAnXFxcIlwiICsgdmFsdWUgKyBcIlxcXCInYFwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJvY2Vzc2VkID0gb2xkUHJvY2Vzc1N0eWxlVmFsdWUoa2V5LCB2YWx1ZSk7XG5cbiAgICBpZiAocHJvY2Vzc2VkICE9PSAnJyAmJiAhaXNDdXN0b21Qcm9wZXJ0eShrZXkpICYmIGtleS5pbmRleE9mKCctJykgIT09IC0xICYmIGh5cGhlbmF0ZWRDYWNoZVtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGh5cGhlbmF0ZWRDYWNoZVtrZXldID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJVc2luZyBrZWJhYi1jYXNlIGZvciBjc3MgcHJvcGVydGllcyBpbiBvYmplY3RzIGlzIG5vdCBzdXBwb3J0ZWQuIERpZCB5b3UgbWVhbiBcIiArIGtleS5yZXBsYWNlKG1zUGF0dGVybiwgJ21zLScpLnJlcGxhY2UoaHlwaGVuUGF0dGVybiwgZnVuY3Rpb24gKHN0ciwgX2NoYXIpIHtcbiAgICAgICAgcmV0dXJuIF9jaGFyLnRvVXBwZXJDYXNlKCk7XG4gICAgICB9KSArIFwiP1wiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvY2Vzc2VkO1xuICB9O1xufVxuXG52YXIgbm9Db21wb25lbnRTZWxlY3Rvck1lc3NhZ2UgPSAnQ29tcG9uZW50IHNlbGVjdG9ycyBjYW4gb25seSBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggJyArICdAZW1vdGlvbi9iYWJlbC1wbHVnaW4sIHRoZSBzd2MgRW1vdGlvbiBwbHVnaW4sIG9yIGFub3RoZXIgRW1vdGlvbi1hd2FyZSAnICsgJ2NvbXBpbGVyIHRyYW5zZm9ybS4nO1xuXG5mdW5jdGlvbiBoYW5kbGVJbnRlcnBvbGF0aW9uKG1lcmdlZFByb3BzLCByZWdpc3RlcmVkLCBpbnRlcnBvbGF0aW9uKSB7XG4gIGlmIChpbnRlcnBvbGF0aW9uID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAoaW50ZXJwb2xhdGlvbi5fX2Vtb3Rpb25fc3R5bGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpbnRlcnBvbGF0aW9uLnRvU3RyaW5nKCkgPT09ICdOT19DT01QT05FTlRfU0VMRUNUT1InKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3Iobm9Db21wb25lbnRTZWxlY3Rvck1lc3NhZ2UpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnRlcnBvbGF0aW9uO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlb2YgaW50ZXJwb2xhdGlvbikge1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAge1xuICAgICAgICBpZiAoaW50ZXJwb2xhdGlvbi5hbmltID09PSAxKSB7XG4gICAgICAgICAgY3Vyc29yID0ge1xuICAgICAgICAgICAgbmFtZTogaW50ZXJwb2xhdGlvbi5uYW1lLFxuICAgICAgICAgICAgc3R5bGVzOiBpbnRlcnBvbGF0aW9uLnN0eWxlcyxcbiAgICAgICAgICAgIG5leHQ6IGN1cnNvclxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIGludGVycG9sYXRpb24ubmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnRlcnBvbGF0aW9uLnN0eWxlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIG5leHQgPSBpbnRlcnBvbGF0aW9uLm5leHQ7XG5cbiAgICAgICAgICBpZiAobmV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBub3QgdGhlIG1vc3QgZWZmaWNpZW50IHRoaW5nIGV2ZXIgYnV0IHRoaXMgaXMgYSBwcmV0dHkgcmFyZSBjYXNlXG4gICAgICAgICAgICAvLyBhbmQgdGhlcmUgd2lsbCBiZSB2ZXJ5IGZldyBpdGVyYXRpb25zIG9mIHRoaXMgZ2VuZXJhbGx5XG4gICAgICAgICAgICB3aGlsZSAobmV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGN1cnNvciA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBuZXh0Lm5hbWUsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBuZXh0LnN0eWxlcyxcbiAgICAgICAgICAgICAgICBuZXh0OiBjdXJzb3JcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgbmV4dCA9IG5leHQubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc3R5bGVzID0gaW50ZXJwb2xhdGlvbi5zdHlsZXMgKyBcIjtcIjtcblxuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGludGVycG9sYXRpb24ubWFwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0eWxlcyArPSBpbnRlcnBvbGF0aW9uLm1hcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3R5bGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNyZWF0ZVN0cmluZ0Zyb21PYmplY3QobWVyZ2VkUHJvcHMsIHJlZ2lzdGVyZWQsIGludGVycG9sYXRpb24pO1xuICAgICAgfVxuXG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAge1xuICAgICAgICBpZiAobWVyZ2VkUHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBwcmV2aW91c0N1cnNvciA9IGN1cnNvcjtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gaW50ZXJwb2xhdGlvbihtZXJnZWRQcm9wcyk7XG4gICAgICAgICAgY3Vyc29yID0gcHJldmlvdXNDdXJzb3I7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZUludGVycG9sYXRpb24obWVyZ2VkUHJvcHMsIHJlZ2lzdGVyZWQsIHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Z1bmN0aW9ucyB0aGF0IGFyZSBpbnRlcnBvbGF0ZWQgaW4gY3NzIGNhbGxzIHdpbGwgYmUgc3RyaW5naWZpZWQuXFxuJyArICdJZiB5b3Ugd2FudCB0byBoYXZlIGEgY3NzIGNhbGwgYmFzZWQgb24gcHJvcHMsIGNyZWF0ZSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGNzcyBjYWxsIGxpa2UgdGhpc1xcbicgKyAnbGV0IGR5bmFtaWNTdHlsZSA9IChwcm9wcykgPT4gY3NzYGNvbG9yOiAke3Byb3BzLmNvbG9yfWBcXG4nICsgJ0l0IGNhbiBiZSBjYWxsZWQgZGlyZWN0bHkgd2l0aCBwcm9wcyBvciBpbnRlcnBvbGF0ZWQgaW4gYSBzdHlsZWQgY2FsbCBsaWtlIHRoaXNcXG4nICsgXCJsZXQgU29tZUNvbXBvbmVudCA9IHN0eWxlZCgnZGl2JylgJHtkeW5hbWljU3R5bGV9YFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciBtYXRjaGVkID0gW107XG4gICAgICAgIHZhciByZXBsYWNlZCA9IGludGVycG9sYXRpb24ucmVwbGFjZShhbmltYXRpb25SZWdleCwgZnVuY3Rpb24gKG1hdGNoLCBwMSwgcDIpIHtcbiAgICAgICAgICB2YXIgZmFrZVZhck5hbWUgPSBcImFuaW1hdGlvblwiICsgbWF0Y2hlZC5sZW5ndGg7XG4gICAgICAgICAgbWF0Y2hlZC5wdXNoKFwiY29uc3QgXCIgKyBmYWtlVmFyTmFtZSArIFwiID0ga2V5ZnJhbWVzYFwiICsgcDIucmVwbGFjZSgvXkBrZXlmcmFtZXMgYW5pbWF0aW9uLVxcdysvLCAnJykgKyBcImBcIik7XG4gICAgICAgICAgcmV0dXJuIFwiJHtcIiArIGZha2VWYXJOYW1lICsgXCJ9XCI7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChtYXRjaGVkLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2BrZXlmcmFtZXNgIG91dHB1dCBnb3QgaW50ZXJwb2xhdGVkIGludG8gcGxhaW4gc3RyaW5nLCBwbGVhc2Ugd3JhcCBpdCB3aXRoIGBjc3NgLlxcblxcbicgKyAnSW5zdGVhZCBvZiBkb2luZyB0aGlzOlxcblxcbicgKyBbXS5jb25jYXQobWF0Y2hlZCwgW1wiYFwiICsgcmVwbGFjZWQgKyBcImBcIl0pLmpvaW4oJ1xcbicpICsgJ1xcblxcbllvdSBzaG91bGQgd3JhcCBpdCB3aXRoIGBjc3NgIGxpa2UgdGhpczpcXG5cXG4nICsgKFwiY3NzYFwiICsgcmVwbGFjZWQgKyBcImBcIikpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICB9IC8vIGZpbmFsaXplIHN0cmluZyB2YWx1ZXMgKHJlZ3VsYXIgc3RyaW5ncyBhbmQgZnVuY3Rpb25zIGludGVycG9sYXRlZCBpbnRvIGNzcyBjYWxscylcblxuXG4gIGlmIChyZWdpc3RlcmVkID09IG51bGwpIHtcbiAgICByZXR1cm4gaW50ZXJwb2xhdGlvbjtcbiAgfVxuXG4gIHZhciBjYWNoZWQgPSByZWdpc3RlcmVkW2ludGVycG9sYXRpb25dO1xuICByZXR1cm4gY2FjaGVkICE9PSB1bmRlZmluZWQgPyBjYWNoZWQgOiBpbnRlcnBvbGF0aW9uO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHJpbmdGcm9tT2JqZWN0KG1lcmdlZFByb3BzLCByZWdpc3RlcmVkLCBvYmopIHtcbiAgdmFyIHN0cmluZyA9ICcnO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgc3RyaW5nICs9IGhhbmRsZUludGVycG9sYXRpb24obWVyZ2VkUHJvcHMsIHJlZ2lzdGVyZWQsIG9ialtpXSkgKyBcIjtcIjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgX2tleSBpbiBvYmopIHtcbiAgICAgIHZhciB2YWx1ZSA9IG9ialtfa2V5XTtcblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKHJlZ2lzdGVyZWQgIT0gbnVsbCAmJiByZWdpc3RlcmVkW3ZhbHVlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc3RyaW5nICs9IF9rZXkgKyBcIntcIiArIHJlZ2lzdGVyZWRbdmFsdWVdICsgXCJ9XCI7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNQcm9jZXNzYWJsZVZhbHVlKHZhbHVlKSkge1xuICAgICAgICAgIHN0cmluZyArPSBwcm9jZXNzU3R5bGVOYW1lKF9rZXkpICsgXCI6XCIgKyBwcm9jZXNzU3R5bGVWYWx1ZShfa2V5LCB2YWx1ZSkgKyBcIjtcIjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKF9rZXkgPT09ICdOT19DT01QT05FTlRfU0VMRUNUT1InICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Iobm9Db21wb25lbnRTZWxlY3Rvck1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHR5cGVvZiB2YWx1ZVswXSA9PT0gJ3N0cmluZycgJiYgKHJlZ2lzdGVyZWQgPT0gbnVsbCB8fCByZWdpc3RlcmVkW3ZhbHVlWzBdXSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB2YWx1ZS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGlmIChpc1Byb2Nlc3NhYmxlVmFsdWUodmFsdWVbX2ldKSkge1xuICAgICAgICAgICAgICBzdHJpbmcgKz0gcHJvY2Vzc1N0eWxlTmFtZShfa2V5KSArIFwiOlwiICsgcHJvY2Vzc1N0eWxlVmFsdWUoX2tleSwgdmFsdWVbX2ldKSArIFwiO1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgaW50ZXJwb2xhdGVkID0gaGFuZGxlSW50ZXJwb2xhdGlvbihtZXJnZWRQcm9wcywgcmVnaXN0ZXJlZCwgdmFsdWUpO1xuXG4gICAgICAgICAgc3dpdGNoIChfa2V5KSB7XG4gICAgICAgICAgICBjYXNlICdhbmltYXRpb24nOlxuICAgICAgICAgICAgY2FzZSAnYW5pbWF0aW9uTmFtZSc6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gcHJvY2Vzc1N0eWxlTmFtZShfa2V5KSArIFwiOlwiICsgaW50ZXJwb2xhdGVkICsgXCI7XCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIF9rZXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFVOREVGSU5FRF9BU19PQkpFQ1RfS0VZX0VSUk9SKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gX2tleSArIFwie1wiICsgaW50ZXJwb2xhdGVkICsgXCJ9XCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RyaW5nO1xufVxuXG52YXIgbGFiZWxQYXR0ZXJuID0gL2xhYmVsOlxccyooW15cXHM7XFxue10rKVxccyooO3wkKS9nO1xudmFyIHNvdXJjZU1hcFBhdHRlcm47XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHNvdXJjZU1hcFBhdHRlcm4gPSAvXFwvXFwqI1xcc3NvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvblxcL2pzb247XFxTK1xccytcXCpcXC8vZztcbn0gLy8gdGhpcyBpcyB0aGUgY3Vyc29yIGZvciBrZXlmcmFtZXNcbi8vIGtleWZyYW1lcyBhcmUgc3RvcmVkIG9uIHRoZSBTZXJpYWxpemVkU3R5bGVzIG9iamVjdCBhcyBhIGxpbmtlZCBsaXN0XG5cblxudmFyIGN1cnNvcjtcbnZhciBzZXJpYWxpemVTdHlsZXMgPSBmdW5jdGlvbiBzZXJpYWxpemVTdHlsZXMoYXJncywgcmVnaXN0ZXJlZCwgbWVyZ2VkUHJvcHMpIHtcbiAgaWYgKGFyZ3MubGVuZ3RoID09PSAxICYmIHR5cGVvZiBhcmdzWzBdID09PSAnb2JqZWN0JyAmJiBhcmdzWzBdICE9PSBudWxsICYmIGFyZ3NbMF0uc3R5bGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gYXJnc1swXTtcbiAgfVxuXG4gIHZhciBzdHJpbmdNb2RlID0gdHJ1ZTtcbiAgdmFyIHN0eWxlcyA9ICcnO1xuICBjdXJzb3IgPSB1bmRlZmluZWQ7XG4gIHZhciBzdHJpbmdzID0gYXJnc1swXTtcblxuICBpZiAoc3RyaW5ncyA9PSBudWxsIHx8IHN0cmluZ3MucmF3ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdHJpbmdNb2RlID0gZmFsc2U7XG4gICAgc3R5bGVzICs9IGhhbmRsZUludGVycG9sYXRpb24obWVyZ2VkUHJvcHMsIHJlZ2lzdGVyZWQsIHN0cmluZ3MpO1xuICB9IGVsc2Uge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHN0cmluZ3NbMF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc29sZS5lcnJvcihJTExFR0FMX0VTQ0FQRV9TRVFVRU5DRV9FUlJPUiQxKTtcbiAgICB9XG5cbiAgICBzdHlsZXMgKz0gc3RyaW5nc1swXTtcbiAgfSAvLyB3ZSBzdGFydCBhdCAxIHNpbmNlIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgZmlyc3QgYXJnXG5cblxuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBzdHlsZXMgKz0gaGFuZGxlSW50ZXJwb2xhdGlvbihtZXJnZWRQcm9wcywgcmVnaXN0ZXJlZCwgYXJnc1tpXSk7XG5cbiAgICBpZiAoc3RyaW5nTW9kZSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc3RyaW5nc1tpXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoSUxMRUdBTF9FU0NBUEVfU0VRVUVOQ0VfRVJST1IkMSk7XG4gICAgICB9XG5cbiAgICAgIHN0eWxlcyArPSBzdHJpbmdzW2ldO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzb3VyY2VNYXA7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBzdHlsZXMgPSBzdHlsZXMucmVwbGFjZShzb3VyY2VNYXBQYXR0ZXJuLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgIHNvdXJjZU1hcCA9IG1hdGNoO1xuICAgICAgcmV0dXJuICcnO1xuICAgIH0pO1xuICB9IC8vIHVzaW5nIGEgZ2xvYmFsIHJlZ2V4IHdpdGggLmV4ZWMgaXMgc3RhdGVmdWwgc28gbGFzdEluZGV4IGhhcyB0byBiZSByZXNldCBlYWNoIHRpbWVcblxuXG4gIGxhYmVsUGF0dGVybi5sYXN0SW5kZXggPSAwO1xuICB2YXIgaWRlbnRpZmllck5hbWUgPSAnJztcbiAgdmFyIG1hdGNoOyAvLyBodHRwczovL2VzYmVuY2guY29tL2JlbmNoLzViODA5YzJjZjI5NDk4MDBhMGY2MWZiNVxuXG4gIHdoaWxlICgobWF0Y2ggPSBsYWJlbFBhdHRlcm4uZXhlYyhzdHlsZXMpKSAhPT0gbnVsbCkge1xuICAgIGlkZW50aWZpZXJOYW1lICs9ICctJyArIC8vICRGbG93Rml4TWUgd2Uga25vdyBpdCdzIG5vdCBudWxsXG4gICAgbWF0Y2hbMV07XG4gIH1cblxuICB2YXIgbmFtZSA9IG11cm11cjIoc3R5bGVzKSArIGlkZW50aWZpZXJOYW1lO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gJEZsb3dGaXhNZSBTZXJpYWxpemVkU3R5bGVzIHR5cGUgZG9lc24ndCBoYXZlIHRvU3RyaW5nIHByb3BlcnR5IChhbmQgd2UgZG9uJ3Qgd2FudCB0byBhZGQgaXQpXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBzdHlsZXM6IHN0eWxlcyxcbiAgICAgIG1hcDogc291cmNlTWFwLFxuICAgICAgbmV4dDogY3Vyc29yLFxuICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gXCJZb3UgaGF2ZSB0cmllZCB0byBzdHJpbmdpZnkgb2JqZWN0IHJldHVybmVkIGZyb20gYGNzc2AgZnVuY3Rpb24uIEl0IGlzbid0IHN1cHBvc2VkIHRvIGJlIHVzZWQgZGlyZWN0bHkgKGUuZy4gYXMgdmFsdWUgb2YgdGhlIGBjbGFzc05hbWVgIHByb3ApLCBidXQgcmF0aGVyIGhhbmRlZCB0byBlbW90aW9uIHNvIGl0IGNhbiBoYW5kbGUgaXQgKGUuZy4gYXMgdmFsdWUgb2YgYGNzc2AgcHJvcCkuXCI7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBzdHlsZXM6IHN0eWxlcyxcbiAgICBuZXh0OiBjdXJzb3JcbiAgfTtcbn07XG5cbnZhciB0ZXN0T21pdFByb3BzT25TdHJpbmdUYWcgPSBpc1Byb3BWYWxpZDtcblxudmFyIHRlc3RPbWl0UHJvcHNPbkNvbXBvbmVudCA9IGZ1bmN0aW9uIHRlc3RPbWl0UHJvcHNPbkNvbXBvbmVudChrZXkpIHtcbiAgcmV0dXJuIGtleSAhPT0gJ3RoZW1lJztcbn07XG5cbnZhciBnZXREZWZhdWx0U2hvdWxkRm9yd2FyZFByb3AgPSBmdW5jdGlvbiBnZXREZWZhdWx0U2hvdWxkRm9yd2FyZFByb3AodGFnKSB7XG4gIHJldHVybiB0eXBlb2YgdGFnID09PSAnc3RyaW5nJyAmJiAvLyA5NiBpcyBvbmUgbGVzcyB0aGFuIHRoZSBjaGFyIGNvZGVcbiAgLy8gZm9yIFwiYVwiIHNvIHRoaXMgaXMgY2hlY2tpbmcgdGhhdFxuICAvLyBpdCdzIGEgbG93ZXJjYXNlIGNoYXJhY3RlclxuICB0YWcuY2hhckNvZGVBdCgwKSA+IDk2ID8gdGVzdE9taXRQcm9wc09uU3RyaW5nVGFnIDogdGVzdE9taXRQcm9wc09uQ29tcG9uZW50O1xufTtcbnZhciBjb21wb3NlU2hvdWxkRm9yd2FyZFByb3BzID0gZnVuY3Rpb24gY29tcG9zZVNob3VsZEZvcndhcmRQcm9wcyh0YWcsIG9wdGlvbnMsIGlzUmVhbCkge1xuICB2YXIgc2hvdWxkRm9yd2FyZFByb3A7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICB2YXIgb3B0aW9uc1Nob3VsZEZvcndhcmRQcm9wID0gb3B0aW9ucy5zaG91bGRGb3J3YXJkUHJvcDtcbiAgICBzaG91bGRGb3J3YXJkUHJvcCA9IHRhZy5fX2Vtb3Rpb25fZm9yd2FyZFByb3AgJiYgb3B0aW9uc1Nob3VsZEZvcndhcmRQcm9wID8gZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICByZXR1cm4gdGFnLl9fZW1vdGlvbl9mb3J3YXJkUHJvcChwcm9wTmFtZSkgJiYgb3B0aW9uc1Nob3VsZEZvcndhcmRQcm9wKHByb3BOYW1lKTtcbiAgICB9IDogb3B0aW9uc1Nob3VsZEZvcndhcmRQcm9wO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBzaG91bGRGb3J3YXJkUHJvcCAhPT0gJ2Z1bmN0aW9uJyAmJiBpc1JlYWwpIHtcbiAgICBzaG91bGRGb3J3YXJkUHJvcCA9IHRhZy5fX2Vtb3Rpb25fZm9yd2FyZFByb3A7XG4gIH1cblxuICByZXR1cm4gc2hvdWxkRm9yd2FyZFByb3A7XG59O1xuXG52YXIgSUxMRUdBTF9FU0NBUEVfU0VRVUVOQ0VfRVJST1IgPSBcIllvdSBoYXZlIGlsbGVnYWwgZXNjYXBlIHNlcXVlbmNlIGluIHlvdXIgdGVtcGxhdGUgbGl0ZXJhbCwgbW9zdCBsaWtlbHkgaW5zaWRlIGNvbnRlbnQncyBwcm9wZXJ0eSB2YWx1ZS5cXG5CZWNhdXNlIHlvdSB3cml0ZSB5b3VyIENTUyBpbnNpZGUgYSBKYXZhU2NyaXB0IHN0cmluZyB5b3UgYWN0dWFsbHkgaGF2ZSB0byBkbyBkb3VibGUgZXNjYXBpbmcsIHNvIGZvciBleGFtcGxlIFxcXCJjb250ZW50OiAnXFxcXDAwZDcnO1xcXCIgc2hvdWxkIGJlY29tZSBcXFwiY29udGVudDogJ1xcXFxcXFxcMDBkNyc7XFxcIi5cXG5Zb3UgY2FuIHJlYWQgbW9yZSBhYm91dCB0aGlzIGhlcmU6XFxuaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvVGVtcGxhdGVfbGl0ZXJhbHMjRVMyMDE4X3JldmlzaW9uX29mX2lsbGVnYWxfZXNjYXBlX3NlcXVlbmNlc1wiO1xudmFyIGlzQnJvd3NlciA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbnZhciBJbnNlcnRpb24gPSBmdW5jdGlvbiBJbnNlcnRpb24oX3JlZikge1xuICB2YXIgY2FjaGUgPSBfcmVmLmNhY2hlLFxuICAgICAgc2VyaWFsaXplZCA9IF9yZWYuc2VyaWFsaXplZCxcbiAgICAgIGlzU3RyaW5nVGFnID0gX3JlZi5pc1N0cmluZ1RhZztcbiAgcmVnaXN0ZXJTdHlsZXMoY2FjaGUsIHNlcmlhbGl6ZWQsIGlzU3RyaW5nVGFnKTtcbiAgdmFyIHJ1bGVzID0gdXNlSW5zZXJ0aW9uRWZmZWN0QWx3YXlzV2l0aFN5bmNGYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGluc2VydFN0eWxlcyhjYWNoZSwgc2VyaWFsaXplZCwgaXNTdHJpbmdUYWcpO1xuICB9KTtcblxuICBpZiAoIWlzQnJvd3NlciAmJiBydWxlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIF9yZWYyO1xuXG4gICAgdmFyIHNlcmlhbGl6ZWROYW1lcyA9IHNlcmlhbGl6ZWQubmFtZTtcbiAgICB2YXIgbmV4dCA9IHNlcmlhbGl6ZWQubmV4dDtcblxuICAgIHdoaWxlIChuZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHNlcmlhbGl6ZWROYW1lcyArPSAnICcgKyBuZXh0Lm5hbWU7XG4gICAgICBuZXh0ID0gbmV4dC5uZXh0O1xuICAgIH1cblxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovY3JlYXRlRWxlbWVudChcInN0eWxlXCIsIChfcmVmMiA9IHt9LCBfcmVmMltcImRhdGEtZW1vdGlvblwiXSA9IGNhY2hlLmtleSArIFwiIFwiICsgc2VyaWFsaXplZE5hbWVzLCBfcmVmMi5kYW5nZXJvdXNseVNldElubmVySFRNTCA9IHtcbiAgICAgIF9faHRtbDogcnVsZXNcbiAgICB9LCBfcmVmMi5ub25jZSA9IGNhY2hlLnNoZWV0Lm5vbmNlLCBfcmVmMikpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG52YXIgY3JlYXRlU3R5bGVkID0gZnVuY3Rpb24gY3JlYXRlU3R5bGVkKHRhZywgb3B0aW9ucykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmICh0YWcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgYXJlIHRyeWluZyB0byBjcmVhdGUgYSBzdHlsZWQgZWxlbWVudCB3aXRoIGFuIHVuZGVmaW5lZCBjb21wb25lbnQuXFxuWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBpbXBvcnQgaXQuJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGlzUmVhbCA9IHRhZy5fX2Vtb3Rpb25fcmVhbCA9PT0gdGFnO1xuICB2YXIgYmFzZVRhZyA9IGlzUmVhbCAmJiB0YWcuX19lbW90aW9uX2Jhc2UgfHwgdGFnO1xuICB2YXIgaWRlbnRpZmllck5hbWU7XG4gIHZhciB0YXJnZXRDbGFzc05hbWU7XG5cbiAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgIGlkZW50aWZpZXJOYW1lID0gb3B0aW9ucy5sYWJlbDtcbiAgICB0YXJnZXRDbGFzc05hbWUgPSBvcHRpb25zLnRhcmdldDtcbiAgfVxuXG4gIHZhciBzaG91bGRGb3J3YXJkUHJvcCA9IGNvbXBvc2VTaG91bGRGb3J3YXJkUHJvcHModGFnLCBvcHRpb25zLCBpc1JlYWwpO1xuICB2YXIgZGVmYXVsdFNob3VsZEZvcndhcmRQcm9wID0gc2hvdWxkRm9yd2FyZFByb3AgfHwgZ2V0RGVmYXVsdFNob3VsZEZvcndhcmRQcm9wKGJhc2VUYWcpO1xuICB2YXIgc2hvdWxkVXNlQXMgPSAhZGVmYXVsdFNob3VsZEZvcndhcmRQcm9wKCdhcycpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBzdHlsZXMgPSBpc1JlYWwgJiYgdGFnLl9fZW1vdGlvbl9zdHlsZXMgIT09IHVuZGVmaW5lZCA/IHRhZy5fX2Vtb3Rpb25fc3R5bGVzLnNsaWNlKDApIDogW107XG5cbiAgICBpZiAoaWRlbnRpZmllck5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc3R5bGVzLnB1c2goXCJsYWJlbDpcIiArIGlkZW50aWZpZXJOYW1lICsgXCI7XCIpO1xuICAgIH1cblxuICAgIGlmIChhcmdzWzBdID09IG51bGwgfHwgYXJnc1swXS5yYXcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgc3R5bGVzLnB1c2guYXBwbHkoc3R5bGVzLCBhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgYXJnc1swXVswXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoSUxMRUdBTF9FU0NBUEVfU0VRVUVOQ0VfRVJST1IpO1xuICAgICAgfVxuXG4gICAgICBzdHlsZXMucHVzaChhcmdzWzBdWzBdKTtcbiAgICAgIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgICAgIHZhciBpID0gMTtcblxuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBhcmdzWzBdW2ldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKElMTEVHQUxfRVNDQVBFX1NFUVVFTkNFX0VSUk9SKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0eWxlcy5wdXNoKGFyZ3NbaV0sIGFyZ3NbMF1baV0pO1xuICAgICAgfVxuICAgIH0gLy8gJEZsb3dGaXhNZTogd2UgbmVlZCB0byBjYXN0IFN0YXRlbGVzc0Z1bmN0aW9uYWxDb21wb25lbnQgdG8gb3VyIFByaXZhdGVTdHlsZWRDb21wb25lbnQgY2xhc3NcblxuXG4gICAgdmFyIFN0eWxlZCA9IHdpdGhFbW90aW9uQ2FjaGUoZnVuY3Rpb24gKHByb3BzLCBjYWNoZSwgcmVmKSB7XG4gICAgICB2YXIgRmluYWxUYWcgPSBzaG91bGRVc2VBcyAmJiBwcm9wcy5hcyB8fCBiYXNlVGFnO1xuICAgICAgdmFyIGNsYXNzTmFtZSA9ICcnO1xuICAgICAgdmFyIGNsYXNzSW50ZXJwb2xhdGlvbnMgPSBbXTtcbiAgICAgIHZhciBtZXJnZWRQcm9wcyA9IHByb3BzO1xuXG4gICAgICBpZiAocHJvcHMudGhlbWUgPT0gbnVsbCkge1xuICAgICAgICBtZXJnZWRQcm9wcyA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgICAgIG1lcmdlZFByb3BzW2tleV0gPSBwcm9wc1trZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgbWVyZ2VkUHJvcHMudGhlbWUgPSB1c2VDb250ZXh0KFRoZW1lQ29udGV4dCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgcHJvcHMuY2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICBjbGFzc05hbWUgPSBnZXRSZWdpc3RlcmVkU3R5bGVzKGNhY2hlLnJlZ2lzdGVyZWQsIGNsYXNzSW50ZXJwb2xhdGlvbnMsIHByb3BzLmNsYXNzTmFtZSk7XG4gICAgICB9IGVsc2UgaWYgKHByb3BzLmNsYXNzTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSArIFwiIFwiO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VyaWFsaXplZCA9IHNlcmlhbGl6ZVN0eWxlcyhzdHlsZXMuY29uY2F0KGNsYXNzSW50ZXJwb2xhdGlvbnMpLCBjYWNoZS5yZWdpc3RlcmVkLCBtZXJnZWRQcm9wcyk7XG4gICAgICBjbGFzc05hbWUgKz0gY2FjaGUua2V5ICsgXCItXCIgKyBzZXJpYWxpemVkLm5hbWU7XG5cbiAgICAgIGlmICh0YXJnZXRDbGFzc05hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjbGFzc05hbWUgKz0gXCIgXCIgKyB0YXJnZXRDbGFzc05hbWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBmaW5hbFNob3VsZEZvcndhcmRQcm9wID0gc2hvdWxkVXNlQXMgJiYgc2hvdWxkRm9yd2FyZFByb3AgPT09IHVuZGVmaW5lZCA/IGdldERlZmF1bHRTaG91bGRGb3J3YXJkUHJvcChGaW5hbFRhZykgOiBkZWZhdWx0U2hvdWxkRm9yd2FyZFByb3A7XG4gICAgICB2YXIgbmV3UHJvcHMgPSB7fTtcblxuICAgICAgZm9yICh2YXIgX2tleSBpbiBwcm9wcykge1xuICAgICAgICBpZiAoc2hvdWxkVXNlQXMgJiYgX2tleSA9PT0gJ2FzJykgY29udGludWU7XG5cbiAgICAgICAgaWYgKCAvLyAkRmxvd0ZpeE1lXG4gICAgICAgIGZpbmFsU2hvdWxkRm9yd2FyZFByb3AoX2tleSkpIHtcbiAgICAgICAgICBuZXdQcm9wc1tfa2V5XSA9IHByb3BzW19rZXldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5ld1Byb3BzLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgIG5ld1Byb3BzLnJlZiA9IHJlZjtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qL2NyZWF0ZUVsZW1lbnQoSW5zZXJ0aW9uLCB7XG4gICAgICAgIGNhY2hlOiBjYWNoZSxcbiAgICAgICAgc2VyaWFsaXplZDogc2VyaWFsaXplZCxcbiAgICAgICAgaXNTdHJpbmdUYWc6IHR5cGVvZiBGaW5hbFRhZyA9PT0gJ3N0cmluZydcbiAgICAgIH0pLCAvKiNfX1BVUkVfXyovY3JlYXRlRWxlbWVudChGaW5hbFRhZywgbmV3UHJvcHMpKTtcbiAgICB9KTtcbiAgICBTdHlsZWQuZGlzcGxheU5hbWUgPSBpZGVudGlmaWVyTmFtZSAhPT0gdW5kZWZpbmVkID8gaWRlbnRpZmllck5hbWUgOiBcIlN0eWxlZChcIiArICh0eXBlb2YgYmFzZVRhZyA9PT0gJ3N0cmluZycgPyBiYXNlVGFnIDogYmFzZVRhZy5kaXNwbGF5TmFtZSB8fCBiYXNlVGFnLm5hbWUgfHwgJ0NvbXBvbmVudCcpICsgXCIpXCI7XG4gICAgU3R5bGVkLmRlZmF1bHRQcm9wcyA9IHRhZy5kZWZhdWx0UHJvcHM7XG4gICAgU3R5bGVkLl9fZW1vdGlvbl9yZWFsID0gU3R5bGVkO1xuICAgIFN0eWxlZC5fX2Vtb3Rpb25fYmFzZSA9IGJhc2VUYWc7XG4gICAgU3R5bGVkLl9fZW1vdGlvbl9zdHlsZXMgPSBzdHlsZXM7XG4gICAgU3R5bGVkLl9fZW1vdGlvbl9mb3J3YXJkUHJvcCA9IHNob3VsZEZvcndhcmRQcm9wO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHlsZWQsICd0b1N0cmluZycsIHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgICAgaWYgKHRhcmdldENsYXNzTmFtZSA9PT0gdW5kZWZpbmVkICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gJ05PX0NPTVBPTkVOVF9TRUxFQ1RPUic7XG4gICAgICAgIH0gLy8gJEZsb3dGaXhNZTogY29lcmNlIHVuZGVmaW5lZCB0byBzdHJpbmdcblxuXG4gICAgICAgIHJldHVybiBcIi5cIiArIHRhcmdldENsYXNzTmFtZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIFN0eWxlZC53aXRoQ29tcG9uZW50ID0gZnVuY3Rpb24gKG5leHRUYWcsIG5leHRPcHRpb25zKSB7XG4gICAgICByZXR1cm4gY3JlYXRlU3R5bGVkKG5leHRUYWcsIF9leHRlbmRzKHt9LCBvcHRpb25zLCBuZXh0T3B0aW9ucywge1xuICAgICAgICBzaG91bGRGb3J3YXJkUHJvcDogY29tcG9zZVNob3VsZEZvcndhcmRQcm9wcyhTdHlsZWQsIG5leHRPcHRpb25zLCB0cnVlKVxuICAgICAgfSkpLmFwcGx5KHZvaWQgMCwgc3R5bGVzKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFN0eWxlZDtcbiAgfTtcbn07XG5cbnZhciB0YWdzID0gWydhJywgJ2FiYnInLCAnYWRkcmVzcycsICdhcmVhJywgJ2FydGljbGUnLCAnYXNpZGUnLCAnYXVkaW8nLCAnYicsICdiYXNlJywgJ2JkaScsICdiZG8nLCAnYmlnJywgJ2Jsb2NrcXVvdGUnLCAnYm9keScsICdicicsICdidXR0b24nLCAnY2FudmFzJywgJ2NhcHRpb24nLCAnY2l0ZScsICdjb2RlJywgJ2NvbCcsICdjb2xncm91cCcsICdkYXRhJywgJ2RhdGFsaXN0JywgJ2RkJywgJ2RlbCcsICdkZXRhaWxzJywgJ2RmbicsICdkaWFsb2cnLCAnZGl2JywgJ2RsJywgJ2R0JywgJ2VtJywgJ2VtYmVkJywgJ2ZpZWxkc2V0JywgJ2ZpZ2NhcHRpb24nLCAnZmlndXJlJywgJ2Zvb3RlcicsICdmb3JtJywgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2JywgJ2hlYWQnLCAnaGVhZGVyJywgJ2hncm91cCcsICdocicsICdodG1sJywgJ2knLCAnaWZyYW1lJywgJ2ltZycsICdpbnB1dCcsICdpbnMnLCAna2JkJywgJ2tleWdlbicsICdsYWJlbCcsICdsZWdlbmQnLCAnbGknLCAnbGluaycsICdtYWluJywgJ21hcCcsICdtYXJrJywgJ21hcnF1ZWUnLCAnbWVudScsICdtZW51aXRlbScsICdtZXRhJywgJ21ldGVyJywgJ25hdicsICdub3NjcmlwdCcsICdvYmplY3QnLCAnb2wnLCAnb3B0Z3JvdXAnLCAnb3B0aW9uJywgJ291dHB1dCcsICdwJywgJ3BhcmFtJywgJ3BpY3R1cmUnLCAncHJlJywgJ3Byb2dyZXNzJywgJ3EnLCAncnAnLCAncnQnLCAncnVieScsICdzJywgJ3NhbXAnLCAnc2NyaXB0JywgJ3NlY3Rpb24nLCAnc2VsZWN0JywgJ3NtYWxsJywgJ3NvdXJjZScsICdzcGFuJywgJ3N0cm9uZycsICdzdHlsZScsICdzdWInLCAnc3VtbWFyeScsICdzdXAnLCAndGFibGUnLCAndGJvZHknLCAndGQnLCAndGV4dGFyZWEnLCAndGZvb3QnLCAndGgnLCAndGhlYWQnLCAndGltZScsICd0aXRsZScsICd0cicsICd0cmFjaycsICd1JywgJ3VsJywgJ3ZhcicsICd2aWRlbycsICd3YnInLCAvLyBTVkdcbidjaXJjbGUnLCAnY2xpcFBhdGgnLCAnZGVmcycsICdlbGxpcHNlJywgJ2ZvcmVpZ25PYmplY3QnLCAnZycsICdpbWFnZScsICdsaW5lJywgJ2xpbmVhckdyYWRpZW50JywgJ21hc2snLCAncGF0aCcsICdwYXR0ZXJuJywgJ3BvbHlnb24nLCAncG9seWxpbmUnLCAncmFkaWFsR3JhZGllbnQnLCAncmVjdCcsICdzdG9wJywgJ3N2ZycsICd0ZXh0JywgJ3RzcGFuJ107XG5cbnZhciBuZXdTdHlsZWQgPSBjcmVhdGVTdHlsZWQuYmluZCgpO1xudGFncy5mb3JFYWNoKGZ1bmN0aW9uICh0YWdOYW1lKSB7XG4gIC8vICRGbG93Rml4TWU6IHdlIGNhbiBpZ25vcmUgdGhpcyBiZWNhdXNlIGl0cyBleHBvc2VkIHR5cGUgaXMgZGVmaW5lZCBieSB0aGUgQ3JlYXRlU3R5bGVkIHR5cGVcbiAgbmV3U3R5bGVkW3RhZ05hbWVdID0gbmV3U3R5bGVkKHRhZ05hbWUpO1xufSk7XG5cbnZhciBjbGFzc25hbWVzJDEgPSB7ZXhwb3J0czoge319O1xuXG4vKiFcblx0Q29weXJpZ2h0IChjKSAyMDE4IEplZCBXYXRzb24uXG5cdExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgc2VlXG5cdGh0dHA6Ly9qZWR3YXRzb24uZ2l0aHViLmlvL2NsYXNzbmFtZXNcbiovXG5cbihmdW5jdGlvbiAobW9kdWxlKSB7XG4vKiBnbG9iYWwgZGVmaW5lICovXG5cbihmdW5jdGlvbiAoKSB7XG5cblx0dmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5cdGZ1bmN0aW9uIGNsYXNzTmFtZXMoKSB7XG5cdFx0dmFyIGNsYXNzZXMgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0aWYgKCFhcmcpIGNvbnRpbnVlO1xuXG5cdFx0XHR2YXIgYXJnVHlwZSA9IHR5cGVvZiBhcmc7XG5cblx0XHRcdGlmIChhcmdUeXBlID09PSAnc3RyaW5nJyB8fCBhcmdUeXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRjbGFzc2VzLnB1c2goYXJnKTtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG5cdFx0XHRcdGlmIChhcmcubGVuZ3RoKSB7XG5cdFx0XHRcdFx0dmFyIGlubmVyID0gY2xhc3NOYW1lcy5hcHBseShudWxsLCBhcmcpO1xuXHRcdFx0XHRcdGlmIChpbm5lcikge1xuXHRcdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGlubmVyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoYXJnVHlwZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0aWYgKGFyZy50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyAmJiAhYXJnLnRvU3RyaW5nLnRvU3RyaW5nKCkuaW5jbHVkZXMoJ1tuYXRpdmUgY29kZV0nKSkge1xuXHRcdFx0XHRcdGNsYXNzZXMucHVzaChhcmcudG9TdHJpbmcoKSk7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gYXJnKSB7XG5cdFx0XHRcdFx0aWYgKGhhc093bi5jYWxsKGFyZywga2V5KSAmJiBhcmdba2V5XSkge1xuXHRcdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGtleSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNsYXNzZXMuam9pbignICcpO1xuXHR9XG5cblx0aWYgKG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0Y2xhc3NOYW1lcy5kZWZhdWx0ID0gY2xhc3NOYW1lcztcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGNsYXNzTmFtZXM7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93LmNsYXNzTmFtZXMgPSBjbGFzc05hbWVzO1xuXHR9XG59KCkpO1xufShjbGFzc25hbWVzJDEpKTtcblxudmFyIGNsYXNzbmFtZXMgPSBjbGFzc25hbWVzJDEuZXhwb3J0cztcblxudmFyIExlZ2FjeVNpZGViYXJDb250ZXh0ID0gUmVhY3RfX2RlZmF1bHQuY3JlYXRlQ29udGV4dCh1bmRlZmluZWQpO1xyXG52YXIgU2lkZWJhclByb3ZpZGVyID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbjtcclxuICAgIHZhciBfYiA9IFJlYWN0X19kZWZhdWx0LnVzZVN0YXRlKHtcclxuICAgICAgICBjb2xsYXBzZWQ6IGZhbHNlLFxyXG4gICAgICAgIHRvZ2dsZWQ6IGZhbHNlLFxyXG4gICAgICAgIGJyb2tlbjogZmFsc2UsXHJcbiAgICAgICAgcnRsOiBmYWxzZSxcclxuICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246IDMwMCxcclxuICAgIH0pLCBzaWRlYmFyU3RhdGUgPSBfYlswXSwgc2V0U2lkZWJhclN0YXRlID0gX2JbMV07XHJcbiAgICB2YXIgdXBkYXRlU2lkZWJhclN0YXRlID0gUmVhY3RfX2RlZmF1bHQudXNlQ2FsbGJhY2soZnVuY3Rpb24gKHZhbHVlcykge1xyXG4gICAgICAgIHNldFNpZGViYXJTdGF0ZShmdW5jdGlvbiAocHJldlN0YXRlKSB7IHJldHVybiAoX19hc3NpZ24oX19hc3NpZ24oe30sIHByZXZTdGF0ZSksIHZhbHVlcykpOyB9KTtcclxuICAgIH0sIFtdKTtcclxuICAgIHZhciB1cGRhdGVDb2xsYXBzZVN0YXRlID0gUmVhY3RfX2RlZmF1bHQudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNldFNpZGViYXJTdGF0ZShmdW5jdGlvbiAocHJldlN0YXRlKSB7IHJldHVybiAoX19hc3NpZ24oX19hc3NpZ24oe30sIHByZXZTdGF0ZSksIHsgY29sbGFwc2VkOiAhQm9vbGVhbihwcmV2U3RhdGUgPT09IG51bGwgfHwgcHJldlN0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcmV2U3RhdGUuY29sbGFwc2VkKSB9KSk7IH0pO1xyXG4gICAgfSwgW10pO1xyXG4gICAgdmFyIHVwZGF0ZVRvZ2dsZVN0YXRlID0gUmVhY3RfX2RlZmF1bHQudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNldFNpZGViYXJTdGF0ZShmdW5jdGlvbiAocHJldlN0YXRlKSB7IHJldHVybiAoX19hc3NpZ24oX19hc3NpZ24oe30sIHByZXZTdGF0ZSksIHsgdG9nZ2xlZDogIUJvb2xlYW4ocHJldlN0YXRlID09PSBudWxsIHx8IHByZXZTdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJldlN0YXRlLnRvZ2dsZWQpIH0pKTsgfSk7XHJcbiAgICB9LCBbXSk7XHJcbiAgICB2YXIgcHJvdmlkZXJWYWx1ZSA9IFJlYWN0X19kZWZhdWx0LnVzZU1lbW8oZnVuY3Rpb24gKCkgeyByZXR1cm4gKF9fYXNzaWduKF9fYXNzaWduKHt9LCBzaWRlYmFyU3RhdGUpLCB7IHVwZGF0ZVNpZGViYXJTdGF0ZTogdXBkYXRlU2lkZWJhclN0YXRlLCB1cGRhdGVDb2xsYXBzZVN0YXRlOiB1cGRhdGVDb2xsYXBzZVN0YXRlLCB1cGRhdGVUb2dnbGVTdGF0ZTogdXBkYXRlVG9nZ2xlU3RhdGUgfSkpOyB9LCBbc2lkZWJhclN0YXRlLCB1cGRhdGVDb2xsYXBzZVN0YXRlLCB1cGRhdGVTaWRlYmFyU3RhdGUsIHVwZGF0ZVRvZ2dsZVN0YXRlXSk7XHJcbiAgICByZXR1cm4gKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoTGVnYWN5U2lkZWJhckNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHByb3ZpZGVyVmFsdWUgfSwgY2hpbGRyZW4pKTtcclxufTtcblxudmFyIHVzZUxlZ2FjeVNpZGViYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgY29udGV4dCA9IFJlYWN0X19kZWZhdWx0LnVzZUNvbnRleHQoTGVnYWN5U2lkZWJhckNvbnRleHQpO1xyXG4gICAgcmV0dXJuIGNvbnRleHQ7XHJcbn07XG5cbnZhciB1c2VNZWRpYVF1ZXJ5ID0gZnVuY3Rpb24gKGJyZWFrcG9pbnQpIHtcclxuICAgIHZhciBfYSA9IFJlYWN0X19kZWZhdWx0LnVzZVN0YXRlKCEhYnJlYWtwb2ludCAmJiB3aW5kb3cubWF0Y2hNZWRpYShicmVha3BvaW50KS5tYXRjaGVzKSwgbWF0Y2hlcyA9IF9hWzBdLCBzZXRNYXRjaGVzID0gX2FbMV07XHJcbiAgICBSZWFjdF9fZGVmYXVsdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChicmVha3BvaW50KSB7XHJcbiAgICAgICAgICAgIHZhciBtZWRpYV8xID0gd2luZG93Lm1hdGNoTWVkaWEoYnJlYWtwb2ludCk7XHJcbiAgICAgICAgICAgIHZhciBoYW5kbGVNYXRjaF8xID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1lZGlhXzEubWF0Y2hlcyAhPT0gbWF0Y2hlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldE1hdGNoZXMobWVkaWFfMS5tYXRjaGVzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaGFuZGxlTWF0Y2hfMSgpO1xyXG4gICAgICAgICAgICBtZWRpYV8xLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGhhbmRsZU1hdGNoXzEpO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVkaWFfMS5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBoYW5kbGVNYXRjaF8xKTsgfTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbbWF0Y2hlcywgYnJlYWtwb2ludF0pO1xyXG4gICAgcmV0dXJuIG1hdGNoZXM7XHJcbn07XG5cbnZhciBzaWRlYmFyQ2xhc3NlcyA9IHtcclxuICAgIHJvb3Q6ICdwcy1zaWRlYmFyLXJvb3QnLFxyXG4gICAgY29udGFpbmVyOiAncHMtc2lkZWJhci1jb250YWluZXInLFxyXG4gICAgaW1hZ2U6ICdwcy1zaWRlYmFyLWltYWdlJyxcclxuICAgIGJhY2tkcm9wOiAncHMtc2lkZWJhci1iYWNrZHJvcCcsXHJcbiAgICBjb2xsYXBzZWQ6ICdwcy1jb2xsYXBzZWQnLFxyXG4gICAgdG9nZ2xlZDogJ3BzLXRvZ2dsZWQnLFxyXG4gICAgcnRsOiAncHMtcnRsJyxcclxuICAgIGJyb2tlbjogJ3BzLWJyb2tlbicsXHJcbn07XHJcbnZhciBtZW51Q2xhc3NlcyA9IHtcclxuICAgIHJvb3Q6ICdwcy1tZW51LXJvb3QnLFxyXG4gICAgbWVudUl0ZW1Sb290OiAncHMtbWVudWl0ZW0tcm9vdCcsXHJcbiAgICBzdWJNZW51Um9vdDogJ3BzLXN1Ym1lbnUtcm9vdCcsXHJcbiAgICBidXR0b246ICdwcy1tZW51LWJ1dHRvbicsXHJcbiAgICBwcmVmaXg6ICdwcy1tZW51LXByZWZpeCcsXHJcbiAgICBzdWZmaXg6ICdwcy1tZW51LXN1ZmZpeCcsXHJcbiAgICBsYWJlbDogJ3BzLW1lbnUtbGFiZWwnLFxyXG4gICAgaWNvbjogJ3BzLW1lbnUtaWNvbicsXHJcbiAgICBzdWJNZW51Q29udGVudDogJ3BzLXN1Ym1lbnUtY29udGVudCcsXHJcbiAgICBTdWJNZW51RXhwYW5kSWNvbjogJ3BzLXN1Ym1lbnUtZXhwYW5kLWljb24nLFxyXG4gICAgZGlzYWJsZWQ6ICdwcy1kaXNhYmxlZCcsXHJcbiAgICBhY3RpdmU6ICdwcy1hY3RpdmUnLFxyXG4gICAgb3BlbjogJ3BzLW9wZW4nLFxyXG59O1xuXG52YXIgU3R5bGVkQmFja2Ryb3AgPSBuZXdTdHlsZWQuZGl2KHRlbXBsYXRlT2JqZWN0XzEkYiB8fCAodGVtcGxhdGVPYmplY3RfMSRiID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICB0b3A6IDBweDtcXG4gIHJpZ2h0OiAwcHg7XFxuICBib3R0b206IDBweDtcXG4gIGxlZnQ6IDBweDtcXG4gIHotaW5kZXg6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMCwgMCwgMCwgMC4zKTtcXG5cIl0sIFtcIlxcbiAgcG9zaXRpb246IGZpeGVkO1xcbiAgdG9wOiAwcHg7XFxuICByaWdodDogMHB4O1xcbiAgYm90dG9tOiAwcHg7XFxuICBsZWZ0OiAwcHg7XFxuICB6LWluZGV4OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDAsIDAsIDAsIDAuMyk7XFxuXCJdKSkpO1xyXG52YXIgdGVtcGxhdGVPYmplY3RfMSRiO1xuXG52YXIgQlJFQUtfUE9JTlRTID0ge1xyXG4gICAgeHM6ICc0ODBweCcsXHJcbiAgICBzbTogJzU3NnB4JyxcclxuICAgIG1kOiAnNzY4cHgnLFxyXG4gICAgbGc6ICc5OTJweCcsXHJcbiAgICB4bDogJzEyMDBweCcsXHJcbiAgICB4eGw6ICcxNjAwcHgnLFxyXG4gICAgYWx3YXlzOiAnYWx3YXlzJyxcclxuICAgIGFsbDogJ2FsbCcsXHJcbn07XHJcbnZhciBTdHlsZWRTaWRlYmFyID0gbmV3U3R5bGVkLmFzaWRlKHRlbXBsYXRlT2JqZWN0XzEkYSB8fCAodGVtcGxhdGVPYmplY3RfMSRhID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBib3JkZXItcmlnaHQtd2lkdGg6IDFweDtcXG4gIGJvcmRlci1yaWdodC1zdHlsZTogc29saWQ7XFxuICBib3JkZXItY29sb3I6ICNlZmVmZWY7XFxuXFxuICB0cmFuc2l0aW9uOiBcIiwgXCI7XFxuXFxuICB3aWR0aDogXCIsIFwiO1xcbiAgbWluLXdpZHRoOiBcIiwgXCI7XFxuXFxuICAmLlwiLCBcIiB7XFxuICAgIHdpZHRoOiBcIiwgXCI7XFxuICAgIG1pbi13aWR0aDogXCIsIFwiO1xcbiAgfVxcblxcbiAgJi5cIiwgXCIge1xcbiAgICBkaXJlY3Rpb246IHJ0bDtcXG4gICAgYm9yZGVyLXJpZ2h0LXdpZHRoOiBub25lO1xcbiAgICBib3JkZXItbGVmdC13aWR0aDogMXB4O1xcbiAgICBib3JkZXItcmlnaHQtc3R5bGU6IG5vbmU7XFxuICAgIGJvcmRlci1sZWZ0LXN0eWxlOiBzb2xpZDtcXG4gIH1cXG5cXG4gICYuXCIsIFwiIHtcXG4gICAgcG9zaXRpb246IGZpeGVkO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIHRvcDogMHB4O1xcbiAgICB6LWluZGV4OiAxMDA7XFxuXFxuICAgIFwiLCBcIlxcblxcbiAgICAmLlwiLCBcIiB7XFxuICAgICAgXCIsIFwiXFxuICAgIH1cXG5cXG4gICAgJi5cIiwgXCIge1xcbiAgICAgIFwiLCBcIlxcbiAgICB9XFxuXFxuICAgICYuXCIsIFwiIHtcXG4gICAgICByaWdodDogLVwiLCBcIjtcXG5cXG4gICAgICAmLlwiLCBcIiB7XFxuICAgICAgICByaWdodDogLVwiLCBcIjtcXG4gICAgICB9XFxuXFxuICAgICAgJi5cIiwgXCIge1xcbiAgICAgICAgcmlnaHQ6IDA7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICBcIiwgXCJcXG5cIl0sIFtcIlxcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgYm9yZGVyLXJpZ2h0LXdpZHRoOiAxcHg7XFxuICBib3JkZXItcmlnaHQtc3R5bGU6IHNvbGlkO1xcbiAgYm9yZGVyLWNvbG9yOiAjZWZlZmVmO1xcblxcbiAgdHJhbnNpdGlvbjogXCIsIFwiO1xcblxcbiAgd2lkdGg6IFwiLCBcIjtcXG4gIG1pbi13aWR0aDogXCIsIFwiO1xcblxcbiAgJi5cIiwgXCIge1xcbiAgICB3aWR0aDogXCIsIFwiO1xcbiAgICBtaW4td2lkdGg6IFwiLCBcIjtcXG4gIH1cXG5cXG4gICYuXCIsIFwiIHtcXG4gICAgZGlyZWN0aW9uOiBydGw7XFxuICAgIGJvcmRlci1yaWdodC13aWR0aDogbm9uZTtcXG4gICAgYm9yZGVyLWxlZnQtd2lkdGg6IDFweDtcXG4gICAgYm9yZGVyLXJpZ2h0LXN0eWxlOiBub25lO1xcbiAgICBib3JkZXItbGVmdC1zdHlsZTogc29saWQ7XFxuICB9XFxuXFxuICAmLlwiLCBcIiB7XFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICB0b3A6IDBweDtcXG4gICAgei1pbmRleDogMTAwO1xcblxcbiAgICBcIiwgXCJcXG5cXG4gICAgJi5cIiwgXCIge1xcbiAgICAgIFwiLCBcIlxcbiAgICB9XFxuXFxuICAgICYuXCIsIFwiIHtcXG4gICAgICBcIiwgXCJcXG4gICAgfVxcblxcbiAgICAmLlwiLCBcIiB7XFxuICAgICAgcmlnaHQ6IC1cIiwgXCI7XFxuXFxuICAgICAgJi5cIiwgXCIge1xcbiAgICAgICAgcmlnaHQ6IC1cIiwgXCI7XFxuICAgICAgfVxcblxcbiAgICAgICYuXCIsIFwiIHtcXG4gICAgICAgIHJpZ2h0OiAwO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgXCIsIFwiXFxuXCJdKSksIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IF9hLnRyYW5zaXRpb25EdXJhdGlvbjtcclxuICAgIHJldHVybiBcIndpZHRoLCBsZWZ0LCByaWdodCwgXCIuY29uY2F0KHRyYW5zaXRpb25EdXJhdGlvbiwgXCJtc1wiKTtcclxufSwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgd2lkdGggPSBfYS53aWR0aDtcclxuICAgIHJldHVybiB3aWR0aDtcclxufSwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgd2lkdGggPSBfYS53aWR0aDtcclxuICAgIHJldHVybiB3aWR0aDtcclxufSwgc2lkZWJhckNsYXNzZXMuY29sbGFwc2VkLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciBjb2xsYXBzZWRXaWR0aCA9IF9hLmNvbGxhcHNlZFdpZHRoO1xyXG4gICAgcmV0dXJuIGNvbGxhcHNlZFdpZHRoO1xyXG59LCBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciBjb2xsYXBzZWRXaWR0aCA9IF9hLmNvbGxhcHNlZFdpZHRoO1xyXG4gICAgcmV0dXJuIGNvbGxhcHNlZFdpZHRoO1xyXG59LCBzaWRlYmFyQ2xhc3Nlcy5ydGwsIHNpZGViYXJDbGFzc2VzLmJyb2tlbiwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgcnRsID0gX2EucnRsLCB3aWR0aCA9IF9hLndpZHRoO1xyXG4gICAgcmV0dXJuICghcnRsID8gXCJsZWZ0OiAtXCIuY29uY2F0KHdpZHRoLCBcIjtcIikgOiAnJyk7XHJcbn0sIHNpZGViYXJDbGFzc2VzLmNvbGxhcHNlZCwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgcnRsID0gX2EucnRsLCBjb2xsYXBzZWRXaWR0aCA9IF9hLmNvbGxhcHNlZFdpZHRoO1xyXG4gICAgcmV0dXJuICghcnRsID8gXCJsZWZ0OiAtXCIuY29uY2F0KGNvbGxhcHNlZFdpZHRoLCBcIjsgXCIpIDogJycpO1xyXG59LCBzaWRlYmFyQ2xhc3Nlcy50b2dnbGVkLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciBydGwgPSBfYS5ydGw7XHJcbiAgICByZXR1cm4gKCFydGwgPyBcImxlZnQ6IDA7XCIgOiAnJyk7XHJcbn0sIHNpZGViYXJDbGFzc2VzLnJ0bCwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgd2lkdGggPSBfYS53aWR0aDtcclxuICAgIHJldHVybiB3aWR0aDtcclxufSwgc2lkZWJhckNsYXNzZXMuY29sbGFwc2VkLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciBjb2xsYXBzZWRXaWR0aCA9IF9hLmNvbGxhcHNlZFdpZHRoO1xyXG4gICAgcmV0dXJuIGNvbGxhcHNlZFdpZHRoO1xyXG59LCBzaWRlYmFyQ2xhc3Nlcy50b2dnbGVkLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciByb290U3R5bGVzID0gX2Eucm9vdFN0eWxlcztcclxuICAgIHJldHVybiByb290U3R5bGVzO1xyXG59KTtcclxudmFyIFN0eWxlZFNpZGViYXJDb250YWluZXIgPSBuZXdTdHlsZWQuZGl2KHRlbXBsYXRlT2JqZWN0XzIkMSB8fCAodGVtcGxhdGVPYmplY3RfMiQxID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBvdmVyZmxvdy15OiBhdXRvO1xcbiAgb3ZlcmZsb3cteDogaGlkZGVuO1xcbiAgei1pbmRleDogMztcXG5cXG4gIFwiLCBcIlxcblwiXSwgW1wiXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBvdmVyZmxvdy15OiBhdXRvO1xcbiAgb3ZlcmZsb3cteDogaGlkZGVuO1xcbiAgei1pbmRleDogMztcXG5cXG4gIFwiLCBcIlxcblwiXSkpLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciBiYWNrZ3JvdW5kQ29sb3IgPSBfYS5iYWNrZ3JvdW5kQ29sb3I7XHJcbiAgICByZXR1cm4gKGJhY2tncm91bmRDb2xvciA/IFwiYmFja2dyb3VuZC1jb2xvcjpcIi5jb25jYXQoYmFja2dyb3VuZENvbG9yLCBcIjtcIikgOiAnJyk7XHJcbn0pO1xyXG52YXIgU3R5bGVkU2lkZWJhckltYWdlID0gbmV3U3R5bGVkLmltZyh0ZW1wbGF0ZU9iamVjdF8zJDEgfHwgKHRlbXBsYXRlT2JqZWN0XzMkMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgJi5cIiwgXCIge1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICBvYmplY3QtZml0OiBjb3ZlcjtcXG4gICAgb2JqZWN0LXBvc2l0aW9uOiBjZW50ZXI7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgbGVmdDogMDtcXG4gICAgdG9wOiAwO1xcbiAgICB6LWluZGV4OiAyO1xcbiAgfVxcblwiXSwgW1wiXFxuICAmLlwiLCBcIiB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIG9iamVjdC1maXQ6IGNvdmVyO1xcbiAgICBvYmplY3QtcG9zaXRpb246IGNlbnRlcjtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBsZWZ0OiAwO1xcbiAgICB0b3A6IDA7XFxuICAgIHotaW5kZXg6IDI7XFxuICB9XFxuXCJdKSksIHNpZGViYXJDbGFzc2VzLmltYWdlKTtcclxudmFyIFNpZGViYXJDb250ZXh0ID0gUmVhY3RfX2RlZmF1bHQuY3JlYXRlQ29udGV4dCh7XHJcbiAgICBjb2xsYXBzZWQ6IGZhbHNlLFxyXG4gICAgdG9nZ2xlZDogZmFsc2UsXHJcbiAgICBydGw6IGZhbHNlLFxyXG4gICAgdHJhbnNpdGlvbkR1cmF0aW9uOiAzMDAsXHJcbn0pO1xyXG52YXIgU2lkZWJhciA9IFJlYWN0X19kZWZhdWx0LmZvcndhcmRSZWYoZnVuY3Rpb24gKF9hLCByZWYpIHtcclxuICAgIHZhciBfYjtcclxuICAgIHZhciBjb2xsYXBzZWQgPSBfYS5jb2xsYXBzZWQsIHRvZ2dsZWQgPSBfYS50b2dnbGVkLCBvbkJhY2tkcm9wQ2xpY2sgPSBfYS5vbkJhY2tkcm9wQ2xpY2ssIG9uQnJlYWtQb2ludCA9IF9hLm9uQnJlYWtQb2ludCwgX2MgPSBfYS53aWR0aCwgd2lkdGggPSBfYyA9PT0gdm9pZCAwID8gJzI1MHB4JyA6IF9jLCBfZCA9IF9hLmNvbGxhcHNlZFdpZHRoLCBjb2xsYXBzZWRXaWR0aCA9IF9kID09PSB2b2lkIDAgPyAnODBweCcgOiBfZCwgZGVmYXVsdENvbGxhcHNlZCA9IF9hLmRlZmF1bHRDb2xsYXBzZWQsIGNsYXNzTmFtZSA9IF9hLmNsYXNzTmFtZSwgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgYnJlYWtQb2ludCA9IF9hLmJyZWFrUG9pbnQsIGN1c3RvbUJyZWFrUG9pbnQgPSBfYS5jdXN0b21CcmVha1BvaW50LCBfZSA9IF9hLmJhY2tncm91bmRDb2xvciwgYmFja2dyb3VuZENvbG9yID0gX2UgPT09IHZvaWQgMCA/ICdyZ2IoMjQ5LCAyNDksIDI0OSwgMC43KScgOiBfZSwgX2YgPSBfYS50cmFuc2l0aW9uRHVyYXRpb24sIHRyYW5zaXRpb25EdXJhdGlvbiA9IF9mID09PSB2b2lkIDAgPyAzMDAgOiBfZiwgaW1hZ2UgPSBfYS5pbWFnZSwgcnRsID0gX2EucnRsLCByb290U3R5bGVzID0gX2Eucm9vdFN0eWxlcywgcmVzdCA9IF9fcmVzdChfYSwgW1wiY29sbGFwc2VkXCIsIFwidG9nZ2xlZFwiLCBcIm9uQmFja2Ryb3BDbGlja1wiLCBcIm9uQnJlYWtQb2ludFwiLCBcIndpZHRoXCIsIFwiY29sbGFwc2VkV2lkdGhcIiwgXCJkZWZhdWx0Q29sbGFwc2VkXCIsIFwiY2xhc3NOYW1lXCIsIFwiY2hpbGRyZW5cIiwgXCJicmVha1BvaW50XCIsIFwiY3VzdG9tQnJlYWtQb2ludFwiLCBcImJhY2tncm91bmRDb2xvclwiLCBcInRyYW5zaXRpb25EdXJhdGlvblwiLCBcImltYWdlXCIsIFwicnRsXCIsIFwicm9vdFN0eWxlc1wiXSk7XHJcbiAgICB2YXIgZ2V0QnJlYWtwb2ludFZhbHVlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChjdXN0b21CcmVha1BvaW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcIihtYXgtd2lkdGg6IFwiLmNvbmNhdChjdXN0b21CcmVha1BvaW50LCBcIilcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChicmVha1BvaW50KSB7XHJcbiAgICAgICAgICAgIGlmIChbJ3hzJywgJ3NtJywgJ21kJywgJ2xnJywgJ3hsJywgJ3h4bCddLmluY2x1ZGVzKGJyZWFrUG9pbnQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCIobWF4LXdpZHRoOiBcIi5jb25jYXQoQlJFQUtfUE9JTlRTW2JyZWFrUG9pbnRdLCBcIilcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGJyZWFrUG9pbnQgPT09ICdhbHdheXMnIHx8IGJyZWFrUG9pbnQgPT09ICdhbGwnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYnJlYWtQb2ludCA9PT0gJ2Fsd2F5cycpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSBcImFsd2F5c1wiIGJyZWFrUG9pbnQgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGZ1dHVyZSByZWxlYXNlLiAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ1BsZWFzZSB1c2UgdGhlIFwiYWxsXCIgYnJlYWtQb2ludCBpbnN0ZWFkLicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwic2NyZWVuXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFwiKG1heC13aWR0aDogXCIuY29uY2F0KGJyZWFrUG9pbnQsIFwiKVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdmFyIGJyZWFrcG9pbnRDYWxsYmFja0ZuUmVmID0gUmVhY3RfX2RlZmF1bHQudXNlUmVmKCk7XHJcbiAgICBicmVha3BvaW50Q2FsbGJhY2tGblJlZi5jdXJyZW50ID0gZnVuY3Rpb24gKGJyb2tlbikge1xyXG4gICAgICAgIG9uQnJlYWtQb2ludCA9PT0gbnVsbCB8fCBvbkJyZWFrUG9pbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uQnJlYWtQb2ludChicm9rZW4pO1xyXG4gICAgfTtcclxuICAgIHZhciBicm9rZW4gPSB1c2VNZWRpYVF1ZXJ5KGdldEJyZWFrcG9pbnRWYWx1ZSgpKTtcclxuICAgIHZhciBfZyA9IFJlYWN0X19kZWZhdWx0LnVzZVN0YXRlKGZhbHNlKSwgbW91bnRlZCA9IF9nWzBdLCBzZXRNb3VudGVkID0gX2dbMV07XHJcbiAgICB2YXIgbGVnYWN5U2lkZWJhckNvbnRleHQgPSB1c2VMZWdhY3lTaWRlYmFyKCk7XHJcbiAgICB2YXIgY29sbGFwc2VkVmFsdWUgPSBjb2xsYXBzZWQgIT09IG51bGwgJiYgY29sbGFwc2VkICE9PSB2b2lkIDAgPyBjb2xsYXBzZWQgOiAoIW1vdW50ZWQgJiYgZGVmYXVsdENvbGxhcHNlZCA/IHRydWUgOiBsZWdhY3lTaWRlYmFyQ29udGV4dCA9PT0gbnVsbCB8fCBsZWdhY3lTaWRlYmFyQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGVnYWN5U2lkZWJhckNvbnRleHQuY29sbGFwc2VkKTtcclxuICAgIHZhciB0b2dnbGVkVmFsdWUgPSB0b2dnbGVkICE9PSBudWxsICYmIHRvZ2dsZWQgIT09IHZvaWQgMCA/IHRvZ2dsZWQgOiBsZWdhY3lTaWRlYmFyQ29udGV4dCA9PT0gbnVsbCB8fCBsZWdhY3lTaWRlYmFyQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGVnYWN5U2lkZWJhckNvbnRleHQudG9nZ2xlZDtcclxuICAgIHZhciBoYW5kbGVCYWNrZHJvcENsaWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIG9uQmFja2Ryb3BDbGljayA9PT0gbnVsbCB8fCBvbkJhY2tkcm9wQ2xpY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uQmFja2Ryb3BDbGljaygpO1xyXG4gICAgICAgIGxlZ2FjeVNpZGViYXJDb250ZXh0ID09PSBudWxsIHx8IGxlZ2FjeVNpZGViYXJDb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsZWdhY3lTaWRlYmFyQ29udGV4dC51cGRhdGVTaWRlYmFyU3RhdGUoeyB0b2dnbGVkOiBmYWxzZSB9KTtcclxuICAgIH07XHJcbiAgICBSZWFjdF9fZGVmYXVsdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICAoX2EgPSBicmVha3BvaW50Q2FsbGJhY2tGblJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChicmVha3BvaW50Q2FsbGJhY2tGblJlZiwgYnJva2VuKTtcclxuICAgIH0sIFticm9rZW5dKTtcclxuICAgIC8vIFRPRE86IHJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb25cclxuICAgIFJlYWN0X19kZWZhdWx0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgbGVnYWN5U2lkZWJhckNvbnRleHQgPT09IG51bGwgfHwgbGVnYWN5U2lkZWJhckNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxlZ2FjeVNpZGViYXJDb250ZXh0LnVwZGF0ZVNpZGViYXJTdGF0ZSh7IGJyb2tlbjogYnJva2VuLCBydGw6IHJ0bCwgdHJhbnNpdGlvbkR1cmF0aW9uOiB0cmFuc2l0aW9uRHVyYXRpb24gfSk7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xyXG4gICAgfSwgW2Jyb2tlbiwgbGVnYWN5U2lkZWJhckNvbnRleHQgPT09IG51bGwgfHwgbGVnYWN5U2lkZWJhckNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxlZ2FjeVNpZGViYXJDb250ZXh0LnVwZGF0ZVNpZGViYXJTdGF0ZSwgcnRsLCB0cmFuc2l0aW9uRHVyYXRpb25dKTtcclxuICAgIC8vIFRPRE86IHJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb25cclxuICAgIFJlYWN0X19kZWZhdWx0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCFtb3VudGVkKSB7XHJcbiAgICAgICAgICAgIGxlZ2FjeVNpZGViYXJDb250ZXh0ID09PSBudWxsIHx8IGxlZ2FjeVNpZGViYXJDb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsZWdhY3lTaWRlYmFyQ29udGV4dC51cGRhdGVTaWRlYmFyU3RhdGUoe1xyXG4gICAgICAgICAgICAgICAgY29sbGFwc2VkOiBkZWZhdWx0Q29sbGFwc2VkLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc2V0TW91bnRlZCh0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xyXG4gICAgfSwgW2RlZmF1bHRDb2xsYXBzZWQsIG1vdW50ZWQsIGxlZ2FjeVNpZGViYXJDb250ZXh0ID09PSBudWxsIHx8IGxlZ2FjeVNpZGViYXJDb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsZWdhY3lTaWRlYmFyQ29udGV4dC51cGRhdGVTaWRlYmFyU3RhdGVdKTtcclxuICAgIHJldHVybiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChTaWRlYmFyQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogeyBjb2xsYXBzZWQ6IGNvbGxhcHNlZFZhbHVlLCB0b2dnbGVkOiB0b2dnbGVkVmFsdWUsIHJ0bDogcnRsLCB0cmFuc2l0aW9uRHVyYXRpb246IHRyYW5zaXRpb25EdXJhdGlvbiB9IH0sXHJcbiAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChTdHlsZWRTaWRlYmFyLCBfX2Fzc2lnbih7IHJlZjogcmVmLCBcImRhdGEtdGVzdGlkXCI6IFwiXCIuY29uY2F0KHNpZGViYXJDbGFzc2VzLnJvb3QsIFwiLXRlc3QtaWRcIiksIHJ0bDogcnRsLCByb290U3R5bGVzOiByb290U3R5bGVzLCB3aWR0aDogd2lkdGgsIGNvbGxhcHNlZFdpZHRoOiBjb2xsYXBzZWRXaWR0aCwgdHJhbnNpdGlvbkR1cmF0aW9uOiB0cmFuc2l0aW9uRHVyYXRpb24sIGNsYXNzTmFtZTogY2xhc3NuYW1lcyhzaWRlYmFyQ2xhc3Nlcy5yb290LCAoX2IgPSB7fSxcclxuICAgICAgICAgICAgICAgIF9iW3NpZGViYXJDbGFzc2VzLmNvbGxhcHNlZF0gPSBjb2xsYXBzZWRWYWx1ZSxcclxuICAgICAgICAgICAgICAgIF9iW3NpZGViYXJDbGFzc2VzLnRvZ2dsZWRdID0gdG9nZ2xlZFZhbHVlLFxyXG4gICAgICAgICAgICAgICAgX2Jbc2lkZWJhckNsYXNzZXMuYnJva2VuXSA9IGJyb2tlbixcclxuICAgICAgICAgICAgICAgIF9iW3NpZGViYXJDbGFzc2VzLnJ0bF0gPSBydGwsXHJcbiAgICAgICAgICAgICAgICBfYiksIGNsYXNzTmFtZSkgfSwgcmVzdCksXHJcbiAgICAgICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU3R5bGVkU2lkZWJhckNvbnRhaW5lciwgeyBcImRhdGEtdGVzdGlkXCI6IFwiXCIuY29uY2F0KHNpZGViYXJDbGFzc2VzLmNvbnRhaW5lciwgXCItdGVzdC1pZFwiKSwgY2xhc3NOYW1lOiBzaWRlYmFyQ2xhc3Nlcy5jb250YWluZXIsIGJhY2tncm91bmRDb2xvcjogYmFja2dyb3VuZENvbG9yIH0sIGNoaWxkcmVuKSxcclxuICAgICAgICAgICAgaW1hZ2UgJiYgKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU3R5bGVkU2lkZWJhckltYWdlLCB7IFwiZGF0YS10ZXN0aWRcIjogXCJcIi5jb25jYXQoc2lkZWJhckNsYXNzZXMuaW1hZ2UsIFwiLXRlc3QtaWRcIiksIHNyYzogaW1hZ2UsIGFsdDogXCJzaWRlYmFyIGJhY2tncm91bmRcIiwgY2xhc3NOYW1lOiBzaWRlYmFyQ2xhc3Nlcy5pbWFnZSB9KSksXHJcbiAgICAgICAgICAgIGJyb2tlbiAmJiB0b2dnbGVkVmFsdWUgJiYgKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU3R5bGVkQmFja2Ryb3AsIHsgXCJkYXRhLXRlc3RpZFwiOiBcIlwiLmNvbmNhdChzaWRlYmFyQ2xhc3Nlcy5iYWNrZHJvcCwgXCItdGVzdC1pZFwiKSwgcm9sZTogXCJidXR0b25cIiwgdGFiSW5kZXg6IDAsIFwiYXJpYS1sYWJlbFwiOiBcImJhY2tkcm9wXCIsIG9uQ2xpY2s6IGhhbmRsZUJhY2tkcm9wQ2xpY2ssIG9uS2V5UHJlc3M6IGhhbmRsZUJhY2tkcm9wQ2xpY2ssIGNsYXNzTmFtZTogc2lkZWJhckNsYXNzZXMuYmFja2Ryb3AgfSkpKSkpO1xyXG59KTtcclxudmFyIHRlbXBsYXRlT2JqZWN0XzEkYSwgdGVtcGxhdGVPYmplY3RfMiQxLCB0ZW1wbGF0ZU9iamVjdF8zJDE7XG5cbnZhciBTdHlsZWRVbCA9IG5ld1N0eWxlZC51bCh0ZW1wbGF0ZU9iamVjdF8xJDkgfHwgKHRlbXBsYXRlT2JqZWN0XzEkOSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgbGlzdC1zdHlsZS10eXBlOiBub25lO1xcbiAgcGFkZGluZzogMDtcXG4gIG1hcmdpbjogMDtcXG5cIl0sIFtcIlxcbiAgbGlzdC1zdHlsZS10eXBlOiBub25lO1xcbiAgcGFkZGluZzogMDtcXG4gIG1hcmdpbjogMDtcXG5cIl0pKSk7XHJcbnZhciB0ZW1wbGF0ZU9iamVjdF8xJDk7XG5cbnZhciBTdHlsZWRNZW51ID0gbmV3U3R5bGVkLm5hdih0ZW1wbGF0ZU9iamVjdF8xJDggfHwgKHRlbXBsYXRlT2JqZWN0XzEkOCA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgJi5cIiwgXCIge1xcbiAgICBcIiwgXCJcXG4gIH1cXG5cIl0sIFtcIlxcbiAgJi5cIiwgXCIge1xcbiAgICBcIiwgXCJcXG4gIH1cXG5cIl0pKSwgbWVudUNsYXNzZXMucm9vdCwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgcm9vdFN0eWxlcyA9IF9hLnJvb3RTdHlsZXM7XHJcbiAgICByZXR1cm4gcm9vdFN0eWxlcztcclxufSk7XHJcbnZhciBNZW51Q29udGV4dCA9IFJlYWN0X19kZWZhdWx0LmNyZWF0ZUNvbnRleHQodW5kZWZpbmVkKTtcclxudmFyIExldmVsQ29udGV4dCA9IFJlYWN0X19kZWZhdWx0LmNyZWF0ZUNvbnRleHQoMCk7XHJcbnZhciBNZW51RlIgPSBmdW5jdGlvbiAoX2EsIHJlZikge1xyXG4gICAgdmFyIGNoaWxkcmVuID0gX2EuY2hpbGRyZW4sIGNsYXNzTmFtZSA9IF9hLmNsYXNzTmFtZSwgX2IgPSBfYS50cmFuc2l0aW9uRHVyYXRpb24sIHRyYW5zaXRpb25EdXJhdGlvbiA9IF9iID09PSB2b2lkIDAgPyAzMDAgOiBfYiwgX2MgPSBfYS5jbG9zZU9uQ2xpY2ssIGNsb3NlT25DbGljayA9IF9jID09PSB2b2lkIDAgPyBmYWxzZSA6IF9jLCByb290U3R5bGVzID0gX2Eucm9vdFN0eWxlcywgbWVudUl0ZW1TdHlsZXMgPSBfYS5tZW51SXRlbVN0eWxlcywgcmVuZGVyRXhwYW5kSWNvbiA9IF9hLnJlbmRlckV4cGFuZEljb24sIHJlc3QgPSBfX3Jlc3QoX2EsIFtcImNoaWxkcmVuXCIsIFwiY2xhc3NOYW1lXCIsIFwidHJhbnNpdGlvbkR1cmF0aW9uXCIsIFwiY2xvc2VPbkNsaWNrXCIsIFwicm9vdFN0eWxlc1wiLCBcIm1lbnVJdGVtU3R5bGVzXCIsIFwicmVuZGVyRXhwYW5kSWNvblwiXSk7XHJcbiAgICB2YXIgcHJvdmlkZXJWYWx1ZSA9IFJlYWN0X19kZWZhdWx0LnVzZU1lbW8oZnVuY3Rpb24gKCkgeyByZXR1cm4gKHsgdHJhbnNpdGlvbkR1cmF0aW9uOiB0cmFuc2l0aW9uRHVyYXRpb24sIGNsb3NlT25DbGljazogY2xvc2VPbkNsaWNrLCBtZW51SXRlbVN0eWxlczogbWVudUl0ZW1TdHlsZXMsIHJlbmRlckV4cGFuZEljb246IHJlbmRlckV4cGFuZEljb24gfSk7IH0sIFt0cmFuc2l0aW9uRHVyYXRpb24sIGNsb3NlT25DbGljaywgbWVudUl0ZW1TdHlsZXMsIHJlbmRlckV4cGFuZEljb25dKTtcclxuICAgIHJldHVybiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChNZW51Q29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogcHJvdmlkZXJWYWx1ZSB9LFxyXG4gICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoTGV2ZWxDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiAwIH0sXHJcbiAgICAgICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU3R5bGVkTWVudSwgX19hc3NpZ24oeyByZWY6IHJlZiwgY2xhc3NOYW1lOiBjbGFzc25hbWVzKG1lbnVDbGFzc2VzLnJvb3QsIGNsYXNzTmFtZSksIHJvb3RTdHlsZXM6IHJvb3RTdHlsZXMgfSwgcmVzdCksXHJcbiAgICAgICAgICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFN0eWxlZFVsLCBudWxsLCBjaGlsZHJlbikpKSkpO1xyXG59O1xyXG52YXIgTWVudSA9IFJlYWN0X19kZWZhdWx0LmZvcndhcmRSZWYoTWVudUZSKTtcclxudmFyIHRlbXBsYXRlT2JqZWN0XzEkODtcblxudmFyIHVzZU1lbnUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgY29udGV4dCA9IFJlYWN0X19kZWZhdWx0LnVzZUNvbnRleHQoTWVudUNvbnRleHQpO1xyXG4gICAgaWYgKGNvbnRleHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIC8vVE9ETzogc2V0IGJldHRlciBlcnJvciBtZXNzYWdlXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZW51IENvbXBvbmVudCBpcyByZXF1aXJlZCEnKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjb250ZXh0O1xyXG59O1xuXG52YXIgU3R5bGVkU3ViTWVudUNvbnRlbnQgPSBuZXdTdHlsZWQuZGl2KHRlbXBsYXRlT2JqZWN0XzEkNyB8fCAodGVtcGxhdGVPYmplY3RfMSQ3ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICBkaXNwbGF5OiBub25lO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIHotaW5kZXg6IDk5OTtcXG4gIHRyYW5zaXRpb246IGhlaWdodCBcIiwgXCJtcztcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXG5cXG4gIFwiLCBcIlxcblxcbiAgXCIsIFwiXFxuXFxuICBcIiwgXCI7XFxuXFxuICBcIiwgXCI7XFxuXCJdLCBbXCJcXG4gIGRpc3BsYXk6IG5vbmU7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgei1pbmRleDogOTk5O1xcbiAgdHJhbnNpdGlvbjogaGVpZ2h0IFwiLCBcIm1zO1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcblxcbiAgXCIsIFwiXFxuXFxuICBcIiwgXCJcXG5cXG4gIFwiLCBcIjtcXG5cXG4gIFwiLCBcIjtcXG5cIl0pKSwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9uID0gX2EudHJhbnNpdGlvbkR1cmF0aW9uO1xyXG4gICAgcmV0dXJuIHRyYW5zaXRpb25EdXJhdGlvbjtcclxufSwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgZmlyc3RMZXZlbCA9IF9hLmZpcnN0TGV2ZWwsIGNvbGxhcHNlZCA9IF9hLmNvbGxhcHNlZDtcclxuICAgIHJldHVybiBmaXJzdExldmVsICYmXHJcbiAgICAgICAgY29sbGFwc2VkICYmXHJcbiAgICAgICAgXCJcXG4gICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcbiAgICAgYm94LXNoYWRvdzogMCAzcHggNnB4IC00cHggIzAwMDAwMDFmLCAwIDZweCAxNnB4ICMwMDAwMDAxNCwgMCA5cHggMjhweCA4cHggIzAwMDAwMDBkO1xcbiAgICAgXCI7XHJcbn0sIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIGRlZmF1bHRPcGVuID0gX2EuZGVmYXVsdE9wZW47XHJcbiAgICByZXR1cm4gZGVmYXVsdE9wZW4gJiYgJ2hlaWdodDogYXV0bztkaXNwbGF5OiBibG9jazsnO1xyXG59LCBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciBjb2xsYXBzZWQgPSBfYS5jb2xsYXBzZWQsIGZpcnN0TGV2ZWwgPSBfYS5maXJzdExldmVsLCBvcGVuV2hlbkNvbGxhcHNlZCA9IF9hLm9wZW5XaGVuQ29sbGFwc2VkO1xyXG4gICAgcmV0dXJuIGNvbGxhcHNlZCAmJiBmaXJzdExldmVsXHJcbiAgICAgICAgPyBcIlxcbiAgICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgICBwYWRkaW5nLWxlZnQ6IDBweDtcXG4gICAgICB3aWR0aDogMjAwcHg7XFxuICAgICAgYm9yZGVyLXJhZGl1czogNHB4O1xcbiAgICAgIGhlaWdodDogYXV0byFpbXBvcnRhbnQ7XFxuICAgICAgZGlzcGxheTogYmxvY2shaW1wb3J0YW50OyAgICAgXFxuICAgICAgdHJhbnNpdGlvbjogbm9uZSFpbXBvcnRhbnQ7ICAgICBcXG4gICAgICB2aXNpYmlsaXR5OiBcIi5jb25jYXQob3BlbldoZW5Db2xsYXBzZWQgPyAndmlzaWJsZScgOiAnaGlkZGVuJywgXCI7XFxuICAgICBcIilcclxuICAgICAgICA6IFwiXFxuICAgICAgcG9zaXRpb246IHN0YXRpYyFpbXBvcnRhbnQ7XFxuICAgICAgdHJhbnNmb3JtOiBub25lIWltcG9ydGFudDtcXG4gICAgICBcIjtcclxufSwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgcm9vdFN0eWxlcyA9IF9hLnJvb3RTdHlsZXM7XHJcbiAgICByZXR1cm4gcm9vdFN0eWxlcztcclxufSk7XHJcbnZhciBTdWJNZW51Q29udGVudEZSID0gZnVuY3Rpb24gKF9hLCByZWYpIHtcclxuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBvcGVuID0gX2Eub3Blbiwgb3BlbldoZW5Db2xsYXBzZWQgPSBfYS5vcGVuV2hlbkNvbGxhcHNlZCwgZmlyc3RMZXZlbCA9IF9hLmZpcnN0TGV2ZWwsIGNvbGxhcHNlZCA9IF9hLmNvbGxhcHNlZCwgZGVmYXVsdE9wZW4gPSBfYS5kZWZhdWx0T3BlbiwgcmVzdCA9IF9fcmVzdChfYSwgW1wiY2hpbGRyZW5cIiwgXCJvcGVuXCIsIFwib3BlbldoZW5Db2xsYXBzZWRcIiwgXCJmaXJzdExldmVsXCIsIFwiY29sbGFwc2VkXCIsIFwiZGVmYXVsdE9wZW5cIl0pO1xyXG4gICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IHVzZU1lbnUoKS50cmFuc2l0aW9uRHVyYXRpb247XHJcbiAgICB2YXIgZGVmYXVsdE9wZW5TdGF0ZSA9IFJlYWN0X19kZWZhdWx0LnVzZVN0YXRlKGRlZmF1bHRPcGVuKVswXTtcclxuICAgIHJldHVybiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChTdHlsZWRTdWJNZW51Q29udGVudCwgX19hc3NpZ24oeyBcImRhdGEtdGVzdGlkXCI6IFwiXCIuY29uY2F0KG1lbnVDbGFzc2VzLnN1Yk1lbnVDb250ZW50LCBcIi10ZXN0LWlkXCIpLCByZWY6IHJlZiwgZmlyc3RMZXZlbDogZmlyc3RMZXZlbCwgY29sbGFwc2VkOiBjb2xsYXBzZWQsIG9wZW46IG9wZW4sIG9wZW5XaGVuQ29sbGFwc2VkOiBvcGVuV2hlbkNvbGxhcHNlZCwgdHJhbnNpdGlvbkR1cmF0aW9uOiB0cmFuc2l0aW9uRHVyYXRpb24sIGRlZmF1bHRPcGVuOiBkZWZhdWx0T3BlblN0YXRlIH0sIHJlc3QpLFxyXG4gICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU3R5bGVkVWwsIG51bGwsIGNoaWxkcmVuKSkpO1xyXG59O1xyXG52YXIgU3ViTWVudUNvbnRlbnQgPSBSZWFjdF9fZGVmYXVsdC5mb3J3YXJkUmVmKFN1Yk1lbnVDb250ZW50RlIpO1xyXG52YXIgdGVtcGxhdGVPYmplY3RfMSQ3O1xuXG52YXIgU3R5bGVkTWVudUxhYmVsID0gbmV3U3R5bGVkLnNwYW4odGVtcGxhdGVPYmplY3RfMSQ2IHx8ICh0ZW1wbGF0ZU9iamVjdF8xJDYgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gIGZsZXgtZ3JvdzogMTtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxuXFxuICBcIiwgXCI7XFxuXCJdLCBbXCJcXG4gIGZsZXgtZ3JvdzogMTtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxuXFxuICBcIiwgXCI7XFxuXCJdKSksIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIHJvb3RTdHlsZXMgPSBfYS5yb290U3R5bGVzO1xyXG4gICAgcmV0dXJuIHJvb3RTdHlsZXM7XHJcbn0pO1xyXG52YXIgdGVtcGxhdGVPYmplY3RfMSQ2O1xuXG52YXIgU3R5bGVkTWVudUljb24gPSBuZXdTdHlsZWQuc3Bhbih0ZW1wbGF0ZU9iamVjdF8xJDUgfHwgKHRlbXBsYXRlT2JqZWN0XzEkNSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgd2lkdGg6IDM1cHg7XFxuICBtaW4td2lkdGg6IDM1cHg7XFxuICBoZWlnaHQ6IDM1cHg7XFxuICBsaW5lLWhlaWdodDogMzVweDtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIGJvcmRlci1yYWRpdXM6IDJweDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuXFxuICBcIiwgXCJcXG5cXG4gIFwiLCBcIjtcXG5cIl0sIFtcIlxcbiAgd2lkdGg6IDM1cHg7XFxuICBtaW4td2lkdGg6IDM1cHg7XFxuICBoZWlnaHQ6IDM1cHg7XFxuICBsaW5lLWhlaWdodDogMzVweDtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIGJvcmRlci1yYWRpdXM6IDJweDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuXFxuICBcIiwgXCJcXG5cXG4gIFwiLCBcIjtcXG5cIl0pKSwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgcnRsID0gX2EucnRsO1xyXG4gICAgcmV0dXJuIChydGwgPyAnbWFyZ2luLWxlZnQ6IDEwcHg7JyA6ICdtYXJnaW4tcmlnaHQ6IDEwcHg7Jyk7XHJcbn0sIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIHJvb3RTdHlsZXMgPSBfYS5yb290U3R5bGVzO1xyXG4gICAgcmV0dXJuIHJvb3RTdHlsZXM7XHJcbn0pO1xyXG52YXIgdGVtcGxhdGVPYmplY3RfMSQ1O1xuXG52YXIgU3R5bGVkTWVudVByZWZpeCA9IG5ld1N0eWxlZC5zcGFuKHRlbXBsYXRlT2JqZWN0XzEkNCB8fCAodGVtcGxhdGVPYmplY3RfMSQ0ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICBcIiwgXCJcXG4gIG9wYWNpdHk6IFwiLCBcIjtcXG4gIHRyYW5zaXRpb246IG9wYWNpdHkgXCIsIFwibXM7XFxuXFxuICBcIiwgXCI7XFxuXCJdLCBbXCJcXG4gIFwiLCBcIlxcbiAgb3BhY2l0eTogXCIsIFwiO1xcbiAgdHJhbnNpdGlvbjogb3BhY2l0eSBcIiwgXCJtcztcXG5cXG4gIFwiLCBcIjtcXG5cIl0pKSwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgcnRsID0gX2EucnRsO1xyXG4gICAgcmV0dXJuIChydGwgPyAnbWFyZ2luLWxlZnQ6IDVweDsnIDogJ21hcmdpbi1yaWdodDogNXB4OycpO1xyXG59LCBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciBmaXJzdExldmVsID0gX2EuZmlyc3RMZXZlbCwgY29sbGFwc2VkID0gX2EuY29sbGFwc2VkO1xyXG4gICAgcmV0dXJuIChmaXJzdExldmVsICYmIGNvbGxhcHNlZCA/ICcwJyA6ICcxJyk7XHJcbn0sIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IF9hLnRyYW5zaXRpb25EdXJhdGlvbjtcclxuICAgIHJldHVybiB0cmFuc2l0aW9uRHVyYXRpb247XHJcbn0sIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIHJvb3RTdHlsZXMgPSBfYS5yb290U3R5bGVzO1xyXG4gICAgcmV0dXJuIHJvb3RTdHlsZXM7XHJcbn0pO1xyXG52YXIgdGVtcGxhdGVPYmplY3RfMSQ0O1xuXG52YXIgU3R5bGVkTWVudVN1ZmZpeCA9IG5ld1N0eWxlZC5zcGFuKHRlbXBsYXRlT2JqZWN0XzEkMyB8fCAodGVtcGxhdGVPYmplY3RfMSQzID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICBtYXJnaW4tcmlnaHQ6IDVweDtcXG4gIG1hcmdpbi1sZWZ0OiA1cHg7XFxuICBvcGFjaXR5OiBcIiwgXCI7XFxuICB0cmFuc2l0aW9uOiBvcGFjaXR5IFwiLCBcIm1zO1xcblxcbiAgXCIsIFwiO1xcblwiXSwgW1wiXFxuICBtYXJnaW4tcmlnaHQ6IDVweDtcXG4gIG1hcmdpbi1sZWZ0OiA1cHg7XFxuICBvcGFjaXR5OiBcIiwgXCI7XFxuICB0cmFuc2l0aW9uOiBvcGFjaXR5IFwiLCBcIm1zO1xcblxcbiAgXCIsIFwiO1xcblwiXSkpLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciBmaXJzdExldmVsID0gX2EuZmlyc3RMZXZlbCwgY29sbGFwc2VkID0gX2EuY29sbGFwc2VkO1xyXG4gICAgcmV0dXJuIChmaXJzdExldmVsICYmIGNvbGxhcHNlZCA/ICcwJyA6ICcxJyk7XHJcbn0sIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IF9hLnRyYW5zaXRpb25EdXJhdGlvbjtcclxuICAgIHJldHVybiB0cmFuc2l0aW9uRHVyYXRpb247XHJcbn0sIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIHJvb3RTdHlsZXMgPSBfYS5yb290U3R5bGVzO1xyXG4gICAgcmV0dXJuIHJvb3RTdHlsZXM7XHJcbn0pO1xyXG52YXIgdGVtcGxhdGVPYmplY3RfMSQzO1xuXG52YXIgU3R5bGVkRXhwYW5kSWNvbldyYXBwZXIgPSBuZXdTdHlsZWQuc3Bhbih0ZW1wbGF0ZU9iamVjdF8xJDIgfHwgKHRlbXBsYXRlT2JqZWN0XzEkMiA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgXCIsIFwiXFxuXFxuICBcIiwgXCI7XFxuXCJdLCBbXCJcXG4gIFwiLCBcIlxcblxcbiAgXCIsIFwiO1xcblwiXSkpLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciBjb2xsYXBzZWQgPSBfYS5jb2xsYXBzZWQsIGxldmVsID0gX2EubGV2ZWwsIHJ0bCA9IF9hLnJ0bDtcclxuICAgIHJldHVybiBjb2xsYXBzZWQgJiZcclxuICAgICAgICBsZXZlbCA9PT0gMCAmJlxyXG4gICAgICAgIFwiXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgXCIuY29uY2F0KHJ0bCA/ICdsZWZ0OiAxMHB4OycgOiAncmlnaHQ6IDEwcHg7JywgXCJcXG4gICAgdG9wOiA1MCU7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNTAlKTtcXG4gICAgXFxuICAgIFwiKTtcclxufSwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgcm9vdFN0eWxlcyA9IF9hLnJvb3RTdHlsZXM7XHJcbiAgICByZXR1cm4gcm9vdFN0eWxlcztcclxufSk7XHJcbnZhciBTdHlsZWRFeHBhbmRJY29uID0gbmV3U3R5bGVkLnNwYW4odGVtcGxhdGVPYmplY3RfMiB8fCAodGVtcGxhdGVPYmplY3RfMiA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuM3M7XFxuICBcIiwgXCJcXG5cXG4gIHdpZHRoOiA1cHg7XFxuICBoZWlnaHQ6IDVweDtcXG4gIHRyYW5zZm9ybTogcm90YXRlKFwiLCBcIik7XFxuXCJdLCBbXCJcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjNzO1xcbiAgXCIsIFwiXFxuXFxuICB3aWR0aDogNXB4O1xcbiAgaGVpZ2h0OiA1cHg7XFxuICB0cmFuc2Zvcm06IHJvdGF0ZShcIiwgXCIpO1xcblwiXSkpLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciBydGwgPSBfYS5ydGw7XHJcbiAgICByZXR1cm4gcnRsXHJcbiAgICAgICAgPyBcIlxcbiAgICAgICAgICBib3JkZXItbGVmdDogMnB4IHNvbGlkIGN1cnJlbnRjb2xvcjtcXG4gICAgICAgICAgYm9yZGVyLXRvcDogMnB4IHNvbGlkIGN1cnJlbnRjb2xvcjtcXG4gICAgICAgIFwiXHJcbiAgICAgICAgOiBcIiBib3JkZXItcmlnaHQ6IDJweCBzb2xpZCBjdXJyZW50Y29sb3I7XFxuICAgICAgICAgIGJvcmRlci1ib3R0b206IDJweCBzb2xpZCBjdXJyZW50Y29sb3I7XFxuICAgICAgICBcIjtcclxufSwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgb3BlbiA9IF9hLm9wZW4sIHJ0bCA9IF9hLnJ0bDtcclxuICAgIHJldHVybiAob3BlbiA/IChydGwgPyAnLTEzNWRlZycgOiAnNDVkZWcnKSA6ICctNDVkZWcnKTtcclxufSk7XHJcbnZhciBTdHlsZWRFeHBhbmRJY29uQ29sbGFwc2VkID0gbmV3U3R5bGVkLnNwYW4odGVtcGxhdGVPYmplY3RfMyB8fCAodGVtcGxhdGVPYmplY3RfMyA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgd2lkdGg6IDVweDtcXG4gIGhlaWdodDogNXB4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogY3VycmVudGNvbG9yO1xcbiAgYm9yZGVyLXJhZGl1czogNTAlO1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcblwiXSwgW1wiXFxuICB3aWR0aDogNXB4O1xcbiAgaGVpZ2h0OiA1cHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiBjdXJyZW50Y29sb3I7XFxuICBib3JkZXItcmFkaXVzOiA1MCU7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuXCJdKSkpO1xyXG52YXIgdGVtcGxhdGVPYmplY3RfMSQyLCB0ZW1wbGF0ZU9iamVjdF8yLCB0ZW1wbGF0ZU9iamVjdF8zO1xuXG52YXIgdG9wID0gJ3RvcCc7XG52YXIgYm90dG9tID0gJ2JvdHRvbSc7XG52YXIgcmlnaHQgPSAncmlnaHQnO1xudmFyIGxlZnQgPSAnbGVmdCc7XG52YXIgYXV0byA9ICdhdXRvJztcbnZhciBiYXNlUGxhY2VtZW50cyA9IFt0b3AsIGJvdHRvbSwgcmlnaHQsIGxlZnRdO1xudmFyIHN0YXJ0ID0gJ3N0YXJ0JztcbnZhciBlbmQgPSAnZW5kJztcbnZhciBjbGlwcGluZ1BhcmVudHMgPSAnY2xpcHBpbmdQYXJlbnRzJztcbnZhciB2aWV3cG9ydCA9ICd2aWV3cG9ydCc7XG52YXIgcG9wcGVyID0gJ3BvcHBlcic7XG52YXIgcmVmZXJlbmNlID0gJ3JlZmVyZW5jZSc7XG52YXIgdmFyaWF0aW9uUGxhY2VtZW50cyA9IC8qI19fUFVSRV9fKi9iYXNlUGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gIHJldHVybiBhY2MuY29uY2F0KFtwbGFjZW1lbnQgKyBcIi1cIiArIHN0YXJ0LCBwbGFjZW1lbnQgKyBcIi1cIiArIGVuZF0pO1xufSwgW10pO1xudmFyIHBsYWNlbWVudHMgPSAvKiNfX1BVUkVfXyovW10uY29uY2F0KGJhc2VQbGFjZW1lbnRzLCBbYXV0b10pLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIGFjYy5jb25jYXQoW3BsYWNlbWVudCwgcGxhY2VtZW50ICsgXCItXCIgKyBzdGFydCwgcGxhY2VtZW50ICsgXCItXCIgKyBlbmRdKTtcbn0sIFtdKTsgLy8gbW9kaWZpZXJzIHRoYXQgbmVlZCB0byByZWFkIHRoZSBET01cblxudmFyIGJlZm9yZVJlYWQgPSAnYmVmb3JlUmVhZCc7XG52YXIgcmVhZCA9ICdyZWFkJztcbnZhciBhZnRlclJlYWQgPSAnYWZ0ZXJSZWFkJzsgLy8gcHVyZS1sb2dpYyBtb2RpZmllcnNcblxudmFyIGJlZm9yZU1haW4gPSAnYmVmb3JlTWFpbic7XG52YXIgbWFpbiA9ICdtYWluJztcbnZhciBhZnRlck1haW4gPSAnYWZ0ZXJNYWluJzsgLy8gbW9kaWZpZXIgd2l0aCB0aGUgcHVycG9zZSB0byB3cml0ZSB0byB0aGUgRE9NIChvciB3cml0ZSBpbnRvIGEgZnJhbWV3b3JrIHN0YXRlKVxuXG52YXIgYmVmb3JlV3JpdGUgPSAnYmVmb3JlV3JpdGUnO1xudmFyIHdyaXRlID0gJ3dyaXRlJztcbnZhciBhZnRlcldyaXRlID0gJ2FmdGVyV3JpdGUnO1xudmFyIG1vZGlmaWVyUGhhc2VzID0gW2JlZm9yZVJlYWQsIHJlYWQsIGFmdGVyUmVhZCwgYmVmb3JlTWFpbiwgbWFpbiwgYWZ0ZXJNYWluLCBiZWZvcmVXcml0ZSwgd3JpdGUsIGFmdGVyV3JpdGVdO1xuXG5mdW5jdGlvbiBnZXROb2RlTmFtZShlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50ID8gKGVsZW1lbnQubm9kZU5hbWUgfHwgJycpLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3cobm9kZSkge1xuICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIGlmIChub2RlLnRvU3RyaW5nKCkgIT09ICdbb2JqZWN0IFdpbmRvd10nKSB7XG4gICAgdmFyIG93bmVyRG9jdW1lbnQgPSBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgcmV0dXJuIG93bmVyRG9jdW1lbnQgPyBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdyA6IHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBpc0VsZW1lbnQobm9kZSkge1xuICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5FbGVtZW50O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQobm9kZSkge1xuICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5IVE1MRWxlbWVudDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gaXNTaGFkb3dSb290KG5vZGUpIHtcbiAgLy8gSUUgMTEgaGFzIG5vIFNoYWRvd1Jvb3RcbiAgaWYgKHR5cGVvZiBTaGFkb3dSb290ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLlNoYWRvd1Jvb3Q7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgU2hhZG93Um9vdDtcbn1cblxuLy8gYW5kIGFwcGxpZXMgdGhlbSB0byB0aGUgSFRNTEVsZW1lbnRzIHN1Y2ggYXMgcG9wcGVyIGFuZCBhcnJvd1xuXG5mdW5jdGlvbiBhcHBseVN0eWxlcyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGU7XG4gIE9iamVjdC5rZXlzKHN0YXRlLmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHN0eWxlID0gc3RhdGUuc3R5bGVzW25hbWVdIHx8IHt9O1xuICAgIHZhciBhdHRyaWJ1dGVzID0gc3RhdGUuYXR0cmlidXRlc1tuYW1lXSB8fCB7fTtcbiAgICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW25hbWVdOyAvLyBhcnJvdyBpcyBvcHRpb25hbCArIHZpcnR1YWwgZWxlbWVudHNcblxuICAgIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAhZ2V0Tm9kZU5hbWUoZWxlbWVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEZsb3cgZG9lc24ndCBzdXBwb3J0IHRvIGV4dGVuZCB0aGlzIHByb3BlcnR5LCBidXQgaXQncyB0aGUgbW9zdFxuICAgIC8vIGVmZmVjdGl2ZSB3YXkgdG8gYXBwbHkgc3R5bGVzIHRvIGFuIEhUTUxFbGVtZW50XG4gICAgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdXG5cblxuICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZXNbbmFtZV07XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSA9PT0gdHJ1ZSA/ICcnIDogdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZWZmZWN0JDIoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGU7XG4gIHZhciBpbml0aWFsU3R5bGVzID0ge1xuICAgIHBvcHBlcjoge1xuICAgICAgcG9zaXRpb246IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBsZWZ0OiAnMCcsXG4gICAgICB0b3A6ICcwJyxcbiAgICAgIG1hcmdpbjogJzAnXG4gICAgfSxcbiAgICBhcnJvdzoge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgICB9LFxuICAgIHJlZmVyZW5jZToge31cbiAgfTtcbiAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5wb3BwZXIuc3R5bGUsIGluaXRpYWxTdHlsZXMucG9wcGVyKTtcbiAgc3RhdGUuc3R5bGVzID0gaW5pdGlhbFN0eWxlcztcblxuICBpZiAoc3RhdGUuZWxlbWVudHMuYXJyb3cpIHtcbiAgICBPYmplY3QuYXNzaWduKHN0YXRlLmVsZW1lbnRzLmFycm93LnN0eWxlLCBpbml0aWFsU3R5bGVzLmFycm93KTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgT2JqZWN0LmtleXMoc3RhdGUuZWxlbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbbmFtZV07XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IHN0YXRlLmF0dHJpYnV0ZXNbbmFtZV0gfHwge307XG4gICAgICB2YXIgc3R5bGVQcm9wZXJ0aWVzID0gT2JqZWN0LmtleXMoc3RhdGUuc3R5bGVzLmhhc093blByb3BlcnR5KG5hbWUpID8gc3RhdGUuc3R5bGVzW25hbWVdIDogaW5pdGlhbFN0eWxlc1tuYW1lXSk7IC8vIFNldCBhbGwgdmFsdWVzIHRvIGFuIGVtcHR5IHN0cmluZyB0byB1bnNldCB0aGVtXG5cbiAgICAgIHZhciBzdHlsZSA9IHN0eWxlUHJvcGVydGllcy5yZWR1Y2UoZnVuY3Rpb24gKHN0eWxlLCBwcm9wZXJ0eSkge1xuICAgICAgICBzdHlsZVtwcm9wZXJ0eV0gPSAnJztcbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgfSwge30pOyAvLyBhcnJvdyBpcyBvcHRpb25hbCArIHZpcnR1YWwgZWxlbWVudHNcblxuICAgICAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8ICFnZXROb2RlTmFtZShlbGVtZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbnZhciBhcHBseVN0eWxlcyQxID0ge1xuICBuYW1lOiAnYXBwbHlTdHlsZXMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ3dyaXRlJyxcbiAgZm46IGFwcGx5U3R5bGVzLFxuICBlZmZlY3Q6IGVmZmVjdCQyLFxuICByZXF1aXJlczogWydjb21wdXRlU3R5bGVzJ11cbn07XG5cbmZ1bmN0aW9uIGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbn1cblxudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xudmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcblxuZnVuY3Rpb24gZ2V0VUFTdHJpbmcoKSB7XG4gIHZhciB1YURhdGEgPSBuYXZpZ2F0b3IudXNlckFnZW50RGF0YTtcblxuICBpZiAodWFEYXRhICE9IG51bGwgJiYgdWFEYXRhLmJyYW5kcykge1xuICAgIHJldHVybiB1YURhdGEuYnJhbmRzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW0uYnJhbmQgKyBcIi9cIiArIGl0ZW0udmVyc2lvbjtcbiAgICB9KS5qb2luKCcgJyk7XG4gIH1cblxuICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbn1cblxuZnVuY3Rpb24gaXNMYXlvdXRWaWV3cG9ydCgpIHtcbiAgcmV0dXJuICEvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KGdldFVBU3RyaW5nKCkpO1xufVxuXG5mdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgaW5jbHVkZVNjYWxlLCBpc0ZpeGVkU3RyYXRlZ3kpIHtcbiAgaWYgKGluY2x1ZGVTY2FsZSA9PT0gdm9pZCAwKSB7XG4gICAgaW5jbHVkZVNjYWxlID0gZmFsc2U7XG4gIH1cblxuICBpZiAoaXNGaXhlZFN0cmF0ZWd5ID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkU3RyYXRlZ3kgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBjbGllbnRSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHNjYWxlWCA9IDE7XG4gIHZhciBzY2FsZVkgPSAxO1xuXG4gIGlmIChpbmNsdWRlU2NhbGUgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgIHNjYWxlWCA9IGVsZW1lbnQub2Zmc2V0V2lkdGggPiAwID8gcm91bmQoY2xpZW50UmVjdC53aWR0aCkgLyBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDEgOiAxO1xuICAgIHNjYWxlWSA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0ID4gMCA/IHJvdW5kKGNsaWVudFJlY3QuaGVpZ2h0KSAvIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDEgOiAxO1xuICB9XG5cbiAgdmFyIF9yZWYgPSBpc0VsZW1lbnQoZWxlbWVudCkgPyBnZXRXaW5kb3coZWxlbWVudCkgOiB3aW5kb3csXG4gICAgICB2aXN1YWxWaWV3cG9ydCA9IF9yZWYudmlzdWFsVmlld3BvcnQ7XG5cbiAgdmFyIGFkZFZpc3VhbE9mZnNldHMgPSAhaXNMYXlvdXRWaWV3cG9ydCgpICYmIGlzRml4ZWRTdHJhdGVneTtcbiAgdmFyIHggPSAoY2xpZW50UmVjdC5sZWZ0ICsgKGFkZFZpc3VhbE9mZnNldHMgJiYgdmlzdWFsVmlld3BvcnQgPyB2aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0IDogMCkpIC8gc2NhbGVYO1xuICB2YXIgeSA9IChjbGllbnRSZWN0LnRvcCArIChhZGRWaXN1YWxPZmZzZXRzICYmIHZpc3VhbFZpZXdwb3J0ID8gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wIDogMCkpIC8gc2NhbGVZO1xuICB2YXIgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoIC8gc2NhbGVYO1xuICB2YXIgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQgLyBzY2FsZVk7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHRvcDogeSxcbiAgICByaWdodDogeCArIHdpZHRoLFxuICAgIGJvdHRvbTogeSArIGhlaWdodCxcbiAgICBsZWZ0OiB4LFxuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xufVxuXG4vLyBtZWFucyBpdCBkb2Vzbid0IHRha2UgaW50byBhY2NvdW50IHRyYW5zZm9ybXMuXG5cbmZ1bmN0aW9uIGdldExheW91dFJlY3QoZWxlbWVudCkge1xuICB2YXIgY2xpZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KTsgLy8gVXNlIHRoZSBjbGllbnRSZWN0IHNpemVzIGlmIGl0J3Mgbm90IGJlZW4gdHJhbnNmb3JtZWQuXG4gIC8vIEZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvMTIyM1xuXG4gIHZhciB3aWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gIHZhciBoZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcblxuICBpZiAoTWF0aC5hYnMoY2xpZW50UmVjdC53aWR0aCAtIHdpZHRoKSA8PSAxKSB7XG4gICAgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoO1xuICB9XG5cbiAgaWYgKE1hdGguYWJzKGNsaWVudFJlY3QuaGVpZ2h0IC0gaGVpZ2h0KSA8PSAxKSB7XG4gICAgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IGVsZW1lbnQub2Zmc2V0TGVmdCxcbiAgICB5OiBlbGVtZW50Lm9mZnNldFRvcCxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnMocGFyZW50LCBjaGlsZCkge1xuICB2YXIgcm9vdE5vZGUgPSBjaGlsZC5nZXRSb290Tm9kZSAmJiBjaGlsZC5nZXRSb290Tm9kZSgpOyAvLyBGaXJzdCwgYXR0ZW1wdCB3aXRoIGZhc3RlciBuYXRpdmUgbWV0aG9kXG5cbiAgaWYgKHBhcmVudC5jb250YWlucyhjaGlsZCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyB0aGVuIGZhbGxiYWNrIHRvIGN1c3RvbSBpbXBsZW1lbnRhdGlvbiB3aXRoIFNoYWRvdyBET00gc3VwcG9ydFxuICBlbHNlIGlmIChyb290Tm9kZSAmJiBpc1NoYWRvd1Jvb3Qocm9vdE5vZGUpKSB7XG4gICAgICB2YXIgbmV4dCA9IGNoaWxkO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChuZXh0ICYmIHBhcmVudC5pc1NhbWVOb2RlKG5leHQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddOiBuZWVkIGEgYmV0dGVyIHdheSB0byBoYW5kbGUgdGhpcy4uLlxuXG5cbiAgICAgICAgbmV4dCA9IG5leHQucGFyZW50Tm9kZSB8fCBuZXh0Lmhvc3Q7XG4gICAgICB9IHdoaWxlIChuZXh0KTtcbiAgICB9IC8vIEdpdmUgdXAsIHRoZSByZXN1bHQgaXMgZmFsc2VcblxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSB7XG4gIHJldHVybiBnZXRXaW5kb3coZWxlbWVudCkuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gaXNUYWJsZUVsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gWyd0YWJsZScsICd0ZCcsICd0aCddLmluZGV4T2YoZ2V0Tm9kZU5hbWUoZWxlbWVudCkpID49IDA7XG59XG5cbmZ1bmN0aW9uIGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSB7XG4gIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGFzc3VtZSBib2R5IGlzIGFsd2F5cyBhdmFpbGFibGVcbiAgcmV0dXJuICgoaXNFbGVtZW50KGVsZW1lbnQpID8gZWxlbWVudC5vd25lckRvY3VtZW50IDogLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gIGVsZW1lbnQuZG9jdW1lbnQpIHx8IHdpbmRvdy5kb2N1bWVudCkuZG9jdW1lbnRFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBnZXRQYXJlbnROb2RlKGVsZW1lbnQpIHtcbiAgaWYgKGdldE5vZGVOYW1lKGVsZW1lbnQpID09PSAnaHRtbCcpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiAoLy8gdGhpcyBpcyBhIHF1aWNrZXIgKGJ1dCBsZXNzIHR5cGUgc2FmZSkgd2F5IHRvIHNhdmUgcXVpdGUgc29tZSBieXRlcyBmcm9tIHRoZSBidW5kbGVcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG4gICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgZWxlbWVudC5hc3NpZ25lZFNsb3QgfHwgLy8gc3RlcCBpbnRvIHRoZSBzaGFkb3cgRE9NIG9mIHRoZSBwYXJlbnQgb2YgYSBzbG90dGVkIG5vZGVcbiAgICBlbGVtZW50LnBhcmVudE5vZGUgfHwgKCAvLyBET00gRWxlbWVudCBkZXRlY3RlZFxuICAgIGlzU2hhZG93Um9vdChlbGVtZW50KSA/IGVsZW1lbnQuaG9zdCA6IG51bGwpIHx8IC8vIFNoYWRvd1Jvb3QgZGV0ZWN0ZWRcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogSFRNTEVsZW1lbnQgaXMgYSBOb2RlXG4gICAgZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpIC8vIGZhbGxiYWNrXG5cbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzgzN1xuICBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG59IC8vIGAub2Zmc2V0UGFyZW50YCByZXBvcnRzIGBudWxsYCBmb3IgZml4ZWQgZWxlbWVudHMsIHdoaWxlIGFic29sdXRlIGVsZW1lbnRzXG4vLyByZXR1cm4gdGhlIGNvbnRhaW5pbmcgYmxvY2tcblxuXG5mdW5jdGlvbiBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkge1xuICB2YXIgaXNGaXJlZm94ID0gL2ZpcmVmb3gvaS50ZXN0KGdldFVBU3RyaW5nKCkpO1xuICB2YXIgaXNJRSA9IC9UcmlkZW50L2kudGVzdChnZXRVQVN0cmluZygpKTtcblxuICBpZiAoaXNJRSAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgLy8gSW4gSUUgOSwgMTAgYW5kIDExIGZpeGVkIGVsZW1lbnRzIGNvbnRhaW5pbmcgYmxvY2sgaXMgYWx3YXlzIGVzdGFibGlzaGVkIGJ5IHRoZSB2aWV3cG9ydFxuICAgIHZhciBlbGVtZW50Q3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcblxuICAgIGlmIChlbGVtZW50Q3NzLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICB2YXIgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuXG4gIGlmIChpc1NoYWRvd1Jvb3QoY3VycmVudE5vZGUpKSB7XG4gICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5ob3N0O1xuICB9XG5cbiAgd2hpbGUgKGlzSFRNTEVsZW1lbnQoY3VycmVudE5vZGUpICYmIFsnaHRtbCcsICdib2R5J10uaW5kZXhPZihnZXROb2RlTmFtZShjdXJyZW50Tm9kZSkpIDwgMCkge1xuICAgIHZhciBjc3MgPSBnZXRDb21wdXRlZFN0eWxlKGN1cnJlbnROb2RlKTsgLy8gVGhpcyBpcyBub24tZXhoYXVzdGl2ZSBidXQgY292ZXJzIHRoZSBtb3N0IGNvbW1vbiBDU1MgcHJvcGVydGllcyB0aGF0XG4gICAgLy8gY3JlYXRlIGEgY29udGFpbmluZyBibG9jay5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ29udGFpbmluZ19ibG9jayNpZGVudGlmeWluZ190aGVfY29udGFpbmluZ19ibG9ja1xuXG4gICAgaWYgKGNzcy50cmFuc2Zvcm0gIT09ICdub25lJyB8fCBjc3MucGVyc3BlY3RpdmUgIT09ICdub25lJyB8fCBjc3MuY29udGFpbiA9PT0gJ3BhaW50JyB8fCBbJ3RyYW5zZm9ybScsICdwZXJzcGVjdGl2ZSddLmluZGV4T2YoY3NzLndpbGxDaGFuZ2UpICE9PSAtMSB8fCBpc0ZpcmVmb3ggJiYgY3NzLndpbGxDaGFuZ2UgPT09ICdmaWx0ZXInIHx8IGlzRmlyZWZveCAmJiBjc3MuZmlsdGVyICYmIGNzcy5maWx0ZXIgIT09ICdub25lJykge1xuICAgICAgcmV0dXJuIGN1cnJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59IC8vIEdldHMgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgcG9zaXRpb25lZCBlbGVtZW50LiBIYW5kbGVzIHNvbWUgZWRnZSBjYXNlcyxcbi8vIHN1Y2ggYXMgdGFibGUgYW5jZXN0b3JzIGFuZCBjcm9zcyBicm93c2VyIGJ1Z3MuXG5cblxuZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgdmFyIHdpbmRvdyA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgdmFyIG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCk7XG5cbiAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBpc1RhYmxlRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCk7XG4gIH1cblxuICBpZiAob2Zmc2V0UGFyZW50ICYmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnaHRtbCcgfHwgZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSA9PT0gJ2JvZHknICYmIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHx8IHdpbmRvdztcbn1cblxuZnVuY3Rpb24gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpID49IDAgPyAneCcgOiAneSc7XG59XG5cbmZ1bmN0aW9uIHdpdGhpbihtaW4kMSwgdmFsdWUsIG1heCQxKSB7XG4gIHJldHVybiBtYXgobWluJDEsIG1pbih2YWx1ZSwgbWF4JDEpKTtcbn1cbmZ1bmN0aW9uIHdpdGhpbk1heENsYW1wKG1pbiwgdmFsdWUsIG1heCkge1xuICB2YXIgdiA9IHdpdGhpbihtaW4sIHZhbHVlLCBtYXgpO1xuICByZXR1cm4gdiA+IG1heCA/IG1heCA6IHY7XG59XG5cbmZ1bmN0aW9uIGdldEZyZXNoU2lkZU9iamVjdCgpIHtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IDBcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VQYWRkaW5nT2JqZWN0KHBhZGRpbmdPYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGdldEZyZXNoU2lkZU9iamVjdCgpLCBwYWRkaW5nT2JqZWN0KTtcbn1cblxuZnVuY3Rpb24gZXhwYW5kVG9IYXNoTWFwKHZhbHVlLCBrZXlzKSB7XG4gIHJldHVybiBrZXlzLnJlZHVjZShmdW5jdGlvbiAoaGFzaE1hcCwga2V5KSB7XG4gICAgaGFzaE1hcFtrZXldID0gdmFsdWU7XG4gICAgcmV0dXJuIGhhc2hNYXA7XG4gIH0sIHt9KTtcbn1cblxudmFyIHRvUGFkZGluZ09iamVjdCA9IGZ1bmN0aW9uIHRvUGFkZGluZ09iamVjdChwYWRkaW5nLCBzdGF0ZSkge1xuICBwYWRkaW5nID0gdHlwZW9mIHBhZGRpbmcgPT09ICdmdW5jdGlvbicgPyBwYWRkaW5nKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSkpIDogcGFkZGluZztcbiAgcmV0dXJuIG1lcmdlUGFkZGluZ09iamVjdCh0eXBlb2YgcGFkZGluZyAhPT0gJ251bWJlcicgPyBwYWRkaW5nIDogZXhwYW5kVG9IYXNoTWFwKHBhZGRpbmcsIGJhc2VQbGFjZW1lbnRzKSk7XG59O1xuXG5mdW5jdGlvbiBhcnJvdyhfcmVmKSB7XG4gIHZhciBfc3RhdGUkbW9kaWZpZXJzRGF0YSQ7XG5cbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zO1xuICB2YXIgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3c7XG4gIHZhciBwb3BwZXJPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzO1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KTtcbiAgdmFyIGF4aXMgPSBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCk7XG4gIHZhciBpc1ZlcnRpY2FsID0gW2xlZnQsIHJpZ2h0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDA7XG4gIHZhciBsZW4gPSBpc1ZlcnRpY2FsID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gIGlmICghYXJyb3dFbGVtZW50IHx8ICFwb3BwZXJPZmZzZXRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHBhZGRpbmdPYmplY3QgPSB0b1BhZGRpbmdPYmplY3Qob3B0aW9ucy5wYWRkaW5nLCBzdGF0ZSk7XG4gIHZhciBhcnJvd1JlY3QgPSBnZXRMYXlvdXRSZWN0KGFycm93RWxlbWVudCk7XG4gIHZhciBtaW5Qcm9wID0gYXhpcyA9PT0gJ3knID8gdG9wIDogbGVmdDtcbiAgdmFyIG1heFByb3AgPSBheGlzID09PSAneScgPyBib3R0b20gOiByaWdodDtcbiAgdmFyIGVuZERpZmYgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbbGVuXSArIHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtheGlzXSAtIHBvcHBlck9mZnNldHNbYXhpc10gLSBzdGF0ZS5yZWN0cy5wb3BwZXJbbGVuXTtcbiAgdmFyIHN0YXJ0RGlmZiA9IHBvcHBlck9mZnNldHNbYXhpc10gLSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbYXhpc107XG4gIHZhciBhcnJvd09mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChhcnJvd0VsZW1lbnQpO1xuICB2YXIgY2xpZW50U2l6ZSA9IGFycm93T2Zmc2V0UGFyZW50ID8gYXhpcyA9PT0gJ3knID8gYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50SGVpZ2h0IHx8IDAgOiBhcnJvd09mZnNldFBhcmVudC5jbGllbnRXaWR0aCB8fCAwIDogMDtcbiAgdmFyIGNlbnRlclRvUmVmZXJlbmNlID0gZW5kRGlmZiAvIDIgLSBzdGFydERpZmYgLyAyOyAvLyBNYWtlIHN1cmUgdGhlIGFycm93IGRvZXNuJ3Qgb3ZlcmZsb3cgdGhlIHBvcHBlciBpZiB0aGUgY2VudGVyIHBvaW50IGlzXG4gIC8vIG91dHNpZGUgb2YgdGhlIHBvcHBlciBib3VuZHNcblxuICB2YXIgbWluID0gcGFkZGluZ09iamVjdFttaW5Qcm9wXTtcbiAgdmFyIG1heCA9IGNsaWVudFNpemUgLSBhcnJvd1JlY3RbbGVuXSAtIHBhZGRpbmdPYmplY3RbbWF4UHJvcF07XG4gIHZhciBjZW50ZXIgPSBjbGllbnRTaXplIC8gMiAtIGFycm93UmVjdFtsZW5dIC8gMiArIGNlbnRlclRvUmVmZXJlbmNlO1xuICB2YXIgb2Zmc2V0ID0gd2l0aGluKG1pbiwgY2VudGVyLCBtYXgpOyAvLyBQcmV2ZW50cyBicmVha2luZyBzeW50YXggaGlnaGxpZ2h0aW5nLi4uXG5cbiAgdmFyIGF4aXNQcm9wID0gYXhpcztcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IChfc3RhdGUkbW9kaWZpZXJzRGF0YSQgPSB7fSwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkW2F4aXNQcm9wXSA9IG9mZnNldCwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkLmNlbnRlck9mZnNldCA9IG9mZnNldCAtIGNlbnRlciwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkKTtcbn1cblxuZnVuY3Rpb24gZWZmZWN0JDEoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjIub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJGVsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQsXG4gICAgICBhcnJvd0VsZW1lbnQgPSBfb3B0aW9ucyRlbGVtZW50ID09PSB2b2lkIDAgPyAnW2RhdGEtcG9wcGVyLWFycm93XScgOiBfb3B0aW9ucyRlbGVtZW50O1xuXG4gIGlmIChhcnJvd0VsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfSAvLyBDU1Mgc2VsZWN0b3JcblxuXG4gIGlmICh0eXBlb2YgYXJyb3dFbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLnBvcHBlci5xdWVyeVNlbGVjdG9yKGFycm93RWxlbWVudCk7XG5cbiAgICBpZiAoIWFycm93RWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoIWlzSFRNTEVsZW1lbnQoYXJyb3dFbGVtZW50KSkge1xuICAgICAgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogXCJhcnJvd1wiIGVsZW1lbnQgbXVzdCBiZSBhbiBIVE1MRWxlbWVudCAobm90IGFuIFNWR0VsZW1lbnQpLicsICdUbyB1c2UgYW4gU1ZHIGFycm93LCB3cmFwIGl0IGluIGFuIEhUTUxFbGVtZW50IHRoYXQgd2lsbCBiZSB1c2VkIGFzJywgJ3RoZSBhcnJvdy4nXS5qb2luKCcgJykpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29udGFpbnMoc3RhdGUuZWxlbWVudHMucG9wcGVyLCBhcnJvd0VsZW1lbnQpKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogXCJhcnJvd1wiIG1vZGlmaWVyXFwncyBgZWxlbWVudGAgbXVzdCBiZSBhIGNoaWxkIG9mIHRoZSBwb3BwZXInLCAnZWxlbWVudC4nXS5qb2luKCcgJykpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIHN0YXRlLmVsZW1lbnRzLmFycm93ID0gYXJyb3dFbGVtZW50O1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxudmFyIGFycm93JDEgPSB7XG4gIG5hbWU6ICdhcnJvdycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBhcnJvdyxcbiAgZWZmZWN0OiBlZmZlY3QkMSxcbiAgcmVxdWlyZXM6IFsncG9wcGVyT2Zmc2V0cyddLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ3ByZXZlbnRPdmVyZmxvdyddXG59O1xuXG5mdW5jdGlvbiBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcbn1cblxudmFyIHVuc2V0U2lkZXMgPSB7XG4gIHRvcDogJ2F1dG8nLFxuICByaWdodDogJ2F1dG8nLFxuICBib3R0b206ICdhdXRvJyxcbiAgbGVmdDogJ2F1dG8nXG59OyAvLyBSb3VuZCB0aGUgb2Zmc2V0cyB0byB0aGUgbmVhcmVzdCBzdWl0YWJsZSBzdWJwaXhlbCBiYXNlZCBvbiB0aGUgRFBSLlxuLy8gWm9vbWluZyBjYW4gY2hhbmdlIHRoZSBEUFIsIGJ1dCBpdCBzZWVtcyB0byByZXBvcnQgYSB2YWx1ZSB0aGF0IHdpbGxcbi8vIGNsZWFubHkgZGl2aWRlIHRoZSB2YWx1ZXMgaW50byB0aGUgYXBwcm9wcmlhdGUgc3VicGl4ZWxzLlxuXG5mdW5jdGlvbiByb3VuZE9mZnNldHNCeURQUihfcmVmKSB7XG4gIHZhciB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueTtcbiAgdmFyIHdpbiA9IHdpbmRvdztcbiAgdmFyIGRwciA9IHdpbi5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gIHJldHVybiB7XG4gICAgeDogcm91bmQoeCAqIGRwcikgLyBkcHIgfHwgMCxcbiAgICB5OiByb3VuZCh5ICogZHByKSAvIGRwciB8fCAwXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1hcFRvU3R5bGVzKF9yZWYyKSB7XG4gIHZhciBfT2JqZWN0JGFzc2lnbjI7XG5cbiAgdmFyIHBvcHBlciA9IF9yZWYyLnBvcHBlcixcbiAgICAgIHBvcHBlclJlY3QgPSBfcmVmMi5wb3BwZXJSZWN0LFxuICAgICAgcGxhY2VtZW50ID0gX3JlZjIucGxhY2VtZW50LFxuICAgICAgdmFyaWF0aW9uID0gX3JlZjIudmFyaWF0aW9uLFxuICAgICAgb2Zmc2V0cyA9IF9yZWYyLm9mZnNldHMsXG4gICAgICBwb3NpdGlvbiA9IF9yZWYyLnBvc2l0aW9uLFxuICAgICAgZ3B1QWNjZWxlcmF0aW9uID0gX3JlZjIuZ3B1QWNjZWxlcmF0aW9uLFxuICAgICAgYWRhcHRpdmUgPSBfcmVmMi5hZGFwdGl2ZSxcbiAgICAgIHJvdW5kT2Zmc2V0cyA9IF9yZWYyLnJvdW5kT2Zmc2V0cyxcbiAgICAgIGlzRml4ZWQgPSBfcmVmMi5pc0ZpeGVkO1xuICB2YXIgX29mZnNldHMkeCA9IG9mZnNldHMueCxcbiAgICAgIHggPSBfb2Zmc2V0cyR4ID09PSB2b2lkIDAgPyAwIDogX29mZnNldHMkeCxcbiAgICAgIF9vZmZzZXRzJHkgPSBvZmZzZXRzLnksXG4gICAgICB5ID0gX29mZnNldHMkeSA9PT0gdm9pZCAwID8gMCA6IF9vZmZzZXRzJHk7XG5cbiAgdmFyIF9yZWYzID0gdHlwZW9mIHJvdW5kT2Zmc2V0cyA9PT0gJ2Z1bmN0aW9uJyA/IHJvdW5kT2Zmc2V0cyh7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH0pIDoge1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xuXG4gIHggPSBfcmVmMy54O1xuICB5ID0gX3JlZjMueTtcbiAgdmFyIGhhc1ggPSBvZmZzZXRzLmhhc093blByb3BlcnR5KCd4Jyk7XG4gIHZhciBoYXNZID0gb2Zmc2V0cy5oYXNPd25Qcm9wZXJ0eSgneScpO1xuICB2YXIgc2lkZVggPSBsZWZ0O1xuICB2YXIgc2lkZVkgPSB0b3A7XG4gIHZhciB3aW4gPSB3aW5kb3c7XG5cbiAgaWYgKGFkYXB0aXZlKSB7XG4gICAgdmFyIG9mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChwb3BwZXIpO1xuICAgIHZhciBoZWlnaHRQcm9wID0gJ2NsaWVudEhlaWdodCc7XG4gICAgdmFyIHdpZHRoUHJvcCA9ICdjbGllbnRXaWR0aCc7XG5cbiAgICBpZiAob2Zmc2V0UGFyZW50ID09PSBnZXRXaW5kb3cocG9wcGVyKSkge1xuICAgICAgb2Zmc2V0UGFyZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KHBvcHBlcik7XG5cbiAgICAgIGlmIChnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gIT09ICdzdGF0aWMnICYmIHBvc2l0aW9uID09PSAnYWJzb2x1dGUnKSB7XG4gICAgICAgIGhlaWdodFByb3AgPSAnc2Nyb2xsSGVpZ2h0JztcbiAgICAgICAgd2lkdGhQcm9wID0gJ3Njcm9sbFdpZHRoJztcbiAgICAgIH1cbiAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhc3RdOiBmb3JjZSB0eXBlIHJlZmluZW1lbnQsIHdlIGNvbXBhcmUgb2Zmc2V0UGFyZW50IHdpdGggd2luZG93IGFib3ZlLCBidXQgRmxvdyBkb2Vzbid0IGRldGVjdCBpdFxuXG5cbiAgICBvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQ7XG5cbiAgICBpZiAocGxhY2VtZW50ID09PSB0b3AgfHwgKHBsYWNlbWVudCA9PT0gbGVmdCB8fCBwbGFjZW1lbnQgPT09IHJpZ2h0KSAmJiB2YXJpYXRpb24gPT09IGVuZCkge1xuICAgICAgc2lkZVkgPSBib3R0b207XG4gICAgICB2YXIgb2Zmc2V0WSA9IGlzRml4ZWQgJiYgb2Zmc2V0UGFyZW50ID09PSB3aW4gJiYgd2luLnZpc3VhbFZpZXdwb3J0ID8gd2luLnZpc3VhbFZpZXdwb3J0LmhlaWdodCA6IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgb2Zmc2V0UGFyZW50W2hlaWdodFByb3BdO1xuICAgICAgeSAtPSBvZmZzZXRZIC0gcG9wcGVyUmVjdC5oZWlnaHQ7XG4gICAgICB5ICo9IGdwdUFjY2VsZXJhdGlvbiA/IDEgOiAtMTtcbiAgICB9XG5cbiAgICBpZiAocGxhY2VtZW50ID09PSBsZWZ0IHx8IChwbGFjZW1lbnQgPT09IHRvcCB8fCBwbGFjZW1lbnQgPT09IGJvdHRvbSkgJiYgdmFyaWF0aW9uID09PSBlbmQpIHtcbiAgICAgIHNpZGVYID0gcmlnaHQ7XG4gICAgICB2YXIgb2Zmc2V0WCA9IGlzRml4ZWQgJiYgb2Zmc2V0UGFyZW50ID09PSB3aW4gJiYgd2luLnZpc3VhbFZpZXdwb3J0ID8gd2luLnZpc3VhbFZpZXdwb3J0LndpZHRoIDogLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgICBvZmZzZXRQYXJlbnRbd2lkdGhQcm9wXTtcbiAgICAgIHggLT0gb2Zmc2V0WCAtIHBvcHBlclJlY3Qud2lkdGg7XG4gICAgICB4ICo9IGdwdUFjY2VsZXJhdGlvbiA/IDEgOiAtMTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29tbW9uU3R5bGVzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgcG9zaXRpb246IHBvc2l0aW9uXG4gIH0sIGFkYXB0aXZlICYmIHVuc2V0U2lkZXMpO1xuXG4gIHZhciBfcmVmNCA9IHJvdW5kT2Zmc2V0cyA9PT0gdHJ1ZSA/IHJvdW5kT2Zmc2V0c0J5RFBSKHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfSkgOiB7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG5cbiAgeCA9IF9yZWY0Lng7XG4gIHkgPSBfcmVmNC55O1xuXG4gIGlmIChncHVBY2NlbGVyYXRpb24pIHtcbiAgICB2YXIgX09iamVjdCRhc3NpZ247XG5cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCAoX09iamVjdCRhc3NpZ24gPSB7fSwgX09iamVjdCRhc3NpZ25bc2lkZVldID0gaGFzWSA/ICcwJyA6ICcnLCBfT2JqZWN0JGFzc2lnbltzaWRlWF0gPSBoYXNYID8gJzAnIDogJycsIF9PYmplY3QkYXNzaWduLnRyYW5zZm9ybSA9ICh3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSA8PSAxID8gXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCJweCwgXCIgKyB5ICsgXCJweClcIiA6IFwidHJhbnNsYXRlM2QoXCIgKyB4ICsgXCJweCwgXCIgKyB5ICsgXCJweCwgMClcIiwgX09iamVjdCRhc3NpZ24pKTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIChfT2JqZWN0JGFzc2lnbjIgPSB7fSwgX09iamVjdCRhc3NpZ24yW3NpZGVZXSA9IGhhc1kgPyB5ICsgXCJweFwiIDogJycsIF9PYmplY3QkYXNzaWduMltzaWRlWF0gPSBoYXNYID8geCArIFwicHhcIiA6ICcnLCBfT2JqZWN0JGFzc2lnbjIudHJhbnNmb3JtID0gJycsIF9PYmplY3QkYXNzaWduMikpO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlU3R5bGVzKF9yZWY1KSB7XG4gIHZhciBzdGF0ZSA9IF9yZWY1LnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWY1Lm9wdGlvbnM7XG4gIHZhciBfb3B0aW9ucyRncHVBY2NlbGVyYXQgPSBvcHRpb25zLmdwdUFjY2VsZXJhdGlvbixcbiAgICAgIGdwdUFjY2VsZXJhdGlvbiA9IF9vcHRpb25zJGdwdUFjY2VsZXJhdCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGdwdUFjY2VsZXJhdCxcbiAgICAgIF9vcHRpb25zJGFkYXB0aXZlID0gb3B0aW9ucy5hZGFwdGl2ZSxcbiAgICAgIGFkYXB0aXZlID0gX29wdGlvbnMkYWRhcHRpdmUgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRhZGFwdGl2ZSxcbiAgICAgIF9vcHRpb25zJHJvdW5kT2Zmc2V0cyA9IG9wdGlvbnMucm91bmRPZmZzZXRzLFxuICAgICAgcm91bmRPZmZzZXRzID0gX29wdGlvbnMkcm91bmRPZmZzZXRzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkcm91bmRPZmZzZXRzO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2YXIgdHJhbnNpdGlvblByb3BlcnR5ID0gZ2V0Q29tcHV0ZWRTdHlsZShzdGF0ZS5lbGVtZW50cy5wb3BwZXIpLnRyYW5zaXRpb25Qcm9wZXJ0eSB8fCAnJztcblxuICAgIGlmIChhZGFwdGl2ZSAmJiBbJ3RyYW5zZm9ybScsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXS5zb21lKGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIHRyYW5zaXRpb25Qcm9wZXJ0eS5pbmRleE9mKHByb3BlcnR5KSA+PSAwO1xuICAgIH0pKSB7XG4gICAgICBjb25zb2xlLndhcm4oWydQb3BwZXI6IERldGVjdGVkIENTUyB0cmFuc2l0aW9ucyBvbiBhdCBsZWFzdCBvbmUgb2YgdGhlIGZvbGxvd2luZycsICdDU1MgcHJvcGVydGllczogXCJ0cmFuc2Zvcm1cIiwgXCJ0b3BcIiwgXCJyaWdodFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIi4nLCAnXFxuXFxuJywgJ0Rpc2FibGUgdGhlIFwiY29tcHV0ZVN0eWxlc1wiIG1vZGlmaWVyXFwncyBgYWRhcHRpdmVgIG9wdGlvbiB0byBhbGxvdycsICdmb3Igc21vb3RoIHRyYW5zaXRpb25zLCBvciByZW1vdmUgdGhlc2UgcHJvcGVydGllcyBmcm9tIHRoZSBDU1MnLCAndHJhbnNpdGlvbiBkZWNsYXJhdGlvbiBvbiB0aGUgcG9wcGVyIGVsZW1lbnQgaWYgb25seSB0cmFuc2l0aW9uaW5nJywgJ29wYWNpdHkgb3IgYmFja2dyb3VuZC1jb2xvciBmb3IgZXhhbXBsZS4nLCAnXFxuXFxuJywgJ1dlIHJlY29tbWVuZCB1c2luZyB0aGUgcG9wcGVyIGVsZW1lbnQgYXMgYSB3cmFwcGVyIGFyb3VuZCBhbiBpbm5lcicsICdlbGVtZW50IHRoYXQgY2FuIGhhdmUgYW55IENTUyBwcm9wZXJ0eSB0cmFuc2l0aW9uZWQgZm9yIGFuaW1hdGlvbnMuJ10uam9pbignICcpKTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29tbW9uU3R5bGVzID0ge1xuICAgIHBsYWNlbWVudDogZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpLFxuICAgIHZhcmlhdGlvbjogZ2V0VmFyaWF0aW9uKHN0YXRlLnBsYWNlbWVudCksXG4gICAgcG9wcGVyOiBzdGF0ZS5lbGVtZW50cy5wb3BwZXIsXG4gICAgcG9wcGVyUmVjdDogc3RhdGUucmVjdHMucG9wcGVyLFxuICAgIGdwdUFjY2VsZXJhdGlvbjogZ3B1QWNjZWxlcmF0aW9uLFxuICAgIGlzRml4ZWQ6IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3kgPT09ICdmaXhlZCdcbiAgfTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwpIHtcbiAgICBzdGF0ZS5zdHlsZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuc3R5bGVzLnBvcHBlciwgbWFwVG9TdHlsZXMoT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCB7XG4gICAgICBvZmZzZXRzOiBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMsXG4gICAgICBwb3NpdGlvbjogc3RhdGUub3B0aW9ucy5zdHJhdGVneSxcbiAgICAgIGFkYXB0aXZlOiBhZGFwdGl2ZSxcbiAgICAgIHJvdW5kT2Zmc2V0czogcm91bmRPZmZzZXRzXG4gICAgfSkpKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLmFycm93ICE9IG51bGwpIHtcbiAgICBzdGF0ZS5zdHlsZXMuYXJyb3cgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5zdHlsZXMuYXJyb3csIG1hcFRvU3R5bGVzKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywge1xuICAgICAgb2Zmc2V0czogc3RhdGUubW9kaWZpZXJzRGF0YS5hcnJvdyxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgYWRhcHRpdmU6IGZhbHNlLFxuICAgICAgcm91bmRPZmZzZXRzOiByb3VuZE9mZnNldHNcbiAgICB9KSkpO1xuICB9XG5cbiAgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciwge1xuICAgICdkYXRhLXBvcHBlci1wbGFjZW1lbnQnOiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG52YXIgY29tcHV0ZVN0eWxlcyQxID0ge1xuICBuYW1lOiAnY29tcHV0ZVN0eWxlcycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnYmVmb3JlV3JpdGUnLFxuICBmbjogY29tcHV0ZVN0eWxlcyxcbiAgZGF0YToge31cbn07XG5cbnZhciBwYXNzaXZlID0ge1xuICBwYXNzaXZlOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBlZmZlY3QoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgaW5zdGFuY2UgPSBfcmVmLmluc3RhbmNlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJHNjcm9sbCA9IG9wdGlvbnMuc2Nyb2xsLFxuICAgICAgc2Nyb2xsID0gX29wdGlvbnMkc2Nyb2xsID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkc2Nyb2xsLFxuICAgICAgX29wdGlvbnMkcmVzaXplID0gb3B0aW9ucy5yZXNpemUsXG4gICAgICByZXNpemUgPSBfb3B0aW9ucyRyZXNpemUgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRyZXNpemU7XG4gIHZhciB3aW5kb3cgPSBnZXRXaW5kb3coc3RhdGUuZWxlbWVudHMucG9wcGVyKTtcbiAgdmFyIHNjcm9sbFBhcmVudHMgPSBbXS5jb25jYXQoc3RhdGUuc2Nyb2xsUGFyZW50cy5yZWZlcmVuY2UsIHN0YXRlLnNjcm9sbFBhcmVudHMucG9wcGVyKTtcblxuICBpZiAoc2Nyb2xsKSB7XG4gICAgc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzY3JvbGxQYXJlbnQpIHtcbiAgICAgIHNjcm9sbFBhcmVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHJlc2l6ZSkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2Nyb2xsKSB7XG4gICAgICBzY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHNjcm9sbFBhcmVudCkge1xuICAgICAgICBzY3JvbGxQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChyZXNpemUpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgIH1cbiAgfTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbnZhciBldmVudExpc3RlbmVycyA9IHtcbiAgbmFtZTogJ2V2ZW50TGlzdGVuZXJzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICd3cml0ZScsXG4gIGZuOiBmdW5jdGlvbiBmbigpIHt9LFxuICBlZmZlY3Q6IGVmZmVjdCxcbiAgZGF0YToge31cbn07XG5cbnZhciBoYXNoJDEgPSB7XG4gIGxlZnQ6ICdyaWdodCcsXG4gIHJpZ2h0OiAnbGVmdCcsXG4gIGJvdHRvbTogJ3RvcCcsXG4gIHRvcDogJ2JvdHRvbSdcbn07XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgZnVuY3Rpb24gKG1hdGNoZWQpIHtcbiAgICByZXR1cm4gaGFzaCQxW21hdGNoZWRdO1xuICB9KTtcbn1cblxudmFyIGhhc2ggPSB7XG4gIHN0YXJ0OiAnZW5kJyxcbiAgZW5kOiAnc3RhcnQnXG59O1xuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvc3RhcnR8ZW5kL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgcmV0dXJuIGhhc2hbbWF0Y2hlZF07XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGwobm9kZSkge1xuICB2YXIgd2luID0gZ2V0V2luZG93KG5vZGUpO1xuICB2YXIgc2Nyb2xsTGVmdCA9IHdpbi5wYWdlWE9mZnNldDtcbiAgdmFyIHNjcm9sbFRvcCA9IHdpbi5wYWdlWU9mZnNldDtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBzY3JvbGxMZWZ0LFxuICAgIHNjcm9sbFRvcDogc2Nyb2xsVG9wXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCkge1xuICAvLyBJZiA8aHRtbD4gaGFzIGEgQ1NTIHdpZHRoIGdyZWF0ZXIgdGhhbiB0aGUgdmlld3BvcnQsIHRoZW4gdGhpcyB3aWxsIGJlXG4gIC8vIGluY29ycmVjdCBmb3IgUlRMLlxuICAvLyBQb3BwZXIgMSBpcyBicm9rZW4gaW4gdGhpcyBjYXNlIGFuZCBuZXZlciBoYWQgYSBidWcgcmVwb3J0IHNvIGxldCdzIGFzc3VtZVxuICAvLyBpdCdzIG5vdCBhbiBpc3N1ZS4gSSBkb24ndCB0aGluayBhbnlvbmUgZXZlciBzcGVjaWZpZXMgd2lkdGggb24gPGh0bWw+XG4gIC8vIGFueXdheS5cbiAgLy8gQnJvd3NlcnMgd2hlcmUgdGhlIGxlZnQgc2Nyb2xsYmFyIGRvZXNuJ3QgY2F1c2UgYW4gaXNzdWUgcmVwb3J0IGAwYCBmb3JcbiAgLy8gdGhpcyAoZS5nLiBFZGdlIDIwMTksIElFMTEsIFNhZmFyaSlcbiAgcmV0dXJuIGdldEJvdW5kaW5nQ2xpZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpLmxlZnQgKyBnZXRXaW5kb3dTY3JvbGwoZWxlbWVudCkuc2Nyb2xsTGVmdDtcbn1cblxuZnVuY3Rpb24gZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIHZhciB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIHZhciBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICB2YXIgdmlzdWFsVmlld3BvcnQgPSB3aW4udmlzdWFsVmlld3BvcnQ7XG4gIHZhciB3aWR0aCA9IGh0bWwuY2xpZW50V2lkdGg7XG4gIHZhciBoZWlnaHQgPSBodG1sLmNsaWVudEhlaWdodDtcbiAgdmFyIHggPSAwO1xuICB2YXIgeSA9IDA7XG5cbiAgaWYgKHZpc3VhbFZpZXdwb3J0KSB7XG4gICAgd2lkdGggPSB2aXN1YWxWaWV3cG9ydC53aWR0aDtcbiAgICBoZWlnaHQgPSB2aXN1YWxWaWV3cG9ydC5oZWlnaHQ7XG4gICAgdmFyIGxheW91dFZpZXdwb3J0ID0gaXNMYXlvdXRWaWV3cG9ydCgpO1xuXG4gICAgaWYgKGxheW91dFZpZXdwb3J0IHx8ICFsYXlvdXRWaWV3cG9ydCAmJiBzdHJhdGVneSA9PT0gJ2ZpeGVkJykge1xuICAgICAgeCA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQ7XG4gICAgICB5ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHg6IHggKyBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpLFxuICAgIHk6IHlcbiAgfTtcbn1cblxuLy8gb2YgdGhlIGA8aHRtbD5gIGFuZCBgPGJvZHk+YCByZWN0IGJvdW5kcyBpZiBob3Jpem9udGFsbHkgc2Nyb2xsYWJsZVxuXG5mdW5jdGlvbiBnZXREb2N1bWVudFJlY3QoZWxlbWVudCkge1xuICB2YXIgX2VsZW1lbnQkb3duZXJEb2N1bWVuO1xuXG4gIHZhciBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICB2YXIgd2luU2Nyb2xsID0gZ2V0V2luZG93U2Nyb2xsKGVsZW1lbnQpO1xuICB2YXIgYm9keSA9IChfZWxlbWVudCRvd25lckRvY3VtZW4gPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZWxlbWVudCRvd25lckRvY3VtZW4uYm9keTtcbiAgdmFyIHdpZHRoID0gbWF4KGh0bWwuc2Nyb2xsV2lkdGgsIGh0bWwuY2xpZW50V2lkdGgsIGJvZHkgPyBib2R5LnNjcm9sbFdpZHRoIDogMCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKTtcbiAgdmFyIGhlaWdodCA9IG1heChodG1sLnNjcm9sbEhlaWdodCwgaHRtbC5jbGllbnRIZWlnaHQsIGJvZHkgPyBib2R5LnNjcm9sbEhlaWdodCA6IDAsIGJvZHkgPyBib2R5LmNsaWVudEhlaWdodCA6IDApO1xuICB2YXIgeCA9IC13aW5TY3JvbGwuc2Nyb2xsTGVmdCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCk7XG4gIHZhciB5ID0gLXdpblNjcm9sbC5zY3JvbGxUb3A7XG5cbiAgaWYgKGdldENvbXB1dGVkU3R5bGUoYm9keSB8fCBodG1sKS5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgeCArPSBtYXgoaHRtbC5jbGllbnRXaWR0aCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKSAtIHdpZHRoO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzU2Nyb2xsUGFyZW50KGVsZW1lbnQpIHtcbiAgLy8gRmlyZWZveCB3YW50cyB1cyB0byBjaGVjayBgLXhgIGFuZCBgLXlgIHZhcmlhdGlvbnMgYXMgd2VsbFxuICB2YXIgX2dldENvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLFxuICAgICAgb3ZlcmZsb3cgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5vdmVyZmxvdyxcbiAgICAgIG92ZXJmbG93WCA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93WCxcbiAgICAgIG92ZXJmbG93WSA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93WTtcblxuICByZXR1cm4gL2F1dG98c2Nyb2xsfG92ZXJsYXl8aGlkZGVuLy50ZXN0KG92ZXJmbG93ICsgb3ZlcmZsb3dZICsgb3ZlcmZsb3dYKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2Nyb2xsUGFyZW50KG5vZGUpIHtcbiAgaWYgKFsnaHRtbCcsICdib2R5JywgJyNkb2N1bWVudCddLmluZGV4T2YoZ2V0Tm9kZU5hbWUobm9kZSkpID49IDApIHtcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBhc3N1bWUgYm9keSBpcyBhbHdheXMgYXZhaWxhYmxlXG4gICAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudC5ib2R5O1xuICB9XG5cbiAgaWYgKGlzSFRNTEVsZW1lbnQobm9kZSkgJiYgaXNTY3JvbGxQYXJlbnQobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHJldHVybiBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShub2RlKSk7XG59XG5cbi8qXG5naXZlbiBhIERPTSBlbGVtZW50LCByZXR1cm4gdGhlIGxpc3Qgb2YgYWxsIHNjcm9sbCBwYXJlbnRzLCB1cCB0aGUgbGlzdCBvZiBhbmNlc29yc1xudW50aWwgd2UgZ2V0IHRvIHRoZSB0b3Agd2luZG93IG9iamVjdC4gVGhpcyBsaXN0IGlzIHdoYXQgd2UgYXR0YWNoIHNjcm9sbCBsaXN0ZW5lcnNcbnRvLCBiZWNhdXNlIGlmIGFueSBvZiB0aGVzZSBwYXJlbnQgZWxlbWVudHMgc2Nyb2xsLCB3ZSdsbCBuZWVkIHRvIHJlLWNhbGN1bGF0ZSB0aGVcbnJlZmVyZW5jZSBlbGVtZW50J3MgcG9zaXRpb24uXG4qL1xuXG5mdW5jdGlvbiBsaXN0U2Nyb2xsUGFyZW50cyhlbGVtZW50LCBsaXN0KSB7XG4gIHZhciBfZWxlbWVudCRvd25lckRvY3VtZW47XG5cbiAgaWYgKGxpc3QgPT09IHZvaWQgMCkge1xuICAgIGxpc3QgPSBbXTtcbiAgfVxuXG4gIHZhciBzY3JvbGxQYXJlbnQgPSBnZXRTY3JvbGxQYXJlbnQoZWxlbWVudCk7XG4gIHZhciBpc0JvZHkgPSBzY3JvbGxQYXJlbnQgPT09ICgoX2VsZW1lbnQkb3duZXJEb2N1bWVuID0gZWxlbWVudC5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2VsZW1lbnQkb3duZXJEb2N1bWVuLmJvZHkpO1xuICB2YXIgd2luID0gZ2V0V2luZG93KHNjcm9sbFBhcmVudCk7XG4gIHZhciB0YXJnZXQgPSBpc0JvZHkgPyBbd2luXS5jb25jYXQod2luLnZpc3VhbFZpZXdwb3J0IHx8IFtdLCBpc1Njcm9sbFBhcmVudChzY3JvbGxQYXJlbnQpID8gc2Nyb2xsUGFyZW50IDogW10pIDogc2Nyb2xsUGFyZW50O1xuICB2YXIgdXBkYXRlZExpc3QgPSBsaXN0LmNvbmNhdCh0YXJnZXQpO1xuICByZXR1cm4gaXNCb2R5ID8gdXBkYXRlZExpc3QgOiAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogaXNCb2R5IHRlbGxzIHVzIHRhcmdldCB3aWxsIGJlIGFuIEhUTUxFbGVtZW50IGhlcmVcbiAgdXBkYXRlZExpc3QuY29uY2F0KGxpc3RTY3JvbGxQYXJlbnRzKGdldFBhcmVudE5vZGUodGFyZ2V0KSkpO1xufVxuXG5mdW5jdGlvbiByZWN0VG9DbGllbnRSZWN0KHJlY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHJlY3QsIHtcbiAgICBsZWZ0OiByZWN0LngsXG4gICAgdG9wOiByZWN0LnksXG4gICAgcmlnaHQ6IHJlY3QueCArIHJlY3Qud2lkdGgsXG4gICAgYm90dG9tOiByZWN0LnkgKyByZWN0LmhlaWdodFxuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpIHtcbiAgdmFyIHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgZmFsc2UsIHN0cmF0ZWd5ID09PSAnZml4ZWQnKTtcbiAgcmVjdC50b3AgPSByZWN0LnRvcCArIGVsZW1lbnQuY2xpZW50VG9wO1xuICByZWN0LmxlZnQgPSByZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudExlZnQ7XG4gIHJlY3QuYm90dG9tID0gcmVjdC50b3AgKyBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgcmVjdC5yaWdodCA9IHJlY3QubGVmdCArIGVsZW1lbnQuY2xpZW50V2lkdGg7XG4gIHJlY3Qud2lkdGggPSBlbGVtZW50LmNsaWVudFdpZHRoO1xuICByZWN0LmhlaWdodCA9IGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICByZWN0LnggPSByZWN0LmxlZnQ7XG4gIHJlY3QueSA9IHJlY3QudG9wO1xuICByZXR1cm4gcmVjdDtcbn1cblxuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoZWxlbWVudCwgY2xpcHBpbmdQYXJlbnQsIHN0cmF0ZWd5KSB7XG4gIHJldHVybiBjbGlwcGluZ1BhcmVudCA9PT0gdmlld3BvcnQgPyByZWN0VG9DbGllbnRSZWN0KGdldFZpZXdwb3J0UmVjdChlbGVtZW50LCBzdHJhdGVneSkpIDogaXNFbGVtZW50KGNsaXBwaW5nUGFyZW50KSA/IGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGNsaXBwaW5nUGFyZW50LCBzdHJhdGVneSkgOiByZWN0VG9DbGllbnRSZWN0KGdldERvY3VtZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpKTtcbn0gLy8gQSBcImNsaXBwaW5nIHBhcmVudFwiIGlzIGFuIG92ZXJmbG93YWJsZSBjb250YWluZXIgd2l0aCB0aGUgY2hhcmFjdGVyaXN0aWMgb2Zcbi8vIGNsaXBwaW5nIChvciBoaWRpbmcpIG92ZXJmbG93aW5nIGVsZW1lbnRzIHdpdGggYSBwb3NpdGlvbiBkaWZmZXJlbnQgZnJvbVxuLy8gYGluaXRpYWxgXG5cblxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsZW1lbnQpIHtcbiAgdmFyIGNsaXBwaW5nUGFyZW50cyA9IGxpc3RTY3JvbGxQYXJlbnRzKGdldFBhcmVudE5vZGUoZWxlbWVudCkpO1xuICB2YXIgY2FuRXNjYXBlQ2xpcHBpbmcgPSBbJ2Fic29sdXRlJywgJ2ZpeGVkJ10uaW5kZXhPZihnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uKSA+PSAwO1xuICB2YXIgY2xpcHBlckVsZW1lbnQgPSBjYW5Fc2NhcGVDbGlwcGluZyAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpID8gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIDogZWxlbWVudDtcblxuICBpZiAoIWlzRWxlbWVudChjbGlwcGVyRWxlbWVudCkpIHtcbiAgICByZXR1cm4gW107XG4gIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzE0MTRcblxuXG4gIHJldHVybiBjbGlwcGluZ1BhcmVudHMuZmlsdGVyKGZ1bmN0aW9uIChjbGlwcGluZ1BhcmVudCkge1xuICAgIHJldHVybiBpc0VsZW1lbnQoY2xpcHBpbmdQYXJlbnQpICYmIGNvbnRhaW5zKGNsaXBwaW5nUGFyZW50LCBjbGlwcGVyRWxlbWVudCkgJiYgZ2V0Tm9kZU5hbWUoY2xpcHBpbmdQYXJlbnQpICE9PSAnYm9keSc7XG4gIH0pO1xufSAvLyBHZXRzIHRoZSBtYXhpbXVtIGFyZWEgdGhhdCB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIGluIGR1ZSB0byBhbnkgbnVtYmVyIG9mXG4vLyBjbGlwcGluZyBwYXJlbnRzXG5cblxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdSZWN0KGVsZW1lbnQsIGJvdW5kYXJ5LCByb290Qm91bmRhcnksIHN0cmF0ZWd5KSB7XG4gIHZhciBtYWluQ2xpcHBpbmdQYXJlbnRzID0gYm91bmRhcnkgPT09ICdjbGlwcGluZ1BhcmVudHMnID8gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsZW1lbnQpIDogW10uY29uY2F0KGJvdW5kYXJ5KTtcbiAgdmFyIGNsaXBwaW5nUGFyZW50cyA9IFtdLmNvbmNhdChtYWluQ2xpcHBpbmdQYXJlbnRzLCBbcm9vdEJvdW5kYXJ5XSk7XG4gIHZhciBmaXJzdENsaXBwaW5nUGFyZW50ID0gY2xpcHBpbmdQYXJlbnRzWzBdO1xuICB2YXIgY2xpcHBpbmdSZWN0ID0gY2xpcHBpbmdQYXJlbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjUmVjdCwgY2xpcHBpbmdQYXJlbnQpIHtcbiAgICB2YXIgcmVjdCA9IGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGNsaXBwaW5nUGFyZW50LCBzdHJhdGVneSk7XG4gICAgYWNjUmVjdC50b3AgPSBtYXgocmVjdC50b3AsIGFjY1JlY3QudG9wKTtcbiAgICBhY2NSZWN0LnJpZ2h0ID0gbWluKHJlY3QucmlnaHQsIGFjY1JlY3QucmlnaHQpO1xuICAgIGFjY1JlY3QuYm90dG9tID0gbWluKHJlY3QuYm90dG9tLCBhY2NSZWN0LmJvdHRvbSk7XG4gICAgYWNjUmVjdC5sZWZ0ID0gbWF4KHJlY3QubGVmdCwgYWNjUmVjdC5sZWZ0KTtcbiAgICByZXR1cm4gYWNjUmVjdDtcbiAgfSwgZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoZWxlbWVudCwgZmlyc3RDbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpKTtcbiAgY2xpcHBpbmdSZWN0LndpZHRoID0gY2xpcHBpbmdSZWN0LnJpZ2h0IC0gY2xpcHBpbmdSZWN0LmxlZnQ7XG4gIGNsaXBwaW5nUmVjdC5oZWlnaHQgPSBjbGlwcGluZ1JlY3QuYm90dG9tIC0gY2xpcHBpbmdSZWN0LnRvcDtcbiAgY2xpcHBpbmdSZWN0LnggPSBjbGlwcGluZ1JlY3QubGVmdDtcbiAgY2xpcHBpbmdSZWN0LnkgPSBjbGlwcGluZ1JlY3QudG9wO1xuICByZXR1cm4gY2xpcHBpbmdSZWN0O1xufVxuXG5mdW5jdGlvbiBjb21wdXRlT2Zmc2V0cyhfcmVmKSB7XG4gIHZhciByZWZlcmVuY2UgPSBfcmVmLnJlZmVyZW5jZSxcbiAgICAgIGVsZW1lbnQgPSBfcmVmLmVsZW1lbnQsXG4gICAgICBwbGFjZW1lbnQgPSBfcmVmLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQgPyBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgOiBudWxsO1xuICB2YXIgdmFyaWF0aW9uID0gcGxhY2VtZW50ID8gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgOiBudWxsO1xuICB2YXIgY29tbW9uWCA9IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoIC8gMiAtIGVsZW1lbnQud2lkdGggLyAyO1xuICB2YXIgY29tbW9uWSA9IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodCAvIDIgLSBlbGVtZW50LmhlaWdodCAvIDI7XG4gIHZhciBvZmZzZXRzO1xuXG4gIHN3aXRjaCAoYmFzZVBsYWNlbWVudCkge1xuICAgIGNhc2UgdG9wOlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgLSBlbGVtZW50LmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBib3R0b206XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcmlnaHQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBsZWZ0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggLSBlbGVtZW50LndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLngsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55XG4gICAgICB9O1xuICB9XG5cbiAgdmFyIG1haW5BeGlzID0gYmFzZVBsYWNlbWVudCA/IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KSA6IG51bGw7XG5cbiAgaWYgKG1haW5BeGlzICE9IG51bGwpIHtcbiAgICB2YXIgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICAgIHN3aXRjaCAodmFyaWF0aW9uKSB7XG4gICAgICBjYXNlIHN0YXJ0OlxuICAgICAgICBvZmZzZXRzW21haW5BeGlzXSA9IG9mZnNldHNbbWFpbkF4aXNdIC0gKHJlZmVyZW5jZVtsZW5dIC8gMiAtIGVsZW1lbnRbbGVuXSAvIDIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBlbmQ6XG4gICAgICAgIG9mZnNldHNbbWFpbkF4aXNdID0gb2Zmc2V0c1ttYWluQXhpc10gKyAocmVmZXJlbmNlW2xlbl0gLyAyIC0gZWxlbWVudFtsZW5dIC8gMik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvZmZzZXRzO1xufVxuXG5mdW5jdGlvbiBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgIF9vcHRpb25zJHBsYWNlbWVudCA9IF9vcHRpb25zLnBsYWNlbWVudCxcbiAgICAgIHBsYWNlbWVudCA9IF9vcHRpb25zJHBsYWNlbWVudCA9PT0gdm9pZCAwID8gc3RhdGUucGxhY2VtZW50IDogX29wdGlvbnMkcGxhY2VtZW50LFxuICAgICAgX29wdGlvbnMkc3RyYXRlZ3kgPSBfb3B0aW9ucy5zdHJhdGVneSxcbiAgICAgIHN0cmF0ZWd5ID0gX29wdGlvbnMkc3RyYXRlZ3kgPT09IHZvaWQgMCA/IHN0YXRlLnN0cmF0ZWd5IDogX29wdGlvbnMkc3RyYXRlZ3ksXG4gICAgICBfb3B0aW9ucyRib3VuZGFyeSA9IF9vcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgYm91bmRhcnkgPSBfb3B0aW9ucyRib3VuZGFyeSA9PT0gdm9pZCAwID8gY2xpcHBpbmdQYXJlbnRzIDogX29wdGlvbnMkYm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRyb290Qm91bmRhcnkgPSBfb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBfb3B0aW9ucyRyb290Qm91bmRhcnkgPT09IHZvaWQgMCA/IHZpZXdwb3J0IDogX29wdGlvbnMkcm9vdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkZWxlbWVudENvbnRlID0gX29wdGlvbnMuZWxlbWVudENvbnRleHQsXG4gICAgICBlbGVtZW50Q29udGV4dCA9IF9vcHRpb25zJGVsZW1lbnRDb250ZSA9PT0gdm9pZCAwID8gcG9wcGVyIDogX29wdGlvbnMkZWxlbWVudENvbnRlLFxuICAgICAgX29wdGlvbnMkYWx0Qm91bmRhcnkgPSBfb3B0aW9ucy5hbHRCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5ID0gX29wdGlvbnMkYWx0Qm91bmRhcnkgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkYWx0Qm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRwYWRkaW5nID0gX29wdGlvbnMucGFkZGluZyxcbiAgICAgIHBhZGRpbmcgPSBfb3B0aW9ucyRwYWRkaW5nID09PSB2b2lkIDAgPyAwIDogX29wdGlvbnMkcGFkZGluZztcbiAgdmFyIHBhZGRpbmdPYmplY3QgPSBtZXJnZVBhZGRpbmdPYmplY3QodHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gcGFkZGluZyA6IGV4cGFuZFRvSGFzaE1hcChwYWRkaW5nLCBiYXNlUGxhY2VtZW50cykpO1xuICB2YXIgYWx0Q29udGV4dCA9IGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgPyByZWZlcmVuY2UgOiBwb3BwZXI7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW2FsdEJvdW5kYXJ5ID8gYWx0Q29udGV4dCA6IGVsZW1lbnRDb250ZXh0XTtcbiAgdmFyIGNsaXBwaW5nQ2xpZW50UmVjdCA9IGdldENsaXBwaW5nUmVjdChpc0VsZW1lbnQoZWxlbWVudCkgPyBlbGVtZW50IDogZWxlbWVudC5jb250ZXh0RWxlbWVudCB8fCBnZXREb2N1bWVudEVsZW1lbnQoc3RhdGUuZWxlbWVudHMucG9wcGVyKSwgYm91bmRhcnksIHJvb3RCb3VuZGFyeSwgc3RyYXRlZ3kpO1xuICB2YXIgcmVmZXJlbmNlQ2xpZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChzdGF0ZS5lbGVtZW50cy5yZWZlcmVuY2UpO1xuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IGNvbXB1dGVPZmZzZXRzKHtcbiAgICByZWZlcmVuY2U6IHJlZmVyZW5jZUNsaWVudFJlY3QsXG4gICAgZWxlbWVudDogcG9wcGVyUmVjdCxcbiAgICBzdHJhdGVneTogJ2Fic29sdXRlJyxcbiAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudFxuICB9KTtcbiAgdmFyIHBvcHBlckNsaWVudFJlY3QgPSByZWN0VG9DbGllbnRSZWN0KE9iamVjdC5hc3NpZ24oe30sIHBvcHBlclJlY3QsIHBvcHBlck9mZnNldHMpKTtcbiAgdmFyIGVsZW1lbnRDbGllbnRSZWN0ID0gZWxlbWVudENvbnRleHQgPT09IHBvcHBlciA/IHBvcHBlckNsaWVudFJlY3QgOiByZWZlcmVuY2VDbGllbnRSZWN0OyAvLyBwb3NpdGl2ZSA9IG92ZXJmbG93aW5nIHRoZSBjbGlwcGluZyByZWN0XG4gIC8vIDAgb3IgbmVnYXRpdmUgPSB3aXRoaW4gdGhlIGNsaXBwaW5nIHJlY3RcblxuICB2YXIgb3ZlcmZsb3dPZmZzZXRzID0ge1xuICAgIHRvcDogY2xpcHBpbmdDbGllbnRSZWN0LnRvcCAtIGVsZW1lbnRDbGllbnRSZWN0LnRvcCArIHBhZGRpbmdPYmplY3QudG9wLFxuICAgIGJvdHRvbTogZWxlbWVudENsaWVudFJlY3QuYm90dG9tIC0gY2xpcHBpbmdDbGllbnRSZWN0LmJvdHRvbSArIHBhZGRpbmdPYmplY3QuYm90dG9tLFxuICAgIGxlZnQ6IGNsaXBwaW5nQ2xpZW50UmVjdC5sZWZ0IC0gZWxlbWVudENsaWVudFJlY3QubGVmdCArIHBhZGRpbmdPYmplY3QubGVmdCxcbiAgICByaWdodDogZWxlbWVudENsaWVudFJlY3QucmlnaHQgLSBjbGlwcGluZ0NsaWVudFJlY3QucmlnaHQgKyBwYWRkaW5nT2JqZWN0LnJpZ2h0XG4gIH07XG4gIHZhciBvZmZzZXREYXRhID0gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXQ7IC8vIE9mZnNldHMgY2FuIGJlIGFwcGxpZWQgb25seSB0byB0aGUgcG9wcGVyIGVsZW1lbnRcblxuICBpZiAoZWxlbWVudENvbnRleHQgPT09IHBvcHBlciAmJiBvZmZzZXREYXRhKSB7XG4gICAgdmFyIG9mZnNldCA9IG9mZnNldERhdGFbcGxhY2VtZW50XTtcbiAgICBPYmplY3Qua2V5cyhvdmVyZmxvd09mZnNldHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIG11bHRpcGx5ID0gW3JpZ2h0LCBib3R0b21dLmluZGV4T2Yoa2V5KSA+PSAwID8gMSA6IC0xO1xuICAgICAgdmFyIGF4aXMgPSBbdG9wLCBib3R0b21dLmluZGV4T2Yoa2V5KSA+PSAwID8gJ3knIDogJ3gnO1xuICAgICAgb3ZlcmZsb3dPZmZzZXRzW2tleV0gKz0gb2Zmc2V0W2F4aXNdICogbXVsdGlwbHk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gb3ZlcmZsb3dPZmZzZXRzO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlQXV0b1BsYWNlbWVudChzdGF0ZSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgIHBsYWNlbWVudCA9IF9vcHRpb25zLnBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5ID0gX29wdGlvbnMuYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBfb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICBwYWRkaW5nID0gX29wdGlvbnMucGFkZGluZyxcbiAgICAgIGZsaXBWYXJpYXRpb25zID0gX29wdGlvbnMuZmxpcFZhcmlhdGlvbnMsXG4gICAgICBfb3B0aW9ucyRhbGxvd2VkQXV0b1AgPSBfb3B0aW9ucy5hbGxvd2VkQXV0b1BsYWNlbWVudHMsXG4gICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHMgPSBfb3B0aW9ucyRhbGxvd2VkQXV0b1AgPT09IHZvaWQgMCA/IHBsYWNlbWVudHMgOiBfb3B0aW9ucyRhbGxvd2VkQXV0b1A7XG4gIHZhciB2YXJpYXRpb24gPSBnZXRWYXJpYXRpb24ocGxhY2VtZW50KTtcbiAgdmFyIHBsYWNlbWVudHMkMSA9IHZhcmlhdGlvbiA/IGZsaXBWYXJpYXRpb25zID8gdmFyaWF0aW9uUGxhY2VtZW50cyA6IHZhcmlhdGlvblBsYWNlbWVudHMuZmlsdGVyKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgPT09IHZhcmlhdGlvbjtcbiAgfSkgOiBiYXNlUGxhY2VtZW50cztcbiAgdmFyIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cyQxLmZpbHRlcihmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGFsbG93ZWRBdXRvUGxhY2VtZW50cy5pbmRleE9mKHBsYWNlbWVudCkgPj0gMDtcbiAgfSk7XG5cbiAgaWYgKGFsbG93ZWRQbGFjZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cyQxO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogVGhlIGBhbGxvd2VkQXV0b1BsYWNlbWVudHNgIG9wdGlvbiBkaWQgbm90IGFsbG93IGFueScsICdwbGFjZW1lbnRzLiBFbnN1cmUgdGhlIGBwbGFjZW1lbnRgIG9wdGlvbiBtYXRjaGVzIHRoZSB2YXJpYXRpb24nLCAnb2YgdGhlIGFsbG93ZWQgcGxhY2VtZW50cy4nLCAnRm9yIGV4YW1wbGUsIFwiYXV0b1wiIGNhbm5vdCBiZSB1c2VkIHRvIGFsbG93IFwiYm90dG9tLXN0YXJ0XCIuJywgJ1VzZSBcImF1dG8tc3RhcnRcIiBpbnN0ZWFkLiddLmpvaW4oJyAnKSk7XG4gICAgfVxuICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdOiBGbG93IHNlZW1zIHRvIGhhdmUgcHJvYmxlbXMgd2l0aCB0d28gYXJyYXkgdW5pb25zLi4uXG5cblxuICB2YXIgb3ZlcmZsb3dzID0gYWxsb3dlZFBsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICAgIGFjY1twbGFjZW1lbnRdID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICBwYWRkaW5nOiBwYWRkaW5nXG4gICAgfSlbZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpXTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvdmVyZmxvd3MpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gb3ZlcmZsb3dzW2FdIC0gb3ZlcmZsb3dzW2JdO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0RXhwYW5kZWRGYWxsYmFja1BsYWNlbWVudHMocGxhY2VtZW50KSB7XG4gIGlmIChnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgPT09IGF1dG8pIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgb3Bwb3NpdGVQbGFjZW1lbnQgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICByZXR1cm4gW2dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KHBsYWNlbWVudCksIG9wcG9zaXRlUGxhY2VtZW50LCBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChvcHBvc2l0ZVBsYWNlbWVudCldO1xufVxuXG5mdW5jdGlvbiBmbGlwKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdLl9za2lwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIF9vcHRpb25zJG1haW5BeGlzID0gb3B0aW9ucy5tYWluQXhpcyxcbiAgICAgIGNoZWNrTWFpbkF4aXMgPSBfb3B0aW9ucyRtYWluQXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJG1haW5BeGlzLFxuICAgICAgX29wdGlvbnMkYWx0QXhpcyA9IG9wdGlvbnMuYWx0QXhpcyxcbiAgICAgIGNoZWNrQWx0QXhpcyA9IF9vcHRpb25zJGFsdEF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRhbHRBeGlzLFxuICAgICAgc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzID0gb3B0aW9ucy5mYWxsYmFja1BsYWNlbWVudHMsXG4gICAgICBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgYm91bmRhcnkgPSBvcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeSA9IG9wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRmbGlwVmFyaWF0aW8gPSBvcHRpb25zLmZsaXBWYXJpYXRpb25zLFxuICAgICAgZmxpcFZhcmlhdGlvbnMgPSBfb3B0aW9ucyRmbGlwVmFyaWF0aW8gPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRmbGlwVmFyaWF0aW8sXG4gICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHMgPSBvcHRpb25zLmFsbG93ZWRBdXRvUGxhY2VtZW50cztcbiAgdmFyIHByZWZlcnJlZFBsYWNlbWVudCA9IHN0YXRlLm9wdGlvbnMucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocHJlZmVycmVkUGxhY2VtZW50KTtcbiAgdmFyIGlzQmFzZVBsYWNlbWVudCA9IGJhc2VQbGFjZW1lbnQgPT09IHByZWZlcnJlZFBsYWNlbWVudDtcbiAgdmFyIGZhbGxiYWNrUGxhY2VtZW50cyA9IHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyB8fCAoaXNCYXNlUGxhY2VtZW50IHx8ICFmbGlwVmFyaWF0aW9ucyA/IFtnZXRPcHBvc2l0ZVBsYWNlbWVudChwcmVmZXJyZWRQbGFjZW1lbnQpXSA6IGdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzKHByZWZlcnJlZFBsYWNlbWVudCkpO1xuICB2YXIgcGxhY2VtZW50cyA9IFtwcmVmZXJyZWRQbGFjZW1lbnRdLmNvbmNhdChmYWxsYmFja1BsYWNlbWVudHMpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gYWNjLmNvbmNhdChnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgPT09IGF1dG8gPyBjb21wdXRlQXV0b1BsYWNlbWVudChzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgICBmbGlwVmFyaWF0aW9uczogZmxpcFZhcmlhdGlvbnMsXG4gICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHM6IGFsbG93ZWRBdXRvUGxhY2VtZW50c1xuICAgIH0pIDogcGxhY2VtZW50KTtcbiAgfSwgW10pO1xuICB2YXIgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciBjaGVja3NNYXAgPSBuZXcgTWFwKCk7XG4gIHZhciBtYWtlRmFsbGJhY2tDaGVja3MgPSB0cnVlO1xuICB2YXIgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50c1swXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBsYWNlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGxhY2VtZW50ID0gcGxhY2VtZW50c1tpXTtcblxuICAgIHZhciBfYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KTtcblxuICAgIHZhciBpc1N0YXJ0VmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgPT09IHN0YXJ0O1xuICAgIHZhciBpc1ZlcnRpY2FsID0gW3RvcCwgYm90dG9tXS5pbmRleE9mKF9iYXNlUGxhY2VtZW50KSA+PSAwO1xuICAgIHZhciBsZW4gPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuICAgIHZhciBvdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnk6IGFsdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgIH0pO1xuICAgIHZhciBtYWluVmFyaWF0aW9uU2lkZSA9IGlzVmVydGljYWwgPyBpc1N0YXJ0VmFyaWF0aW9uID8gcmlnaHQgOiBsZWZ0IDogaXNTdGFydFZhcmlhdGlvbiA/IGJvdHRvbSA6IHRvcDtcblxuICAgIGlmIChyZWZlcmVuY2VSZWN0W2xlbl0gPiBwb3BwZXJSZWN0W2xlbl0pIHtcbiAgICAgIG1haW5WYXJpYXRpb25TaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpblZhcmlhdGlvblNpZGUpO1xuICAgIH1cblxuICAgIHZhciBhbHRWYXJpYXRpb25TaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpblZhcmlhdGlvblNpZGUpO1xuICAgIHZhciBjaGVja3MgPSBbXTtcblxuICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICBjaGVja3MucHVzaChvdmVyZmxvd1tfYmFzZVBsYWNlbWVudF0gPD0gMCk7XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrQWx0QXhpcykge1xuICAgICAgY2hlY2tzLnB1c2gob3ZlcmZsb3dbbWFpblZhcmlhdGlvblNpZGVdIDw9IDAsIG92ZXJmbG93W2FsdFZhcmlhdGlvblNpZGVdIDw9IDApO1xuICAgIH1cblxuICAgIGlmIChjaGVja3MuZXZlcnkoZnVuY3Rpb24gKGNoZWNrKSB7XG4gICAgICByZXR1cm4gY2hlY2s7XG4gICAgfSkpIHtcbiAgICAgIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudDtcbiAgICAgIG1ha2VGYWxsYmFja0NoZWNrcyA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2hlY2tzTWFwLnNldChwbGFjZW1lbnQsIGNoZWNrcyk7XG4gIH1cblxuICBpZiAobWFrZUZhbGxiYWNrQ2hlY2tzKSB7XG4gICAgLy8gYDJgIG1heSBiZSBkZXNpcmVkIGluIHNvbWUgY2FzZXMg4oCTIHJlc2VhcmNoIGxhdGVyXG4gICAgdmFyIG51bWJlck9mQ2hlY2tzID0gZmxpcFZhcmlhdGlvbnMgPyAzIDogMTtcblxuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKF9pKSB7XG4gICAgICB2YXIgZml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudHMuZmluZChmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgICAgIHZhciBjaGVja3MgPSBjaGVja3NNYXAuZ2V0KHBsYWNlbWVudCk7XG5cbiAgICAgICAgaWYgKGNoZWNrcykge1xuICAgICAgICAgIHJldHVybiBjaGVja3Muc2xpY2UoMCwgX2kpLmV2ZXJ5KGZ1bmN0aW9uIChjaGVjaykge1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKGZpdHRpbmdQbGFjZW1lbnQpIHtcbiAgICAgICAgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gZml0dGluZ1BsYWNlbWVudDtcbiAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yICh2YXIgX2kgPSBudW1iZXJPZkNoZWNrczsgX2kgPiAwOyBfaS0tKSB7XG4gICAgICB2YXIgX3JldCA9IF9sb29wKF9pKTtcblxuICAgICAgaWYgKF9yZXQgPT09IFwiYnJlYWtcIikgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRlLnBsYWNlbWVudCAhPT0gZmlyc3RGaXR0aW5nUGxhY2VtZW50KSB7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXS5fc2tpcCA9IHRydWU7XG4gICAgc3RhdGUucGxhY2VtZW50ID0gZmlyc3RGaXR0aW5nUGxhY2VtZW50O1xuICAgIHN0YXRlLnJlc2V0ID0gdHJ1ZTtcbiAgfVxufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxudmFyIGZsaXAkMSA9IHtcbiAgbmFtZTogJ2ZsaXAnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogZmxpcCxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydvZmZzZXQnXSxcbiAgZGF0YToge1xuICAgIF9za2lwOiBmYWxzZVxuICB9XG59O1xuXG5mdW5jdGlvbiBnZXRTaWRlT2Zmc2V0cyhvdmVyZmxvdywgcmVjdCwgcHJldmVudGVkT2Zmc2V0cykge1xuICBpZiAocHJldmVudGVkT2Zmc2V0cyA9PT0gdm9pZCAwKSB7XG4gICAgcHJldmVudGVkT2Zmc2V0cyA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdG9wOiBvdmVyZmxvdy50b3AgLSByZWN0LmhlaWdodCAtIHByZXZlbnRlZE9mZnNldHMueSxcbiAgICByaWdodDogb3ZlcmZsb3cucmlnaHQgLSByZWN0LndpZHRoICsgcHJldmVudGVkT2Zmc2V0cy54LFxuICAgIGJvdHRvbTogb3ZlcmZsb3cuYm90dG9tIC0gcmVjdC5oZWlnaHQgKyBwcmV2ZW50ZWRPZmZzZXRzLnksXG4gICAgbGVmdDogb3ZlcmZsb3cubGVmdCAtIHJlY3Qud2lkdGggLSBwcmV2ZW50ZWRPZmZzZXRzLnhcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKG92ZXJmbG93KSB7XG4gIHJldHVybiBbdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XS5zb21lKGZ1bmN0aW9uIChzaWRlKSB7XG4gICAgcmV0dXJuIG92ZXJmbG93W3NpZGVdID49IDA7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBoaWRlKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG4gIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIHByZXZlbnRlZE9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnByZXZlbnRPdmVyZmxvdztcbiAgdmFyIHJlZmVyZW5jZU92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBlbGVtZW50Q29udGV4dDogJ3JlZmVyZW5jZSdcbiAgfSk7XG4gIHZhciBwb3BwZXJBbHRPdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgYWx0Qm91bmRhcnk6IHRydWVcbiAgfSk7XG4gIHZhciByZWZlcmVuY2VDbGlwcGluZ09mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhyZWZlcmVuY2VPdmVyZmxvdywgcmVmZXJlbmNlUmVjdCk7XG4gIHZhciBwb3BwZXJFc2NhcGVPZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMocG9wcGVyQWx0T3ZlcmZsb3csIHBvcHBlclJlY3QsIHByZXZlbnRlZE9mZnNldHMpO1xuICB2YXIgaXNSZWZlcmVuY2VIaWRkZW4gPSBpc0FueVNpZGVGdWxseUNsaXBwZWQocmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzKTtcbiAgdmFyIGhhc1BvcHBlckVzY2FwZWQgPSBpc0FueVNpZGVGdWxseUNsaXBwZWQocG9wcGVyRXNjYXBlT2Zmc2V0cyk7XG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSB7XG4gICAgcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzOiByZWZlcmVuY2VDbGlwcGluZ09mZnNldHMsXG4gICAgcG9wcGVyRXNjYXBlT2Zmc2V0czogcG9wcGVyRXNjYXBlT2Zmc2V0cyxcbiAgICBpc1JlZmVyZW5jZUhpZGRlbjogaXNSZWZlcmVuY2VIaWRkZW4sXG4gICAgaGFzUG9wcGVyRXNjYXBlZDogaGFzUG9wcGVyRXNjYXBlZFxuICB9O1xuICBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyLCB7XG4gICAgJ2RhdGEtcG9wcGVyLXJlZmVyZW5jZS1oaWRkZW4nOiBpc1JlZmVyZW5jZUhpZGRlbixcbiAgICAnZGF0YS1wb3BwZXItZXNjYXBlZCc6IGhhc1BvcHBlckVzY2FwZWRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG52YXIgaGlkZSQxID0ge1xuICBuYW1lOiAnaGlkZScsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsncHJldmVudE92ZXJmbG93J10sXG4gIGZuOiBoaWRlXG59O1xuXG5mdW5jdGlvbiBkaXN0YW5jZUFuZFNraWRkaW5nVG9YWShwbGFjZW1lbnQsIHJlY3RzLCBvZmZzZXQpIHtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHZhciBpbnZlcnREaXN0YW5jZSA9IFtsZWZ0LCB0b3BdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMCA/IC0xIDogMTtcblxuICB2YXIgX3JlZiA9IHR5cGVvZiBvZmZzZXQgPT09ICdmdW5jdGlvbicgPyBvZmZzZXQoT2JqZWN0LmFzc2lnbih7fSwgcmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudFxuICB9KSkgOiBvZmZzZXQsXG4gICAgICBza2lkZGluZyA9IF9yZWZbMF0sXG4gICAgICBkaXN0YW5jZSA9IF9yZWZbMV07XG5cbiAgc2tpZGRpbmcgPSBza2lkZGluZyB8fCAwO1xuICBkaXN0YW5jZSA9IChkaXN0YW5jZSB8fCAwKSAqIGludmVydERpc3RhbmNlO1xuICByZXR1cm4gW2xlZnQsIHJpZ2h0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDAgPyB7XG4gICAgeDogZGlzdGFuY2UsXG4gICAgeTogc2tpZGRpbmdcbiAgfSA6IHtcbiAgICB4OiBza2lkZGluZyxcbiAgICB5OiBkaXN0YW5jZVxuICB9O1xufVxuXG5mdW5jdGlvbiBvZmZzZXQoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjIub3B0aW9ucyxcbiAgICAgIG5hbWUgPSBfcmVmMi5uYW1lO1xuICB2YXIgX29wdGlvbnMkb2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQsXG4gICAgICBvZmZzZXQgPSBfb3B0aW9ucyRvZmZzZXQgPT09IHZvaWQgMCA/IFswLCAwXSA6IF9vcHRpb25zJG9mZnNldDtcbiAgdmFyIGRhdGEgPSBwbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICBhY2NbcGxhY2VtZW50XSA9IGRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZKHBsYWNlbWVudCwgc3RhdGUucmVjdHMsIG9mZnNldCk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICB2YXIgX2RhdGEkc3RhdGUkcGxhY2VtZW50ID0gZGF0YVtzdGF0ZS5wbGFjZW1lbnRdLFxuICAgICAgeCA9IF9kYXRhJHN0YXRlJHBsYWNlbWVudC54LFxuICAgICAgeSA9IF9kYXRhJHN0YXRlJHBsYWNlbWVudC55O1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCkge1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy54ICs9IHg7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnkgKz0geTtcbiAgfVxuXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBkYXRhO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxudmFyIG9mZnNldCQxID0ge1xuICBuYW1lOiAnb2Zmc2V0JyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgcmVxdWlyZXM6IFsncG9wcGVyT2Zmc2V0cyddLFxuICBmbjogb2Zmc2V0XG59O1xuXG5mdW5jdGlvbiBwb3BwZXJPZmZzZXRzKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG4gIC8vIE9mZnNldHMgYXJlIHRoZSBhY3R1YWwgcG9zaXRpb24gdGhlIHBvcHBlciBuZWVkcyB0byBoYXZlIHRvIGJlXG4gIC8vIHByb3Blcmx5IHBvc2l0aW9uZWQgbmVhciBpdHMgcmVmZXJlbmNlIGVsZW1lbnRcbiAgLy8gVGhpcyBpcyB0aGUgbW9zdCBiYXNpYyBwbGFjZW1lbnQsIGFuZCB3aWxsIGJlIGFkanVzdGVkIGJ5XG4gIC8vIHRoZSBtb2RpZmllcnMgaW4gdGhlIG5leHQgc3RlcFxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gY29tcHV0ZU9mZnNldHMoe1xuICAgIHJlZmVyZW5jZTogc3RhdGUucmVjdHMucmVmZXJlbmNlLFxuICAgIGVsZW1lbnQ6IHN0YXRlLnJlY3RzLnBvcHBlcixcbiAgICBzdHJhdGVneTogJ2Fic29sdXRlJyxcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxuICB9KTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbnZhciBwb3BwZXJPZmZzZXRzJDEgPSB7XG4gIG5hbWU6ICdwb3BwZXJPZmZzZXRzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdyZWFkJyxcbiAgZm46IHBvcHBlck9mZnNldHMsXG4gIGRhdGE6IHt9XG59O1xuXG5mdW5jdGlvbiBnZXRBbHRBeGlzKGF4aXMpIHtcbiAgcmV0dXJuIGF4aXMgPT09ICd4JyA/ICd5JyA6ICd4Jztcbn1cblxuZnVuY3Rpb24gcHJldmVudE92ZXJmbG93KF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICB2YXIgX29wdGlvbnMkbWFpbkF4aXMgPSBvcHRpb25zLm1haW5BeGlzLFxuICAgICAgY2hlY2tNYWluQXhpcyA9IF9vcHRpb25zJG1haW5BeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkbWFpbkF4aXMsXG4gICAgICBfb3B0aW9ucyRhbHRBeGlzID0gb3B0aW9ucy5hbHRBeGlzLFxuICAgICAgY2hlY2tBbHRBeGlzID0gX29wdGlvbnMkYWx0QXhpcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRhbHRBeGlzLFxuICAgICAgYm91bmRhcnkgPSBvcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeSA9IG9wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgX29wdGlvbnMkdGV0aGVyID0gb3B0aW9ucy50ZXRoZXIsXG4gICAgICB0ZXRoZXIgPSBfb3B0aW9ucyR0ZXRoZXIgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyR0ZXRoZXIsXG4gICAgICBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQgPSBvcHRpb25zLnRldGhlck9mZnNldCxcbiAgICAgIHRldGhlck9mZnNldCA9IF9vcHRpb25zJHRldGhlck9mZnNldCA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJHRldGhlck9mZnNldDtcbiAgdmFyIG92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgcGFkZGluZzogcGFkZGluZyxcbiAgICBhbHRCb3VuZGFyeTogYWx0Qm91bmRhcnlcbiAgfSk7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgdmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHN0YXRlLnBsYWNlbWVudCk7XG4gIHZhciBpc0Jhc2VQbGFjZW1lbnQgPSAhdmFyaWF0aW9uO1xuICB2YXIgbWFpbkF4aXMgPSBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCk7XG4gIHZhciBhbHRBeGlzID0gZ2V0QWx0QXhpcyhtYWluQXhpcyk7XG4gIHZhciBwb3BwZXJPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzO1xuICB2YXIgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciB0ZXRoZXJPZmZzZXRWYWx1ZSA9IHR5cGVvZiB0ZXRoZXJPZmZzZXQgPT09ICdmdW5jdGlvbicgPyB0ZXRoZXJPZmZzZXQoT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUucmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxuICB9KSkgOiB0ZXRoZXJPZmZzZXQ7XG4gIHZhciBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUgPSB0eXBlb2YgdGV0aGVyT2Zmc2V0VmFsdWUgPT09ICdudW1iZXInID8ge1xuICAgIG1haW5BeGlzOiB0ZXRoZXJPZmZzZXRWYWx1ZSxcbiAgICBhbHRBeGlzOiB0ZXRoZXJPZmZzZXRWYWx1ZVxuICB9IDogT2JqZWN0LmFzc2lnbih7XG4gICAgbWFpbkF4aXM6IDAsXG4gICAgYWx0QXhpczogMFxuICB9LCB0ZXRoZXJPZmZzZXRWYWx1ZSk7XG4gIHZhciBvZmZzZXRNb2RpZmllclN0YXRlID0gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXQgPyBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldFtzdGF0ZS5wbGFjZW1lbnRdIDogbnVsbDtcbiAgdmFyIGRhdGEgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG5cbiAgaWYgKCFwb3BwZXJPZmZzZXRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICB2YXIgX29mZnNldE1vZGlmaWVyU3RhdGUkO1xuXG4gICAgdmFyIG1haW5TaWRlID0gbWFpbkF4aXMgPT09ICd5JyA/IHRvcCA6IGxlZnQ7XG4gICAgdmFyIGFsdFNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gYm90dG9tIDogcmlnaHQ7XG4gICAgdmFyIGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgdmFyIG9mZnNldCA9IHBvcHBlck9mZnNldHNbbWFpbkF4aXNdO1xuICAgIHZhciBtaW4kMSA9IG9mZnNldCArIG92ZXJmbG93W21haW5TaWRlXTtcbiAgICB2YXIgbWF4JDEgPSBvZmZzZXQgLSBvdmVyZmxvd1thbHRTaWRlXTtcbiAgICB2YXIgYWRkaXRpdmUgPSB0ZXRoZXIgPyAtcG9wcGVyUmVjdFtsZW5dIC8gMiA6IDA7XG4gICAgdmFyIG1pbkxlbiA9IHZhcmlhdGlvbiA9PT0gc3RhcnQgPyByZWZlcmVuY2VSZWN0W2xlbl0gOiBwb3BwZXJSZWN0W2xlbl07XG4gICAgdmFyIG1heExlbiA9IHZhcmlhdGlvbiA9PT0gc3RhcnQgPyAtcG9wcGVyUmVjdFtsZW5dIDogLXJlZmVyZW5jZVJlY3RbbGVuXTsgLy8gV2UgbmVlZCB0byBpbmNsdWRlIHRoZSBhcnJvdyBpbiB0aGUgY2FsY3VsYXRpb24gc28gdGhlIGFycm93IGRvZXNuJ3QgZ29cbiAgICAvLyBvdXRzaWRlIHRoZSByZWZlcmVuY2UgYm91bmRzXG5cbiAgICB2YXIgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3c7XG4gICAgdmFyIGFycm93UmVjdCA9IHRldGhlciAmJiBhcnJvd0VsZW1lbnQgPyBnZXRMYXlvdXRSZWN0KGFycm93RWxlbWVudCkgOiB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH07XG4gICAgdmFyIGFycm93UGFkZGluZ09iamVjdCA9IHN0YXRlLm1vZGlmaWVyc0RhdGFbJ2Fycm93I3BlcnNpc3RlbnQnXSA/IHN0YXRlLm1vZGlmaWVyc0RhdGFbJ2Fycm93I3BlcnNpc3RlbnQnXS5wYWRkaW5nIDogZ2V0RnJlc2hTaWRlT2JqZWN0KCk7XG4gICAgdmFyIGFycm93UGFkZGluZ01pbiA9IGFycm93UGFkZGluZ09iamVjdFttYWluU2lkZV07XG4gICAgdmFyIGFycm93UGFkZGluZ01heCA9IGFycm93UGFkZGluZ09iamVjdFthbHRTaWRlXTsgLy8gSWYgdGhlIHJlZmVyZW5jZSBsZW5ndGggaXMgc21hbGxlciB0aGFuIHRoZSBhcnJvdyBsZW5ndGgsIHdlIGRvbid0IHdhbnRcbiAgICAvLyB0byBpbmNsdWRlIGl0cyBmdWxsIHNpemUgaW4gdGhlIGNhbGN1bGF0aW9uLiBJZiB0aGUgcmVmZXJlbmNlIGlzIHNtYWxsXG4gICAgLy8gYW5kIG5lYXIgdGhlIGVkZ2Ugb2YgYSBib3VuZGFyeSwgdGhlIHBvcHBlciBjYW4gb3ZlcmZsb3cgZXZlbiBpZiB0aGVcbiAgICAvLyByZWZlcmVuY2UgaXMgbm90IG92ZXJmbG93aW5nIGFzIHdlbGwgKGUuZy4gdmlydHVhbCBlbGVtZW50cyB3aXRoIG5vXG4gICAgLy8gd2lkdGggb3IgaGVpZ2h0KVxuXG4gICAgdmFyIGFycm93TGVuID0gd2l0aGluKDAsIHJlZmVyZW5jZVJlY3RbbGVuXSwgYXJyb3dSZWN0W2xlbl0pO1xuICAgIHZhciBtaW5PZmZzZXQgPSBpc0Jhc2VQbGFjZW1lbnQgPyByZWZlcmVuY2VSZWN0W2xlbl0gLyAyIC0gYWRkaXRpdmUgLSBhcnJvd0xlbiAtIGFycm93UGFkZGluZ01pbiAtIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcyA6IG1pbkxlbiAtIGFycm93TGVuIC0gYXJyb3dQYWRkaW5nTWluIC0gbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzO1xuICAgIHZhciBtYXhPZmZzZXQgPSBpc0Jhc2VQbGFjZW1lbnQgPyAtcmVmZXJlbmNlUmVjdFtsZW5dIC8gMiArIGFkZGl0aXZlICsgYXJyb3dMZW4gKyBhcnJvd1BhZGRpbmdNYXggKyBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXMgOiBtYXhMZW4gKyBhcnJvd0xlbiArIGFycm93UGFkZGluZ01heCArIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcztcbiAgICB2YXIgYXJyb3dPZmZzZXRQYXJlbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdyAmJiBnZXRPZmZzZXRQYXJlbnQoc3RhdGUuZWxlbWVudHMuYXJyb3cpO1xuICAgIHZhciBjbGllbnRPZmZzZXQgPSBhcnJvd09mZnNldFBhcmVudCA/IG1haW5BeGlzID09PSAneScgPyBhcnJvd09mZnNldFBhcmVudC5jbGllbnRUb3AgfHwgMCA6IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudExlZnQgfHwgMCA6IDA7XG4gICAgdmFyIG9mZnNldE1vZGlmaWVyVmFsdWUgPSAoX29mZnNldE1vZGlmaWVyU3RhdGUkID0gb2Zmc2V0TW9kaWZpZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogb2Zmc2V0TW9kaWZpZXJTdGF0ZVttYWluQXhpc10pICE9IG51bGwgPyBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQgOiAwO1xuICAgIHZhciB0ZXRoZXJNaW4gPSBvZmZzZXQgKyBtaW5PZmZzZXQgLSBvZmZzZXRNb2RpZmllclZhbHVlIC0gY2xpZW50T2Zmc2V0O1xuICAgIHZhciB0ZXRoZXJNYXggPSBvZmZzZXQgKyBtYXhPZmZzZXQgLSBvZmZzZXRNb2RpZmllclZhbHVlO1xuICAgIHZhciBwcmV2ZW50ZWRPZmZzZXQgPSB3aXRoaW4odGV0aGVyID8gbWluKG1pbiQxLCB0ZXRoZXJNaW4pIDogbWluJDEsIG9mZnNldCwgdGV0aGVyID8gbWF4KG1heCQxLCB0ZXRoZXJNYXgpIDogbWF4JDEpO1xuICAgIHBvcHBlck9mZnNldHNbbWFpbkF4aXNdID0gcHJldmVudGVkT2Zmc2V0O1xuICAgIGRhdGFbbWFpbkF4aXNdID0gcHJldmVudGVkT2Zmc2V0IC0gb2Zmc2V0O1xuICB9XG5cbiAgaWYgKGNoZWNrQWx0QXhpcykge1xuICAgIHZhciBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQyO1xuXG4gICAgdmFyIF9tYWluU2lkZSA9IG1haW5BeGlzID09PSAneCcgPyB0b3AgOiBsZWZ0O1xuXG4gICAgdmFyIF9hbHRTaWRlID0gbWFpbkF4aXMgPT09ICd4JyA/IGJvdHRvbSA6IHJpZ2h0O1xuXG4gICAgdmFyIF9vZmZzZXQgPSBwb3BwZXJPZmZzZXRzW2FsdEF4aXNdO1xuXG4gICAgdmFyIF9sZW4gPSBhbHRBeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgICB2YXIgX21pbiA9IF9vZmZzZXQgKyBvdmVyZmxvd1tfbWFpblNpZGVdO1xuXG4gICAgdmFyIF9tYXggPSBfb2Zmc2V0IC0gb3ZlcmZsb3dbX2FsdFNpZGVdO1xuXG4gICAgdmFyIGlzT3JpZ2luU2lkZSA9IFt0b3AsIGxlZnRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuXG4gICAgdmFyIF9vZmZzZXRNb2RpZmllclZhbHVlID0gKF9vZmZzZXRNb2RpZmllclN0YXRlJDIgPSBvZmZzZXRNb2RpZmllclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBvZmZzZXRNb2RpZmllclN0YXRlW2FsdEF4aXNdKSAhPSBudWxsID8gX29mZnNldE1vZGlmaWVyU3RhdGUkMiA6IDA7XG5cbiAgICB2YXIgX3RldGhlck1pbiA9IGlzT3JpZ2luU2lkZSA/IF9taW4gOiBfb2Zmc2V0IC0gcmVmZXJlbmNlUmVjdFtfbGVuXSAtIHBvcHBlclJlY3RbX2xlbl0gLSBfb2Zmc2V0TW9kaWZpZXJWYWx1ZSArIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5hbHRBeGlzO1xuXG4gICAgdmFyIF90ZXRoZXJNYXggPSBpc09yaWdpblNpZGUgPyBfb2Zmc2V0ICsgcmVmZXJlbmNlUmVjdFtfbGVuXSArIHBvcHBlclJlY3RbX2xlbl0gLSBfb2Zmc2V0TW9kaWZpZXJWYWx1ZSAtIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5hbHRBeGlzIDogX21heDtcblxuICAgIHZhciBfcHJldmVudGVkT2Zmc2V0ID0gdGV0aGVyICYmIGlzT3JpZ2luU2lkZSA/IHdpdGhpbk1heENsYW1wKF90ZXRoZXJNaW4sIF9vZmZzZXQsIF90ZXRoZXJNYXgpIDogd2l0aGluKHRldGhlciA/IF90ZXRoZXJNaW4gOiBfbWluLCBfb2Zmc2V0LCB0ZXRoZXIgPyBfdGV0aGVyTWF4IDogX21heCk7XG5cbiAgICBwb3BwZXJPZmZzZXRzW2FsdEF4aXNdID0gX3ByZXZlbnRlZE9mZnNldDtcbiAgICBkYXRhW2FsdEF4aXNdID0gX3ByZXZlbnRlZE9mZnNldCAtIF9vZmZzZXQ7XG4gIH1cblxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gZGF0YTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbnZhciBwcmV2ZW50T3ZlcmZsb3ckMSA9IHtcbiAgbmFtZTogJ3ByZXZlbnRPdmVyZmxvdycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBwcmV2ZW50T3ZlcmZsb3csXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsnb2Zmc2V0J11cbn07XG5cbmZ1bmN0aW9uIGdldEhUTUxFbGVtZW50U2Nyb2xsKGVsZW1lbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBlbGVtZW50LnNjcm9sbExlZnQsXG4gICAgc2Nyb2xsVG9wOiBlbGVtZW50LnNjcm9sbFRvcFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXROb2RlU2Nyb2xsKG5vZGUpIHtcbiAgaWYgKG5vZGUgPT09IGdldFdpbmRvdyhub2RlKSB8fCAhaXNIVE1MRWxlbWVudChub2RlKSkge1xuICAgIHJldHVybiBnZXRXaW5kb3dTY3JvbGwobm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdldEhUTUxFbGVtZW50U2Nyb2xsKG5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzRWxlbWVudFNjYWxlZChlbGVtZW50KSB7XG4gIHZhciByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHNjYWxlWCA9IHJvdW5kKHJlY3Qud2lkdGgpIC8gZWxlbWVudC5vZmZzZXRXaWR0aCB8fCAxO1xuICB2YXIgc2NhbGVZID0gcm91bmQocmVjdC5oZWlnaHQpIC8gZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgMTtcbiAgcmV0dXJuIHNjYWxlWCAhPT0gMSB8fCBzY2FsZVkgIT09IDE7XG59IC8vIFJldHVybnMgdGhlIGNvbXBvc2l0ZSByZWN0IG9mIGFuIGVsZW1lbnQgcmVsYXRpdmUgdG8gaXRzIG9mZnNldFBhcmVudC5cbi8vIENvbXBvc2l0ZSBtZWFucyBpdCB0YWtlcyBpbnRvIGFjY291bnQgdHJhbnNmb3JtcyBhcyB3ZWxsIGFzIGxheW91dC5cblxuXG5mdW5jdGlvbiBnZXRDb21wb3NpdGVSZWN0KGVsZW1lbnRPclZpcnR1YWxFbGVtZW50LCBvZmZzZXRQYXJlbnQsIGlzRml4ZWQpIHtcbiAgaWYgKGlzRml4ZWQgPT09IHZvaWQgMCkge1xuICAgIGlzRml4ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBpc09mZnNldFBhcmVudEFuRWxlbWVudCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgdmFyIG9mZnNldFBhcmVudElzU2NhbGVkID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGlzRWxlbWVudFNjYWxlZChvZmZzZXRQYXJlbnQpO1xuICB2YXIgZG9jdW1lbnRFbGVtZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIHZhciByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnRPclZpcnR1YWxFbGVtZW50LCBvZmZzZXRQYXJlbnRJc1NjYWxlZCwgaXNGaXhlZCk7XG4gIHZhciBzY3JvbGwgPSB7XG4gICAgc2Nyb2xsTGVmdDogMCxcbiAgICBzY3JvbGxUb3A6IDBcbiAgfTtcbiAgdmFyIG9mZnNldHMgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG5cbiAgaWYgKGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50IHx8ICFpc09mZnNldFBhcmVudEFuRWxlbWVudCAmJiAhaXNGaXhlZCkge1xuICAgIGlmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpICE9PSAnYm9keScgfHwgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy8xMDc4XG4gICAgaXNTY3JvbGxQYXJlbnQoZG9jdW1lbnRFbGVtZW50KSkge1xuICAgICAgc2Nyb2xsID0gZ2V0Tm9kZVNjcm9sbChvZmZzZXRQYXJlbnQpO1xuICAgIH1cblxuICAgIGlmIChpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCkpIHtcbiAgICAgIG9mZnNldHMgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50LCB0cnVlKTtcbiAgICAgIG9mZnNldHMueCArPSBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcbiAgICAgIG9mZnNldHMueSArPSBvZmZzZXRQYXJlbnQuY2xpZW50VG9wO1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICBvZmZzZXRzLnggPSBnZXRXaW5kb3dTY3JvbGxCYXJYKGRvY3VtZW50RWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiByZWN0LmxlZnQgKyBzY3JvbGwuc2Nyb2xsTGVmdCAtIG9mZnNldHMueCxcbiAgICB5OiByZWN0LnRvcCArIHNjcm9sbC5zY3JvbGxUb3AgLSBvZmZzZXRzLnksXG4gICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodFxuICB9O1xufVxuXG5mdW5jdGlvbiBvcmRlcihtb2RpZmllcnMpIHtcbiAgdmFyIG1hcCA9IG5ldyBNYXAoKTtcbiAgdmFyIHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgbWFwLnNldChtb2RpZmllci5uYW1lLCBtb2RpZmllcik7XG4gIH0pOyAvLyBPbiB2aXNpdGluZyBvYmplY3QsIGNoZWNrIGZvciBpdHMgZGVwZW5kZW5jaWVzIGFuZCB2aXNpdCB0aGVtIHJlY3Vyc2l2ZWx5XG5cbiAgZnVuY3Rpb24gc29ydChtb2RpZmllcikge1xuICAgIHZpc2l0ZWQuYWRkKG1vZGlmaWVyLm5hbWUpO1xuICAgIHZhciByZXF1aXJlcyA9IFtdLmNvbmNhdChtb2RpZmllci5yZXF1aXJlcyB8fCBbXSwgbW9kaWZpZXIucmVxdWlyZXNJZkV4aXN0cyB8fCBbXSk7XG4gICAgcmVxdWlyZXMuZm9yRWFjaChmdW5jdGlvbiAoZGVwKSB7XG4gICAgICBpZiAoIXZpc2l0ZWQuaGFzKGRlcCkpIHtcbiAgICAgICAgdmFyIGRlcE1vZGlmaWVyID0gbWFwLmdldChkZXApO1xuXG4gICAgICAgIGlmIChkZXBNb2RpZmllcikge1xuICAgICAgICAgIHNvcnQoZGVwTW9kaWZpZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmVzdWx0LnB1c2gobW9kaWZpZXIpO1xuICB9XG5cbiAgbW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgaWYgKCF2aXNpdGVkLmhhcyhtb2RpZmllci5uYW1lKSkge1xuICAgICAgLy8gY2hlY2sgZm9yIHZpc2l0ZWQgb2JqZWN0XG4gICAgICBzb3J0KG1vZGlmaWVyKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBvcmRlck1vZGlmaWVycyhtb2RpZmllcnMpIHtcbiAgLy8gb3JkZXIgYmFzZWQgb24gZGVwZW5kZW5jaWVzXG4gIHZhciBvcmRlcmVkTW9kaWZpZXJzID0gb3JkZXIobW9kaWZpZXJzKTsgLy8gb3JkZXIgYmFzZWQgb24gcGhhc2VcblxuICByZXR1cm4gbW9kaWZpZXJQaGFzZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBoYXNlKSB7XG4gICAgcmV0dXJuIGFjYy5jb25jYXQob3JkZXJlZE1vZGlmaWVycy5maWx0ZXIoZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgICByZXR1cm4gbW9kaWZpZXIucGhhc2UgPT09IHBoYXNlO1xuICAgIH0pKTtcbiAgfSwgW10pO1xufVxuXG5mdW5jdGlvbiBkZWJvdW5jZShmbikge1xuICB2YXIgcGVuZGluZztcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXBlbmRpbmcpIHtcbiAgICAgIHBlbmRpbmcgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBwZW5kaW5nID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHJlc29sdmUoZm4oKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBlbmRpbmc7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZvcm1hdChzdHIpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIFtdLmNvbmNhdChhcmdzKS5yZWR1Y2UoZnVuY3Rpb24gKHAsIGMpIHtcbiAgICByZXR1cm4gcC5yZXBsYWNlKC8lcy8sIGMpO1xuICB9LCBzdHIpO1xufVxuXG52YXIgSU5WQUxJRF9NT0RJRklFUl9FUlJPUiA9ICdQb3BwZXI6IG1vZGlmaWVyIFwiJXNcIiBwcm92aWRlZCBhbiBpbnZhbGlkICVzIHByb3BlcnR5LCBleHBlY3RlZCAlcyBidXQgZ290ICVzJztcbnZhciBNSVNTSU5HX0RFUEVOREVOQ1lfRVJST1IgPSAnUG9wcGVyOiBtb2RpZmllciBcIiVzXCIgcmVxdWlyZXMgXCIlc1wiLCBidXQgXCIlc1wiIG1vZGlmaWVyIGlzIG5vdCBhdmFpbGFibGUnO1xudmFyIFZBTElEX1BST1BFUlRJRVMgPSBbJ25hbWUnLCAnZW5hYmxlZCcsICdwaGFzZScsICdmbicsICdlZmZlY3QnLCAncmVxdWlyZXMnLCAnb3B0aW9ucyddO1xuZnVuY3Rpb24gdmFsaWRhdGVNb2RpZmllcnMobW9kaWZpZXJzKSB7XG4gIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIFtdLmNvbmNhdChPYmplY3Qua2V5cyhtb2RpZmllciksIFZBTElEX1BST1BFUlRJRVMpIC8vIElFMTEtY29tcGF0aWJsZSByZXBsYWNlbWVudCBmb3IgYG5ldyBTZXQoaXRlcmFibGUpYFxuICAgIC5maWx0ZXIoZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgc2VsZikge1xuICAgICAgcmV0dXJuIHNlbGYuaW5kZXhPZih2YWx1ZSkgPT09IGluZGV4O1xuICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgY2FzZSAnbmFtZSc6XG4gICAgICAgICAgaWYgKHR5cGVvZiBtb2RpZmllci5uYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihmb3JtYXQoSU5WQUxJRF9NT0RJRklFUl9FUlJPUiwgU3RyaW5nKG1vZGlmaWVyLm5hbWUpLCAnXCJuYW1lXCInLCAnXCJzdHJpbmdcIicsIFwiXFxcIlwiICsgU3RyaW5nKG1vZGlmaWVyLm5hbWUpICsgXCJcXFwiXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdlbmFibGVkJzpcbiAgICAgICAgICBpZiAodHlwZW9mIG1vZGlmaWVyLmVuYWJsZWQgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihmb3JtYXQoSU5WQUxJRF9NT0RJRklFUl9FUlJPUiwgbW9kaWZpZXIubmFtZSwgJ1wiZW5hYmxlZFwiJywgJ1wiYm9vbGVhblwiJywgXCJcXFwiXCIgKyBTdHJpbmcobW9kaWZpZXIuZW5hYmxlZCkgKyBcIlxcXCJcIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3BoYXNlJzpcbiAgICAgICAgICBpZiAobW9kaWZpZXJQaGFzZXMuaW5kZXhPZihtb2RpZmllci5waGFzZSkgPCAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGZvcm1hdChJTlZBTElEX01PRElGSUVSX0VSUk9SLCBtb2RpZmllci5uYW1lLCAnXCJwaGFzZVwiJywgXCJlaXRoZXIgXCIgKyBtb2RpZmllclBoYXNlcy5qb2luKCcsICcpLCBcIlxcXCJcIiArIFN0cmluZyhtb2RpZmllci5waGFzZSkgKyBcIlxcXCJcIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2ZuJzpcbiAgICAgICAgICBpZiAodHlwZW9mIG1vZGlmaWVyLmZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGZvcm1hdChJTlZBTElEX01PRElGSUVSX0VSUk9SLCBtb2RpZmllci5uYW1lLCAnXCJmblwiJywgJ1wiZnVuY3Rpb25cIicsIFwiXFxcIlwiICsgU3RyaW5nKG1vZGlmaWVyLmZuKSArIFwiXFxcIlwiKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZWZmZWN0JzpcbiAgICAgICAgICBpZiAobW9kaWZpZXIuZWZmZWN0ICE9IG51bGwgJiYgdHlwZW9mIG1vZGlmaWVyLmVmZmVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihmb3JtYXQoSU5WQUxJRF9NT0RJRklFUl9FUlJPUiwgbW9kaWZpZXIubmFtZSwgJ1wiZWZmZWN0XCInLCAnXCJmdW5jdGlvblwiJywgXCJcXFwiXCIgKyBTdHJpbmcobW9kaWZpZXIuZm4pICsgXCJcXFwiXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdyZXF1aXJlcyc6XG4gICAgICAgICAgaWYgKG1vZGlmaWVyLnJlcXVpcmVzICE9IG51bGwgJiYgIUFycmF5LmlzQXJyYXkobW9kaWZpZXIucmVxdWlyZXMpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGZvcm1hdChJTlZBTElEX01PRElGSUVSX0VSUk9SLCBtb2RpZmllci5uYW1lLCAnXCJyZXF1aXJlc1wiJywgJ1wiYXJyYXlcIicsIFwiXFxcIlwiICsgU3RyaW5nKG1vZGlmaWVyLnJlcXVpcmVzKSArIFwiXFxcIlwiKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncmVxdWlyZXNJZkV4aXN0cyc6XG4gICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1vZGlmaWVyLnJlcXVpcmVzSWZFeGlzdHMpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGZvcm1hdChJTlZBTElEX01PRElGSUVSX0VSUk9SLCBtb2RpZmllci5uYW1lLCAnXCJyZXF1aXJlc0lmRXhpc3RzXCInLCAnXCJhcnJheVwiJywgXCJcXFwiXCIgKyBTdHJpbmcobW9kaWZpZXIucmVxdWlyZXNJZkV4aXN0cykgKyBcIlxcXCJcIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ29wdGlvbnMnOlxuICAgICAgICBjYXNlICdkYXRhJzpcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJQb3BwZXJKUzogYW4gaW52YWxpZCBwcm9wZXJ0eSBoYXMgYmVlbiBwcm92aWRlZCB0byB0aGUgXFxcIlwiICsgbW9kaWZpZXIubmFtZSArIFwiXFxcIiBtb2RpZmllciwgdmFsaWQgcHJvcGVydGllcyBhcmUgXCIgKyBWQUxJRF9QUk9QRVJUSUVTLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgcmV0dXJuIFwiXFxcIlwiICsgcyArIFwiXFxcIlwiO1xuICAgICAgICAgIH0pLmpvaW4oJywgJykgKyBcIjsgYnV0IFxcXCJcIiArIGtleSArIFwiXFxcIiB3YXMgcHJvdmlkZWQuXCIpO1xuICAgICAgfVxuXG4gICAgICBtb2RpZmllci5yZXF1aXJlcyAmJiBtb2RpZmllci5yZXF1aXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChyZXF1aXJlbWVudCkge1xuICAgICAgICBpZiAobW9kaWZpZXJzLmZpbmQoZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICAgIHJldHVybiBtb2QubmFtZSA9PT0gcmVxdWlyZW1lbnQ7XG4gICAgICAgIH0pID09IG51bGwpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGZvcm1hdChNSVNTSU5HX0RFUEVOREVOQ1lfRVJST1IsIFN0cmluZyhtb2RpZmllci5uYW1lKSwgcmVxdWlyZW1lbnQsIHJlcXVpcmVtZW50KSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdW5pcXVlQnkoYXJyLCBmbikge1xuICB2YXIgaWRlbnRpZmllcnMgPSBuZXcgU2V0KCk7XG4gIHJldHVybiBhcnIuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgdmFyIGlkZW50aWZpZXIgPSBmbihpdGVtKTtcblxuICAgIGlmICghaWRlbnRpZmllcnMuaGFzKGlkZW50aWZpZXIpKSB7XG4gICAgICBpZGVudGlmaWVycy5hZGQoaWRlbnRpZmllcik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBtZXJnZUJ5TmFtZShtb2RpZmllcnMpIHtcbiAgdmFyIG1lcmdlZCA9IG1vZGlmaWVycy5yZWR1Y2UoZnVuY3Rpb24gKG1lcmdlZCwgY3VycmVudCkge1xuICAgIHZhciBleGlzdGluZyA9IG1lcmdlZFtjdXJyZW50Lm5hbWVdO1xuICAgIG1lcmdlZFtjdXJyZW50Lm5hbWVdID0gZXhpc3RpbmcgPyBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZywgY3VycmVudCwge1xuICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgZXhpc3Rpbmcub3B0aW9ucywgY3VycmVudC5vcHRpb25zKSxcbiAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLmRhdGEsIGN1cnJlbnQuZGF0YSlcbiAgICB9KSA6IGN1cnJlbnQ7XG4gICAgcmV0dXJuIG1lcmdlZDtcbiAgfSwge30pOyAvLyBJRTExIGRvZXMgbm90IHN1cHBvcnQgT2JqZWN0LnZhbHVlc1xuXG4gIHJldHVybiBPYmplY3Qua2V5cyhtZXJnZWQpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIG1lcmdlZFtrZXldO1xuICB9KTtcbn1cblxudmFyIElOVkFMSURfRUxFTUVOVF9FUlJPUiA9ICdQb3BwZXI6IEludmFsaWQgcmVmZXJlbmNlIG9yIHBvcHBlciBhcmd1bWVudCBwcm92aWRlZC4gVGhleSBtdXN0IGJlIGVpdGhlciBhIERPTSBlbGVtZW50IG9yIHZpcnR1YWwgZWxlbWVudC4nO1xudmFyIElORklOSVRFX0xPT1BfRVJST1IgPSAnUG9wcGVyOiBBbiBpbmZpbml0ZSBsb29wIGluIHRoZSBtb2RpZmllcnMgY3ljbGUgaGFzIGJlZW4gZGV0ZWN0ZWQhIFRoZSBjeWNsZSBoYXMgYmVlbiBpbnRlcnJ1cHRlZCB0byBwcmV2ZW50IGEgYnJvd3NlciBjcmFzaC4nO1xudmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgcGxhY2VtZW50OiAnYm90dG9tJyxcbiAgbW9kaWZpZXJzOiBbXSxcbiAgc3RyYXRlZ3k6ICdhYnNvbHV0ZSdcbn07XG5cbmZ1bmN0aW9uIGFyZVZhbGlkRWxlbWVudHMoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gIWFyZ3Muc29tZShmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHJldHVybiAhKGVsZW1lbnQgJiYgdHlwZW9mIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID09PSAnZnVuY3Rpb24nKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHBvcHBlckdlbmVyYXRvcihnZW5lcmF0b3JPcHRpb25zKSB7XG4gIGlmIChnZW5lcmF0b3JPcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBnZW5lcmF0b3JPcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX2dlbmVyYXRvck9wdGlvbnMgPSBnZW5lcmF0b3JPcHRpb25zLFxuICAgICAgX2dlbmVyYXRvck9wdGlvbnMkZGVmID0gX2dlbmVyYXRvck9wdGlvbnMuZGVmYXVsdE1vZGlmaWVycyxcbiAgICAgIGRlZmF1bHRNb2RpZmllcnMgPSBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYgPT09IHZvaWQgMCA/IFtdIDogX2dlbmVyYXRvck9wdGlvbnMkZGVmLFxuICAgICAgX2dlbmVyYXRvck9wdGlvbnMkZGVmMiA9IF9nZW5lcmF0b3JPcHRpb25zLmRlZmF1bHRPcHRpb25zLFxuICAgICAgZGVmYXVsdE9wdGlvbnMgPSBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyID09PSB2b2lkIDAgPyBERUZBVUxUX09QVElPTlMgOiBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyO1xuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlUG9wcGVyKHJlZmVyZW5jZSwgcG9wcGVyLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuICAgIH1cblxuICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gICAgICBvcmRlcmVkTW9kaWZpZXJzOiBbXSxcbiAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgZGVmYXVsdE9wdGlvbnMpLFxuICAgICAgbW9kaWZpZXJzRGF0YToge30sXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICByZWZlcmVuY2U6IHJlZmVyZW5jZSxcbiAgICAgICAgcG9wcGVyOiBwb3BwZXJcbiAgICAgIH0sXG4gICAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICAgIHN0eWxlczoge31cbiAgICB9O1xuICAgIHZhciBlZmZlY3RDbGVhbnVwRm5zID0gW107XG4gICAgdmFyIGlzRGVzdHJveWVkID0gZmFsc2U7XG4gICAgdmFyIGluc3RhbmNlID0ge1xuICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgc2V0T3B0aW9uczogZnVuY3Rpb24gc2V0T3B0aW9ucyhzZXRPcHRpb25zQWN0aW9uKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdHlwZW9mIHNldE9wdGlvbnNBY3Rpb24gPT09ICdmdW5jdGlvbicgPyBzZXRPcHRpb25zQWN0aW9uKHN0YXRlLm9wdGlvbnMpIDogc2V0T3B0aW9uc0FjdGlvbjtcbiAgICAgICAgY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpO1xuICAgICAgICBzdGF0ZS5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIHN0YXRlLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICBzdGF0ZS5zY3JvbGxQYXJlbnRzID0ge1xuICAgICAgICAgIHJlZmVyZW5jZTogaXNFbGVtZW50KHJlZmVyZW5jZSkgPyBsaXN0U2Nyb2xsUGFyZW50cyhyZWZlcmVuY2UpIDogcmVmZXJlbmNlLmNvbnRleHRFbGVtZW50ID8gbGlzdFNjcm9sbFBhcmVudHMocmVmZXJlbmNlLmNvbnRleHRFbGVtZW50KSA6IFtdLFxuICAgICAgICAgIHBvcHBlcjogbGlzdFNjcm9sbFBhcmVudHMocG9wcGVyKVxuICAgICAgICB9OyAvLyBPcmRlcnMgdGhlIG1vZGlmaWVycyBiYXNlZCBvbiB0aGVpciBkZXBlbmRlbmNpZXMgYW5kIGBwaGFzZWBcbiAgICAgICAgLy8gcHJvcGVydGllc1xuXG4gICAgICAgIHZhciBvcmRlcmVkTW9kaWZpZXJzID0gb3JkZXJNb2RpZmllcnMobWVyZ2VCeU5hbWUoW10uY29uY2F0KGRlZmF1bHRNb2RpZmllcnMsIHN0YXRlLm9wdGlvbnMubW9kaWZpZXJzKSkpOyAvLyBTdHJpcCBvdXQgZGlzYWJsZWQgbW9kaWZpZXJzXG5cbiAgICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyZWRNb2RpZmllcnMuZmlsdGVyKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgcmV0dXJuIG0uZW5hYmxlZDtcbiAgICAgICAgfSk7IC8vIFZhbGlkYXRlIHRoZSBwcm92aWRlZCBtb2RpZmllcnMgc28gdGhhdCB0aGUgY29uc3VtZXIgd2lsbCBnZXQgd2FybmVkXG4gICAgICAgIC8vIGlmIG9uZSBvZiB0aGUgbW9kaWZpZXJzIGlzIGludmFsaWQgZm9yIGFueSByZWFzb25cblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgdmFyIG1vZGlmaWVycyA9IHVuaXF1ZUJ5KFtdLmNvbmNhdChvcmRlcmVkTW9kaWZpZXJzLCBzdGF0ZS5vcHRpb25zLm1vZGlmaWVycyksIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IF9yZWYubmFtZTtcbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhbGlkYXRlTW9kaWZpZXJzKG1vZGlmaWVycyk7XG5cbiAgICAgICAgICBpZiAoZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5vcHRpb25zLnBsYWNlbWVudCkgPT09IGF1dG8pIHtcbiAgICAgICAgICAgIHZhciBmbGlwTW9kaWZpZXIgPSBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmZpbmQoZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICAgICAgICAgIHZhciBuYW1lID0gX3JlZjIubmFtZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5hbWUgPT09ICdmbGlwJztcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIWZsaXBNb2RpZmllcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFsnUG9wcGVyOiBcImF1dG9cIiBwbGFjZW1lbnRzIHJlcXVpcmUgdGhlIFwiZmxpcFwiIG1vZGlmaWVyIGJlJywgJ3ByZXNlbnQgYW5kIGVuYWJsZWQgdG8gd29yay4nXS5qb2luKCcgJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfZ2V0Q29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUocG9wcGVyKSxcbiAgICAgICAgICAgICAgbWFyZ2luVG9wID0gX2dldENvbXB1dGVkU3R5bGUubWFyZ2luVG9wLFxuICAgICAgICAgICAgICBtYXJnaW5SaWdodCA9IF9nZXRDb21wdXRlZFN0eWxlLm1hcmdpblJpZ2h0LFxuICAgICAgICAgICAgICBtYXJnaW5Cb3R0b20gPSBfZ2V0Q29tcHV0ZWRTdHlsZS5tYXJnaW5Cb3R0b20sXG4gICAgICAgICAgICAgIG1hcmdpbkxlZnQgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5tYXJnaW5MZWZ0OyAvLyBXZSBubyBsb25nZXIgdGFrZSBpbnRvIGFjY291bnQgYG1hcmdpbnNgIG9uIHRoZSBwb3BwZXIsIGFuZCBpdCBjYW5cbiAgICAgICAgICAvLyBjYXVzZSBidWdzIHdpdGggcG9zaXRpb25pbmcsIHNvIHdlJ2xsIHdhcm4gdGhlIGNvbnN1bWVyXG5cblxuICAgICAgICAgIGlmIChbbWFyZ2luVG9wLCBtYXJnaW5SaWdodCwgbWFyZ2luQm90dG9tLCBtYXJnaW5MZWZ0XS5zb21lKGZ1bmN0aW9uIChtYXJnaW4pIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KG1hcmdpbik7XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihbJ1BvcHBlcjogQ1NTIFwibWFyZ2luXCIgc3R5bGVzIGNhbm5vdCBiZSB1c2VkIHRvIGFwcGx5IHBhZGRpbmcnLCAnYmV0d2VlbiB0aGUgcG9wcGVyIGFuZCBpdHMgcmVmZXJlbmNlIGVsZW1lbnQgb3IgYm91bmRhcnkuJywgJ1RvIHJlcGxpY2F0ZSBtYXJnaW4sIHVzZSB0aGUgYG9mZnNldGAgbW9kaWZpZXIsIGFzIHdlbGwgYXMnLCAndGhlIGBwYWRkaW5nYCBvcHRpb24gaW4gdGhlIGBwcmV2ZW50T3ZlcmZsb3dgIGFuZCBgZmxpcGAnLCAnbW9kaWZpZXJzLiddLmpvaW4oJyAnKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcnVuTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgIH0sXG4gICAgICAvLyBTeW5jIHVwZGF0ZSDigJMgaXQgd2lsbCBhbHdheXMgYmUgZXhlY3V0ZWQsIGV2ZW4gaWYgbm90IG5lY2Vzc2FyeS4gVGhpc1xuICAgICAgLy8gaXMgdXNlZnVsIGZvciBsb3cgZnJlcXVlbmN5IHVwZGF0ZXMgd2hlcmUgc3luYyBiZWhhdmlvciBzaW1wbGlmaWVzIHRoZVxuICAgICAgLy8gbG9naWMuXG4gICAgICAvLyBGb3IgaGlnaCBmcmVxdWVuY3kgdXBkYXRlcyAoZS5nLiBgcmVzaXplYCBhbmQgYHNjcm9sbGAgZXZlbnRzKSwgYWx3YXlzXG4gICAgICAvLyBwcmVmZXIgdGhlIGFzeW5jIFBvcHBlciN1cGRhdGUgbWV0aG9kXG4gICAgICBmb3JjZVVwZGF0ZTogZnVuY3Rpb24gZm9yY2VVcGRhdGUoKSB7XG4gICAgICAgIGlmIChpc0Rlc3Ryb3llZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfc3RhdGUkZWxlbWVudHMgPSBzdGF0ZS5lbGVtZW50cyxcbiAgICAgICAgICAgIHJlZmVyZW5jZSA9IF9zdGF0ZSRlbGVtZW50cy5yZWZlcmVuY2UsXG4gICAgICAgICAgICBwb3BwZXIgPSBfc3RhdGUkZWxlbWVudHMucG9wcGVyOyAvLyBEb24ndCBwcm9jZWVkIGlmIGByZWZlcmVuY2VgIG9yIGBwb3BwZXJgIGFyZSBub3QgdmFsaWQgZWxlbWVudHNcbiAgICAgICAgLy8gYW55bW9yZVxuXG4gICAgICAgIGlmICghYXJlVmFsaWRFbGVtZW50cyhyZWZlcmVuY2UsIHBvcHBlcikpIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKElOVkFMSURfRUxFTUVOVF9FUlJPUik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIFN0b3JlIHRoZSByZWZlcmVuY2UgYW5kIHBvcHBlciByZWN0cyB0byBiZSByZWFkIGJ5IG1vZGlmaWVyc1xuXG5cbiAgICAgICAgc3RhdGUucmVjdHMgPSB7XG4gICAgICAgICAgcmVmZXJlbmNlOiBnZXRDb21wb3NpdGVSZWN0KHJlZmVyZW5jZSwgZ2V0T2Zmc2V0UGFyZW50KHBvcHBlciksIHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3kgPT09ICdmaXhlZCcpLFxuICAgICAgICAgIHBvcHBlcjogZ2V0TGF5b3V0UmVjdChwb3BwZXIpXG4gICAgICAgIH07IC8vIE1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIHJlc2V0IHRoZSBjdXJyZW50IHVwZGF0ZSBjeWNsZS4gVGhlXG4gICAgICAgIC8vIG1vc3QgY29tbW9uIHVzZSBjYXNlIGZvciB0aGlzIGlzIHRoZSBgZmxpcGAgbW9kaWZpZXIgY2hhbmdpbmcgdGhlXG4gICAgICAgIC8vIHBsYWNlbWVudCwgd2hpY2ggdGhlbiBuZWVkcyB0byByZS1ydW4gYWxsIHRoZSBtb2RpZmllcnMsIGJlY2F1c2UgdGhlXG4gICAgICAgIC8vIGxvZ2ljIHdhcyBwcmV2aW91c2x5IHJhbiBmb3IgdGhlIHByZXZpb3VzIHBsYWNlbWVudCBhbmQgaXMgdGhlcmVmb3JlXG4gICAgICAgIC8vIHN0YWxlL2luY29ycmVjdFxuXG4gICAgICAgIHN0YXRlLnJlc2V0ID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLnBsYWNlbWVudCA9IHN0YXRlLm9wdGlvbnMucGxhY2VtZW50OyAvLyBPbiBlYWNoIHVwZGF0ZSBjeWNsZSwgdGhlIGBtb2RpZmllcnNEYXRhYCBwcm9wZXJ0eSBmb3IgZWFjaCBtb2RpZmllclxuICAgICAgICAvLyBpcyBmaWxsZWQgd2l0aCB0aGUgaW5pdGlhbCBkYXRhIHNwZWNpZmllZCBieSB0aGUgbW9kaWZpZXIuIFRoaXMgbWVhbnNcbiAgICAgICAgLy8gaXQgZG9lc24ndCBwZXJzaXN0IGFuZCBpcyBmcmVzaCBvbiBlYWNoIHVwZGF0ZS5cbiAgICAgICAgLy8gVG8gZW5zdXJlIHBlcnNpc3RlbnQgZGF0YSwgdXNlIGAke25hbWV9I3BlcnNpc3RlbnRgXG5cbiAgICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgICAgICAgIHJldHVybiBzdGF0ZS5tb2RpZmllcnNEYXRhW21vZGlmaWVyLm5hbWVdID0gT2JqZWN0LmFzc2lnbih7fSwgbW9kaWZpZXIuZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgX19kZWJ1Z19sb29wc19fID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBfX2RlYnVnX2xvb3BzX18gKz0gMTtcblxuICAgICAgICAgICAgaWYgKF9fZGVidWdfbG9vcHNfXyA+IDEwMCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKElORklOSVRFX0xPT1BfRVJST1IpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3RhdGUucmVzZXQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHN0YXRlLnJlc2V0ID0gZmFsc2U7XG4gICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9zdGF0ZSRvcmRlcmVkTW9kaWZpZSA9IHN0YXRlLm9yZGVyZWRNb2RpZmllcnNbaW5kZXhdLFxuICAgICAgICAgICAgICBmbiA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZS5mbixcbiAgICAgICAgICAgICAgX3N0YXRlJG9yZGVyZWRNb2RpZmllMiA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZS5vcHRpb25zLFxuICAgICAgICAgICAgICBfb3B0aW9ucyA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIgPT09IHZvaWQgMCA/IHt9IDogX3N0YXRlJG9yZGVyZWRNb2RpZmllMixcbiAgICAgICAgICAgICAgbmFtZSA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZS5uYW1lO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc3RhdGUgPSBmbih7XG4gICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgICAgb3B0aW9uczogX29wdGlvbnMsXG4gICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZVxuICAgICAgICAgICAgfSkgfHwgc3RhdGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gQXN5bmMgYW5kIG9wdGltaXN0aWNhbGx5IG9wdGltaXplZCB1cGRhdGUg4oCTIGl0IHdpbGwgbm90IGJlIGV4ZWN1dGVkIGlmXG4gICAgICAvLyBub3QgbmVjZXNzYXJ5IChkZWJvdW5jZWQgdG8gcnVuIGF0IG1vc3Qgb25jZS1wZXItdGljaylcbiAgICAgIHVwZGF0ZTogZGVib3VuY2UoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICBpbnN0YW5jZS5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgIHJlc29sdmUoc3RhdGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pLFxuICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpO1xuICAgICAgICBpc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmICghYXJlVmFsaWRFbGVtZW50cyhyZWZlcmVuY2UsIHBvcHBlcikpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihJTlZBTElEX0VMRU1FTlRfRVJST1IpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgaWYgKCFpc0Rlc3Ryb3llZCAmJiBvcHRpb25zLm9uRmlyc3RVcGRhdGUpIHtcbiAgICAgICAgb3B0aW9ucy5vbkZpcnN0VXBkYXRlKHN0YXRlKTtcbiAgICAgIH1cbiAgICB9KTsgLy8gTW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gZXhlY3V0ZSBhcmJpdHJhcnkgY29kZSBiZWZvcmUgdGhlIGZpcnN0XG4gICAgLy8gdXBkYXRlIGN5Y2xlIHJ1bnMuIFRoZXkgd2lsbCBiZSBleGVjdXRlZCBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGUgdXBkYXRlXG4gICAgLy8gY3ljbGUuIFRoaXMgaXMgdXNlZnVsIHdoZW4gYSBtb2RpZmllciBhZGRzIHNvbWUgcGVyc2lzdGVudCBkYXRhIHRoYXRcbiAgICAvLyBvdGhlciBtb2RpZmllcnMgbmVlZCB0byB1c2UsIGJ1dCB0aGUgbW9kaWZpZXIgaXMgcnVuIGFmdGVyIHRoZSBkZXBlbmRlbnRcbiAgICAvLyBvbmUuXG5cbiAgICBmdW5jdGlvbiBydW5Nb2RpZmllckVmZmVjdHMoKSB7XG4gICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgICAgIHZhciBuYW1lID0gX3JlZjMubmFtZSxcbiAgICAgICAgICAgIF9yZWYzJG9wdGlvbnMgPSBfcmVmMy5vcHRpb25zLFxuICAgICAgICAgICAgb3B0aW9ucyA9IF9yZWYzJG9wdGlvbnMgPT09IHZvaWQgMCA/IHt9IDogX3JlZjMkb3B0aW9ucyxcbiAgICAgICAgICAgIGVmZmVjdCA9IF9yZWYzLmVmZmVjdDtcblxuICAgICAgICBpZiAodHlwZW9mIGVmZmVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciBjbGVhbnVwRm4gPSBlZmZlY3Qoe1xuICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBub29wRm4gPSBmdW5jdGlvbiBub29wRm4oKSB7fTtcblxuICAgICAgICAgIGVmZmVjdENsZWFudXBGbnMucHVzaChjbGVhbnVwRm4gfHwgbm9vcEZuKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpIHtcbiAgICAgIGVmZmVjdENsZWFudXBGbnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICB9KTtcbiAgICAgIGVmZmVjdENsZWFudXBGbnMgPSBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG59XG5cbnZhciBkZWZhdWx0TW9kaWZpZXJzID0gW2V2ZW50TGlzdGVuZXJzLCBwb3BwZXJPZmZzZXRzJDEsIGNvbXB1dGVTdHlsZXMkMSwgYXBwbHlTdHlsZXMkMSwgb2Zmc2V0JDEsIGZsaXAkMSwgcHJldmVudE92ZXJmbG93JDEsIGFycm93JDEsIGhpZGUkMV07XG52YXIgY3JlYXRlUG9wcGVyID0gLyojX19QVVJFX18qL3BvcHBlckdlbmVyYXRvcih7XG4gIGRlZmF1bHRNb2RpZmllcnM6IGRlZmF1bHRNb2RpZmllcnNcbn0pOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbnZhciB1c2VQb3BwZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgdmFyIGxldmVsID0gb3B0aW9ucy5sZXZlbCwgYnV0dG9uUmVmID0gb3B0aW9ucy5idXR0b25SZWYsIGNvbnRlbnRSZWYgPSBvcHRpb25zLmNvbnRlbnRSZWY7XHJcbiAgICB2YXIgX2EgPSBSZWFjdF9fZGVmYXVsdC51c2VDb250ZXh0KFNpZGViYXJDb250ZXh0KSwgY29sbGFwc2VkID0gX2EuY29sbGFwc2VkLCB0b2dnbGVkID0gX2EudG9nZ2xlZCwgdHJhbnNpdGlvbkR1cmF0aW9uID0gX2EudHJhbnNpdGlvbkR1cmF0aW9uO1xyXG4gICAgdmFyIHBvcHBlckluc3RhbmNlUmVmID0gUmVhY3RfX2RlZmF1bHQudXNlUmVmKCk7XHJcbiAgICAvKipcclxuICAgICAqIGNyZWF0ZSBwb3BwZXIgaW5zdGFuY2Ugb25seSBvbiBmaXJzdCBsZXZlbCBzdWJtZW51IGNvbXBvbmVudHMgYW5kIHdoZW4gc2lkZWJhciBpcyBjb2xsYXBzZWRcclxuICAgICAqL1xyXG4gICAgUmVhY3RfX2RlZmF1bHQudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAobGV2ZWwgPT09IDAgJiYgY29sbGFwc2VkICYmIGNvbnRlbnRSZWYuY3VycmVudCAmJiBidXR0b25SZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICBwb3BwZXJJbnN0YW5jZVJlZi5jdXJyZW50ID0gY3JlYXRlUG9wcGVyKGJ1dHRvblJlZi5jdXJyZW50LCBjb250ZW50UmVmLmN1cnJlbnQsIHtcclxuICAgICAgICAgICAgICAgIHBsYWNlbWVudDogJ3JpZ2h0JyxcclxuICAgICAgICAgICAgICAgIHN0cmF0ZWd5OiAnZml4ZWQnLFxyXG4gICAgICAgICAgICAgICAgbW9kaWZpZXJzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnb2Zmc2V0JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBbMCwgNV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgX2E7IHJldHVybiAoX2EgPSBwb3BwZXJJbnN0YW5jZVJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVzdHJveSgpOyB9O1xyXG4gICAgfSwgW2xldmVsLCBjb2xsYXBzZWQsIGNvbnRlbnRSZWYsIGJ1dHRvblJlZl0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiB1cGRhdGUgcG9wcGVyIGluc3RhbmNlIChwb3NpdGlvbikgd2hlbiBidXR0b25SZWYgb3IgY29udGVudFJlZiBjaGFuZ2VzXHJcbiAgICAgKi9cclxuICAgIFJlYWN0X19kZWZhdWx0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGNvbnRlbnRSZWYuY3VycmVudCAmJiBidXR0b25SZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICB2YXIgcm8gPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgKF9hID0gcG9wcGVySW5zdGFuY2VSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcm8ub2JzZXJ2ZShjb250ZW50UmVmLmN1cnJlbnQpO1xyXG4gICAgICAgICAgICByby5vYnNlcnZlKGJ1dHRvblJlZi5jdXJyZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgKF9hID0gcG9wcGVySW5zdGFuY2VSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVwZGF0ZSgpO1xyXG4gICAgICAgIH0sIHRyYW5zaXRpb25EdXJhdGlvbik7XHJcbiAgICB9LCBbdHJhbnNpdGlvbkR1cmF0aW9uLCB0b2dnbGVkLCBjb250ZW50UmVmLCBidXR0b25SZWZdKTtcclxuICAgIHJldHVybiB7IHBvcHBlckluc3RhbmNlOiBwb3BwZXJJbnN0YW5jZVJlZi5jdXJyZW50IH07XHJcbn07XG5cbnZhciBtZW51QnV0dG9uU3R5bGVzID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcbiAgICB2YXIgcnRsID0gcHJvcHMucnRsLCBsZXZlbCA9IHByb3BzLmxldmVsLCBjb2xsYXBzZWQgPSBwcm9wcy5jb2xsYXBzZWQsIGRpc2FibGVkID0gcHJvcHMuZGlzYWJsZWQsIGFjdGl2ZSA9IHByb3BzLmFjdGl2ZTtcclxuICAgIHJldHVybiBcIlxcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBoZWlnaHQ6IDUwcHg7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gICAgY29sb3I6IGluaGVyaXQ7XFxuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG5cXG4gICAgXCIuY29uY2F0KHJ0bFxyXG4gICAgICAgID8gXCJwYWRkaW5nLWxlZnQ6IDIwcHg7XFxuICAgICAgICAgICBwYWRkaW5nLXJpZ2h0OiBcIi5jb25jYXQobGV2ZWwgPT09IDAgPyAyMCA6IChjb2xsYXBzZWQgPyBsZXZlbCA6IGxldmVsICsgMSkgKiAyMCwgXCJweDtcXG4gICAgICAgICAgICBcIilcclxuICAgICAgICA6IFwicGFkZGluZy1yaWdodDogMjBweDtcXG4gICAgICAgICAgIHBhZGRpbmctbGVmdDogXCIuY29uY2F0KGxldmVsID09PSAwID8gMjAgOiAoY29sbGFwc2VkID8gbGV2ZWwgOiBsZXZlbCArIDEpICogMjAsIFwicHg7XFxuICAgICAgICAgICBcIiksIFwiXFxuXFxuICAgICY6aG92ZXIge1xcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmM2YzZjM7XFxuICAgIH1cXG5cXG4gICAgXCIpLmNvbmNhdChkaXNhYmxlZCAmJlxyXG4gICAgICAgIFwiIFxcbiAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbiAgICAgIGN1cnNvcjogZGVmYXVsdDtcXG4gICAgICBjb2xvcjojYWRhZGFkO1xcbiAgICAgICAgXCIsIFwiXFxuXFxuICAgIFwiKS5jb25jYXQoYWN0aXZlICYmICdiYWNrZ3JvdW5kLWNvbG9yOiAjZTJlZWY5OycsIFwiXFxuICBcXG4gIFwiKTtcclxufTtcclxudmFyIE1lbnVCdXR0b25SZWYgPSBmdW5jdGlvbiAoX2EsIHJlZikge1xyXG4gICAgdmFyIGNsYXNzTmFtZSA9IF9hLmNsYXNzTmFtZSwgY29tcG9uZW50ID0gX2EuY29tcG9uZW50LCBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCByZXN0ID0gX19yZXN0KF9hLCBbXCJjbGFzc05hbWVcIiwgXCJjb21wb25lbnRcIiwgXCJjaGlsZHJlblwiXSk7XHJcbiAgICBpZiAoY29tcG9uZW50KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjb21wb25lbnQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KGNvbXBvbmVudCwgX19hc3NpZ24oX19hc3NpZ24oeyBjbGFzc05hbWU6IGNsYXNzbmFtZXMoY2xhc3NOYW1lKSB9LCByZXN0KSwgeyByZWY6IHJlZiB9KSwgY2hpbGRyZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIF9iID0gY29tcG9uZW50LnByb3BzLCBjbGFzc05hbWVQcm9wID0gX2IuY2xhc3NOYW1lLCBwcm9wcyA9IF9fcmVzdChfYiwgW1wiY2xhc3NOYW1lXCJdKTtcclxuICAgICAgICAgICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNsb25lRWxlbWVudChjb21wb25lbnQsIF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHsgY2xhc3NOYW1lOiBjbGFzc25hbWVzKGNsYXNzTmFtZSwgY2xhc3NOYW1lUHJvcCkgfSwgcmVzdCksIHByb3BzKSwgeyByZWY6IHJlZiB9KSwgY2hpbGRyZW4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImFcIiwgX19hc3NpZ24oeyByZWY6IHJlZiwgY2xhc3NOYW1lOiBjbGFzc25hbWVzKGNsYXNzTmFtZSkgfSwgcmVzdCksIGNoaWxkcmVuKSk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBNZW51QnV0dG9uID0gUmVhY3RfX2RlZmF1bHQuZm9yd2FyZFJlZihNZW51QnV0dG9uUmVmKTtcblxudmFyIFN0eWxlZFN1Yk1lbnUgPSBuZXdTdHlsZWQubGkodGVtcGxhdGVPYmplY3RfMSQxIHx8ICh0ZW1wbGF0ZU9iamVjdF8xJDEgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHdpZHRoOiAxMDAlO1xcblxcbiAgXCIsIFwiO1xcblxcbiAgXCIsIFwiO1xcblxcbiAgPiAuXCIsIFwiIHtcXG4gICAgXCIsIFwiO1xcblxcbiAgICBcIiwgXCI7XFxuICB9XFxuXCJdLCBbXCJcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHdpZHRoOiAxMDAlO1xcblxcbiAgXCIsIFwiO1xcblxcbiAgXCIsIFwiO1xcblxcbiAgPiAuXCIsIFwiIHtcXG4gICAgXCIsIFwiO1xcblxcbiAgICBcIiwgXCI7XFxuICB9XFxuXCJdKSksIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIG1lbnVJdGVtU3R5bGVzID0gX2EubWVudUl0ZW1TdHlsZXM7XHJcbiAgICByZXR1cm4gbWVudUl0ZW1TdHlsZXM7XHJcbn0sIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIHJvb3RTdHlsZXMgPSBfYS5yb290U3R5bGVzO1xyXG4gICAgcmV0dXJuIHJvb3RTdHlsZXM7XHJcbn0sIG1lbnVDbGFzc2VzLmJ1dHRvbiwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgbGV2ZWwgPSBfYS5sZXZlbCwgZGlzYWJsZWQgPSBfYS5kaXNhYmxlZCwgYWN0aXZlID0gX2EuYWN0aXZlLCBjb2xsYXBzZWQgPSBfYS5jb2xsYXBzZWQsIHJ0bCA9IF9hLnJ0bDtcclxuICAgIHJldHVybiBtZW51QnV0dG9uU3R5bGVzKHtcclxuICAgICAgICBsZXZlbDogbGV2ZWwsXHJcbiAgICAgICAgZGlzYWJsZWQ6IGRpc2FibGVkLFxyXG4gICAgICAgIGFjdGl2ZTogYWN0aXZlLFxyXG4gICAgICAgIGNvbGxhcHNlZDogY29sbGFwc2VkLFxyXG4gICAgICAgIHJ0bDogcnRsLFxyXG4gICAgfSk7XHJcbn0sIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIGJ1dHRvblN0eWxlcyA9IF9hLmJ1dHRvblN0eWxlcztcclxuICAgIHJldHVybiBidXR0b25TdHlsZXM7XHJcbn0pO1xyXG52YXIgU3ViTWVudUZSID0gZnVuY3Rpb24gKF9hLCByZWYpIHtcclxuICAgIHZhciBfYjtcclxuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBjbGFzc05hbWUgPSBfYS5jbGFzc05hbWUsIGxhYmVsID0gX2EubGFiZWwsIGljb24gPSBfYS5pY29uLCB0aXRsZSA9IF9hLnRpdGxlLCBwcmVmaXggPSBfYS5wcmVmaXgsIHN1ZmZpeCA9IF9hLnN1ZmZpeCwgb3BlbkNvbnRyb2xsZWQgPSBfYS5vcGVuLCBkZWZhdWx0T3BlbiA9IF9hLmRlZmF1bHRPcGVuLCBfYyA9IF9hLmFjdGl2ZSwgYWN0aXZlID0gX2MgPT09IHZvaWQgMCA/IGZhbHNlIDogX2MsIF9kID0gX2EuZGlzYWJsZWQsIGRpc2FibGVkID0gX2QgPT09IHZvaWQgMCA/IGZhbHNlIDogX2QsIHJvb3RTdHlsZXMgPSBfYS5yb290U3R5bGVzLCBjb21wb25lbnQgPSBfYS5jb21wb25lbnQsIG9uT3BlbkNoYW5nZSA9IF9hLm9uT3BlbkNoYW5nZSwgb25DbGljayA9IF9hLm9uQ2xpY2ssIG9uS2V5VXAgPSBfYS5vbktleVVwLCByZXN0ID0gX19yZXN0KF9hLCBbXCJjaGlsZHJlblwiLCBcImNsYXNzTmFtZVwiLCBcImxhYmVsXCIsIFwiaWNvblwiLCBcInRpdGxlXCIsIFwicHJlZml4XCIsIFwic3VmZml4XCIsIFwib3BlblwiLCBcImRlZmF1bHRPcGVuXCIsIFwiYWN0aXZlXCIsIFwiZGlzYWJsZWRcIiwgXCJyb290U3R5bGVzXCIsIFwiY29tcG9uZW50XCIsIFwib25PcGVuQ2hhbmdlXCIsIFwib25DbGlja1wiLCBcIm9uS2V5VXBcIl0pO1xyXG4gICAgdmFyIGxldmVsID0gUmVhY3RfX2RlZmF1bHQudXNlQ29udGV4dChMZXZlbENvbnRleHQpO1xyXG4gICAgdmFyIF9lID0gUmVhY3RfX2RlZmF1bHQudXNlQ29udGV4dChTaWRlYmFyQ29udGV4dCksIGNvbGxhcHNlZCA9IF9lLmNvbGxhcHNlZCwgcnRsID0gX2UucnRsLCBzaWRlYmFyVHJhbnNpdGlvbkR1cmF0aW9uID0gX2UudHJhbnNpdGlvbkR1cmF0aW9uO1xyXG4gICAgdmFyIF9mID0gdXNlTWVudSgpLCByZW5kZXJFeHBhbmRJY29uID0gX2YucmVuZGVyRXhwYW5kSWNvbiwgY2xvc2VPbkNsaWNrID0gX2YuY2xvc2VPbkNsaWNrLCBtZW51SXRlbVN0eWxlcyA9IF9mLm1lbnVJdGVtU3R5bGVzLCB0cmFuc2l0aW9uRHVyYXRpb24gPSBfZi50cmFuc2l0aW9uRHVyYXRpb247XHJcbiAgICB2YXIgX2cgPSBSZWFjdF9fZGVmYXVsdC51c2VTdGF0ZSghIWRlZmF1bHRPcGVuKSwgb3BlbiA9IF9nWzBdLCBzZXRPcGVuID0gX2dbMV07XHJcbiAgICB2YXIgX2ggPSBSZWFjdF9fZGVmYXVsdC51c2VTdGF0ZShmYWxzZSksIG9wZW5XaGVuQ29sbGFwc2VkID0gX2hbMF0sIHNldE9wZW5XaGVuQ29sbGFwc2VkID0gX2hbMV07XHJcbiAgICB2YXIgX2ogPSBSZWFjdF9fZGVmYXVsdC51c2VTdGF0ZShmYWxzZSksIG1vdW50ZWQgPSBfalswXSwgc2V0TW91bnRlZCA9IF9qWzFdO1xyXG4gICAgdmFyIGJ1dHRvblJlZiA9IFJlYWN0X19kZWZhdWx0LnVzZVJlZihudWxsKTtcclxuICAgIHZhciBjb250ZW50UmVmID0gUmVhY3RfX2RlZmF1bHQudXNlUmVmKG51bGwpO1xyXG4gICAgdmFyIHRpbWVyID0gUmVhY3RfX2RlZmF1bHQudXNlUmVmKCk7XHJcbiAgICB2YXIgcG9wcGVySW5zdGFuY2UgPSB1c2VQb3BwZXIoe1xyXG4gICAgICAgIGxldmVsOiBsZXZlbCxcclxuICAgICAgICBidXR0b25SZWY6IGJ1dHRvblJlZixcclxuICAgICAgICBjb250ZW50UmVmOiBjb250ZW50UmVmLFxyXG4gICAgfSkucG9wcGVySW5zdGFuY2U7XHJcbiAgICB2YXIgc2xpZGVVcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdGFyZ2V0ID0gY29udGVudFJlZi5jdXJyZW50O1xyXG4gICAgICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG4gICAgICAgICAgICB0YXJnZXQuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcclxuICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLmhlaWdodCA9ICdhdXRvJztcclxuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHRhcmdldC5vZmZzZXRIZWlnaHQ7XHJcbiAgICAgICAgICAgIHRhcmdldC5zdHlsZS5oZWlnaHQgPSAnMHB4JztcclxuICAgICAgICAgICAgdGFyZ2V0Lm9mZnNldEhlaWdodDtcclxuICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLmhlaWdodCA9IFwiXCIuY29uY2F0KGhlaWdodCwgXCJweFwiKTtcclxuICAgICAgICAgICAgdGltZXIuY3VycmVudCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLm92ZXJmbG93ID0gJ2F1dG8nO1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLmhlaWdodCA9ICdhdXRvJztcclxuICAgICAgICAgICAgfSwgdHJhbnNpdGlvbkR1cmF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdmFyIHNsaWRlRG93biA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdGFyZ2V0ID0gY29udGVudFJlZi5jdXJyZW50O1xyXG4gICAgICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XHJcbiAgICAgICAgICAgIHRhcmdldC5zdHlsZS5oZWlnaHQgPSBcIlwiLmNvbmNhdCh0YXJnZXQub2Zmc2V0SGVpZ2h0LCBcInB4XCIpO1xyXG4gICAgICAgICAgICB0YXJnZXQub2Zmc2V0SGVpZ2h0O1xyXG4gICAgICAgICAgICB0YXJnZXQuc3R5bGUuaGVpZ2h0ID0gJzBweCc7XHJcbiAgICAgICAgICAgIHRpbWVyLmN1cnJlbnQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5zdHlsZS5vdmVyZmxvdyA9ICdhdXRvJztcclxuICAgICAgICAgICAgICAgIHRhcmdldC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgICAgICB9LCB0cmFuc2l0aW9uRHVyYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB2YXIgaGFuZGxlU2xpZGVUb2dnbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCEobGV2ZWwgPT09IDAgJiYgY29sbGFwc2VkKSkge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoTnVtYmVyKHRpbWVyLmN1cnJlbnQpKTtcclxuICAgICAgICAgICAgdmFyIG9wZW5WYWx1ZSA9IG9wZW5Db250cm9sbGVkICE9PSBudWxsICYmIG9wZW5Db250cm9sbGVkICE9PSB2b2lkIDAgPyBvcGVuQ29udHJvbGxlZCA6IG9wZW47XHJcbiAgICAgICAgICAgIG9wZW5WYWx1ZSA/IHNsaWRlRG93bigpIDogc2xpZGVVcCgpO1xyXG4gICAgICAgICAgICBvbk9wZW5DaGFuZ2UgPT09IG51bGwgfHwgb25PcGVuQ2hhbmdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbk9wZW5DaGFuZ2UoIW9wZW5WYWx1ZSk7XHJcbiAgICAgICAgICAgIHR5cGVvZiBvcGVuQ29udHJvbGxlZCA9PT0gJ3VuZGVmaW5lZCcgJiYgc2V0T3Blbighb3Blbik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHZhciBoYW5kbGVPbkNsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgb25DbGljayA9PT0gbnVsbCB8fCBvbkNsaWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkNsaWNrKGV2ZW50KTtcclxuICAgICAgICBoYW5kbGVTbGlkZVRvZ2dsZSgpO1xyXG4gICAgfTtcclxuICAgIHZhciBoYW5kbGVPbktleVVwID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgb25LZXlVcCA9PT0gbnVsbCB8fCBvbktleVVwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbktleVVwKGV2ZW50KTtcclxuICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnRW50ZXInKSB7XHJcbiAgICAgICAgICAgIGhhbmRsZVNsaWRlVG9nZ2xlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHZhciBnZXRTdWJNZW51SXRlbVN0eWxlcyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKG1lbnVJdGVtU3R5bGVzKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7IGxldmVsOiBsZXZlbCwgZGlzYWJsZWQ6IGRpc2FibGVkLCBhY3RpdmU6IGFjdGl2ZSwgaXNTdWJtZW51OiB0cnVlLCBvcGVuOiBvcGVuQ29udHJvbGxlZCAhPT0gbnVsbCAmJiBvcGVuQ29udHJvbGxlZCAhPT0gdm9pZCAwID8gb3BlbkNvbnRyb2xsZWQgOiBvcGVuIH07XHJcbiAgICAgICAgICAgIHZhciByb290RWxTdHlsZXMgPSBtZW51SXRlbVN0eWxlcy5yb290LCBidXR0b25FbFN0eWxlcyA9IG1lbnVJdGVtU3R5bGVzLmJ1dHRvbiwgbGFiZWxFbFN0eWxlcyA9IG1lbnVJdGVtU3R5bGVzLmxhYmVsLCBpY29uRWxTdHlsZXMgPSBtZW51SXRlbVN0eWxlcy5pY29uLCBwcmVmaXhFbFN0eWxlcyA9IG1lbnVJdGVtU3R5bGVzLnByZWZpeCwgc3VmZml4RWxTdHlsZXMgPSBtZW51SXRlbVN0eWxlcy5zdWZmaXgsIHN1Yk1lbnVDb250ZW50RWxTdHlsZXMgPSBtZW51SXRlbVN0eWxlcy5zdWJNZW51Q29udGVudCwgU3ViTWVudUV4cGFuZEljb25FbFN0eWxlcyA9IG1lbnVJdGVtU3R5bGVzLlN1Yk1lbnVFeHBhbmRJY29uO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3Jvb3QnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygcm9vdEVsU3R5bGVzID09PSAnZnVuY3Rpb24nID8gcm9vdEVsU3R5bGVzKHBhcmFtcykgOiByb290RWxTdHlsZXM7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdidXR0b24nOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYnV0dG9uRWxTdHlsZXMgPT09ICdmdW5jdGlvbicgPyBidXR0b25FbFN0eWxlcyhwYXJhbXMpIDogYnV0dG9uRWxTdHlsZXM7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdsYWJlbCc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBsYWJlbEVsU3R5bGVzID09PSAnZnVuY3Rpb24nID8gbGFiZWxFbFN0eWxlcyhwYXJhbXMpIDogbGFiZWxFbFN0eWxlcztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2ljb24nOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgaWNvbkVsU3R5bGVzID09PSAnZnVuY3Rpb24nID8gaWNvbkVsU3R5bGVzKHBhcmFtcykgOiBpY29uRWxTdHlsZXM7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdwcmVmaXgnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgcHJlZml4RWxTdHlsZXMgPT09ICdmdW5jdGlvbicgPyBwcmVmaXhFbFN0eWxlcyhwYXJhbXMpIDogcHJlZml4RWxTdHlsZXM7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdzdWZmaXgnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygc3VmZml4RWxTdHlsZXMgPT09ICdmdW5jdGlvbicgPyBzdWZmaXhFbFN0eWxlcyhwYXJhbXMpIDogc3VmZml4RWxTdHlsZXM7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdTdWJNZW51RXhwYW5kSWNvbic6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBTdWJNZW51RXhwYW5kSWNvbkVsU3R5bGVzID09PSAnZnVuY3Rpb24nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gU3ViTWVudUV4cGFuZEljb25FbFN0eWxlcyhwYXJhbXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogU3ViTWVudUV4cGFuZEljb25FbFN0eWxlcztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3N1Yk1lbnVDb250ZW50JzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHN1Yk1lbnVDb250ZW50RWxTdHlsZXMgPT09ICdmdW5jdGlvbidcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzdWJNZW51Q29udGVudEVsU3R5bGVzKHBhcmFtcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBzdWJNZW51Q29udGVudEVsU3R5bGVzO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFJlYWN0X19kZWZhdWx0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBwb3BwZXJJbnN0YW5jZSA9PT0gbnVsbCB8fCBwb3BwZXJJbnN0YW5jZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcG9wcGVySW5zdGFuY2UudXBkYXRlKCk7IH0sIHNpZGViYXJUcmFuc2l0aW9uRHVyYXRpb24pO1xyXG4gICAgICAgIGlmIChjb2xsYXBzZWQgJiYgbGV2ZWwgPT09IDApIHtcclxuICAgICAgICAgICAgc2V0T3BlbldoZW5Db2xsYXBzZWQoZmFsc2UpO1xyXG4gICAgICAgICAgICAvLyA/IGlmIGl0cyB1c2VmdWwgdG8gY2xvc2UgZmlyc3QgbGV2ZWwgc3VibWVudXMgb24gY29sbGFwc2Ugc2lkZWJhciB1bmNvbW1lbnQgdGhlIGNvZGUgYmVsb3dcclxuICAgICAgICAgICAgLy8gc2V0T3BlbihmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW2NvbGxhcHNlZCwgbGV2ZWwsIHJ0bCwgc2lkZWJhclRyYW5zaXRpb25EdXJhdGlvbiwgcG9wcGVySW5zdGFuY2VdKTtcclxuICAgIFJlYWN0X19kZWZhdWx0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGhhbmRsZVRvZ2dsZVBvcHBlciA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICAgICAgICAgIGlmICghb3BlbldoZW5Db2xsYXBzZWQgJiYgKChfYSA9IGJ1dHRvblJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29udGFpbnModGFyZ2V0KSkpXHJcbiAgICAgICAgICAgICAgICBzZXRPcGVuV2hlbkNvbGxhcHNlZCh0cnVlKTtcclxuICAgICAgICAgICAgZWxzZSBpZiAoKGNsb3NlT25DbGljayAmJlxyXG4gICAgICAgICAgICAgICAgISgoX2IgPSB0YXJnZXRcclxuICAgICAgICAgICAgICAgICAgICAuY2xvc2VzdChcIi5cIi5jb25jYXQobWVudUNsYXNzZXMubWVudUl0ZW1Sb290KSkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jbGFzc0xpc3QuY29udGFpbnMobWVudUNsYXNzZXMuc3ViTWVudVJvb3QpKSkgfHxcclxuICAgICAgICAgICAgICAgICghKChfYyA9IGNvbnRlbnRSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNvbnRhaW5zKHRhcmdldCkpICYmIG9wZW5XaGVuQ29sbGFwc2VkKSkge1xyXG4gICAgICAgICAgICAgICAgc2V0T3BlbldoZW5Db2xsYXBzZWQoZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgaGFuZGxlRG9jdW1lbnRDbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICBoYW5kbGVUb2dnbGVQb3BwZXIoZXZlbnQudGFyZ2V0KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBoYW5kbGVEb2N1bWVudEtleVVwID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChldmVudC5rZXkgPT09ICdFbnRlcicpIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZVRvZ2dsZVBvcHBlcihldmVudC50YXJnZXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleSA9PT0gJ0VzY2FwZScpIHtcclxuICAgICAgICAgICAgICAgIHNldE9wZW5XaGVuQ29sbGFwc2VkKGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHJlbW92ZUV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZURvY3VtZW50Q2xpY2spO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIGhhbmRsZURvY3VtZW50S2V5VXApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcclxuICAgICAgICBpZiAoY29sbGFwc2VkICYmIGxldmVsID09PSAwKSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlRG9jdW1lbnRDbGljaywgZmFsc2UpO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIGhhbmRsZURvY3VtZW50S2V5VXAsIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcclxuICAgICAgICB9O1xyXG4gICAgfSwgW2NvbGxhcHNlZCwgbGV2ZWwsIGNsb3NlT25DbGljaywgb3BlbldoZW5Db2xsYXBzZWRdKTtcclxuICAgIFJlYWN0X19kZWZhdWx0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2V0TW91bnRlZCh0cnVlKTtcclxuICAgIH0sIFtdKTtcclxuICAgIHZhciBzaGFyZWRDbGFzc2VzID0gKF9iID0ge30sXHJcbiAgICAgICAgX2JbbWVudUNsYXNzZXMuYWN0aXZlXSA9IGFjdGl2ZSxcclxuICAgICAgICBfYlttZW51Q2xhc3Nlcy5kaXNhYmxlZF0gPSBkaXNhYmxlZCxcclxuICAgICAgICBfYlttZW51Q2xhc3Nlcy5vcGVuXSA9IG9wZW5Db250cm9sbGVkICE9PSBudWxsICYmIG9wZW5Db250cm9sbGVkICE9PSB2b2lkIDAgPyBvcGVuQ29udHJvbGxlZCA6IG9wZW4sXHJcbiAgICAgICAgX2IpO1xyXG4gICAgcmV0dXJuIChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFN0eWxlZFN1Yk1lbnUsIHsgcmVmOiByZWYsIGNsYXNzTmFtZTogY2xhc3NuYW1lcyhtZW51Q2xhc3Nlcy5tZW51SXRlbVJvb3QsIG1lbnVDbGFzc2VzLnN1Yk1lbnVSb290LCBzaGFyZWRDbGFzc2VzLCBjbGFzc05hbWUpLCBtZW51SXRlbVN0eWxlczogZ2V0U3ViTWVudUl0ZW1TdHlsZXMoJ3Jvb3QnKSwgbGV2ZWw6IGxldmVsLCBjb2xsYXBzZWQ6IGNvbGxhcHNlZCwgcnRsOiBydGwsIGRpc2FibGVkOiBkaXNhYmxlZCwgYWN0aXZlOiBhY3RpdmUsIGJ1dHRvblN0eWxlczogZ2V0U3ViTWVudUl0ZW1TdHlsZXMoJ2J1dHRvbicpLCByb290U3R5bGVzOiByb290U3R5bGVzIH0sXHJcbiAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChNZW51QnV0dG9uLCBfX2Fzc2lnbih7IFwiZGF0YS10ZXN0aWRcIjogXCJcIi5jb25jYXQobWVudUNsYXNzZXMuYnV0dG9uLCBcIi10ZXN0LWlkXCIpLCByZWY6IGJ1dHRvblJlZiwgdGl0bGU6IHRpdGxlLCBjbGFzc05hbWU6IGNsYXNzbmFtZXMobWVudUNsYXNzZXMuYnV0dG9uLCBzaGFyZWRDbGFzc2VzKSwgb25DbGljazogaGFuZGxlT25DbGljaywgb25LZXlVcDogaGFuZGxlT25LZXlVcCwgY29tcG9uZW50OiBjb21wb25lbnQsIHRhYkluZGV4OiAwIH0sIHJlc3QpLFxyXG4gICAgICAgICAgICBpY29uICYmIChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFN0eWxlZE1lbnVJY29uLCB7IHJ0bDogcnRsLCBjbGFzc05hbWU6IGNsYXNzbmFtZXMobWVudUNsYXNzZXMuaWNvbiwgc2hhcmVkQ2xhc3NlcyksIHJvb3RTdHlsZXM6IGdldFN1Yk1lbnVJdGVtU3R5bGVzKCdpY29uJykgfSwgaWNvbikpLFxyXG4gICAgICAgICAgICBwcmVmaXggJiYgKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU3R5bGVkTWVudVByZWZpeCwgeyBjb2xsYXBzZWQ6IGNvbGxhcHNlZCwgdHJhbnNpdGlvbkR1cmF0aW9uOiBzaWRlYmFyVHJhbnNpdGlvbkR1cmF0aW9uLCBmaXJzdExldmVsOiBsZXZlbCA9PT0gMCwgY2xhc3NOYW1lOiBjbGFzc25hbWVzKG1lbnVDbGFzc2VzLnByZWZpeCwgc2hhcmVkQ2xhc3NlcyksIHJ0bDogcnRsLCByb290U3R5bGVzOiBnZXRTdWJNZW51SXRlbVN0eWxlcygncHJlZml4JykgfSwgcHJlZml4KSksXHJcbiAgICAgICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU3R5bGVkTWVudUxhYmVsLCB7IGNsYXNzTmFtZTogY2xhc3NuYW1lcyhtZW51Q2xhc3Nlcy5sYWJlbCwgc2hhcmVkQ2xhc3NlcyksIHJvb3RTdHlsZXM6IGdldFN1Yk1lbnVJdGVtU3R5bGVzKCdsYWJlbCcpIH0sIGxhYmVsKSxcclxuICAgICAgICAgICAgc3VmZml4ICYmIChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFN0eWxlZE1lbnVTdWZmaXgsIHsgY29sbGFwc2VkOiBjb2xsYXBzZWQsIHRyYW5zaXRpb25EdXJhdGlvbjogc2lkZWJhclRyYW5zaXRpb25EdXJhdGlvbiwgZmlyc3RMZXZlbDogbGV2ZWwgPT09IDAsIGNsYXNzTmFtZTogY2xhc3NuYW1lcyhtZW51Q2xhc3Nlcy5zdWZmaXgsIHNoYXJlZENsYXNzZXMpLCByb290U3R5bGVzOiBnZXRTdWJNZW51SXRlbVN0eWxlcygnc3VmZml4JykgfSwgc3VmZml4KSksXHJcbiAgICAgICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU3R5bGVkRXhwYW5kSWNvbldyYXBwZXIsIHsgcnRsOiBydGwsIGNsYXNzTmFtZTogY2xhc3NuYW1lcyhtZW51Q2xhc3Nlcy5TdWJNZW51RXhwYW5kSWNvbiwgc2hhcmVkQ2xhc3NlcyksIGNvbGxhcHNlZDogY29sbGFwc2VkLCBsZXZlbDogbGV2ZWwsIHJvb3RTdHlsZXM6IGdldFN1Yk1lbnVJdGVtU3R5bGVzKCdTdWJNZW51RXhwYW5kSWNvbicpIH0sIHJlbmRlckV4cGFuZEljb24gPyAocmVuZGVyRXhwYW5kSWNvbih7XHJcbiAgICAgICAgICAgICAgICBsZXZlbDogbGV2ZWwsXHJcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogZGlzYWJsZWQsXHJcbiAgICAgICAgICAgICAgICBhY3RpdmU6IGFjdGl2ZSxcclxuICAgICAgICAgICAgICAgIG9wZW46IG9wZW5Db250cm9sbGVkICE9PSBudWxsICYmIG9wZW5Db250cm9sbGVkICE9PSB2b2lkIDAgPyBvcGVuQ29udHJvbGxlZCA6IG9wZW4sXHJcbiAgICAgICAgICAgIH0pKSA6IGNvbGxhcHNlZCAmJiBsZXZlbCA9PT0gMCA/IChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFN0eWxlZEV4cGFuZEljb25Db2xsYXBzZWQsIG51bGwpKSA6IChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFN0eWxlZEV4cGFuZEljb24sIHsgcnRsOiBydGwsIG9wZW46IG9wZW5Db250cm9sbGVkICE9PSBudWxsICYmIG9wZW5Db250cm9sbGVkICE9PSB2b2lkIDAgPyBvcGVuQ29udHJvbGxlZCA6IG9wZW4gfSkpKSksXHJcbiAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChTdWJNZW51Q29udGVudCwgeyByZWY6IGNvbnRlbnRSZWYsIG9wZW5XaGVuQ29sbGFwc2VkOiBvcGVuV2hlbkNvbGxhcHNlZCwgb3Blbjogb3BlbkNvbnRyb2xsZWQgIT09IG51bGwgJiYgb3BlbkNvbnRyb2xsZWQgIT09IHZvaWQgMCA/IG9wZW5Db250cm9sbGVkIDogb3BlbiwgZmlyc3RMZXZlbDogbGV2ZWwgPT09IDAsIGNvbGxhcHNlZDogY29sbGFwc2VkLCBkZWZhdWx0T3BlbjogKG9wZW5Db250cm9sbGVkICYmICFtb3VudGVkKSB8fCBkZWZhdWx0T3BlbiwgY2xhc3NOYW1lOiBjbGFzc25hbWVzKG1lbnVDbGFzc2VzLnN1Yk1lbnVDb250ZW50LCBzaGFyZWRDbGFzc2VzKSwgcm9vdFN0eWxlczogZ2V0U3ViTWVudUl0ZW1TdHlsZXMoJ3N1Yk1lbnVDb250ZW50JykgfSxcclxuICAgICAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChMZXZlbENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGxldmVsICsgMSB9LCBjaGlsZHJlbikpKSk7XHJcbn07XHJcbnZhciBTdWJNZW51ID0gUmVhY3RfX2RlZmF1bHQuZm9yd2FyZFJlZihTdWJNZW51RlIpO1xyXG52YXIgdGVtcGxhdGVPYmplY3RfMSQxO1xuXG52YXIgU3R5bGVkTWVudUl0ZW0gPSBuZXdTdHlsZWQubGkodGVtcGxhdGVPYmplY3RfMSB8fCAodGVtcGxhdGVPYmplY3RfMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgd2lkdGg6IDEwMCU7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuXFxuICBcIiwgXCI7XFxuXFxuICBcIiwgXCI7XFxuXFxuICA+IC5cIiwgXCIge1xcbiAgICBcIiwgXCI7XFxuXFxuICAgIFwiLCBcIjtcXG4gIH1cXG5cIl0sIFtcIlxcbiAgd2lkdGg6IDEwMCU7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuXFxuICBcIiwgXCI7XFxuXFxuICBcIiwgXCI7XFxuXFxuICA+IC5cIiwgXCIge1xcbiAgICBcIiwgXCI7XFxuXFxuICAgIFwiLCBcIjtcXG4gIH1cXG5cIl0pKSwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgbWVudUl0ZW1TdHlsZXMgPSBfYS5tZW51SXRlbVN0eWxlcztcclxuICAgIHJldHVybiBtZW51SXRlbVN0eWxlcztcclxufSwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgcm9vdFN0eWxlcyA9IF9hLnJvb3RTdHlsZXM7XHJcbiAgICByZXR1cm4gcm9vdFN0eWxlcztcclxufSwgbWVudUNsYXNzZXMuYnV0dG9uLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciBsZXZlbCA9IF9hLmxldmVsLCBkaXNhYmxlZCA9IF9hLmRpc2FibGVkLCBhY3RpdmUgPSBfYS5hY3RpdmUsIGNvbGxhcHNlZCA9IF9hLmNvbGxhcHNlZCwgcnRsID0gX2EucnRsO1xyXG4gICAgcmV0dXJuIG1lbnVCdXR0b25TdHlsZXMoe1xyXG4gICAgICAgIGxldmVsOiBsZXZlbCxcclxuICAgICAgICBkaXNhYmxlZDogZGlzYWJsZWQsXHJcbiAgICAgICAgYWN0aXZlOiBhY3RpdmUsXHJcbiAgICAgICAgY29sbGFwc2VkOiBjb2xsYXBzZWQsXHJcbiAgICAgICAgcnRsOiBydGwsXHJcbiAgICB9KTtcclxufSwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgYnV0dG9uU3R5bGVzID0gX2EuYnV0dG9uU3R5bGVzO1xyXG4gICAgcmV0dXJuIGJ1dHRvblN0eWxlcztcclxufSk7XHJcbnZhciBNZW51SXRlbUZSID0gZnVuY3Rpb24gKF9hLCByZWYpIHtcclxuICAgIHZhciBfYjtcclxuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBpY29uID0gX2EuaWNvbiwgY2xhc3NOYW1lID0gX2EuY2xhc3NOYW1lLCBwcmVmaXggPSBfYS5wcmVmaXgsIHN1ZmZpeCA9IF9hLnN1ZmZpeCwgX2MgPSBfYS5hY3RpdmUsIGFjdGl2ZSA9IF9jID09PSB2b2lkIDAgPyBmYWxzZSA6IF9jLCBfZCA9IF9hLmRpc2FibGVkLCBkaXNhYmxlZCA9IF9kID09PSB2b2lkIDAgPyBmYWxzZSA6IF9kLCBjb21wb25lbnQgPSBfYS5jb21wb25lbnQsIHJvb3RTdHlsZXMgPSBfYS5yb290U3R5bGVzLCByZXN0ID0gX19yZXN0KF9hLCBbXCJjaGlsZHJlblwiLCBcImljb25cIiwgXCJjbGFzc05hbWVcIiwgXCJwcmVmaXhcIiwgXCJzdWZmaXhcIiwgXCJhY3RpdmVcIiwgXCJkaXNhYmxlZFwiLCBcImNvbXBvbmVudFwiLCBcInJvb3RTdHlsZXNcIl0pO1xyXG4gICAgdmFyIGxldmVsID0gUmVhY3RfX2RlZmF1bHQudXNlQ29udGV4dChMZXZlbENvbnRleHQpO1xyXG4gICAgdmFyIF9lID0gUmVhY3RfX2RlZmF1bHQudXNlQ29udGV4dChTaWRlYmFyQ29udGV4dCksIGNvbGxhcHNlZCA9IF9lLmNvbGxhcHNlZCwgcnRsID0gX2UucnRsLCB0cmFuc2l0aW9uRHVyYXRpb24gPSBfZS50cmFuc2l0aW9uRHVyYXRpb247XHJcbiAgICB2YXIgbWVudUl0ZW1TdHlsZXMgPSB1c2VNZW51KCkubWVudUl0ZW1TdHlsZXM7XHJcbiAgICB2YXIgZ2V0TWVudUl0ZW1TdHlsZXMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgIGlmIChtZW51SXRlbVN0eWxlcykge1xyXG4gICAgICAgICAgICB2YXIgcGFyYW1zID0geyBsZXZlbDogbGV2ZWwsIGRpc2FibGVkOiBkaXNhYmxlZCwgYWN0aXZlOiBhY3RpdmUsIGlzU3VibWVudTogZmFsc2UgfTtcclxuICAgICAgICAgICAgdmFyIHJvb3RFbFN0eWxlcyA9IG1lbnVJdGVtU3R5bGVzLnJvb3QsIGJ1dHRvbkVsU3R5bGVzID0gbWVudUl0ZW1TdHlsZXMuYnV0dG9uLCBsYWJlbEVsU3R5bGVzID0gbWVudUl0ZW1TdHlsZXMubGFiZWwsIGljb25FbFN0eWxlcyA9IG1lbnVJdGVtU3R5bGVzLmljb24sIHByZWZpeEVsU3R5bGVzID0gbWVudUl0ZW1TdHlsZXMucHJlZml4LCBzdWZmaXhFbFN0eWxlcyA9IG1lbnVJdGVtU3R5bGVzLnN1ZmZpeDtcclxuICAgICAgICAgICAgc3dpdGNoIChlbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdyb290JzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHJvb3RFbFN0eWxlcyA9PT0gJ2Z1bmN0aW9uJyA/IHJvb3RFbFN0eWxlcyhwYXJhbXMpIDogcm9vdEVsU3R5bGVzO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnYnV0dG9uJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIGJ1dHRvbkVsU3R5bGVzID09PSAnZnVuY3Rpb24nID8gYnV0dG9uRWxTdHlsZXMocGFyYW1zKSA6IGJ1dHRvbkVsU3R5bGVzO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnbGFiZWwnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgbGFiZWxFbFN0eWxlcyA9PT0gJ2Z1bmN0aW9uJyA/IGxhYmVsRWxTdHlsZXMocGFyYW1zKSA6IGxhYmVsRWxTdHlsZXM7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdpY29uJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIGljb25FbFN0eWxlcyA9PT0gJ2Z1bmN0aW9uJyA/IGljb25FbFN0eWxlcyhwYXJhbXMpIDogaWNvbkVsU3R5bGVzO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAncHJlZml4JzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHByZWZpeEVsU3R5bGVzID09PSAnZnVuY3Rpb24nID8gcHJlZml4RWxTdHlsZXMocGFyYW1zKSA6IHByZWZpeEVsU3R5bGVzO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnc3VmZml4JzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHN1ZmZpeEVsU3R5bGVzID09PSAnZnVuY3Rpb24nID8gc3VmZml4RWxTdHlsZXMocGFyYW1zKSA6IHN1ZmZpeEVsU3R5bGVzO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHZhciBzaGFyZWRDbGFzc2VzID0gKF9iID0ge30sXHJcbiAgICAgICAgX2JbbWVudUNsYXNzZXMuYWN0aXZlXSA9IGFjdGl2ZSxcclxuICAgICAgICBfYlttZW51Q2xhc3Nlcy5kaXNhYmxlZF0gPSBkaXNhYmxlZCxcclxuICAgICAgICBfYik7XHJcbiAgICByZXR1cm4gKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU3R5bGVkTWVudUl0ZW0sIHsgcmVmOiByZWYsIGNsYXNzTmFtZTogY2xhc3NuYW1lcyhtZW51Q2xhc3Nlcy5tZW51SXRlbVJvb3QsIHNoYXJlZENsYXNzZXMsIGNsYXNzTmFtZSksIG1lbnVJdGVtU3R5bGVzOiBnZXRNZW51SXRlbVN0eWxlcygncm9vdCcpLCBsZXZlbDogbGV2ZWwsIGNvbGxhcHNlZDogY29sbGFwc2VkLCBydGw6IHJ0bCwgZGlzYWJsZWQ6IGRpc2FibGVkLCBhY3RpdmU6IGFjdGl2ZSwgYnV0dG9uU3R5bGVzOiBnZXRNZW51SXRlbVN0eWxlcygnYnV0dG9uJyksIHJvb3RTdHlsZXM6IHJvb3RTdHlsZXMgfSxcclxuICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KE1lbnVCdXR0b24sIF9fYXNzaWduKHsgY2xhc3NOYW1lOiBjbGFzc25hbWVzKG1lbnVDbGFzc2VzLmJ1dHRvbiwgc2hhcmVkQ2xhc3NlcyksIFwiZGF0YS10ZXN0aWRcIjogXCJcIi5jb25jYXQobWVudUNsYXNzZXMuYnV0dG9uLCBcIi10ZXN0LWlkXCIpLCBjb21wb25lbnQ6IGNvbXBvbmVudCwgdGFiSW5kZXg6IDAgfSwgcmVzdCksXHJcbiAgICAgICAgICAgIGljb24gJiYgKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU3R5bGVkTWVudUljb24sIHsgcnRsOiBydGwsIGNsYXNzTmFtZTogY2xhc3NuYW1lcyhtZW51Q2xhc3Nlcy5pY29uLCBzaGFyZWRDbGFzc2VzKSwgcm9vdFN0eWxlczogZ2V0TWVudUl0ZW1TdHlsZXMoJ2ljb24nKSB9LCBpY29uKSksXHJcbiAgICAgICAgICAgIHByZWZpeCAmJiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChTdHlsZWRNZW51UHJlZml4LCB7IGNvbGxhcHNlZDogY29sbGFwc2VkLCB0cmFuc2l0aW9uRHVyYXRpb246IHRyYW5zaXRpb25EdXJhdGlvbiwgZmlyc3RMZXZlbDogbGV2ZWwgPT09IDAsIGNsYXNzTmFtZTogY2xhc3NuYW1lcyhtZW51Q2xhc3Nlcy5wcmVmaXgsIHNoYXJlZENsYXNzZXMpLCBydGw6IHJ0bCwgcm9vdFN0eWxlczogZ2V0TWVudUl0ZW1TdHlsZXMoJ3ByZWZpeCcpIH0sIHByZWZpeCkpLFxyXG4gICAgICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFN0eWxlZE1lbnVMYWJlbCwgeyBjbGFzc05hbWU6IGNsYXNzbmFtZXMobWVudUNsYXNzZXMubGFiZWwsIHNoYXJlZENsYXNzZXMpLCByb290U3R5bGVzOiBnZXRNZW51SXRlbVN0eWxlcygnbGFiZWwnKSB9LCBjaGlsZHJlbiksXHJcbiAgICAgICAgICAgIHN1ZmZpeCAmJiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChTdHlsZWRNZW51U3VmZml4LCB7IGNvbGxhcHNlZDogY29sbGFwc2VkLCB0cmFuc2l0aW9uRHVyYXRpb246IHRyYW5zaXRpb25EdXJhdGlvbiwgZmlyc3RMZXZlbDogbGV2ZWwgPT09IDAsIGNsYXNzTmFtZTogY2xhc3NuYW1lcyhtZW51Q2xhc3Nlcy5zdWZmaXgsIHNoYXJlZENsYXNzZXMpLCByb290U3R5bGVzOiBnZXRNZW51SXRlbVN0eWxlcygnc3VmZml4JykgfSwgc3VmZml4KSkpKSk7XHJcbn07XHJcbnZhciBNZW51SXRlbSA9IFJlYWN0X19kZWZhdWx0LmZvcndhcmRSZWYoTWVudUl0ZW1GUik7XHJcbnZhciB0ZW1wbGF0ZU9iamVjdF8xO1xuXG4vKipcclxuICogQGRlcHJlY2F0ZWRcclxuICogYFByb1NpZGViYXJQcm92aWRlcmAgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXHJcbiAqL1xyXG52YXIgUHJvU2lkZWJhclByb3ZpZGVyID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbjtcclxuICAgIGNvbnNvbGUud2FybignUHJvU2lkZWJhclByb3ZpZGVyIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLicpO1xyXG4gICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU2lkZWJhclByb3ZpZGVyLCBudWxsLCBjaGlsZHJlbik7XHJcbn07XG5cbi8qKlxyXG4gKiBAZGVwcmVjYXRlZFxyXG4gKiBgdXNlUHJvU2lkZWJhcmAgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXHJcbiAqICBwbGVhc2UgdXNlIFNpZGViYXIgcHJvcHMgaW5zdGVhZC5cclxuICovXHJcbnZhciB1c2VQcm9TaWRlYmFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGxlZ2FjeVNpZGViYXJDb250ZXh0ID0gdXNlTGVnYWN5U2lkZWJhcigpO1xyXG4gICAgaWYgKGxlZ2FjeVNpZGViYXJDb250ZXh0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZVByb1NpZGViYXIgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIFByb1NpZGViYXJQcm92aWRlci4gUGxlYXNlIHdyYXAgeW91ciBjb21wb25lbnQgd2l0aCBhIFByb1NpZGViYXJQcm92aWRlciB0byB1c2UgdGhpcyBob29rLicpO1xyXG4gICAgfVxyXG4gICAgdmFyIGNvbGxhcHNlU2lkZWJhciA9IFJlYWN0X19kZWZhdWx0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICBsZWdhY3lTaWRlYmFyQ29udGV4dC51cGRhdGVDb2xsYXBzZVN0YXRlKCk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBsZWdhY3lTaWRlYmFyQ29udGV4dC51cGRhdGVTaWRlYmFyU3RhdGUoeyBjb2xsYXBzZWQ6IHZhbHVlIH0pO1xyXG4gICAgfSwgXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXHJcbiAgICBbbGVnYWN5U2lkZWJhckNvbnRleHQudXBkYXRlQ29sbGFwc2VTdGF0ZSwgbGVnYWN5U2lkZWJhckNvbnRleHQudXBkYXRlU2lkZWJhclN0YXRlXSk7XHJcbiAgICB2YXIgdG9nZ2xlU2lkZWJhciA9IFJlYWN0X19kZWZhdWx0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICBsZWdhY3lTaWRlYmFyQ29udGV4dC51cGRhdGVUb2dnbGVTdGF0ZSgpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgbGVnYWN5U2lkZWJhckNvbnRleHQudXBkYXRlU2lkZWJhclN0YXRlKHsgdG9nZ2xlZDogdmFsdWUgfSk7XHJcbiAgICB9LCBcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcclxuICAgIFtsZWdhY3lTaWRlYmFyQ29udGV4dC51cGRhdGVUb2dnbGVTdGF0ZSwgbGVnYWN5U2lkZWJhckNvbnRleHQudXBkYXRlU2lkZWJhclN0YXRlXSk7XHJcbiAgICBSZWFjdF9fZGVmYXVsdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybigndXNlUHJvU2lkZWJhciBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS4gUGxlYXNlIHVzZSBTaWRlYmFyIHByb3BzIGluc3RlYWQuJyk7XHJcbiAgICB9LCBbXSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGNvbGxhcHNlU2lkZWJhcjogY29sbGFwc2VTaWRlYmFyLFxyXG4gICAgICAgIHRvZ2dsZVNpZGViYXI6IHRvZ2dsZVNpZGViYXIsXHJcbiAgICAgICAgY29sbGFwc2VkOiAhIWxlZ2FjeVNpZGViYXJDb250ZXh0LmNvbGxhcHNlZCxcclxuICAgICAgICBicm9rZW46ICEhbGVnYWN5U2lkZWJhckNvbnRleHQuYnJva2VuLFxyXG4gICAgICAgIHRvZ2dsZWQ6ICEhbGVnYWN5U2lkZWJhckNvbnRleHQudG9nZ2xlZCxcclxuICAgICAgICBydGw6ICEhbGVnYWN5U2lkZWJhckNvbnRleHQucnRsLFxyXG4gICAgfTtcclxufTtcblxuZXhwb3J0IHsgTGV2ZWxDb250ZXh0LCBNZW51LCBNZW51Q29udGV4dCwgTWVudUl0ZW0sIE1lbnVJdGVtRlIsIFByb1NpZGViYXJQcm92aWRlciwgU2lkZWJhciwgU2lkZWJhckNvbnRleHQsIFN1Yk1lbnUsIFN1Yk1lbnVGUiwgbWVudUNsYXNzZXMsIHNpZGViYXJDbGFzc2VzLCB1c2VQcm9TaWRlYmFyIH07XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJSZWFjdF9fZGVmYXVsdCIsImZvcndhcmRSZWYiLCJ1c2VDb250ZXh0IiwiY3JlYXRlRWxlbWVudCIsImNyZWF0ZUNvbnRleHQiLCJGcmFnbWVudCIsIl9fYXNzaWduIiwiT2JqZWN0IiwiYXNzaWduIiwidCIsInMiLCJpIiwibiIsImFyZ3VtZW50cyIsImxlbmd0aCIsInAiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhcHBseSIsIl9fcmVzdCIsImUiLCJpbmRleE9mIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJfX21ha2VUZW1wbGF0ZU9iamVjdCIsImNvb2tlZCIsInJhdyIsImRlZmluZVByb3BlcnR5IiwidmFsdWUiLCJfZXh0ZW5kcyIsImJpbmQiLCJ0YXJnZXQiLCJzb3VyY2UiLCJrZXkiLCJtZW1vaXplIiwiZm4iLCJjYWNoZSIsImNyZWF0ZSIsImFyZyIsInVuZGVmaW5lZCIsInJlYWN0UHJvcHNSZWdleCIsImlzUHJvcFZhbGlkIiwicHJvcCIsInRlc3QiLCJjaGFyQ29kZUF0Iiwic2hlZXRGb3JUYWciLCJ0YWciLCJzaGVldCIsImRvY3VtZW50Iiwic3R5bGVTaGVldHMiLCJvd25lck5vZGUiLCJjcmVhdGVTdHlsZUVsZW1lbnQiLCJvcHRpb25zIiwic2V0QXR0cmlidXRlIiwibm9uY2UiLCJhcHBlbmRDaGlsZCIsImNyZWF0ZVRleHROb2RlIiwiU3R5bGVTaGVldCIsIl90aGlzIiwiX2luc2VydFRhZyIsImJlZm9yZSIsInRhZ3MiLCJpbnNlcnRpb25Qb2ludCIsIm5leHRTaWJsaW5nIiwicHJlcGVuZCIsImNvbnRhaW5lciIsImZpcnN0Q2hpbGQiLCJpbnNlcnRCZWZvcmUiLCJwdXNoIiwiaXNTcGVlZHkiLCJzcGVlZHkiLCJwcm9jZXNzIiwiY3RyIiwiX3Byb3RvIiwiaHlkcmF0ZSIsIm5vZGVzIiwiZm9yRWFjaCIsImluc2VydCIsInJ1bGUiLCJpc0ltcG9ydFJ1bGUiLCJfYWxyZWFkeUluc2VydGVkT3JkZXJJbnNlbnNpdGl2ZVJ1bGUiLCJjb25zb2xlIiwiZXJyb3IiLCJpbnNlcnRSdWxlIiwiY3NzUnVsZXMiLCJmbHVzaCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsIk1TIiwiTU9aIiwiV0VCS0lUIiwiQ09NTUVOVCIsIlJVTEVTRVQiLCJERUNMQVJBVElPTiIsIklNUE9SVCIsIktFWUZSQU1FUyIsImFicyIsIk1hdGgiLCJmcm9tIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiaGFzaCQyIiwiY2hhcmF0IiwidHJpbSIsIm1hdGNoIiwicGF0dGVybiIsImV4ZWMiLCJyZXBsYWNlIiwicmVwbGFjZW1lbnQiLCJpbmRleG9mIiwic2VhcmNoIiwiaW5kZXgiLCJzdWJzdHIiLCJiZWdpbiIsImVuZCIsInNsaWNlIiwic3RybGVuIiwic2l6ZW9mIiwiYXBwZW5kIiwiYXJyYXkiLCJjb21iaW5lIiwiY2FsbGJhY2siLCJtYXAiLCJqb2luIiwibGluZSIsImNvbHVtbiIsInBvc2l0aW9uIiwiY2hhcmFjdGVyIiwiY2hhcmFjdGVycyIsIm5vZGUiLCJyb290IiwicGFyZW50IiwidHlwZSIsInByb3BzIiwiY2hpbGRyZW4iLCJyZXR1cm4iLCJjb3B5IiwiY2hhciIsInByZXYiLCJuZXh0IiwicGVlayIsImNhcmV0IiwidG9rZW4iLCJhbGxvYyIsImRlYWxsb2MiLCJkZWxpbWl0IiwiZGVsaW1pdGVyIiwid2hpdGVzcGFjZSIsImVzY2FwaW5nIiwiY291bnQiLCJjb21tZW50ZXIiLCJpZGVudGlmaWVyIiwiY29tcGlsZSIsInBhcnNlIiwicnVsZXMiLCJydWxlc2V0cyIsInBzZXVkbyIsInBvaW50cyIsImRlY2xhcmF0aW9ucyIsIm9mZnNldCIsImF0cnVsZSIsInByb3BlcnR5IiwicHJldmlvdXMiLCJ2YXJpYWJsZSIsInNjYW5uaW5nIiwiYW1wZXJzYW5kIiwicmVmZXJlbmNlIiwiY29tbWVudCIsImRlY2xhcmF0aW9uIiwicnVsZXNldCIsInBvc3QiLCJzaXplIiwiaiIsImsiLCJ4IiwieSIsInoiLCJzZXJpYWxpemUiLCJvdXRwdXQiLCJzdHJpbmdpZnkiLCJlbGVtZW50IiwibWlkZGxld2FyZSIsImNvbGxlY3Rpb24iLCJydWxlc2hlZXQiLCJ3ZWFrTWVtb2l6ZSIsImZ1bmMiLCJXZWFrTWFwIiwiaGFzIiwiZ2V0IiwicmV0Iiwic2V0IiwiaWRlbnRpZmllcldpdGhQb2ludFRyYWNraW5nIiwidG9SdWxlcyIsInBhcnNlZCIsImdldFJ1bGVzIiwiZml4ZWRFbGVtZW50cyIsImNvbXBhdCIsImlzSW1wbGljaXRSdWxlIiwicGFyZW50UnVsZXMiLCJyZW1vdmVMYWJlbCIsImlnbm9yZUZsYWciLCJpc0lnbm9yaW5nQ29tbWVudCIsImNyZWF0ZVVuc2FmZVNlbGVjdG9yc0FsYXJtIiwidW5zYWZlUHNldWRvQ2xhc3NlcyIsImlzTmVzdGVkIiwiY29tbWVudENvbnRhaW5lciIsInVuc2FmZVBzZXVkb0NsYXNzIiwic3BsaXQiLCJpc1ByZXBlbmRlZFdpdGhSZWd1bGFyUnVsZXMiLCJudWxsaWZ5RWxlbWVudCIsImluY29ycmVjdEltcG9ydEFsYXJtIiwicHJlZml4IiwicHJlZml4ZXIiLCJpc0Jyb3dzZXIkNSIsImdldFNlcnZlclN0eWxpc0NhY2hlIiwibmFtZSIsImRlZmF1bHRTdHlsaXNQbHVnaW5zIiwiY3JlYXRlQ2FjaGUiLCJFcnJvciIsInNzclN0eWxlcyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJBcnJheSIsImRhdGFFbW90aW9uQXR0cmlidXRlIiwiZ2V0QXR0cmlidXRlIiwiaGVhZCIsInN0eWxpc1BsdWdpbnMiLCJpbnNlcnRlZCIsIm5vZGVzVG9IeWRyYXRlIiwiYXR0cmliIiwiX2luc2VydCIsIm9tbmlwcmVzZW50UGx1Z2lucyIsImN1cnJlbnRTaGVldCIsImZpbmFsaXppbmdQbHVnaW5zIiwic2VyaWFsaXplciIsImNvbmNhdCIsInN0eWxpcyIsInN0eWxlcyIsInNlbGVjdG9yIiwic2VyaWFsaXplZCIsInNob3VsZENhY2hlIiwiX2ZpbmFsaXppbmdQbHVnaW5zIiwiX3NlcmlhbGl6ZXIiLCJfc3R5bGlzIiwic2VydmVyU3R5bGlzQ2FjaGUiLCJyZWdpc3RlcmVkIiwiaXNCcm93c2VyJDQiLCJnZXRSZWdpc3RlcmVkU3R5bGVzJDEiLCJyZWdpc3RlcmVkU3R5bGVzIiwiY2xhc3NOYW1lcyIsInJhd0NsYXNzTmFtZSIsImNsYXNzTmFtZSIsInJlZ2lzdGVyU3R5bGVzJDEiLCJyZWdpc3RlclN0eWxlcyIsImlzU3RyaW5nVGFnIiwiaW5zZXJ0U3R5bGVzJDEiLCJpbnNlcnRTdHlsZXMiLCJzdHlsZXNGb3JTU1IiLCJjdXJyZW50IiwibWF5YmVTdHlsZXMiLCJtdXJtdXIyJDEiLCJzdHIiLCJoIiwibGVuIiwidG9TdHJpbmciLCJ1bml0bGVzc0tleXMkMSIsImFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50IiwiYm9yZGVySW1hZ2VPdXRzZXQiLCJib3JkZXJJbWFnZVNsaWNlIiwiYm9yZGVySW1hZ2VXaWR0aCIsImJveEZsZXgiLCJib3hGbGV4R3JvdXAiLCJib3hPcmRpbmFsR3JvdXAiLCJjb2x1bW5Db3VudCIsImNvbHVtbnMiLCJmbGV4IiwiZmxleEdyb3ciLCJmbGV4UG9zaXRpdmUiLCJmbGV4U2hyaW5rIiwiZmxleE5lZ2F0aXZlIiwiZmxleE9yZGVyIiwiZ3JpZFJvdyIsImdyaWRSb3dFbmQiLCJncmlkUm93U3BhbiIsImdyaWRSb3dTdGFydCIsImdyaWRDb2x1bW4iLCJncmlkQ29sdW1uRW5kIiwiZ3JpZENvbHVtblNwYW4iLCJncmlkQ29sdW1uU3RhcnQiLCJtc0dyaWRSb3ciLCJtc0dyaWRSb3dTcGFuIiwibXNHcmlkQ29sdW1uIiwibXNHcmlkQ29sdW1uU3BhbiIsImZvbnRXZWlnaHQiLCJsaW5lSGVpZ2h0Iiwib3BhY2l0eSIsIm9yZGVyIiwib3JwaGFucyIsInRhYlNpemUiLCJ3aWRvd3MiLCJ6SW5kZXgiLCJ6b29tIiwiV2Via2l0TGluZUNsYW1wIiwiZmlsbE9wYWNpdHkiLCJmbG9vZE9wYWNpdHkiLCJzdG9wT3BhY2l0eSIsInN0cm9rZURhc2hhcnJheSIsInN0cm9rZURhc2hvZmZzZXQiLCJzdHJva2VNaXRlcmxpbWl0Iiwic3Ryb2tlT3BhY2l0eSIsInN0cm9rZVdpZHRoIiwiSUxMRUdBTF9FU0NBUEVfU0VRVUVOQ0VfRVJST1IkMiIsIlVOREVGSU5FRF9BU19PQkpFQ1RfS0VZX0VSUk9SJDEiLCJoeXBoZW5hdGVSZWdleCQxIiwiYW5pbWF0aW9uUmVnZXgkMSIsImlzQ3VzdG9tUHJvcGVydHkkMSIsImlzQ3VzdG9tUHJvcGVydHkiLCJpc1Byb2Nlc3NhYmxlVmFsdWUkMSIsImlzUHJvY2Vzc2FibGVWYWx1ZSIsInByb2Nlc3NTdHlsZU5hbWUkMSIsInN0eWxlTmFtZSIsInRvTG93ZXJDYXNlIiwicHJvY2Vzc1N0eWxlVmFsdWUkMSIsInByb2Nlc3NTdHlsZVZhbHVlIiwicDEiLCJwMiIsImN1cnNvciQxIiwiY29udGVudFZhbHVlUGF0dGVybiQxIiwiY29udGVudFZhbHVlcyQxIiwib2xkUHJvY2Vzc1N0eWxlVmFsdWUkMSIsIm1zUGF0dGVybiQxIiwiaHlwaGVuUGF0dGVybiQxIiwiaHlwaGVuYXRlZENhY2hlJDEiLCJjaGFyQXQiLCJwcm9jZXNzZWQiLCJfY2hhciIsInRvVXBwZXJDYXNlIiwibm9Db21wb25lbnRTZWxlY3Rvck1lc3NhZ2UkMSIsImhhbmRsZUludGVycG9sYXRpb24kMSIsIm1lcmdlZFByb3BzIiwiaW50ZXJwb2xhdGlvbiIsIl9fZW1vdGlvbl9zdHlsZXMiLCJhbmltIiwiY3JlYXRlU3RyaW5nRnJvbU9iamVjdCQxIiwicHJldmlvdXNDdXJzb3IiLCJyZXN1bHQiLCJtYXRjaGVkIiwicmVwbGFjZWQiLCJmYWtlVmFyTmFtZSIsImNhY2hlZCIsIm9iaiIsInN0cmluZyIsImlzQXJyYXkiLCJfa2V5IiwiX2kiLCJpbnRlcnBvbGF0ZWQiLCJsYWJlbFBhdHRlcm4kMSIsInNvdXJjZU1hcFBhdHRlcm4kMSIsInNlcmlhbGl6ZVN0eWxlcyQxIiwic2VyaWFsaXplU3R5bGVzIiwiYXJncyIsInN0cmluZ01vZGUiLCJzdHJpbmdzIiwic291cmNlTWFwIiwibGFzdEluZGV4IiwiaWRlbnRpZmllck5hbWUiLCJpc0Jyb3dzZXIkMyIsInN5bmNGYWxsYmFjayIsInVzZUluc2VydGlvbkVmZmVjdCIsInVzZUluc2VydGlvbkVmZmVjdEFsd2F5c1dpdGhTeW5jRmFsbGJhY2siLCJpc0Jyb3dzZXIkMiIsIkVtb3Rpb25DYWNoZUNvbnRleHQiLCJIVE1MRWxlbWVudCIsImRpc3BsYXlOYW1lIiwiUHJvdmlkZXIiLCJ3aXRoRW1vdGlvbkNhY2hlIiwicmVmIiwiVGhlbWVDb250ZXh0IiwidHlwZVByb3BOYW1lIiwibGFiZWxQcm9wTmFtZSIsIkluc2VydGlvbiQxIiwiSW5zZXJ0aW9uIiwiX3JlZiIsIl9yZWYyIiwic2VyaWFsaXplZE5hbWVzIiwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiLCJfX2h0bWwiLCJFbW90aW9uIiwiY3NzUHJvcCIsImNzcyIsIldyYXBwZWRDb21wb25lbnQiLCJsYWJlbEZyb21TdGFjayIsIm5ld1Byb3BzIiwiaXNCcm93c2VyJDEiLCJnZXRSZWdpc3RlcmVkU3R5bGVzIiwibXVybXVyMiIsInVuaXRsZXNzS2V5cyIsIklMTEVHQUxfRVNDQVBFX1NFUVVFTkNFX0VSUk9SJDEiLCJVTkRFRklORURfQVNfT0JKRUNUX0tFWV9FUlJPUiIsImh5cGhlbmF0ZVJlZ2V4IiwiYW5pbWF0aW9uUmVnZXgiLCJwcm9jZXNzU3R5bGVOYW1lIiwiY3Vyc29yIiwiY29udGVudFZhbHVlUGF0dGVybiIsImNvbnRlbnRWYWx1ZXMiLCJvbGRQcm9jZXNzU3R5bGVWYWx1ZSIsIm1zUGF0dGVybiIsImh5cGhlblBhdHRlcm4iLCJoeXBoZW5hdGVkQ2FjaGUiLCJub0NvbXBvbmVudFNlbGVjdG9yTWVzc2FnZSIsImhhbmRsZUludGVycG9sYXRpb24iLCJjcmVhdGVTdHJpbmdGcm9tT2JqZWN0IiwibGFiZWxQYXR0ZXJuIiwic291cmNlTWFwUGF0dGVybiIsInRlc3RPbWl0UHJvcHNPblN0cmluZ1RhZyIsInRlc3RPbWl0UHJvcHNPbkNvbXBvbmVudCIsImdldERlZmF1bHRTaG91bGRGb3J3YXJkUHJvcCIsImNvbXBvc2VTaG91bGRGb3J3YXJkUHJvcHMiLCJpc1JlYWwiLCJzaG91bGRGb3J3YXJkUHJvcCIsIm9wdGlvbnNTaG91bGRGb3J3YXJkUHJvcCIsIl9fZW1vdGlvbl9mb3J3YXJkUHJvcCIsInByb3BOYW1lIiwiSUxMRUdBTF9FU0NBUEVfU0VRVUVOQ0VfRVJST1IiLCJpc0Jyb3dzZXIiLCJjcmVhdGVTdHlsZWQiLCJfX2Vtb3Rpb25fcmVhbCIsImJhc2VUYWciLCJfX2Vtb3Rpb25fYmFzZSIsInRhcmdldENsYXNzTmFtZSIsImxhYmVsIiwiZGVmYXVsdFNob3VsZEZvcndhcmRQcm9wIiwic2hvdWxkVXNlQXMiLCJTdHlsZWQiLCJGaW5hbFRhZyIsImFzIiwiY2xhc3NJbnRlcnBvbGF0aW9ucyIsInRoZW1lIiwiZmluYWxTaG91bGRGb3J3YXJkUHJvcCIsImRlZmF1bHRQcm9wcyIsIndpdGhDb21wb25lbnQiLCJuZXh0VGFnIiwibmV4dE9wdGlvbnMiLCJuZXdTdHlsZWQiLCJ0YWdOYW1lIiwiY2xhc3NuYW1lcyQxIiwiZXhwb3J0cyIsIm1vZHVsZSIsImhhc093biIsImNsYXNzZXMiLCJhcmdUeXBlIiwiaW5uZXIiLCJpbmNsdWRlcyIsImRlZmF1bHQiLCJ3aW5kb3ciLCJjbGFzc25hbWVzIiwiTGVnYWN5U2lkZWJhckNvbnRleHQiLCJTaWRlYmFyUHJvdmlkZXIiLCJfYSIsIl9iIiwidXNlU3RhdGUiLCJjb2xsYXBzZWQiLCJ0b2dnbGVkIiwiYnJva2VuIiwicnRsIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwic2lkZWJhclN0YXRlIiwic2V0U2lkZWJhclN0YXRlIiwidXBkYXRlU2lkZWJhclN0YXRlIiwidXNlQ2FsbGJhY2siLCJ2YWx1ZXMiLCJwcmV2U3RhdGUiLCJ1cGRhdGVDb2xsYXBzZVN0YXRlIiwiQm9vbGVhbiIsInVwZGF0ZVRvZ2dsZVN0YXRlIiwicHJvdmlkZXJWYWx1ZSIsInVzZU1lbW8iLCJ1c2VMZWdhY3lTaWRlYmFyIiwiY29udGV4dCIsInVzZU1lZGlhUXVlcnkiLCJicmVha3BvaW50IiwibWF0Y2hNZWRpYSIsIm1hdGNoZXMiLCJzZXRNYXRjaGVzIiwidXNlRWZmZWN0IiwibWVkaWFfMSIsImhhbmRsZU1hdGNoXzEiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInNpZGViYXJDbGFzc2VzIiwiaW1hZ2UiLCJiYWNrZHJvcCIsIm1lbnVDbGFzc2VzIiwibWVudUl0ZW1Sb290Iiwic3ViTWVudVJvb3QiLCJidXR0b24iLCJzdWZmaXgiLCJpY29uIiwic3ViTWVudUNvbnRlbnQiLCJTdWJNZW51RXhwYW5kSWNvbiIsImRpc2FibGVkIiwiYWN0aXZlIiwib3BlbiIsIlN0eWxlZEJhY2tkcm9wIiwiZGl2IiwidGVtcGxhdGVPYmplY3RfMSRiIiwiQlJFQUtfUE9JTlRTIiwieHMiLCJzbSIsIm1kIiwibGciLCJ4bCIsInh4bCIsImFsd2F5cyIsImFsbCIsIlN0eWxlZFNpZGViYXIiLCJhc2lkZSIsInRlbXBsYXRlT2JqZWN0XzEkYSIsIndpZHRoIiwiY29sbGFwc2VkV2lkdGgiLCJyb290U3R5bGVzIiwiU3R5bGVkU2lkZWJhckNvbnRhaW5lciIsInRlbXBsYXRlT2JqZWN0XzIkMSIsImJhY2tncm91bmRDb2xvciIsIlN0eWxlZFNpZGViYXJJbWFnZSIsImltZyIsInRlbXBsYXRlT2JqZWN0XzMkMSIsIlNpZGViYXJDb250ZXh0IiwiU2lkZWJhciIsIm9uQmFja2Ryb3BDbGljayIsIm9uQnJlYWtQb2ludCIsIl9jIiwiX2QiLCJkZWZhdWx0Q29sbGFwc2VkIiwiYnJlYWtQb2ludCIsImN1c3RvbUJyZWFrUG9pbnQiLCJfZSIsIl9mIiwicmVzdCIsImdldEJyZWFrcG9pbnRWYWx1ZSIsIndhcm4iLCJicmVha3BvaW50Q2FsbGJhY2tGblJlZiIsInVzZVJlZiIsIl9nIiwibW91bnRlZCIsInNldE1vdW50ZWQiLCJsZWdhY3lTaWRlYmFyQ29udGV4dCIsImNvbGxhcHNlZFZhbHVlIiwidG9nZ2xlZFZhbHVlIiwiaGFuZGxlQmFja2Ryb3BDbGljayIsInNyYyIsImFsdCIsInJvbGUiLCJ0YWJJbmRleCIsIm9uQ2xpY2siLCJvbktleVByZXNzIiwiU3R5bGVkVWwiLCJ1bCIsInRlbXBsYXRlT2JqZWN0XzEkOSIsIlN0eWxlZE1lbnUiLCJuYXYiLCJ0ZW1wbGF0ZU9iamVjdF8xJDgiLCJNZW51Q29udGV4dCIsIkxldmVsQ29udGV4dCIsIk1lbnVGUiIsImNsb3NlT25DbGljayIsIm1lbnVJdGVtU3R5bGVzIiwicmVuZGVyRXhwYW5kSWNvbiIsIk1lbnUiLCJ1c2VNZW51IiwiU3R5bGVkU3ViTWVudUNvbnRlbnQiLCJ0ZW1wbGF0ZU9iamVjdF8xJDciLCJmaXJzdExldmVsIiwiZGVmYXVsdE9wZW4iLCJvcGVuV2hlbkNvbGxhcHNlZCIsIlN1Yk1lbnVDb250ZW50RlIiLCJkZWZhdWx0T3BlblN0YXRlIiwiU3ViTWVudUNvbnRlbnQiLCJTdHlsZWRNZW51TGFiZWwiLCJzcGFuIiwidGVtcGxhdGVPYmplY3RfMSQ2IiwiU3R5bGVkTWVudUljb24iLCJ0ZW1wbGF0ZU9iamVjdF8xJDUiLCJTdHlsZWRNZW51UHJlZml4IiwidGVtcGxhdGVPYmplY3RfMSQ0IiwiU3R5bGVkTWVudVN1ZmZpeCIsInRlbXBsYXRlT2JqZWN0XzEkMyIsIlN0eWxlZEV4cGFuZEljb25XcmFwcGVyIiwidGVtcGxhdGVPYmplY3RfMSQyIiwibGV2ZWwiLCJTdHlsZWRFeHBhbmRJY29uIiwidGVtcGxhdGVPYmplY3RfMiIsIlN0eWxlZEV4cGFuZEljb25Db2xsYXBzZWQiLCJ0ZW1wbGF0ZU9iamVjdF8zIiwidG9wIiwiYm90dG9tIiwicmlnaHQiLCJsZWZ0IiwiYXV0byIsImJhc2VQbGFjZW1lbnRzIiwic3RhcnQiLCJjbGlwcGluZ1BhcmVudHMiLCJ2aWV3cG9ydCIsInBvcHBlciIsInZhcmlhdGlvblBsYWNlbWVudHMiLCJyZWR1Y2UiLCJhY2MiLCJwbGFjZW1lbnQiLCJwbGFjZW1lbnRzIiwiYmVmb3JlUmVhZCIsInJlYWQiLCJhZnRlclJlYWQiLCJiZWZvcmVNYWluIiwibWFpbiIsImFmdGVyTWFpbiIsImJlZm9yZVdyaXRlIiwid3JpdGUiLCJhZnRlcldyaXRlIiwibW9kaWZpZXJQaGFzZXMiLCJnZXROb2RlTmFtZSIsIm5vZGVOYW1lIiwiZ2V0V2luZG93Iiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3IiwiaXNFbGVtZW50IiwiT3duRWxlbWVudCIsIkVsZW1lbnQiLCJpc0hUTUxFbGVtZW50IiwiaXNTaGFkb3dSb290IiwiU2hhZG93Um9vdCIsImFwcGx5U3R5bGVzIiwic3RhdGUiLCJrZXlzIiwiZWxlbWVudHMiLCJzdHlsZSIsImF0dHJpYnV0ZXMiLCJyZW1vdmVBdHRyaWJ1dGUiLCJlZmZlY3QkMiIsImluaXRpYWxTdHlsZXMiLCJzdHJhdGVneSIsIm1hcmdpbiIsImFycm93Iiwic3R5bGVQcm9wZXJ0aWVzIiwiYXR0cmlidXRlIiwiYXBwbHlTdHlsZXMkMSIsImVuYWJsZWQiLCJwaGFzZSIsImVmZmVjdCIsInJlcXVpcmVzIiwiZ2V0QmFzZVBsYWNlbWVudCIsIm1heCIsIm1pbiIsInJvdW5kIiwiZ2V0VUFTdHJpbmciLCJ1YURhdGEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnREYXRhIiwiYnJhbmRzIiwiaXRlbSIsImJyYW5kIiwidmVyc2lvbiIsInVzZXJBZ2VudCIsImlzTGF5b3V0Vmlld3BvcnQiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJpbmNsdWRlU2NhbGUiLCJpc0ZpeGVkU3RyYXRlZ3kiLCJjbGllbnRSZWN0Iiwic2NhbGVYIiwic2NhbGVZIiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJoZWlnaHQiLCJ2aXN1YWxWaWV3cG9ydCIsImFkZFZpc3VhbE9mZnNldHMiLCJvZmZzZXRMZWZ0Iiwib2Zmc2V0VG9wIiwiZ2V0TGF5b3V0UmVjdCIsImNvbnRhaW5zIiwiY2hpbGQiLCJyb290Tm9kZSIsImdldFJvb3ROb2RlIiwiaXNTYW1lTm9kZSIsImhvc3QiLCJnZXRDb21wdXRlZFN0eWxlIiwiaXNUYWJsZUVsZW1lbnQiLCJnZXREb2N1bWVudEVsZW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJnZXRQYXJlbnROb2RlIiwiYXNzaWduZWRTbG90IiwiZ2V0VHJ1ZU9mZnNldFBhcmVudCIsIm9mZnNldFBhcmVudCIsImdldENvbnRhaW5pbmdCbG9jayIsImlzRmlyZWZveCIsImlzSUUiLCJlbGVtZW50Q3NzIiwiY3VycmVudE5vZGUiLCJ0cmFuc2Zvcm0iLCJwZXJzcGVjdGl2ZSIsImNvbnRhaW4iLCJ3aWxsQ2hhbmdlIiwiZmlsdGVyIiwiZ2V0T2Zmc2V0UGFyZW50IiwiZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50Iiwid2l0aGluIiwibWluJDEiLCJtYXgkMSIsIndpdGhpbk1heENsYW1wIiwidiIsImdldEZyZXNoU2lkZU9iamVjdCIsIm1lcmdlUGFkZGluZ09iamVjdCIsInBhZGRpbmdPYmplY3QiLCJleHBhbmRUb0hhc2hNYXAiLCJoYXNoTWFwIiwidG9QYWRkaW5nT2JqZWN0IiwicGFkZGluZyIsInJlY3RzIiwiX3N0YXRlJG1vZGlmaWVyc0RhdGEkIiwiYXJyb3dFbGVtZW50IiwicG9wcGVyT2Zmc2V0cyIsIm1vZGlmaWVyc0RhdGEiLCJiYXNlUGxhY2VtZW50IiwiYXhpcyIsImlzVmVydGljYWwiLCJhcnJvd1JlY3QiLCJtaW5Qcm9wIiwibWF4UHJvcCIsImVuZERpZmYiLCJzdGFydERpZmYiLCJhcnJvd09mZnNldFBhcmVudCIsImNsaWVudFNpemUiLCJjbGllbnRIZWlnaHQiLCJjbGllbnRXaWR0aCIsImNlbnRlclRvUmVmZXJlbmNlIiwiY2VudGVyIiwiYXhpc1Byb3AiLCJjZW50ZXJPZmZzZXQiLCJlZmZlY3QkMSIsIl9vcHRpb25zJGVsZW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwiYXJyb3ckMSIsInJlcXVpcmVzSWZFeGlzdHMiLCJnZXRWYXJpYXRpb24iLCJ1bnNldFNpZGVzIiwicm91bmRPZmZzZXRzQnlEUFIiLCJ3aW4iLCJkcHIiLCJkZXZpY2VQaXhlbFJhdGlvIiwibWFwVG9TdHlsZXMiLCJfT2JqZWN0JGFzc2lnbjIiLCJwb3BwZXJSZWN0IiwidmFyaWF0aW9uIiwib2Zmc2V0cyIsImdwdUFjY2VsZXJhdGlvbiIsImFkYXB0aXZlIiwicm91bmRPZmZzZXRzIiwiaXNGaXhlZCIsIl9vZmZzZXRzJHgiLCJfb2Zmc2V0cyR5IiwiX3JlZjMiLCJoYXNYIiwiaGFzWSIsInNpZGVYIiwic2lkZVkiLCJoZWlnaHRQcm9wIiwid2lkdGhQcm9wIiwib2Zmc2V0WSIsIm9mZnNldFgiLCJjb21tb25TdHlsZXMiLCJfcmVmNCIsIl9PYmplY3QkYXNzaWduIiwiY29tcHV0ZVN0eWxlcyIsIl9yZWY1IiwiX29wdGlvbnMkZ3B1QWNjZWxlcmF0IiwiX29wdGlvbnMkYWRhcHRpdmUiLCJfb3B0aW9ucyRyb3VuZE9mZnNldHMiLCJ0cmFuc2l0aW9uUHJvcGVydHkiLCJzb21lIiwiY29tcHV0ZVN0eWxlcyQxIiwiZGF0YSIsInBhc3NpdmUiLCJpbnN0YW5jZSIsIl9vcHRpb25zJHNjcm9sbCIsInNjcm9sbCIsIl9vcHRpb25zJHJlc2l6ZSIsInJlc2l6ZSIsInNjcm9sbFBhcmVudHMiLCJzY3JvbGxQYXJlbnQiLCJ1cGRhdGUiLCJldmVudExpc3RlbmVycyIsImhhc2gkMSIsImdldE9wcG9zaXRlUGxhY2VtZW50IiwiaGFzaCIsImdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50IiwiZ2V0V2luZG93U2Nyb2xsIiwic2Nyb2xsTGVmdCIsInBhZ2VYT2Zmc2V0Iiwic2Nyb2xsVG9wIiwicGFnZVlPZmZzZXQiLCJnZXRXaW5kb3dTY3JvbGxCYXJYIiwiZ2V0Vmlld3BvcnRSZWN0IiwiaHRtbCIsImxheW91dFZpZXdwb3J0IiwiZ2V0RG9jdW1lbnRSZWN0IiwiX2VsZW1lbnQkb3duZXJEb2N1bWVuIiwid2luU2Nyb2xsIiwiYm9keSIsInNjcm9sbFdpZHRoIiwic2Nyb2xsSGVpZ2h0IiwiZGlyZWN0aW9uIiwiaXNTY3JvbGxQYXJlbnQiLCJfZ2V0Q29tcHV0ZWRTdHlsZSIsIm92ZXJmbG93Iiwib3ZlcmZsb3dYIiwib3ZlcmZsb3dZIiwiZ2V0U2Nyb2xsUGFyZW50IiwibGlzdFNjcm9sbFBhcmVudHMiLCJsaXN0IiwiaXNCb2R5IiwidXBkYXRlZExpc3QiLCJyZWN0VG9DbGllbnRSZWN0IiwicmVjdCIsImdldElubmVyQm91bmRpbmdDbGllbnRSZWN0IiwiY2xpZW50VG9wIiwiY2xpZW50TGVmdCIsImdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlIiwiY2xpcHBpbmdQYXJlbnQiLCJnZXRDbGlwcGluZ1BhcmVudHMiLCJjYW5Fc2NhcGVDbGlwcGluZyIsImNsaXBwZXJFbGVtZW50IiwiZ2V0Q2xpcHBpbmdSZWN0IiwiYm91bmRhcnkiLCJyb290Qm91bmRhcnkiLCJtYWluQ2xpcHBpbmdQYXJlbnRzIiwiZmlyc3RDbGlwcGluZ1BhcmVudCIsImNsaXBwaW5nUmVjdCIsImFjY1JlY3QiLCJjb21wdXRlT2Zmc2V0cyIsImNvbW1vblgiLCJjb21tb25ZIiwibWFpbkF4aXMiLCJkZXRlY3RPdmVyZmxvdyIsIl9vcHRpb25zIiwiX29wdGlvbnMkcGxhY2VtZW50IiwiX29wdGlvbnMkc3RyYXRlZ3kiLCJfb3B0aW9ucyRib3VuZGFyeSIsIl9vcHRpb25zJHJvb3RCb3VuZGFyeSIsIl9vcHRpb25zJGVsZW1lbnRDb250ZSIsImVsZW1lbnRDb250ZXh0IiwiX29wdGlvbnMkYWx0Qm91bmRhcnkiLCJhbHRCb3VuZGFyeSIsIl9vcHRpb25zJHBhZGRpbmciLCJhbHRDb250ZXh0IiwiY2xpcHBpbmdDbGllbnRSZWN0IiwiY29udGV4dEVsZW1lbnQiLCJyZWZlcmVuY2VDbGllbnRSZWN0IiwicG9wcGVyQ2xpZW50UmVjdCIsImVsZW1lbnRDbGllbnRSZWN0Iiwib3ZlcmZsb3dPZmZzZXRzIiwib2Zmc2V0RGF0YSIsIm11bHRpcGx5IiwiY29tcHV0ZUF1dG9QbGFjZW1lbnQiLCJmbGlwVmFyaWF0aW9ucyIsIl9vcHRpb25zJGFsbG93ZWRBdXRvUCIsImFsbG93ZWRBdXRvUGxhY2VtZW50cyIsInBsYWNlbWVudHMkMSIsImFsbG93ZWRQbGFjZW1lbnRzIiwib3ZlcmZsb3dzIiwic29ydCIsImEiLCJiIiwiZ2V0RXhwYW5kZWRGYWxsYmFja1BsYWNlbWVudHMiLCJvcHBvc2l0ZVBsYWNlbWVudCIsImZsaXAiLCJfc2tpcCIsIl9vcHRpb25zJG1haW5BeGlzIiwiY2hlY2tNYWluQXhpcyIsIl9vcHRpb25zJGFsdEF4aXMiLCJhbHRBeGlzIiwiY2hlY2tBbHRBeGlzIiwic3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzIiwiZmFsbGJhY2tQbGFjZW1lbnRzIiwiX29wdGlvbnMkZmxpcFZhcmlhdGlvIiwicHJlZmVycmVkUGxhY2VtZW50IiwiaXNCYXNlUGxhY2VtZW50IiwicmVmZXJlbmNlUmVjdCIsImNoZWNrc01hcCIsIk1hcCIsIm1ha2VGYWxsYmFja0NoZWNrcyIsImZpcnN0Rml0dGluZ1BsYWNlbWVudCIsIl9iYXNlUGxhY2VtZW50IiwiaXNTdGFydFZhcmlhdGlvbiIsIm1haW5WYXJpYXRpb25TaWRlIiwiYWx0VmFyaWF0aW9uU2lkZSIsImNoZWNrcyIsImV2ZXJ5IiwiY2hlY2siLCJudW1iZXJPZkNoZWNrcyIsIl9sb29wIiwiZml0dGluZ1BsYWNlbWVudCIsImZpbmQiLCJfcmV0IiwicmVzZXQiLCJmbGlwJDEiLCJnZXRTaWRlT2Zmc2V0cyIsInByZXZlbnRlZE9mZnNldHMiLCJpc0FueVNpZGVGdWxseUNsaXBwZWQiLCJzaWRlIiwiaGlkZSIsInByZXZlbnRPdmVyZmxvdyIsInJlZmVyZW5jZU92ZXJmbG93IiwicG9wcGVyQWx0T3ZlcmZsb3ciLCJyZWZlcmVuY2VDbGlwcGluZ09mZnNldHMiLCJwb3BwZXJFc2NhcGVPZmZzZXRzIiwiaXNSZWZlcmVuY2VIaWRkZW4iLCJoYXNQb3BwZXJFc2NhcGVkIiwiaGlkZSQxIiwiZGlzdGFuY2VBbmRTa2lkZGluZ1RvWFkiLCJpbnZlcnREaXN0YW5jZSIsInNraWRkaW5nIiwiZGlzdGFuY2UiLCJfb3B0aW9ucyRvZmZzZXQiLCJfZGF0YSRzdGF0ZSRwbGFjZW1lbnQiLCJvZmZzZXQkMSIsInBvcHBlck9mZnNldHMkMSIsImdldEFsdEF4aXMiLCJfb3B0aW9ucyR0ZXRoZXIiLCJ0ZXRoZXIiLCJfb3B0aW9ucyR0ZXRoZXJPZmZzZXQiLCJ0ZXRoZXJPZmZzZXQiLCJ0ZXRoZXJPZmZzZXRWYWx1ZSIsIm5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZSIsIm9mZnNldE1vZGlmaWVyU3RhdGUiLCJfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQiLCJtYWluU2lkZSIsImFsdFNpZGUiLCJhZGRpdGl2ZSIsIm1pbkxlbiIsIm1heExlbiIsImFycm93UGFkZGluZ09iamVjdCIsImFycm93UGFkZGluZ01pbiIsImFycm93UGFkZGluZ01heCIsImFycm93TGVuIiwibWluT2Zmc2V0IiwibWF4T2Zmc2V0IiwiY2xpZW50T2Zmc2V0Iiwib2Zmc2V0TW9kaWZpZXJWYWx1ZSIsInRldGhlck1pbiIsInRldGhlck1heCIsInByZXZlbnRlZE9mZnNldCIsIl9vZmZzZXRNb2RpZmllclN0YXRlJDIiLCJfbWFpblNpZGUiLCJfYWx0U2lkZSIsIl9vZmZzZXQiLCJfbGVuIiwiX21pbiIsIl9tYXgiLCJpc09yaWdpblNpZGUiLCJfb2Zmc2V0TW9kaWZpZXJWYWx1ZSIsIl90ZXRoZXJNaW4iLCJfdGV0aGVyTWF4IiwiX3ByZXZlbnRlZE9mZnNldCIsInByZXZlbnRPdmVyZmxvdyQxIiwiZ2V0SFRNTEVsZW1lbnRTY3JvbGwiLCJnZXROb2RlU2Nyb2xsIiwiaXNFbGVtZW50U2NhbGVkIiwiZ2V0Q29tcG9zaXRlUmVjdCIsImVsZW1lbnRPclZpcnR1YWxFbGVtZW50IiwiaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQiLCJvZmZzZXRQYXJlbnRJc1NjYWxlZCIsIm1vZGlmaWVycyIsInZpc2l0ZWQiLCJTZXQiLCJtb2RpZmllciIsImFkZCIsImRlcCIsImRlcE1vZGlmaWVyIiwib3JkZXJNb2RpZmllcnMiLCJvcmRlcmVkTW9kaWZpZXJzIiwiZGVib3VuY2UiLCJwZW5kaW5nIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwiZm9ybWF0IiwiYyIsIklOVkFMSURfTU9ESUZJRVJfRVJST1IiLCJNSVNTSU5HX0RFUEVOREVOQ1lfRVJST1IiLCJWQUxJRF9QUk9QRVJUSUVTIiwidmFsaWRhdGVNb2RpZmllcnMiLCJzZWxmIiwicmVxdWlyZW1lbnQiLCJtb2QiLCJ1bmlxdWVCeSIsImFyciIsImlkZW50aWZpZXJzIiwibWVyZ2VCeU5hbWUiLCJtZXJnZWQiLCJleGlzdGluZyIsIklOVkFMSURfRUxFTUVOVF9FUlJPUiIsIklORklOSVRFX0xPT1BfRVJST1IiLCJERUZBVUxUX09QVElPTlMiLCJhcmVWYWxpZEVsZW1lbnRzIiwicG9wcGVyR2VuZXJhdG9yIiwiZ2VuZXJhdG9yT3B0aW9ucyIsIl9nZW5lcmF0b3JPcHRpb25zIiwiX2dlbmVyYXRvck9wdGlvbnMkZGVmIiwiZGVmYXVsdE1vZGlmaWVycyIsIl9nZW5lcmF0b3JPcHRpb25zJGRlZjIiLCJkZWZhdWx0T3B0aW9ucyIsImNyZWF0ZVBvcHBlciIsImVmZmVjdENsZWFudXBGbnMiLCJpc0Rlc3Ryb3llZCIsInNldE9wdGlvbnMiLCJzZXRPcHRpb25zQWN0aW9uIiwiY2xlYW51cE1vZGlmaWVyRWZmZWN0cyIsIm0iLCJmbGlwTW9kaWZpZXIiLCJtYXJnaW5Ub3AiLCJtYXJnaW5SaWdodCIsIm1hcmdpbkJvdHRvbSIsIm1hcmdpbkxlZnQiLCJwYXJzZUZsb2F0IiwicnVuTW9kaWZpZXJFZmZlY3RzIiwiZm9yY2VVcGRhdGUiLCJfc3RhdGUkZWxlbWVudHMiLCJfX2RlYnVnX2xvb3BzX18iLCJfc3RhdGUkb3JkZXJlZE1vZGlmaWUiLCJfc3RhdGUkb3JkZXJlZE1vZGlmaWUyIiwiZGVzdHJveSIsIm9uRmlyc3RVcGRhdGUiLCJfcmVmMyRvcHRpb25zIiwiY2xlYW51cEZuIiwibm9vcEZuIiwidXNlUG9wcGVyIiwiYnV0dG9uUmVmIiwiY29udGVudFJlZiIsInBvcHBlckluc3RhbmNlUmVmIiwicm8iLCJSZXNpemVPYnNlcnZlciIsIm9ic2VydmUiLCJzZXRUaW1lb3V0IiwicG9wcGVySW5zdGFuY2UiLCJtZW51QnV0dG9uU3R5bGVzIiwiTWVudUJ1dHRvblJlZiIsImNvbXBvbmVudCIsImNsYXNzTmFtZVByb3AiLCJjbG9uZUVsZW1lbnQiLCJNZW51QnV0dG9uIiwiU3R5bGVkU3ViTWVudSIsImxpIiwidGVtcGxhdGVPYmplY3RfMSQxIiwiYnV0dG9uU3R5bGVzIiwiU3ViTWVudUZSIiwidGl0bGUiLCJvcGVuQ29udHJvbGxlZCIsIm9uT3BlbkNoYW5nZSIsIm9uS2V5VXAiLCJzaWRlYmFyVHJhbnNpdGlvbkR1cmF0aW9uIiwic2V0T3BlbiIsIl9oIiwic2V0T3BlbldoZW5Db2xsYXBzZWQiLCJfaiIsInRpbWVyIiwic2xpZGVVcCIsImRpc3BsYXkiLCJzbGlkZURvd24iLCJoYW5kbGVTbGlkZVRvZ2dsZSIsImNsZWFyVGltZW91dCIsIk51bWJlciIsIm9wZW5WYWx1ZSIsImhhbmRsZU9uQ2xpY2siLCJldmVudCIsImhhbmRsZU9uS2V5VXAiLCJnZXRTdWJNZW51SXRlbVN0eWxlcyIsInBhcmFtcyIsImlzU3VibWVudSIsInJvb3RFbFN0eWxlcyIsImJ1dHRvbkVsU3R5bGVzIiwibGFiZWxFbFN0eWxlcyIsImljb25FbFN0eWxlcyIsInByZWZpeEVsU3R5bGVzIiwic3VmZml4RWxTdHlsZXMiLCJzdWJNZW51Q29udGVudEVsU3R5bGVzIiwiU3ViTWVudUV4cGFuZEljb25FbFN0eWxlcyIsImhhbmRsZVRvZ2dsZVBvcHBlciIsImNsb3Nlc3QiLCJjbGFzc0xpc3QiLCJoYW5kbGVEb2N1bWVudENsaWNrIiwiaGFuZGxlRG9jdW1lbnRLZXlVcCIsInJlbW92ZUV2ZW50TGlzdGVuZXJzIiwic2hhcmVkQ2xhc3NlcyIsIlN1Yk1lbnUiLCJTdHlsZWRNZW51SXRlbSIsInRlbXBsYXRlT2JqZWN0XzEiLCJNZW51SXRlbUZSIiwiZ2V0TWVudUl0ZW1TdHlsZXMiLCJNZW51SXRlbSIsIlByb1NpZGViYXJQcm92aWRlciIsInVzZVByb1NpZGViYXIiLCJjb2xsYXBzZVNpZGViYXIiLCJ0b2dnbGVTaWRlYmFyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-pro-sidebar/dist/index.es.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/redux-thunk/es/index.js":
/*!**********************************************!*\
  !*** ./node_modules/redux-thunk/es/index.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/** A function that accepts a potential \"extra argument\" value to be injected later,\r\n * and returns an instance of the thunk middleware that uses that value\r\n */ function createThunkMiddleware(extraArgument) {\n    // Standard Redux middleware definition pattern:\n    // See: https://redux.js.org/tutorials/fundamentals/part-4-store#writing-custom-middleware\n    var middleware = function middleware(_ref) {\n        var dispatch = _ref.dispatch, getState = _ref.getState;\n        return function(next) {\n            return function(action) {\n                // The thunk middleware looks for any functions that were passed to `store.dispatch`.\n                // If this \"action\" is really a function, call it and return the result.\n                if (typeof action === \"function\") {\n                    // Inject the store's `dispatch` and `getState` methods, as well as any \"extra arg\"\n                    return action(dispatch, getState, extraArgument);\n                } // Otherwise, pass the action down the middleware chain as usual\n                return next(action);\n            };\n        };\n    };\n    return middleware;\n}\nvar thunk = createThunkMiddleware(); // Attach the factory function so users can create a customized version\n// with whatever \"extra arg\" they want to inject into their thunks\nthunk.withExtraArgument = createThunkMiddleware;\n/* harmony default export */ __webpack_exports__[\"default\"] = (thunk);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWR1eC10aHVuay9lcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7O0NBRUMsR0FDRCxTQUFTQSxzQkFBc0JDLGFBQWE7SUFDMUMsZ0RBQWdEO0lBQ2hELDBGQUEwRjtJQUMxRixJQUFJQyxhQUFhLFNBQVNBLFdBQVdDLElBQUk7UUFDdkMsSUFBSUMsV0FBV0QsS0FBS0MsUUFBUSxFQUN4QkMsV0FBV0YsS0FBS0UsUUFBUTtRQUM1QixPQUFPLFNBQVVDLElBQUk7WUFDbkIsT0FBTyxTQUFVQyxNQUFNO2dCQUNyQixxRkFBcUY7Z0JBQ3JGLHdFQUF3RTtnQkFDeEUsSUFBSSxPQUFPQSxXQUFXLFlBQVk7b0JBQ2hDLG1GQUFtRjtvQkFDbkYsT0FBT0EsT0FBT0gsVUFBVUMsVUFBVUo7Z0JBQ3BDLEVBQUUsZ0VBQWdFO2dCQUdsRSxPQUFPSyxLQUFLQztZQUNkO1FBQ0Y7SUFDRjtJQUVBLE9BQU9MO0FBQ1Q7QUFFQSxJQUFJTSxRQUFRUix5QkFBeUIsdUVBQXVFO0FBQzVHLGtFQUFrRTtBQUVsRVEsTUFBTUMsaUJBQWlCLEdBQUdUO0FBQzFCLCtEQUFlUSxLQUFLQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWR1eC10aHVuay9lcy9pbmRleC5qcz81MTFiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBBIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBhIHBvdGVudGlhbCBcImV4dHJhIGFyZ3VtZW50XCIgdmFsdWUgdG8gYmUgaW5qZWN0ZWQgbGF0ZXIsXHJcbiAqIGFuZCByZXR1cm5zIGFuIGluc3RhbmNlIG9mIHRoZSB0aHVuayBtaWRkbGV3YXJlIHRoYXQgdXNlcyB0aGF0IHZhbHVlXHJcbiAqL1xuZnVuY3Rpb24gY3JlYXRlVGh1bmtNaWRkbGV3YXJlKGV4dHJhQXJndW1lbnQpIHtcbiAgLy8gU3RhbmRhcmQgUmVkdXggbWlkZGxld2FyZSBkZWZpbml0aW9uIHBhdHRlcm46XG4gIC8vIFNlZTogaHR0cHM6Ly9yZWR1eC5qcy5vcmcvdHV0b3JpYWxzL2Z1bmRhbWVudGFscy9wYXJ0LTQtc3RvcmUjd3JpdGluZy1jdXN0b20tbWlkZGxld2FyZVxuICB2YXIgbWlkZGxld2FyZSA9IGZ1bmN0aW9uIG1pZGRsZXdhcmUoX3JlZikge1xuICAgIHZhciBkaXNwYXRjaCA9IF9yZWYuZGlzcGF0Y2gsXG4gICAgICAgIGdldFN0YXRlID0gX3JlZi5nZXRTdGF0ZTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIC8vIFRoZSB0aHVuayBtaWRkbGV3YXJlIGxvb2tzIGZvciBhbnkgZnVuY3Rpb25zIHRoYXQgd2VyZSBwYXNzZWQgdG8gYHN0b3JlLmRpc3BhdGNoYC5cbiAgICAgICAgLy8gSWYgdGhpcyBcImFjdGlvblwiIGlzIHJlYWxseSBhIGZ1bmN0aW9uLCBjYWxsIGl0IGFuZCByZXR1cm4gdGhlIHJlc3VsdC5cbiAgICAgICAgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBJbmplY3QgdGhlIHN0b3JlJ3MgYGRpc3BhdGNoYCBhbmQgYGdldFN0YXRlYCBtZXRob2RzLCBhcyB3ZWxsIGFzIGFueSBcImV4dHJhIGFyZ1wiXG4gICAgICAgICAgcmV0dXJuIGFjdGlvbihkaXNwYXRjaCwgZ2V0U3RhdGUsIGV4dHJhQXJndW1lbnQpO1xuICAgICAgICB9IC8vIE90aGVyd2lzZSwgcGFzcyB0aGUgYWN0aW9uIGRvd24gdGhlIG1pZGRsZXdhcmUgY2hhaW4gYXMgdXN1YWxcblxuXG4gICAgICAgIHJldHVybiBuZXh0KGFjdGlvbik7XG4gICAgICB9O1xuICAgIH07XG4gIH07XG5cbiAgcmV0dXJuIG1pZGRsZXdhcmU7XG59XG5cbnZhciB0aHVuayA9IGNyZWF0ZVRodW5rTWlkZGxld2FyZSgpOyAvLyBBdHRhY2ggdGhlIGZhY3RvcnkgZnVuY3Rpb24gc28gdXNlcnMgY2FuIGNyZWF0ZSBhIGN1c3RvbWl6ZWQgdmVyc2lvblxuLy8gd2l0aCB3aGF0ZXZlciBcImV4dHJhIGFyZ1wiIHRoZXkgd2FudCB0byBpbmplY3QgaW50byB0aGVpciB0aHVua3NcblxudGh1bmsud2l0aEV4dHJhQXJndW1lbnQgPSBjcmVhdGVUaHVua01pZGRsZXdhcmU7XG5leHBvcnQgZGVmYXVsdCB0aHVuazsiXSwibmFtZXMiOlsiY3JlYXRlVGh1bmtNaWRkbGV3YXJlIiwiZXh0cmFBcmd1bWVudCIsIm1pZGRsZXdhcmUiLCJfcmVmIiwiZGlzcGF0Y2giLCJnZXRTdGF0ZSIsIm5leHQiLCJhY3Rpb24iLCJ0aHVuayIsIndpdGhFeHRyYUFyZ3VtZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/redux-thunk/es/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/redux/es/redux.js":
/*!****************************************!*\
  !*** ./node_modules/redux/es/redux.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __DO_NOT_USE__ActionTypes: function() { return /* binding */ ActionTypes; },\n/* harmony export */   applyMiddleware: function() { return /* binding */ applyMiddleware; },\n/* harmony export */   bindActionCreators: function() { return /* binding */ bindActionCreators; },\n/* harmony export */   combineReducers: function() { return /* binding */ combineReducers; },\n/* harmony export */   compose: function() { return /* binding */ compose; },\n/* harmony export */   createStore: function() { return /* binding */ createStore; },\n/* harmony export */   legacy_createStore: function() { return /* binding */ legacy_createStore; }\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectSpread2 */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/objectSpread2.js\");\n\n/**\n * Adapted from React: https://github.com/facebook/react/blob/master/packages/shared/formatProdErrorMessage.js\n *\n * Do not require this module directly! Use normal throw error calls. These messages will be replaced with error codes\n * during build.\n * @param {number} code\n */ function formatProdErrorMessage(code) {\n    return \"Minified Redux error #\" + code + \"; visit https://redux.js.org/Errors?code=\" + code + \" for the full message or \" + \"use the non-minified dev environment for full errors. \";\n}\n// Inlined version of the `symbol-observable` polyfill\nvar $$observable = function() {\n    return typeof Symbol === \"function\" && Symbol.observable || \"@@observable\";\n}();\n/**\n * These are private action types reserved by Redux.\n * For any unknown actions, you must return the current state.\n * If the current state is undefined, you must return the initial state.\n * Do not reference these action types directly in your code.\n */ var randomString = function randomString() {\n    return Math.random().toString(36).substring(7).split(\"\").join(\".\");\n};\nvar ActionTypes = {\n    INIT: \"@@redux/INIT\" + randomString(),\n    REPLACE: \"@@redux/REPLACE\" + randomString(),\n    PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {\n        return \"@@redux/PROBE_UNKNOWN_ACTION\" + randomString();\n    }\n};\n/**\n * @param {any} obj The object to inspect.\n * @returns {boolean} True if the argument appears to be a plain object.\n */ function isPlainObject(obj) {\n    if (typeof obj !== \"object\" || obj === null) return false;\n    var proto = obj;\n    while(Object.getPrototypeOf(proto) !== null){\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(obj) === proto;\n}\n// Inlined / shortened version of `kindOf` from https://github.com/jonschlinkert/kind-of\nfunction miniKindOf(val) {\n    if (val === void 0) return \"undefined\";\n    if (val === null) return \"null\";\n    var type = typeof val;\n    switch(type){\n        case \"boolean\":\n        case \"string\":\n        case \"number\":\n        case \"symbol\":\n        case \"function\":\n            {\n                return type;\n            }\n    }\n    if (Array.isArray(val)) return \"array\";\n    if (isDate(val)) return \"date\";\n    if (isError(val)) return \"error\";\n    var constructorName = ctorName(val);\n    switch(constructorName){\n        case \"Symbol\":\n        case \"Promise\":\n        case \"WeakMap\":\n        case \"WeakSet\":\n        case \"Map\":\n        case \"Set\":\n            return constructorName;\n    } // other\n    return type.slice(8, -1).toLowerCase().replace(/\\s/g, \"\");\n}\nfunction ctorName(val) {\n    return typeof val.constructor === \"function\" ? val.constructor.name : null;\n}\nfunction isError(val) {\n    return val instanceof Error || typeof val.message === \"string\" && val.constructor && typeof val.constructor.stackTraceLimit === \"number\";\n}\nfunction isDate(val) {\n    if (val instanceof Date) return true;\n    return typeof val.toDateString === \"function\" && typeof val.getDate === \"function\" && typeof val.setDate === \"function\";\n}\nfunction kindOf(val) {\n    var typeOfVal = typeof val;\n    if (true) {\n        typeOfVal = miniKindOf(val);\n    }\n    return typeOfVal;\n}\n/**\n * @deprecated\n *\n * **We recommend using the `configureStore` method\n * of the `@reduxjs/toolkit` package**, which replaces `createStore`.\n *\n * Redux Toolkit is our recommended approach for writing Redux logic today,\n * including store setup, reducers, data fetching, and more.\n *\n * **For more details, please read this Redux docs page:**\n * **https://redux.js.org/introduction/why-rtk-is-redux-today**\n *\n * `configureStore` from Redux Toolkit is an improved version of `createStore` that\n * simplifies setup and helps avoid common bugs.\n *\n * You should not be using the `redux` core package by itself today, except for learning purposes.\n * The `createStore` method from the core `redux` package will not be removed, but we encourage\n * all users to migrate to using Redux Toolkit for all Redux code.\n *\n * If you want to use `createStore` without this visual deprecation warning, use\n * the `legacy_createStore` import instead:\n *\n * `import { legacy_createStore as createStore} from 'redux'`\n *\n */ function createStore(reducer, preloadedState, enhancer) {\n    var _ref2;\n    if (typeof preloadedState === \"function\" && typeof enhancer === \"function\" || typeof enhancer === \"function\" && typeof arguments[3] === \"function\") {\n        throw new Error( false ? 0 : \"It looks like you are passing several store enhancers to \" + \"createStore(). This is not supported. Instead, compose them \" + \"together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.\");\n    }\n    if (typeof preloadedState === \"function\" && typeof enhancer === \"undefined\") {\n        enhancer = preloadedState;\n        preloadedState = undefined;\n    }\n    if (typeof enhancer !== \"undefined\") {\n        if (typeof enhancer !== \"function\") {\n            throw new Error( false ? 0 : \"Expected the enhancer to be a function. Instead, received: '\" + kindOf(enhancer) + \"'\");\n        }\n        return enhancer(createStore)(reducer, preloadedState);\n    }\n    if (typeof reducer !== \"function\") {\n        throw new Error( false ? 0 : \"Expected the root reducer to be a function. Instead, received: '\" + kindOf(reducer) + \"'\");\n    }\n    var currentReducer = reducer;\n    var currentState = preloadedState;\n    var currentListeners = [];\n    var nextListeners = currentListeners;\n    var isDispatching = false;\n    /**\n   * This makes a shallow copy of currentListeners so we can use\n   * nextListeners as a temporary list while dispatching.\n   *\n   * This prevents any bugs around consumers calling\n   * subscribe/unsubscribe in the middle of a dispatch.\n   */ function ensureCanMutateNextListeners() {\n        if (nextListeners === currentListeners) {\n            nextListeners = currentListeners.slice();\n        }\n    }\n    /**\n   * Reads the state tree managed by the store.\n   *\n   * @returns {any} The current state tree of your application.\n   */ function getState() {\n        if (isDispatching) {\n            throw new Error( false ? 0 : \"You may not call store.getState() while the reducer is executing. \" + \"The reducer has already received the state as an argument. \" + \"Pass it down from the top reducer instead of reading it from the store.\");\n        }\n        return currentState;\n    }\n    /**\n   * Adds a change listener. It will be called any time an action is dispatched,\n   * and some part of the state tree may potentially have changed. You may then\n   * call `getState()` to read the current state tree inside the callback.\n   *\n   * You may call `dispatch()` from a change listener, with the following\n   * caveats:\n   *\n   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\n   * will not have any effect on the `dispatch()` that is currently in progress.\n   * However, the next `dispatch()` call, whether nested or not, will use a more\n   * recent snapshot of the subscription list.\n   *\n   * 2. The listener should not expect to see all state changes, as the state\n   * might have been updated multiple times during a nested `dispatch()` before\n   * the listener is called. It is, however, guaranteed that all subscribers\n   * registered before the `dispatch()` started will be called with the latest\n   * state by the time it exits.\n   *\n   * @param {Function} listener A callback to be invoked on every dispatch.\n   * @returns {Function} A function to remove this change listener.\n   */ function subscribe(listener) {\n        if (typeof listener !== \"function\") {\n            throw new Error( false ? 0 : \"Expected the listener to be a function. Instead, received: '\" + kindOf(listener) + \"'\");\n        }\n        if (isDispatching) {\n            throw new Error( false ? 0 : \"You may not call store.subscribe() while the reducer is executing. \" + \"If you would like to be notified after the store has been updated, subscribe from a \" + \"component and invoke store.getState() in the callback to access the latest state. \" + \"See https://redux.js.org/api/store#subscribelistener for more details.\");\n        }\n        var isSubscribed = true;\n        ensureCanMutateNextListeners();\n        nextListeners.push(listener);\n        return function unsubscribe() {\n            if (!isSubscribed) {\n                return;\n            }\n            if (isDispatching) {\n                throw new Error( false ? 0 : \"You may not unsubscribe from a store listener while the reducer is executing. \" + \"See https://redux.js.org/api/store#subscribelistener for more details.\");\n            }\n            isSubscribed = false;\n            ensureCanMutateNextListeners();\n            var index = nextListeners.indexOf(listener);\n            nextListeners.splice(index, 1);\n            currentListeners = null;\n        };\n    }\n    /**\n   * Dispatches an action. It is the only way to trigger a state change.\n   *\n   * The `reducer` function, used to create the store, will be called with the\n   * current state tree and the given `action`. Its return value will\n   * be considered the **next** state of the tree, and the change listeners\n   * will be notified.\n   *\n   * The base implementation only supports plain object actions. If you want to\n   * dispatch a Promise, an Observable, a thunk, or something else, you need to\n   * wrap your store creating function into the corresponding middleware. For\n   * example, see the documentation for the `redux-thunk` package. Even the\n   * middleware will eventually dispatch plain object actions using this method.\n   *\n   * @param {Object} action A plain object representing “what changed”. It is\n   * a good idea to keep actions serializable so you can record and replay user\n   * sessions, or use the time travelling `redux-devtools`. An action must have\n   * a `type` property which may not be `undefined`. It is a good idea to use\n   * string constants for action types.\n   *\n   * @returns {Object} For convenience, the same action object you dispatched.\n   *\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\n   * return something else (for example, a Promise you can await).\n   */ function dispatch(action) {\n        if (!isPlainObject(action)) {\n            throw new Error( false ? 0 : \"Actions must be plain objects. Instead, the actual type was: '\" + kindOf(action) + \"'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.\");\n        }\n        if (typeof action.type === \"undefined\") {\n            throw new Error( false ? 0 : 'Actions may not have an undefined \"type\" property. You may have misspelled an action type string constant.');\n        }\n        if (isDispatching) {\n            throw new Error( false ? 0 : \"Reducers may not dispatch actions.\");\n        }\n        try {\n            isDispatching = true;\n            currentState = currentReducer(currentState, action);\n        } finally{\n            isDispatching = false;\n        }\n        var listeners = currentListeners = nextListeners;\n        for(var i = 0; i < listeners.length; i++){\n            var listener = listeners[i];\n            listener();\n        }\n        return action;\n    }\n    /**\n   * Replaces the reducer currently used by the store to calculate the state.\n   *\n   * You might need this if your app implements code splitting and you want to\n   * load some of the reducers dynamically. You might also need this if you\n   * implement a hot reloading mechanism for Redux.\n   *\n   * @param {Function} nextReducer The reducer for the store to use instead.\n   * @returns {void}\n   */ function replaceReducer(nextReducer) {\n        if (typeof nextReducer !== \"function\") {\n            throw new Error( false ? 0 : \"Expected the nextReducer to be a function. Instead, received: '\" + kindOf(nextReducer));\n        }\n        currentReducer = nextReducer; // This action has a similiar effect to ActionTypes.INIT.\n        // Any reducers that existed in both the new and old rootReducer\n        // will receive the previous state. This effectively populates\n        // the new state tree with any relevant data from the old one.\n        dispatch({\n            type: ActionTypes.REPLACE\n        });\n    }\n    /**\n   * Interoperability point for observable/reactive libraries.\n   * @returns {observable} A minimal observable of state changes.\n   * For more information, see the observable proposal:\n   * https://github.com/tc39/proposal-observable\n   */ function observable() {\n        var _ref;\n        var outerSubscribe = subscribe;\n        return _ref = {\n            /**\n       * The minimal observable subscription method.\n       * @param {Object} observer Any object that can be used as an observer.\n       * The observer object should have a `next` method.\n       * @returns {subscription} An object with an `unsubscribe` method that can\n       * be used to unsubscribe the observable from the store, and prevent further\n       * emission of values from the observable.\n       */ subscribe: function subscribe(observer) {\n                if (typeof observer !== \"object\" || observer === null) {\n                    throw new Error( false ? 0 : \"Expected the observer to be an object. Instead, received: '\" + kindOf(observer) + \"'\");\n                }\n                function observeState() {\n                    if (observer.next) {\n                        observer.next(getState());\n                    }\n                }\n                observeState();\n                var unsubscribe = outerSubscribe(observeState);\n                return {\n                    unsubscribe: unsubscribe\n                };\n            }\n        }, _ref[$$observable] = function() {\n            return this;\n        }, _ref;\n    } // When a store is created, an \"INIT\" action is dispatched so that every\n    // reducer returns their initial state. This effectively populates\n    // the initial state tree.\n    dispatch({\n        type: ActionTypes.INIT\n    });\n    return _ref2 = {\n        dispatch: dispatch,\n        subscribe: subscribe,\n        getState: getState,\n        replaceReducer: replaceReducer\n    }, _ref2[$$observable] = observable, _ref2;\n}\n/**\n * Creates a Redux store that holds the state tree.\n *\n * **We recommend using `configureStore` from the\n * `@reduxjs/toolkit` package**, which replaces `createStore`:\n * **https://redux.js.org/introduction/why-rtk-is-redux-today**\n *\n * The only way to change the data in the store is to call `dispatch()` on it.\n *\n * There should only be a single store in your app. To specify how different\n * parts of the state tree respond to actions, you may combine several reducers\n * into a single reducer function by using `combineReducers`.\n *\n * @param {Function} reducer A function that returns the next state tree, given\n * the current state tree and the action to handle.\n *\n * @param {any} [preloadedState] The initial state. You may optionally specify it\n * to hydrate the state from the server in universal apps, or to restore a\n * previously serialized user session.\n * If you use `combineReducers` to produce the root reducer function, this must be\n * an object with the same shape as `combineReducers` keys.\n *\n * @param {Function} [enhancer] The store enhancer. You may optionally specify it\n * to enhance the store with third-party capabilities such as middleware,\n * time travel, persistence, etc. The only store enhancer that ships with Redux\n * is `applyMiddleware()`.\n *\n * @returns {Store} A Redux store that lets you read the state, dispatch actions\n * and subscribe to changes.\n */ var legacy_createStore = createStore;\n/**\n * Prints a warning in the console if it exists.\n *\n * @param {String} message The warning message.\n * @returns {void}\n */ function warning(message) {\n    /* eslint-disable no-console */ if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n        console.error(message);\n    }\n    /* eslint-enable no-console */ try {\n        // This error was thrown as a convenience so that if you enable\n        // \"break on all exceptions\" in your console,\n        // it would pause the execution at this line.\n        throw new Error(message);\n    } catch (e) {} // eslint-disable-line no-empty\n}\nfunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {\n    var reducerKeys = Object.keys(reducers);\n    var argumentName = action && action.type === ActionTypes.INIT ? \"preloadedState argument passed to createStore\" : \"previous state received by the reducer\";\n    if (reducerKeys.length === 0) {\n        return \"Store does not have a valid reducer. Make sure the argument passed \" + \"to combineReducers is an object whose values are reducers.\";\n    }\n    if (!isPlainObject(inputState)) {\n        return \"The \" + argumentName + ' has unexpected type of \"' + kindOf(inputState) + '\". Expected argument to be an object with the following ' + ('keys: \"' + reducerKeys.join('\", \"') + '\"');\n    }\n    var unexpectedKeys = Object.keys(inputState).filter(function(key) {\n        return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];\n    });\n    unexpectedKeys.forEach(function(key) {\n        unexpectedKeyCache[key] = true;\n    });\n    if (action && action.type === ActionTypes.REPLACE) return;\n    if (unexpectedKeys.length > 0) {\n        return \"Unexpected \" + (unexpectedKeys.length > 1 ? \"keys\" : \"key\") + \" \" + ('\"' + unexpectedKeys.join('\", \"') + '\" found in ' + argumentName + \". \") + \"Expected to find one of the known reducer keys instead: \" + ('\"' + reducerKeys.join('\", \"') + '\". Unexpected keys will be ignored.');\n    }\n}\nfunction assertReducerShape(reducers) {\n    Object.keys(reducers).forEach(function(key) {\n        var reducer = reducers[key];\n        var initialState = reducer(undefined, {\n            type: ActionTypes.INIT\n        });\n        if (typeof initialState === \"undefined\") {\n            throw new Error( false ? 0 : 'The slice reducer for key \"' + key + '\" returned undefined during initialization. ' + \"If the state passed to the reducer is undefined, you must \" + \"explicitly return the initial state. The initial state may \" + \"not be undefined. If you don't want to set a value for this reducer, \" + \"you can use null instead of undefined.\");\n        }\n        if (typeof reducer(undefined, {\n            type: ActionTypes.PROBE_UNKNOWN_ACTION()\n        }) === \"undefined\") {\n            throw new Error( false ? 0 : 'The slice reducer for key \"' + key + '\" returned undefined when probed with a random type. ' + (\"Don't try to handle '\" + ActionTypes.INIT + '\\' or other actions in \"redux/*\" ') + \"namespace. They are considered private. Instead, you must return the \" + \"current state for any unknown actions, unless it is undefined, \" + \"in which case you must return the initial state, regardless of the \" + \"action type. The initial state may not be undefined, but can be null.\");\n        }\n    });\n}\n/**\n * Turns an object whose values are different reducer functions, into a single\n * reducer function. It will call every child reducer, and gather their results\n * into a single state object, whose keys correspond to the keys of the passed\n * reducer functions.\n *\n * @param {Object} reducers An object whose values correspond to different\n * reducer functions that need to be combined into one. One handy way to obtain\n * it is to use ES6 `import * as reducers` syntax. The reducers may never return\n * undefined for any action. Instead, they should return their initial state\n * if the state passed to them was undefined, and the current state for any\n * unrecognized action.\n *\n * @returns {Function} A reducer function that invokes every reducer inside the\n * passed object, and builds a state object with the same shape.\n */ function combineReducers(reducers) {\n    var reducerKeys = Object.keys(reducers);\n    var finalReducers = {};\n    for(var i = 0; i < reducerKeys.length; i++){\n        var key = reducerKeys[i];\n        if (true) {\n            if (typeof reducers[key] === \"undefined\") {\n                warning('No reducer provided for key \"' + key + '\"');\n            }\n        }\n        if (typeof reducers[key] === \"function\") {\n            finalReducers[key] = reducers[key];\n        }\n    }\n    var finalReducerKeys = Object.keys(finalReducers); // This is used to make sure we don't warn about the same\n    // keys multiple times.\n    var unexpectedKeyCache;\n    if (true) {\n        unexpectedKeyCache = {};\n    }\n    var shapeAssertionError;\n    try {\n        assertReducerShape(finalReducers);\n    } catch (e) {\n        shapeAssertionError = e;\n    }\n    return function combination(state, action) {\n        if (state === void 0) {\n            state = {};\n        }\n        if (shapeAssertionError) {\n            throw shapeAssertionError;\n        }\n        if (true) {\n            var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);\n            if (warningMessage) {\n                warning(warningMessage);\n            }\n        }\n        var hasChanged = false;\n        var nextState = {};\n        for(var _i = 0; _i < finalReducerKeys.length; _i++){\n            var _key = finalReducerKeys[_i];\n            var reducer = finalReducers[_key];\n            var previousStateForKey = state[_key];\n            var nextStateForKey = reducer(previousStateForKey, action);\n            if (typeof nextStateForKey === \"undefined\") {\n                var actionType = action && action.type;\n                throw new Error( false ? 0 : \"When called with an action of type \" + (actionType ? '\"' + String(actionType) + '\"' : \"(unknown type)\") + ', the slice reducer for key \"' + _key + '\" returned undefined. ' + \"To ignore an action, you must explicitly return the previous state. \" + \"If you want this reducer to hold no value, you can return null instead of undefined.\");\n            }\n            nextState[_key] = nextStateForKey;\n            hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n        }\n        hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;\n        return hasChanged ? nextState : state;\n    };\n}\nfunction bindActionCreator(actionCreator, dispatch) {\n    return function() {\n        return dispatch(actionCreator.apply(this, arguments));\n    };\n}\n/**\n * Turns an object whose values are action creators, into an object with the\n * same keys, but with every function wrapped into a `dispatch` call so they\n * may be invoked directly. This is just a convenience method, as you can call\n * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.\n *\n * For convenience, you can also pass an action creator as the first argument,\n * and get a dispatch wrapped function in return.\n *\n * @param {Function|Object} actionCreators An object whose values are action\n * creator functions. One handy way to obtain it is to use ES6 `import * as`\n * syntax. You may also pass a single function.\n *\n * @param {Function} dispatch The `dispatch` function available on your Redux\n * store.\n *\n * @returns {Function|Object} The object mimicking the original object, but with\n * every action creator wrapped into the `dispatch` call. If you passed a\n * function as `actionCreators`, the return value will also be a single\n * function.\n */ function bindActionCreators(actionCreators, dispatch) {\n    if (typeof actionCreators === \"function\") {\n        return bindActionCreator(actionCreators, dispatch);\n    }\n    if (typeof actionCreators !== \"object\" || actionCreators === null) {\n        throw new Error( false ? 0 : \"bindActionCreators expected an object or a function, but instead received: '\" + kindOf(actionCreators) + \"'. \" + 'Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?');\n    }\n    var boundActionCreators = {};\n    for(var key in actionCreators){\n        var actionCreator = actionCreators[key];\n        if (typeof actionCreator === \"function\") {\n            boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\n        }\n    }\n    return boundActionCreators;\n}\n/**\n * Composes single-argument functions from right to left. The rightmost\n * function can take multiple arguments as it provides the signature for\n * the resulting composite function.\n *\n * @param {...Function} funcs The functions to compose.\n * @returns {Function} A function obtained by composing the argument functions\n * from right to left. For example, compose(f, g, h) is identical to doing\n * (...args) => f(g(h(...args))).\n */ function compose() {\n    for(var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++){\n        funcs[_key] = arguments[_key];\n    }\n    if (funcs.length === 0) {\n        return function(arg) {\n            return arg;\n        };\n    }\n    if (funcs.length === 1) {\n        return funcs[0];\n    }\n    return funcs.reduce(function(a, b) {\n        return function() {\n            return a(b.apply(void 0, arguments));\n        };\n    });\n}\n/**\n * Creates a store enhancer that applies middleware to the dispatch method\n * of the Redux store. This is handy for a variety of tasks, such as expressing\n * asynchronous actions in a concise manner, or logging every action payload.\n *\n * See `redux-thunk` package as an example of the Redux middleware.\n *\n * Because middleware is potentially asynchronous, this should be the first\n * store enhancer in the composition chain.\n *\n * Note that each middleware will be given the `dispatch` and `getState` functions\n * as named arguments.\n *\n * @param {...Function} middlewares The middleware chain to be applied.\n * @returns {Function} A store enhancer applying the middleware.\n */ function applyMiddleware() {\n    for(var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++){\n        middlewares[_key] = arguments[_key];\n    }\n    return function(createStore) {\n        return function() {\n            var store = createStore.apply(void 0, arguments);\n            var _dispatch = function dispatch() {\n                throw new Error( false ? 0 : \"Dispatching while constructing your middleware is not allowed. \" + \"Other middleware would not be applied to this dispatch.\");\n            };\n            var middlewareAPI = {\n                getState: store.getState,\n                dispatch: function dispatch() {\n                    return _dispatch.apply(void 0, arguments);\n                }\n            };\n            var chain = middlewares.map(function(middleware) {\n                return middleware(middlewareAPI);\n            });\n            _dispatch = compose.apply(void 0, chain)(store.dispatch);\n            return (0,_babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_0__[\"default\"])((0,_babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, store), {}, {\n                dispatch: _dispatch\n            });\n        };\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWR1eC9lcy9yZWR1eC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFxRTtBQUVyRTs7Ozs7O0NBTUMsR0FDRCxTQUFTQyx1QkFBdUJDLElBQUk7SUFDbEMsT0FBTywyQkFBMkJBLE9BQU8sOENBQThDQSxPQUFPLDhCQUE4QjtBQUM5SDtBQUVBLHNEQUFzRDtBQUN0RCxJQUFJQyxlQUFlO0lBQ2pCLE9BQU8sT0FBT0MsV0FBVyxjQUFjQSxPQUFPQyxVQUFVLElBQUk7QUFDOUQ7QUFFQTs7Ozs7Q0FLQyxHQUNELElBQUlDLGVBQWUsU0FBU0E7SUFDMUIsT0FBT0MsS0FBS0MsTUFBTSxHQUFHQyxRQUFRLENBQUMsSUFBSUMsU0FBUyxDQUFDLEdBQUdDLEtBQUssQ0FBQyxJQUFJQyxJQUFJLENBQUM7QUFDaEU7QUFFQSxJQUFJQyxjQUFjO0lBQ2hCQyxNQUFNLGlCQUFpQlI7SUFDdkJTLFNBQVMsb0JBQW9CVDtJQUM3QlUsc0JBQXNCLFNBQVNBO1FBQzdCLE9BQU8saUNBQWlDVjtJQUMxQztBQUNGO0FBRUE7OztDQUdDLEdBQ0QsU0FBU1csY0FBY0MsR0FBRztJQUN4QixJQUFJLE9BQU9BLFFBQVEsWUFBWUEsUUFBUSxNQUFNLE9BQU87SUFDcEQsSUFBSUMsUUFBUUQ7SUFFWixNQUFPRSxPQUFPQyxjQUFjLENBQUNGLFdBQVcsS0FBTTtRQUM1Q0EsUUFBUUMsT0FBT0MsY0FBYyxDQUFDRjtJQUNoQztJQUVBLE9BQU9DLE9BQU9DLGNBQWMsQ0FBQ0gsU0FBU0M7QUFDeEM7QUFFQSx3RkFBd0Y7QUFDeEYsU0FBU0csV0FBV0MsR0FBRztJQUNyQixJQUFJQSxRQUFRLEtBQUssR0FBRyxPQUFPO0lBQzNCLElBQUlBLFFBQVEsTUFBTSxPQUFPO0lBQ3pCLElBQUlDLE9BQU8sT0FBT0Q7SUFFbEIsT0FBUUM7UUFDTixLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNI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LElBQUloQyxNQUFNUyxNQUFxQyxHQUFHNUMsQ0FBMEIsR0FBRyxvRUFBb0U7WUFDM0o7WUFFQSxJQUFJa0ksZ0JBQWdCO2dCQUNsQnhFLFVBQVVzRSxNQUFNdEUsUUFBUTtnQkFDeEJTLFVBQVUsU0FBU0E7b0JBQ2pCLE9BQU84RCxVQUFVZCxLQUFLLENBQUMsS0FBSyxHQUFHakU7Z0JBQ2pDO1lBQ0Y7WUFDQSxJQUFJaUYsUUFBUUosWUFBWUssR0FBRyxDQUFDLFNBQVVDLFVBQVU7Z0JBQzlDLE9BQU9BLFdBQVdIO1lBQ3BCO1lBQ0FELFlBQVlWLFFBQVFKLEtBQUssQ0FBQyxLQUFLLEdBQUdnQixPQUFPSCxNQUFNN0QsUUFBUTtZQUN2RCxPQUFPcEUsb0ZBQWFBLENBQUNBLG9GQUFhQSxDQUFDLENBQUMsR0FBR2lJLFFBQVEsQ0FBQyxHQUFHO2dCQUNqRDdELFVBQVU4RDtZQUNaO1FBQ0Y7SUFDRjtBQUNGO0FBRW9KIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWR1eC9lcy9yZWR1eC5qcz9lYmYyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfb2JqZWN0U3ByZWFkIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFNwcmVhZDInO1xuXG4vKipcbiAqIEFkYXB0ZWQgZnJvbSBSZWFjdDogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvbWFzdGVyL3BhY2thZ2VzL3NoYXJlZC9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlLmpzXG4gKlxuICogRG8gbm90IHJlcXVpcmUgdGhpcyBtb2R1bGUgZGlyZWN0bHkhIFVzZSBub3JtYWwgdGhyb3cgZXJyb3IgY2FsbHMuIFRoZXNlIG1lc3NhZ2VzIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBlcnJvciBjb2Rlc1xuICogZHVyaW5nIGJ1aWxkLlxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGVcbiAqL1xuZnVuY3Rpb24gZm9ybWF0UHJvZEVycm9yTWVzc2FnZShjb2RlKSB7XG4gIHJldHVybiBcIk1pbmlmaWVkIFJlZHV4IGVycm9yICNcIiArIGNvZGUgKyBcIjsgdmlzaXQgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvRXJyb3JzP2NvZGU9XCIgKyBjb2RlICsgXCIgZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgXCIgKyAndXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciBmdWxsIGVycm9ycy4gJztcbn1cblxuLy8gSW5saW5lZCB2ZXJzaW9uIG9mIHRoZSBgc3ltYm9sLW9ic2VydmFibGVgIHBvbHlmaWxsXG52YXIgJCRvYnNlcnZhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLm9ic2VydmFibGUgfHwgJ0BAb2JzZXJ2YWJsZSc7XG59KSgpO1xuXG4vKipcbiAqIFRoZXNlIGFyZSBwcml2YXRlIGFjdGlvbiB0eXBlcyByZXNlcnZlZCBieSBSZWR1eC5cbiAqIEZvciBhbnkgdW5rbm93biBhY3Rpb25zLCB5b3UgbXVzdCByZXR1cm4gdGhlIGN1cnJlbnQgc3RhdGUuXG4gKiBJZiB0aGUgY3VycmVudCBzdGF0ZSBpcyB1bmRlZmluZWQsIHlvdSBtdXN0IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZS5cbiAqIERvIG5vdCByZWZlcmVuY2UgdGhlc2UgYWN0aW9uIHR5cGVzIGRpcmVjdGx5IGluIHlvdXIgY29kZS5cbiAqL1xudmFyIHJhbmRvbVN0cmluZyA9IGZ1bmN0aW9uIHJhbmRvbVN0cmluZygpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg3KS5zcGxpdCgnJykuam9pbignLicpO1xufTtcblxudmFyIEFjdGlvblR5cGVzID0ge1xuICBJTklUOiBcIkBAcmVkdXgvSU5JVFwiICsgcmFuZG9tU3RyaW5nKCksXG4gIFJFUExBQ0U6IFwiQEByZWR1eC9SRVBMQUNFXCIgKyByYW5kb21TdHJpbmcoKSxcbiAgUFJPQkVfVU5LTk9XTl9BQ1RJT046IGZ1bmN0aW9uIFBST0JFX1VOS05PV05fQUNUSU9OKCkge1xuICAgIHJldHVybiBcIkBAcmVkdXgvUFJPQkVfVU5LTk9XTl9BQ1RJT05cIiArIHJhbmRvbVN0cmluZygpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBvYmogVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIGFyZ3VtZW50IGFwcGVhcnMgdG8gYmUgYSBwbGFpbiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgdmFyIHByb3RvID0gb2JqO1xuXG4gIHdoaWxlIChPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pICE9PSBudWxsKSB7XG4gICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopID09PSBwcm90bztcbn1cblxuLy8gSW5saW5lZCAvIHNob3J0ZW5lZCB2ZXJzaW9uIG9mIGBraW5kT2ZgIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQva2luZC1vZlxuZnVuY3Rpb24gbWluaUtpbmRPZih2YWwpIHtcbiAgaWYgKHZhbCA9PT0gdm9pZCAwKSByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gIGlmICh2YWwgPT09IG51bGwpIHJldHVybiAnbnVsbCc7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgY2FzZSAnc3ltYm9sJzpcbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkgcmV0dXJuICdhcnJheSc7XG4gIGlmIChpc0RhdGUodmFsKSkgcmV0dXJuICdkYXRlJztcbiAgaWYgKGlzRXJyb3IodmFsKSkgcmV0dXJuICdlcnJvcic7XG4gIHZhciBjb25zdHJ1Y3Rvck5hbWUgPSBjdG9yTmFtZSh2YWwpO1xuXG4gIHN3aXRjaCAoY29uc3RydWN0b3JOYW1lKSB7XG4gICAgY2FzZSAnU3ltYm9sJzpcbiAgICBjYXNlICdQcm9taXNlJzpcbiAgICBjYXNlICdXZWFrTWFwJzpcbiAgICBjYXNlICdXZWFrU2V0JzpcbiAgICBjYXNlICdNYXAnOlxuICAgIGNhc2UgJ1NldCc6XG4gICAgICByZXR1cm4gY29uc3RydWN0b3JOYW1lO1xuICB9IC8vIG90aGVyXG5cblxuICByZXR1cm4gdHlwZS5zbGljZSg4LCAtMSkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXHMvZywgJycpO1xufVxuXG5mdW5jdGlvbiBjdG9yTmFtZSh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwuY29uc3RydWN0b3IgPT09ICdmdW5jdGlvbicgPyB2YWwuY29uc3RydWN0b3IubmFtZSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzRXJyb3IodmFsKSB7XG4gIHJldHVybiB2YWwgaW5zdGFuY2VvZiBFcnJvciB8fCB0eXBlb2YgdmFsLm1lc3NhZ2UgPT09ICdzdHJpbmcnICYmIHZhbC5jb25zdHJ1Y3RvciAmJiB0eXBlb2YgdmFsLmNvbnN0cnVjdG9yLnN0YWNrVHJhY2VMaW1pdCA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzRGF0ZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIERhdGUpIHJldHVybiB0cnVlO1xuICByZXR1cm4gdHlwZW9mIHZhbC50b0RhdGVTdHJpbmcgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbC5nZXREYXRlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWwuc2V0RGF0ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24ga2luZE9mKHZhbCkge1xuICB2YXIgdHlwZU9mVmFsID0gdHlwZW9mIHZhbDtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHR5cGVPZlZhbCA9IG1pbmlLaW5kT2YodmFsKTtcbiAgfVxuXG4gIHJldHVybiB0eXBlT2ZWYWw7XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqXG4gKiAqKldlIHJlY29tbWVuZCB1c2luZyB0aGUgYGNvbmZpZ3VyZVN0b3JlYCBtZXRob2RcbiAqIG9mIHRoZSBgQHJlZHV4anMvdG9vbGtpdGAgcGFja2FnZSoqLCB3aGljaCByZXBsYWNlcyBgY3JlYXRlU3RvcmVgLlxuICpcbiAqIFJlZHV4IFRvb2xraXQgaXMgb3VyIHJlY29tbWVuZGVkIGFwcHJvYWNoIGZvciB3cml0aW5nIFJlZHV4IGxvZ2ljIHRvZGF5LFxuICogaW5jbHVkaW5nIHN0b3JlIHNldHVwLCByZWR1Y2VycywgZGF0YSBmZXRjaGluZywgYW5kIG1vcmUuXG4gKlxuICogKipGb3IgbW9yZSBkZXRhaWxzLCBwbGVhc2UgcmVhZCB0aGlzIFJlZHV4IGRvY3MgcGFnZToqKlxuICogKipodHRwczovL3JlZHV4LmpzLm9yZy9pbnRyb2R1Y3Rpb24vd2h5LXJ0ay1pcy1yZWR1eC10b2RheSoqXG4gKlxuICogYGNvbmZpZ3VyZVN0b3JlYCBmcm9tIFJlZHV4IFRvb2xraXQgaXMgYW4gaW1wcm92ZWQgdmVyc2lvbiBvZiBgY3JlYXRlU3RvcmVgIHRoYXRcbiAqIHNpbXBsaWZpZXMgc2V0dXAgYW5kIGhlbHBzIGF2b2lkIGNvbW1vbiBidWdzLlxuICpcbiAqIFlvdSBzaG91bGQgbm90IGJlIHVzaW5nIHRoZSBgcmVkdXhgIGNvcmUgcGFja2FnZSBieSBpdHNlbGYgdG9kYXksIGV4Y2VwdCBmb3IgbGVhcm5pbmcgcHVycG9zZXMuXG4gKiBUaGUgYGNyZWF0ZVN0b3JlYCBtZXRob2QgZnJvbSB0aGUgY29yZSBgcmVkdXhgIHBhY2thZ2Ugd2lsbCBub3QgYmUgcmVtb3ZlZCwgYnV0IHdlIGVuY291cmFnZVxuICogYWxsIHVzZXJzIHRvIG1pZ3JhdGUgdG8gdXNpbmcgUmVkdXggVG9vbGtpdCBmb3IgYWxsIFJlZHV4IGNvZGUuXG4gKlxuICogSWYgeW91IHdhbnQgdG8gdXNlIGBjcmVhdGVTdG9yZWAgd2l0aG91dCB0aGlzIHZpc3VhbCBkZXByZWNhdGlvbiB3YXJuaW5nLCB1c2VcbiAqIHRoZSBgbGVnYWN5X2NyZWF0ZVN0b3JlYCBpbXBvcnQgaW5zdGVhZDpcbiAqXG4gKiBgaW1wb3J0IHsgbGVnYWN5X2NyZWF0ZVN0b3JlIGFzIGNyZWF0ZVN0b3JlfSBmcm9tICdyZWR1eCdgXG4gKlxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlLCBlbmhhbmNlcikge1xuICB2YXIgX3JlZjI7XG5cbiAgaWYgKHR5cGVvZiBwcmVsb2FkZWRTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZW5oYW5jZXIgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGVuaGFuY2VyID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBhcmd1bWVudHNbM10gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgwKSA6ICdJdCBsb29rcyBsaWtlIHlvdSBhcmUgcGFzc2luZyBzZXZlcmFsIHN0b3JlIGVuaGFuY2VycyB0byAnICsgJ2NyZWF0ZVN0b3JlKCkuIFRoaXMgaXMgbm90IHN1cHBvcnRlZC4gSW5zdGVhZCwgY29tcG9zZSB0aGVtICcgKyAndG9nZXRoZXIgdG8gYSBzaW5nbGUgZnVuY3Rpb24uIFNlZSBodHRwczovL3JlZHV4LmpzLm9yZy90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3BhcnQtNC1zdG9yZSNjcmVhdGluZy1hLXN0b3JlLXdpdGgtZW5oYW5jZXJzIGZvciBhbiBleGFtcGxlLicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwcmVsb2FkZWRTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZW5oYW5jZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZW5oYW5jZXIgPSBwcmVsb2FkZWRTdGF0ZTtcbiAgICBwcmVsb2FkZWRTdGF0ZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5oYW5jZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBlbmhhbmNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMSkgOiBcIkV4cGVjdGVkIHRoZSBlbmhhbmNlciB0byBiZSBhIGZ1bmN0aW9uLiBJbnN0ZWFkLCByZWNlaXZlZDogJ1wiICsga2luZE9mKGVuaGFuY2VyKSArIFwiJ1wiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW5oYW5jZXIoY3JlYXRlU3RvcmUpKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcmVkdWNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDIpIDogXCJFeHBlY3RlZCB0aGUgcm9vdCByZWR1Y2VyIHRvIGJlIGEgZnVuY3Rpb24uIEluc3RlYWQsIHJlY2VpdmVkOiAnXCIgKyBraW5kT2YocmVkdWNlcikgKyBcIidcIik7XG4gIH1cblxuICB2YXIgY3VycmVudFJlZHVjZXIgPSByZWR1Y2VyO1xuICB2YXIgY3VycmVudFN0YXRlID0gcHJlbG9hZGVkU3RhdGU7XG4gIHZhciBjdXJyZW50TGlzdGVuZXJzID0gW107XG4gIHZhciBuZXh0TGlzdGVuZXJzID0gY3VycmVudExpc3RlbmVycztcbiAgdmFyIGlzRGlzcGF0Y2hpbmcgPSBmYWxzZTtcbiAgLyoqXG4gICAqIFRoaXMgbWFrZXMgYSBzaGFsbG93IGNvcHkgb2YgY3VycmVudExpc3RlbmVycyBzbyB3ZSBjYW4gdXNlXG4gICAqIG5leHRMaXN0ZW5lcnMgYXMgYSB0ZW1wb3JhcnkgbGlzdCB3aGlsZSBkaXNwYXRjaGluZy5cbiAgICpcbiAgICogVGhpcyBwcmV2ZW50cyBhbnkgYnVncyBhcm91bmQgY29uc3VtZXJzIGNhbGxpbmdcbiAgICogc3Vic2NyaWJlL3Vuc3Vic2NyaWJlIGluIHRoZSBtaWRkbGUgb2YgYSBkaXNwYXRjaC5cbiAgICovXG5cbiAgZnVuY3Rpb24gZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpIHtcbiAgICBpZiAobmV4dExpc3RlbmVycyA9PT0gY3VycmVudExpc3RlbmVycykge1xuICAgICAgbmV4dExpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnMuc2xpY2UoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlYWRzIHRoZSBzdGF0ZSB0cmVlIG1hbmFnZWQgYnkgdGhlIHN0b3JlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7YW55fSBUaGUgY3VycmVudCBzdGF0ZSB0cmVlIG9mIHlvdXIgYXBwbGljYXRpb24uXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0U3RhdGUoKSB7XG4gICAgaWYgKGlzRGlzcGF0Y2hpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMpIDogJ1lvdSBtYXkgbm90IGNhbGwgc3RvcmUuZ2V0U3RhdGUoKSB3aGlsZSB0aGUgcmVkdWNlciBpcyBleGVjdXRpbmcuICcgKyAnVGhlIHJlZHVjZXIgaGFzIGFscmVhZHkgcmVjZWl2ZWQgdGhlIHN0YXRlIGFzIGFuIGFyZ3VtZW50LiAnICsgJ1Bhc3MgaXQgZG93biBmcm9tIHRoZSB0b3AgcmVkdWNlciBpbnN0ZWFkIG9mIHJlYWRpbmcgaXQgZnJvbSB0aGUgc3RvcmUuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnJlbnRTdGF0ZTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIGNoYW5nZSBsaXN0ZW5lci4gSXQgd2lsbCBiZSBjYWxsZWQgYW55IHRpbWUgYW4gYWN0aW9uIGlzIGRpc3BhdGNoZWQsXG4gICAqIGFuZCBzb21lIHBhcnQgb2YgdGhlIHN0YXRlIHRyZWUgbWF5IHBvdGVudGlhbGx5IGhhdmUgY2hhbmdlZC4gWW91IG1heSB0aGVuXG4gICAqIGNhbGwgYGdldFN0YXRlKClgIHRvIHJlYWQgdGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBpbnNpZGUgdGhlIGNhbGxiYWNrLlxuICAgKlxuICAgKiBZb3UgbWF5IGNhbGwgYGRpc3BhdGNoKClgIGZyb20gYSBjaGFuZ2UgbGlzdGVuZXIsIHdpdGggdGhlIGZvbGxvd2luZ1xuICAgKiBjYXZlYXRzOlxuICAgKlxuICAgKiAxLiBUaGUgc3Vic2NyaXB0aW9ucyBhcmUgc25hcHNob3R0ZWQganVzdCBiZWZvcmUgZXZlcnkgYGRpc3BhdGNoKClgIGNhbGwuXG4gICAqIElmIHlvdSBzdWJzY3JpYmUgb3IgdW5zdWJzY3JpYmUgd2hpbGUgdGhlIGxpc3RlbmVycyBhcmUgYmVpbmcgaW52b2tlZCwgdGhpc1xuICAgKiB3aWxsIG5vdCBoYXZlIGFueSBlZmZlY3Qgb24gdGhlIGBkaXNwYXRjaCgpYCB0aGF0IGlzIGN1cnJlbnRseSBpbiBwcm9ncmVzcy5cbiAgICogSG93ZXZlciwgdGhlIG5leHQgYGRpc3BhdGNoKClgIGNhbGwsIHdoZXRoZXIgbmVzdGVkIG9yIG5vdCwgd2lsbCB1c2UgYSBtb3JlXG4gICAqIHJlY2VudCBzbmFwc2hvdCBvZiB0aGUgc3Vic2NyaXB0aW9uIGxpc3QuXG4gICAqXG4gICAqIDIuIFRoZSBsaXN0ZW5lciBzaG91bGQgbm90IGV4cGVjdCB0byBzZWUgYWxsIHN0YXRlIGNoYW5nZXMsIGFzIHRoZSBzdGF0ZVxuICAgKiBtaWdodCBoYXZlIGJlZW4gdXBkYXRlZCBtdWx0aXBsZSB0aW1lcyBkdXJpbmcgYSBuZXN0ZWQgYGRpc3BhdGNoKClgIGJlZm9yZVxuICAgKiB0aGUgbGlzdGVuZXIgaXMgY2FsbGVkLiBJdCBpcywgaG93ZXZlciwgZ3VhcmFudGVlZCB0aGF0IGFsbCBzdWJzY3JpYmVyc1xuICAgKiByZWdpc3RlcmVkIGJlZm9yZSB0aGUgYGRpc3BhdGNoKClgIHN0YXJ0ZWQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgbGF0ZXN0XG4gICAqIHN0YXRlIGJ5IHRoZSB0aW1lIGl0IGV4aXRzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBBIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgb24gZXZlcnkgZGlzcGF0Y2guXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0byByZW1vdmUgdGhpcyBjaGFuZ2UgbGlzdGVuZXIuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNCkgOiBcIkV4cGVjdGVkIHRoZSBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLiBJbnN0ZWFkLCByZWNlaXZlZDogJ1wiICsga2luZE9mKGxpc3RlbmVyKSArIFwiJ1wiKTtcbiAgICB9XG5cbiAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNSkgOiAnWW91IG1heSBub3QgY2FsbCBzdG9yZS5zdWJzY3JpYmUoKSB3aGlsZSB0aGUgcmVkdWNlciBpcyBleGVjdXRpbmcuICcgKyAnSWYgeW91IHdvdWxkIGxpa2UgdG8gYmUgbm90aWZpZWQgYWZ0ZXIgdGhlIHN0b3JlIGhhcyBiZWVuIHVwZGF0ZWQsIHN1YnNjcmliZSBmcm9tIGEgJyArICdjb21wb25lbnQgYW5kIGludm9rZSBzdG9yZS5nZXRTdGF0ZSgpIGluIHRoZSBjYWxsYmFjayB0byBhY2Nlc3MgdGhlIGxhdGVzdCBzdGF0ZS4gJyArICdTZWUgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvYXBpL3N0b3JlI3N1YnNjcmliZWxpc3RlbmVyIGZvciBtb3JlIGRldGFpbHMuJyk7XG4gICAgfVxuXG4gICAgdmFyIGlzU3Vic2NyaWJlZCA9IHRydWU7XG4gICAgZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpO1xuICAgIG5leHRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgaWYgKCFpc1N1YnNjcmliZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg2KSA6ICdZb3UgbWF5IG5vdCB1bnN1YnNjcmliZSBmcm9tIGEgc3RvcmUgbGlzdGVuZXIgd2hpbGUgdGhlIHJlZHVjZXIgaXMgZXhlY3V0aW5nLiAnICsgJ1NlZSBodHRwczovL3JlZHV4LmpzLm9yZy9hcGkvc3RvcmUjc3Vic2NyaWJlbGlzdGVuZXIgZm9yIG1vcmUgZGV0YWlscy4nKTtcbiAgICAgIH1cblxuICAgICAgaXNTdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgICBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCk7XG4gICAgICB2YXIgaW5kZXggPSBuZXh0TGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgbmV4dExpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgY3VycmVudExpc3RlbmVycyA9IG51bGw7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhbiBhY3Rpb24uIEl0IGlzIHRoZSBvbmx5IHdheSB0byB0cmlnZ2VyIGEgc3RhdGUgY2hhbmdlLlxuICAgKlxuICAgKiBUaGUgYHJlZHVjZXJgIGZ1bmN0aW9uLCB1c2VkIHRvIGNyZWF0ZSB0aGUgc3RvcmUsIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlXG4gICAqIGN1cnJlbnQgc3RhdGUgdHJlZSBhbmQgdGhlIGdpdmVuIGBhY3Rpb25gLiBJdHMgcmV0dXJuIHZhbHVlIHdpbGxcbiAgICogYmUgY29uc2lkZXJlZCB0aGUgKipuZXh0Kiogc3RhdGUgb2YgdGhlIHRyZWUsIGFuZCB0aGUgY2hhbmdlIGxpc3RlbmVyc1xuICAgKiB3aWxsIGJlIG5vdGlmaWVkLlxuICAgKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvbmx5IHN1cHBvcnRzIHBsYWluIG9iamVjdCBhY3Rpb25zLiBJZiB5b3Ugd2FudCB0b1xuICAgKiBkaXNwYXRjaCBhIFByb21pc2UsIGFuIE9ic2VydmFibGUsIGEgdGh1bmssIG9yIHNvbWV0aGluZyBlbHNlLCB5b3UgbmVlZCB0b1xuICAgKiB3cmFwIHlvdXIgc3RvcmUgY3JlYXRpbmcgZnVuY3Rpb24gaW50byB0aGUgY29ycmVzcG9uZGluZyBtaWRkbGV3YXJlLiBGb3JcbiAgICogZXhhbXBsZSwgc2VlIHRoZSBkb2N1bWVudGF0aW9uIGZvciB0aGUgYHJlZHV4LXRodW5rYCBwYWNrYWdlLiBFdmVuIHRoZVxuICAgKiBtaWRkbGV3YXJlIHdpbGwgZXZlbnR1YWxseSBkaXNwYXRjaCBwbGFpbiBvYmplY3QgYWN0aW9ucyB1c2luZyB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbiBBIHBsYWluIG9iamVjdCByZXByZXNlbnRpbmcg4oCcd2hhdCBjaGFuZ2Vk4oCdLiBJdCBpc1xuICAgKiBhIGdvb2QgaWRlYSB0byBrZWVwIGFjdGlvbnMgc2VyaWFsaXphYmxlIHNvIHlvdSBjYW4gcmVjb3JkIGFuZCByZXBsYXkgdXNlclxuICAgKiBzZXNzaW9ucywgb3IgdXNlIHRoZSB0aW1lIHRyYXZlbGxpbmcgYHJlZHV4LWRldnRvb2xzYC4gQW4gYWN0aW9uIG11c3QgaGF2ZVxuICAgKiBhIGB0eXBlYCBwcm9wZXJ0eSB3aGljaCBtYXkgbm90IGJlIGB1bmRlZmluZWRgLiBJdCBpcyBhIGdvb2QgaWRlYSB0byB1c2VcbiAgICogc3RyaW5nIGNvbnN0YW50cyBmb3IgYWN0aW9uIHR5cGVzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBGb3IgY29udmVuaWVuY2UsIHRoZSBzYW1lIGFjdGlvbiBvYmplY3QgeW91IGRpc3BhdGNoZWQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCwgaWYgeW91IHVzZSBhIGN1c3RvbSBtaWRkbGV3YXJlLCBpdCBtYXkgd3JhcCBgZGlzcGF0Y2goKWAgdG9cbiAgICogcmV0dXJuIHNvbWV0aGluZyBlbHNlIChmb3IgZXhhbXBsZSwgYSBQcm9taXNlIHlvdSBjYW4gYXdhaXQpLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGRpc3BhdGNoKGFjdGlvbikge1xuICAgIGlmICghaXNQbGFpbk9iamVjdChhY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg3KSA6IFwiQWN0aW9ucyBtdXN0IGJlIHBsYWluIG9iamVjdHMuIEluc3RlYWQsIHRoZSBhY3R1YWwgdHlwZSB3YXM6ICdcIiArIGtpbmRPZihhY3Rpb24pICsgXCInLiBZb3UgbWF5IG5lZWQgdG8gYWRkIG1pZGRsZXdhcmUgdG8geW91ciBzdG9yZSBzZXR1cCB0byBoYW5kbGUgZGlzcGF0Y2hpbmcgb3RoZXIgdmFsdWVzLCBzdWNoIGFzICdyZWR1eC10aHVuaycgdG8gaGFuZGxlIGRpc3BhdGNoaW5nIGZ1bmN0aW9ucy4gU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL3R1dG9yaWFscy9mdW5kYW1lbnRhbHMvcGFydC00LXN0b3JlI21pZGRsZXdhcmUgYW5kIGh0dHBzOi8vcmVkdXguanMub3JnL3R1dG9yaWFscy9mdW5kYW1lbnRhbHMvcGFydC02LWFzeW5jLWxvZ2ljI3VzaW5nLXRoZS1yZWR1eC10aHVuay1taWRkbGV3YXJlIGZvciBleGFtcGxlcy5cIik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBhY3Rpb24udHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDgpIDogJ0FjdGlvbnMgbWF5IG5vdCBoYXZlIGFuIHVuZGVmaW5lZCBcInR5cGVcIiBwcm9wZXJ0eS4gWW91IG1heSBoYXZlIG1pc3NwZWxsZWQgYW4gYWN0aW9uIHR5cGUgc3RyaW5nIGNvbnN0YW50LicpO1xuICAgIH1cblxuICAgIGlmIChpc0Rpc3BhdGNoaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg5KSA6ICdSZWR1Y2VycyBtYXkgbm90IGRpc3BhdGNoIGFjdGlvbnMuJyk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlzRGlzcGF0Y2hpbmcgPSB0cnVlO1xuICAgICAgY3VycmVudFN0YXRlID0gY3VycmVudFJlZHVjZXIoY3VycmVudFN0YXRlLCBhY3Rpb24pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpc0Rpc3BhdGNoaW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGxpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnMgPSBuZXh0TGlzdGVuZXJzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXTtcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjdGlvbjtcbiAgfVxuICAvKipcbiAgICogUmVwbGFjZXMgdGhlIHJlZHVjZXIgY3VycmVudGx5IHVzZWQgYnkgdGhlIHN0b3JlIHRvIGNhbGN1bGF0ZSB0aGUgc3RhdGUuXG4gICAqXG4gICAqIFlvdSBtaWdodCBuZWVkIHRoaXMgaWYgeW91ciBhcHAgaW1wbGVtZW50cyBjb2RlIHNwbGl0dGluZyBhbmQgeW91IHdhbnQgdG9cbiAgICogbG9hZCBzb21lIG9mIHRoZSByZWR1Y2VycyBkeW5hbWljYWxseS4gWW91IG1pZ2h0IGFsc28gbmVlZCB0aGlzIGlmIHlvdVxuICAgKiBpbXBsZW1lbnQgYSBob3QgcmVsb2FkaW5nIG1lY2hhbmlzbSBmb3IgUmVkdXguXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHRSZWR1Y2VyIFRoZSByZWR1Y2VyIGZvciB0aGUgc3RvcmUgdG8gdXNlIGluc3RlYWQuXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHJlcGxhY2VSZWR1Y2VyKG5leHRSZWR1Y2VyKSB7XG4gICAgaWYgKHR5cGVvZiBuZXh0UmVkdWNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTApIDogXCJFeHBlY3RlZCB0aGUgbmV4dFJlZHVjZXIgdG8gYmUgYSBmdW5jdGlvbi4gSW5zdGVhZCwgcmVjZWl2ZWQ6ICdcIiArIGtpbmRPZihuZXh0UmVkdWNlcikpO1xuICAgIH1cblxuICAgIGN1cnJlbnRSZWR1Y2VyID0gbmV4dFJlZHVjZXI7IC8vIFRoaXMgYWN0aW9uIGhhcyBhIHNpbWlsaWFyIGVmZmVjdCB0byBBY3Rpb25UeXBlcy5JTklULlxuICAgIC8vIEFueSByZWR1Y2VycyB0aGF0IGV4aXN0ZWQgaW4gYm90aCB0aGUgbmV3IGFuZCBvbGQgcm9vdFJlZHVjZXJcbiAgICAvLyB3aWxsIHJlY2VpdmUgdGhlIHByZXZpb3VzIHN0YXRlLiBUaGlzIGVmZmVjdGl2ZWx5IHBvcHVsYXRlc1xuICAgIC8vIHRoZSBuZXcgc3RhdGUgdHJlZSB3aXRoIGFueSByZWxldmFudCBkYXRhIGZyb20gdGhlIG9sZCBvbmUuXG5cbiAgICBkaXNwYXRjaCh7XG4gICAgICB0eXBlOiBBY3Rpb25UeXBlcy5SRVBMQUNFXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEludGVyb3BlcmFiaWxpdHkgcG9pbnQgZm9yIG9ic2VydmFibGUvcmVhY3RpdmUgbGlicmFyaWVzLlxuICAgKiBAcmV0dXJucyB7b2JzZXJ2YWJsZX0gQSBtaW5pbWFsIG9ic2VydmFibGUgb2Ygc3RhdGUgY2hhbmdlcy5cbiAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSB0aGUgb2JzZXJ2YWJsZSBwcm9wb3NhbDpcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JzZXJ2YWJsZVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIG9ic2VydmFibGUoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgb3V0ZXJTdWJzY3JpYmUgPSBzdWJzY3JpYmU7XG4gICAgcmV0dXJuIF9yZWYgPSB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBtaW5pbWFsIG9ic2VydmFibGUgc3Vic2NyaXB0aW9uIG1ldGhvZC5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYnNlcnZlciBBbnkgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgYXMgYW4gb2JzZXJ2ZXIuXG4gICAgICAgKiBUaGUgb2JzZXJ2ZXIgb2JqZWN0IHNob3VsZCBoYXZlIGEgYG5leHRgIG1ldGhvZC5cbiAgICAgICAqIEByZXR1cm5zIHtzdWJzY3JpcHRpb259IEFuIG9iamVjdCB3aXRoIGFuIGB1bnN1YnNjcmliZWAgbWV0aG9kIHRoYXQgY2FuXG4gICAgICAgKiBiZSB1c2VkIHRvIHVuc3Vic2NyaWJlIHRoZSBvYnNlcnZhYmxlIGZyb20gdGhlIHN0b3JlLCBhbmQgcHJldmVudCBmdXJ0aGVyXG4gICAgICAgKiBlbWlzc2lvbiBvZiB2YWx1ZXMgZnJvbSB0aGUgb2JzZXJ2YWJsZS5cbiAgICAgICAqL1xuICAgICAgc3Vic2NyaWJlOiBmdW5jdGlvbiBzdWJzY3JpYmUob2JzZXJ2ZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYnNlcnZlciAhPT0gJ29iamVjdCcgfHwgb2JzZXJ2ZXIgPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMSkgOiBcIkV4cGVjdGVkIHRoZSBvYnNlcnZlciB0byBiZSBhbiBvYmplY3QuIEluc3RlYWQsIHJlY2VpdmVkOiAnXCIgKyBraW5kT2Yob2JzZXJ2ZXIpICsgXCInXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gb2JzZXJ2ZVN0YXRlKCkge1xuICAgICAgICAgIGlmIChvYnNlcnZlci5uZXh0KSB7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KGdldFN0YXRlKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9ic2VydmVTdGF0ZSgpO1xuICAgICAgICB2YXIgdW5zdWJzY3JpYmUgPSBvdXRlclN1YnNjcmliZShvYnNlcnZlU3RhdGUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHVuc3Vic2NyaWJlOiB1bnN1YnNjcmliZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIF9yZWZbJCRvYnNlcnZhYmxlXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sIF9yZWY7XG4gIH0gLy8gV2hlbiBhIHN0b3JlIGlzIGNyZWF0ZWQsIGFuIFwiSU5JVFwiIGFjdGlvbiBpcyBkaXNwYXRjaGVkIHNvIHRoYXQgZXZlcnlcbiAgLy8gcmVkdWNlciByZXR1cm5zIHRoZWlyIGluaXRpYWwgc3RhdGUuIFRoaXMgZWZmZWN0aXZlbHkgcG9wdWxhdGVzXG4gIC8vIHRoZSBpbml0aWFsIHN0YXRlIHRyZWUuXG5cblxuICBkaXNwYXRjaCh7XG4gICAgdHlwZTogQWN0aW9uVHlwZXMuSU5JVFxuICB9KTtcbiAgcmV0dXJuIF9yZWYyID0ge1xuICAgIGRpc3BhdGNoOiBkaXNwYXRjaCxcbiAgICBzdWJzY3JpYmU6IHN1YnNjcmliZSxcbiAgICBnZXRTdGF0ZTogZ2V0U3RhdGUsXG4gICAgcmVwbGFjZVJlZHVjZXI6IHJlcGxhY2VSZWR1Y2VyXG4gIH0sIF9yZWYyWyQkb2JzZXJ2YWJsZV0gPSBvYnNlcnZhYmxlLCBfcmVmMjtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIFJlZHV4IHN0b3JlIHRoYXQgaG9sZHMgdGhlIHN0YXRlIHRyZWUuXG4gKlxuICogKipXZSByZWNvbW1lbmQgdXNpbmcgYGNvbmZpZ3VyZVN0b3JlYCBmcm9tIHRoZVxuICogYEByZWR1eGpzL3Rvb2xraXRgIHBhY2thZ2UqKiwgd2hpY2ggcmVwbGFjZXMgYGNyZWF0ZVN0b3JlYDpcbiAqICoqaHR0cHM6Ly9yZWR1eC5qcy5vcmcvaW50cm9kdWN0aW9uL3doeS1ydGstaXMtcmVkdXgtdG9kYXkqKlxuICpcbiAqIFRoZSBvbmx5IHdheSB0byBjaGFuZ2UgdGhlIGRhdGEgaW4gdGhlIHN0b3JlIGlzIHRvIGNhbGwgYGRpc3BhdGNoKClgIG9uIGl0LlxuICpcbiAqIFRoZXJlIHNob3VsZCBvbmx5IGJlIGEgc2luZ2xlIHN0b3JlIGluIHlvdXIgYXBwLiBUbyBzcGVjaWZ5IGhvdyBkaWZmZXJlbnRcbiAqIHBhcnRzIG9mIHRoZSBzdGF0ZSB0cmVlIHJlc3BvbmQgdG8gYWN0aW9ucywgeW91IG1heSBjb21iaW5lIHNldmVyYWwgcmVkdWNlcnNcbiAqIGludG8gYSBzaW5nbGUgcmVkdWNlciBmdW5jdGlvbiBieSB1c2luZyBgY29tYmluZVJlZHVjZXJzYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWR1Y2VyIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBuZXh0IHN0YXRlIHRyZWUsIGdpdmVuXG4gKiB0aGUgY3VycmVudCBzdGF0ZSB0cmVlIGFuZCB0aGUgYWN0aW9uIHRvIGhhbmRsZS5cbiAqXG4gKiBAcGFyYW0ge2FueX0gW3ByZWxvYWRlZFN0YXRlXSBUaGUgaW5pdGlhbCBzdGF0ZS4gWW91IG1heSBvcHRpb25hbGx5IHNwZWNpZnkgaXRcbiAqIHRvIGh5ZHJhdGUgdGhlIHN0YXRlIGZyb20gdGhlIHNlcnZlciBpbiB1bml2ZXJzYWwgYXBwcywgb3IgdG8gcmVzdG9yZSBhXG4gKiBwcmV2aW91c2x5IHNlcmlhbGl6ZWQgdXNlciBzZXNzaW9uLlxuICogSWYgeW91IHVzZSBgY29tYmluZVJlZHVjZXJzYCB0byBwcm9kdWNlIHRoZSByb290IHJlZHVjZXIgZnVuY3Rpb24sIHRoaXMgbXVzdCBiZVxuICogYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUgc2hhcGUgYXMgYGNvbWJpbmVSZWR1Y2Vyc2Aga2V5cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZW5oYW5jZXJdIFRoZSBzdG9yZSBlbmhhbmNlci4gWW91IG1heSBvcHRpb25hbGx5IHNwZWNpZnkgaXRcbiAqIHRvIGVuaGFuY2UgdGhlIHN0b3JlIHdpdGggdGhpcmQtcGFydHkgY2FwYWJpbGl0aWVzIHN1Y2ggYXMgbWlkZGxld2FyZSxcbiAqIHRpbWUgdHJhdmVsLCBwZXJzaXN0ZW5jZSwgZXRjLiBUaGUgb25seSBzdG9yZSBlbmhhbmNlciB0aGF0IHNoaXBzIHdpdGggUmVkdXhcbiAqIGlzIGBhcHBseU1pZGRsZXdhcmUoKWAuXG4gKlxuICogQHJldHVybnMge1N0b3JlfSBBIFJlZHV4IHN0b3JlIHRoYXQgbGV0cyB5b3UgcmVhZCB0aGUgc3RhdGUsIGRpc3BhdGNoIGFjdGlvbnNcbiAqIGFuZCBzdWJzY3JpYmUgdG8gY2hhbmdlcy5cbiAqL1xuXG52YXIgbGVnYWN5X2NyZWF0ZVN0b3JlID0gY3JlYXRlU3RvcmU7XG5cbi8qKlxuICogUHJpbnRzIGEgd2FybmluZyBpbiB0aGUgY29uc29sZSBpZiBpdCBleGlzdHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIHdhcm5pbmcgbWVzc2FnZS5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cblxuXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCBpZiB5b3UgZW5hYmxlXG4gICAgLy8gXCJicmVhayBvbiBhbGwgZXhjZXB0aW9uc1wiIGluIHlvdXIgY29uc29sZSxcbiAgICAvLyBpdCB3b3VsZCBwYXVzZSB0aGUgZXhlY3V0aW9uIGF0IHRoaXMgbGluZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH0gY2F0Y2ggKGUpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcblxufVxuXG5mdW5jdGlvbiBnZXRVbmV4cGVjdGVkU3RhdGVTaGFwZVdhcm5pbmdNZXNzYWdlKGlucHV0U3RhdGUsIHJlZHVjZXJzLCBhY3Rpb24sIHVuZXhwZWN0ZWRLZXlDYWNoZSkge1xuICB2YXIgcmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhyZWR1Y2Vycyk7XG4gIHZhciBhcmd1bWVudE5hbWUgPSBhY3Rpb24gJiYgYWN0aW9uLnR5cGUgPT09IEFjdGlvblR5cGVzLklOSVQgPyAncHJlbG9hZGVkU3RhdGUgYXJndW1lbnQgcGFzc2VkIHRvIGNyZWF0ZVN0b3JlJyA6ICdwcmV2aW91cyBzdGF0ZSByZWNlaXZlZCBieSB0aGUgcmVkdWNlcic7XG5cbiAgaWYgKHJlZHVjZXJLZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnU3RvcmUgZG9lcyBub3QgaGF2ZSBhIHZhbGlkIHJlZHVjZXIuIE1ha2Ugc3VyZSB0aGUgYXJndW1lbnQgcGFzc2VkICcgKyAndG8gY29tYmluZVJlZHVjZXJzIGlzIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIHJlZHVjZXJzLic7XG4gIH1cblxuICBpZiAoIWlzUGxhaW5PYmplY3QoaW5wdXRTdGF0ZSkpIHtcbiAgICByZXR1cm4gXCJUaGUgXCIgKyBhcmd1bWVudE5hbWUgKyBcIiBoYXMgdW5leHBlY3RlZCB0eXBlIG9mIFxcXCJcIiArIGtpbmRPZihpbnB1dFN0YXRlKSArIFwiXFxcIi4gRXhwZWN0ZWQgYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBcIiArIChcImtleXM6IFxcXCJcIiArIHJlZHVjZXJLZXlzLmpvaW4oJ1wiLCBcIicpICsgXCJcXFwiXCIpO1xuICB9XG5cbiAgdmFyIHVuZXhwZWN0ZWRLZXlzID0gT2JqZWN0LmtleXMoaW5wdXRTdGF0ZSkuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gIXJlZHVjZXJzLmhhc093blByb3BlcnR5KGtleSkgJiYgIXVuZXhwZWN0ZWRLZXlDYWNoZVtrZXldO1xuICB9KTtcbiAgdW5leHBlY3RlZEtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdW5leHBlY3RlZEtleUNhY2hlW2tleV0gPSB0cnVlO1xuICB9KTtcbiAgaWYgKGFjdGlvbiAmJiBhY3Rpb24udHlwZSA9PT0gQWN0aW9uVHlwZXMuUkVQTEFDRSkgcmV0dXJuO1xuXG4gIGlmICh1bmV4cGVjdGVkS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIFwiVW5leHBlY3RlZCBcIiArICh1bmV4cGVjdGVkS2V5cy5sZW5ndGggPiAxID8gJ2tleXMnIDogJ2tleScpICsgXCIgXCIgKyAoXCJcXFwiXCIgKyB1bmV4cGVjdGVkS2V5cy5qb2luKCdcIiwgXCInKSArIFwiXFxcIiBmb3VuZCBpbiBcIiArIGFyZ3VtZW50TmFtZSArIFwiLiBcIikgKyBcIkV4cGVjdGVkIHRvIGZpbmQgb25lIG9mIHRoZSBrbm93biByZWR1Y2VyIGtleXMgaW5zdGVhZDogXCIgKyAoXCJcXFwiXCIgKyByZWR1Y2VyS2V5cy5qb2luKCdcIiwgXCInKSArIFwiXFxcIi4gVW5leHBlY3RlZCBrZXlzIHdpbGwgYmUgaWdub3JlZC5cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0UmVkdWNlclNoYXBlKHJlZHVjZXJzKSB7XG4gIE9iamVjdC5rZXlzKHJlZHVjZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgcmVkdWNlciA9IHJlZHVjZXJzW2tleV07XG4gICAgdmFyIGluaXRpYWxTdGF0ZSA9IHJlZHVjZXIodW5kZWZpbmVkLCB7XG4gICAgICB0eXBlOiBBY3Rpb25UeXBlcy5JTklUXG4gICAgfSk7XG5cbiAgICBpZiAodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEyKSA6IFwiVGhlIHNsaWNlIHJlZHVjZXIgZm9yIGtleSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgcmV0dXJuZWQgdW5kZWZpbmVkIGR1cmluZyBpbml0aWFsaXphdGlvbi4gXCIgKyBcIklmIHRoZSBzdGF0ZSBwYXNzZWQgdG8gdGhlIHJlZHVjZXIgaXMgdW5kZWZpbmVkLCB5b3UgbXVzdCBcIiArIFwiZXhwbGljaXRseSByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUuIFRoZSBpbml0aWFsIHN0YXRlIG1heSBcIiArIFwibm90IGJlIHVuZGVmaW5lZC4gSWYgeW91IGRvbid0IHdhbnQgdG8gc2V0IGEgdmFsdWUgZm9yIHRoaXMgcmVkdWNlciwgXCIgKyBcInlvdSBjYW4gdXNlIG51bGwgaW5zdGVhZCBvZiB1bmRlZmluZWQuXCIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcmVkdWNlcih1bmRlZmluZWQsIHtcbiAgICAgIHR5cGU6IEFjdGlvblR5cGVzLlBST0JFX1VOS05PV05fQUNUSU9OKClcbiAgICB9KSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEzKSA6IFwiVGhlIHNsaWNlIHJlZHVjZXIgZm9yIGtleSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgcmV0dXJuZWQgdW5kZWZpbmVkIHdoZW4gcHJvYmVkIHdpdGggYSByYW5kb20gdHlwZS4gXCIgKyAoXCJEb24ndCB0cnkgdG8gaGFuZGxlICdcIiArIEFjdGlvblR5cGVzLklOSVQgKyBcIicgb3Igb3RoZXIgYWN0aW9ucyBpbiBcXFwicmVkdXgvKlxcXCIgXCIpICsgXCJuYW1lc3BhY2UuIFRoZXkgYXJlIGNvbnNpZGVyZWQgcHJpdmF0ZS4gSW5zdGVhZCwgeW91IG11c3QgcmV0dXJuIHRoZSBcIiArIFwiY3VycmVudCBzdGF0ZSBmb3IgYW55IHVua25vd24gYWN0aW9ucywgdW5sZXNzIGl0IGlzIHVuZGVmaW5lZCwgXCIgKyBcImluIHdoaWNoIGNhc2UgeW91IG11c3QgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLCByZWdhcmRsZXNzIG9mIHRoZSBcIiArIFwiYWN0aW9uIHR5cGUuIFRoZSBpbml0aWFsIHN0YXRlIG1heSBub3QgYmUgdW5kZWZpbmVkLCBidXQgY2FuIGJlIG51bGwuXCIpO1xuICAgIH1cbiAgfSk7XG59XG4vKipcbiAqIFR1cm5zIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIGRpZmZlcmVudCByZWR1Y2VyIGZ1bmN0aW9ucywgaW50byBhIHNpbmdsZVxuICogcmVkdWNlciBmdW5jdGlvbi4gSXQgd2lsbCBjYWxsIGV2ZXJ5IGNoaWxkIHJlZHVjZXIsIGFuZCBnYXRoZXIgdGhlaXIgcmVzdWx0c1xuICogaW50byBhIHNpbmdsZSBzdGF0ZSBvYmplY3QsIHdob3NlIGtleXMgY29ycmVzcG9uZCB0byB0aGUga2V5cyBvZiB0aGUgcGFzc2VkXG4gKiByZWR1Y2VyIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcmVkdWNlcnMgQW4gb2JqZWN0IHdob3NlIHZhbHVlcyBjb3JyZXNwb25kIHRvIGRpZmZlcmVudFxuICogcmVkdWNlciBmdW5jdGlvbnMgdGhhdCBuZWVkIHRvIGJlIGNvbWJpbmVkIGludG8gb25lLiBPbmUgaGFuZHkgd2F5IHRvIG9idGFpblxuICogaXQgaXMgdG8gdXNlIEVTNiBgaW1wb3J0ICogYXMgcmVkdWNlcnNgIHN5bnRheC4gVGhlIHJlZHVjZXJzIG1heSBuZXZlciByZXR1cm5cbiAqIHVuZGVmaW5lZCBmb3IgYW55IGFjdGlvbi4gSW5zdGVhZCwgdGhleSBzaG91bGQgcmV0dXJuIHRoZWlyIGluaXRpYWwgc3RhdGVcbiAqIGlmIHRoZSBzdGF0ZSBwYXNzZWQgdG8gdGhlbSB3YXMgdW5kZWZpbmVkLCBhbmQgdGhlIGN1cnJlbnQgc3RhdGUgZm9yIGFueVxuICogdW5yZWNvZ25pemVkIGFjdGlvbi5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgcmVkdWNlciBmdW5jdGlvbiB0aGF0IGludm9rZXMgZXZlcnkgcmVkdWNlciBpbnNpZGUgdGhlXG4gKiBwYXNzZWQgb2JqZWN0LCBhbmQgYnVpbGRzIGEgc3RhdGUgb2JqZWN0IHdpdGggdGhlIHNhbWUgc2hhcGUuXG4gKi9cblxuXG5mdW5jdGlvbiBjb21iaW5lUmVkdWNlcnMocmVkdWNlcnMpIHtcbiAgdmFyIHJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xuICB2YXIgZmluYWxSZWR1Y2VycyA9IHt9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmVkdWNlcktleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gcmVkdWNlcktleXNbaV07XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHR5cGVvZiByZWR1Y2Vyc1trZXldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3YXJuaW5nKFwiTm8gcmVkdWNlciBwcm92aWRlZCBmb3Iga2V5IFxcXCJcIiArIGtleSArIFwiXFxcIlwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHJlZHVjZXJzW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZpbmFsUmVkdWNlcnNba2V5XSA9IHJlZHVjZXJzW2tleV07XG4gICAgfVxuICB9XG5cbiAgdmFyIGZpbmFsUmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhmaW5hbFJlZHVjZXJzKTsgLy8gVGhpcyBpcyB1c2VkIHRvIG1ha2Ugc3VyZSB3ZSBkb24ndCB3YXJuIGFib3V0IHRoZSBzYW1lXG4gIC8vIGtleXMgbXVsdGlwbGUgdGltZXMuXG5cbiAgdmFyIHVuZXhwZWN0ZWRLZXlDYWNoZTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHVuZXhwZWN0ZWRLZXlDYWNoZSA9IHt9O1xuICB9XG5cbiAgdmFyIHNoYXBlQXNzZXJ0aW9uRXJyb3I7XG5cbiAgdHJ5IHtcbiAgICBhc3NlcnRSZWR1Y2VyU2hhcGUoZmluYWxSZWR1Y2Vycyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBzaGFwZUFzc2VydGlvbkVycm9yID0gZTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBjb21iaW5hdGlvbihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgaWYgKHN0YXRlID09PSB2b2lkIDApIHtcbiAgICAgIHN0YXRlID0ge307XG4gICAgfVxuXG4gICAgaWYgKHNoYXBlQXNzZXJ0aW9uRXJyb3IpIHtcbiAgICAgIHRocm93IHNoYXBlQXNzZXJ0aW9uRXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciB3YXJuaW5nTWVzc2FnZSA9IGdldFVuZXhwZWN0ZWRTdGF0ZVNoYXBlV2FybmluZ01lc3NhZ2Uoc3RhdGUsIGZpbmFsUmVkdWNlcnMsIGFjdGlvbiwgdW5leHBlY3RlZEtleUNhY2hlKTtcblxuICAgICAgaWYgKHdhcm5pbmdNZXNzYWdlKSB7XG4gICAgICAgIHdhcm5pbmcod2FybmluZ01lc3NhZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBoYXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgdmFyIG5leHRTdGF0ZSA9IHt9O1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGZpbmFsUmVkdWNlcktleXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2tleSA9IGZpbmFsUmVkdWNlcktleXNbX2ldO1xuICAgICAgdmFyIHJlZHVjZXIgPSBmaW5hbFJlZHVjZXJzW19rZXldO1xuICAgICAgdmFyIHByZXZpb3VzU3RhdGVGb3JLZXkgPSBzdGF0ZVtfa2V5XTtcbiAgICAgIHZhciBuZXh0U3RhdGVGb3JLZXkgPSByZWR1Y2VyKHByZXZpb3VzU3RhdGVGb3JLZXksIGFjdGlvbik7XG5cbiAgICAgIGlmICh0eXBlb2YgbmV4dFN0YXRlRm9yS2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgYWN0aW9uVHlwZSA9IGFjdGlvbiAmJiBhY3Rpb24udHlwZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTQpIDogXCJXaGVuIGNhbGxlZCB3aXRoIGFuIGFjdGlvbiBvZiB0eXBlIFwiICsgKGFjdGlvblR5cGUgPyBcIlxcXCJcIiArIFN0cmluZyhhY3Rpb25UeXBlKSArIFwiXFxcIlwiIDogJyh1bmtub3duIHR5cGUpJykgKyBcIiwgdGhlIHNsaWNlIHJlZHVjZXIgZm9yIGtleSBcXFwiXCIgKyBfa2V5ICsgXCJcXFwiIHJldHVybmVkIHVuZGVmaW5lZC4gXCIgKyBcIlRvIGlnbm9yZSBhbiBhY3Rpb24sIHlvdSBtdXN0IGV4cGxpY2l0bHkgcmV0dXJuIHRoZSBwcmV2aW91cyBzdGF0ZS4gXCIgKyBcIklmIHlvdSB3YW50IHRoaXMgcmVkdWNlciB0byBob2xkIG5vIHZhbHVlLCB5b3UgY2FuIHJldHVybiBudWxsIGluc3RlYWQgb2YgdW5kZWZpbmVkLlwiKTtcbiAgICAgIH1cblxuICAgICAgbmV4dFN0YXRlW19rZXldID0gbmV4dFN0YXRlRm9yS2V5O1xuICAgICAgaGFzQ2hhbmdlZCA9IGhhc0NoYW5nZWQgfHwgbmV4dFN0YXRlRm9yS2V5ICE9PSBwcmV2aW91c1N0YXRlRm9yS2V5O1xuICAgIH1cblxuICAgIGhhc0NoYW5nZWQgPSBoYXNDaGFuZ2VkIHx8IGZpbmFsUmVkdWNlcktleXMubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhzdGF0ZSkubGVuZ3RoO1xuICAgIHJldHVybiBoYXNDaGFuZ2VkID8gbmV4dFN0YXRlIDogc3RhdGU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3IsIGRpc3BhdGNoKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoKGFjdGlvbkNyZWF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH07XG59XG4vKipcbiAqIFR1cm5zIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIGFjdGlvbiBjcmVhdG9ycywgaW50byBhbiBvYmplY3Qgd2l0aCB0aGVcbiAqIHNhbWUga2V5cywgYnV0IHdpdGggZXZlcnkgZnVuY3Rpb24gd3JhcHBlZCBpbnRvIGEgYGRpc3BhdGNoYCBjYWxsIHNvIHRoZXlcbiAqIG1heSBiZSBpbnZva2VkIGRpcmVjdGx5LiBUaGlzIGlzIGp1c3QgYSBjb252ZW5pZW5jZSBtZXRob2QsIGFzIHlvdSBjYW4gY2FsbFxuICogYHN0b3JlLmRpc3BhdGNoKE15QWN0aW9uQ3JlYXRvcnMuZG9Tb21ldGhpbmcoKSlgIHlvdXJzZWxmIGp1c3QgZmluZS5cbiAqXG4gKiBGb3IgY29udmVuaWVuY2UsIHlvdSBjYW4gYWxzbyBwYXNzIGFuIGFjdGlvbiBjcmVhdG9yIGFzIHRoZSBmaXJzdCBhcmd1bWVudCxcbiAqIGFuZCBnZXQgYSBkaXNwYXRjaCB3cmFwcGVkIGZ1bmN0aW9uIGluIHJldHVybi5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdH0gYWN0aW9uQ3JlYXRvcnMgQW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgYWN0aW9uXG4gKiBjcmVhdG9yIGZ1bmN0aW9ucy4gT25lIGhhbmR5IHdheSB0byBvYnRhaW4gaXQgaXMgdG8gdXNlIEVTNiBgaW1wb3J0ICogYXNgXG4gKiBzeW50YXguIFlvdSBtYXkgYWxzbyBwYXNzIGEgc2luZ2xlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRpc3BhdGNoIFRoZSBgZGlzcGF0Y2hgIGZ1bmN0aW9uIGF2YWlsYWJsZSBvbiB5b3VyIFJlZHV4XG4gKiBzdG9yZS5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb258T2JqZWN0fSBUaGUgb2JqZWN0IG1pbWlja2luZyB0aGUgb3JpZ2luYWwgb2JqZWN0LCBidXQgd2l0aFxuICogZXZlcnkgYWN0aW9uIGNyZWF0b3Igd3JhcHBlZCBpbnRvIHRoZSBgZGlzcGF0Y2hgIGNhbGwuIElmIHlvdSBwYXNzZWQgYVxuICogZnVuY3Rpb24gYXMgYGFjdGlvbkNyZWF0b3JzYCwgdGhlIHJldHVybiB2YWx1ZSB3aWxsIGFsc28gYmUgYSBzaW5nbGVcbiAqIGZ1bmN0aW9uLlxuICovXG5cblxuZnVuY3Rpb24gYmluZEFjdGlvbkNyZWF0b3JzKGFjdGlvbkNyZWF0b3JzLCBkaXNwYXRjaCkge1xuICBpZiAodHlwZW9mIGFjdGlvbkNyZWF0b3JzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3JzLCBkaXNwYXRjaCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGFjdGlvbkNyZWF0b3JzICE9PSAnb2JqZWN0JyB8fCBhY3Rpb25DcmVhdG9ycyA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE2KSA6IFwiYmluZEFjdGlvbkNyZWF0b3JzIGV4cGVjdGVkIGFuIG9iamVjdCBvciBhIGZ1bmN0aW9uLCBidXQgaW5zdGVhZCByZWNlaXZlZDogJ1wiICsga2luZE9mKGFjdGlvbkNyZWF0b3JzKSArIFwiJy4gXCIgKyBcIkRpZCB5b3Ugd3JpdGUgXFxcImltcG9ydCBBY3Rpb25DcmVhdG9ycyBmcm9tXFxcIiBpbnN0ZWFkIG9mIFxcXCJpbXBvcnQgKiBhcyBBY3Rpb25DcmVhdG9ycyBmcm9tXFxcIj9cIik7XG4gIH1cblxuICB2YXIgYm91bmRBY3Rpb25DcmVhdG9ycyA9IHt9O1xuXG4gIGZvciAodmFyIGtleSBpbiBhY3Rpb25DcmVhdG9ycykge1xuICAgIHZhciBhY3Rpb25DcmVhdG9yID0gYWN0aW9uQ3JlYXRvcnNba2V5XTtcblxuICAgIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYm91bmRBY3Rpb25DcmVhdG9yc1trZXldID0gYmluZEFjdGlvbkNyZWF0b3IoYWN0aW9uQ3JlYXRvciwgZGlzcGF0Y2gpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBib3VuZEFjdGlvbkNyZWF0b3JzO1xufVxuXG4vKipcbiAqIENvbXBvc2VzIHNpbmdsZS1hcmd1bWVudCBmdW5jdGlvbnMgZnJvbSByaWdodCB0byBsZWZ0LiBUaGUgcmlnaHRtb3N0XG4gKiBmdW5jdGlvbiBjYW4gdGFrZSBtdWx0aXBsZSBhcmd1bWVudHMgYXMgaXQgcHJvdmlkZXMgdGhlIHNpZ25hdHVyZSBmb3JcbiAqIHRoZSByZXN1bHRpbmcgY29tcG9zaXRlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IGZ1bmNzIFRoZSBmdW5jdGlvbnMgdG8gY29tcG9zZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiBvYnRhaW5lZCBieSBjb21wb3NpbmcgdGhlIGFyZ3VtZW50IGZ1bmN0aW9uc1xuICogZnJvbSByaWdodCB0byBsZWZ0LiBGb3IgZXhhbXBsZSwgY29tcG9zZShmLCBnLCBoKSBpcyBpZGVudGljYWwgdG8gZG9pbmdcbiAqICguLi5hcmdzKSA9PiBmKGcoaCguLi5hcmdzKSkpLlxuICovXG5mdW5jdGlvbiBjb21wb3NlKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgZnVuY3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgZnVuY3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpZiAoZnVuY3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgIHJldHVybiBhcmc7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChmdW5jcy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZnVuY3NbMF07XG4gIH1cblxuICByZXR1cm4gZnVuY3MucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhKGIuYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RvcmUgZW5oYW5jZXIgdGhhdCBhcHBsaWVzIG1pZGRsZXdhcmUgdG8gdGhlIGRpc3BhdGNoIG1ldGhvZFxuICogb2YgdGhlIFJlZHV4IHN0b3JlLiBUaGlzIGlzIGhhbmR5IGZvciBhIHZhcmlldHkgb2YgdGFza3MsIHN1Y2ggYXMgZXhwcmVzc2luZ1xuICogYXN5bmNocm9ub3VzIGFjdGlvbnMgaW4gYSBjb25jaXNlIG1hbm5lciwgb3IgbG9nZ2luZyBldmVyeSBhY3Rpb24gcGF5bG9hZC5cbiAqXG4gKiBTZWUgYHJlZHV4LXRodW5rYCBwYWNrYWdlIGFzIGFuIGV4YW1wbGUgb2YgdGhlIFJlZHV4IG1pZGRsZXdhcmUuXG4gKlxuICogQmVjYXVzZSBtaWRkbGV3YXJlIGlzIHBvdGVudGlhbGx5IGFzeW5jaHJvbm91cywgdGhpcyBzaG91bGQgYmUgdGhlIGZpcnN0XG4gKiBzdG9yZSBlbmhhbmNlciBpbiB0aGUgY29tcG9zaXRpb24gY2hhaW4uXG4gKlxuICogTm90ZSB0aGF0IGVhY2ggbWlkZGxld2FyZSB3aWxsIGJlIGdpdmVuIHRoZSBgZGlzcGF0Y2hgIGFuZCBgZ2V0U3RhdGVgIGZ1bmN0aW9uc1xuICogYXMgbmFtZWQgYXJndW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IG1pZGRsZXdhcmVzIFRoZSBtaWRkbGV3YXJlIGNoYWluIHRvIGJlIGFwcGxpZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgc3RvcmUgZW5oYW5jZXIgYXBwbHlpbmcgdGhlIG1pZGRsZXdhcmUuXG4gKi9cblxuZnVuY3Rpb24gYXBwbHlNaWRkbGV3YXJlKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbWlkZGxld2FyZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgbWlkZGxld2FyZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGNyZWF0ZVN0b3JlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdG9yZSA9IGNyZWF0ZVN0b3JlLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcblxuICAgICAgdmFyIF9kaXNwYXRjaCA9IGZ1bmN0aW9uIGRpc3BhdGNoKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNSkgOiAnRGlzcGF0Y2hpbmcgd2hpbGUgY29uc3RydWN0aW5nIHlvdXIgbWlkZGxld2FyZSBpcyBub3QgYWxsb3dlZC4gJyArICdPdGhlciBtaWRkbGV3YXJlIHdvdWxkIG5vdCBiZSBhcHBsaWVkIHRvIHRoaXMgZGlzcGF0Y2guJyk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgbWlkZGxld2FyZUFQSSA9IHtcbiAgICAgICAgZ2V0U3RhdGU6IHN0b3JlLmdldFN0YXRlLFxuICAgICAgICBkaXNwYXRjaDogZnVuY3Rpb24gZGlzcGF0Y2goKSB7XG4gICAgICAgICAgcmV0dXJuIF9kaXNwYXRjaC5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgY2hhaW4gPSBtaWRkbGV3YXJlcy5tYXAoZnVuY3Rpb24gKG1pZGRsZXdhcmUpIHtcbiAgICAgICAgcmV0dXJuIG1pZGRsZXdhcmUobWlkZGxld2FyZUFQSSk7XG4gICAgICB9KTtcbiAgICAgIF9kaXNwYXRjaCA9IGNvbXBvc2UuYXBwbHkodm9pZCAwLCBjaGFpbikoc3RvcmUuZGlzcGF0Y2gpO1xuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc3RvcmUpLCB7fSwge1xuICAgICAgICBkaXNwYXRjaDogX2Rpc3BhdGNoXG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xufVxuXG5leHBvcnQgeyBBY3Rpb25UeXBlcyBhcyBfX0RPX05PVF9VU0VfX0FjdGlvblR5cGVzLCBhcHBseU1pZGRsZXdhcmUsIGJpbmRBY3Rpb25DcmVhdG9ycywgY29tYmluZVJlZHVjZXJzLCBjb21wb3NlLCBjcmVhdGVTdG9yZSwgbGVnYWN5X2NyZWF0ZVN0b3JlIH07XG4iXSwibmFtZXMiOlsiX29iamVjdFNwcmVhZCIsImZvcm1hdFByb2RFcnJvck1lc3NhZ2UiLCJjb2RlIiwiJCRvYnNlcnZhYmxlIiwiU3ltYm9sIiwib2JzZXJ2YWJsZSIsInJhbmRvbVN0cmluZyIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0cmluZyIsInNwbGl0Iiwiam9pbiIsIkFjdGlvblR5cGVzIiwiSU5JVCIsIlJFUExBQ0UiLCJQUk9CRV9VTktOT1dOX0FDVElPTiIsImlzUGxhaW5PYmplY3QiLCJvYmoiLCJwcm90byIsIk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwibWluaUtpbmRPZiIsInZhbCIsInR5cGUiLCJBcnJheSIsImlzQXJyYXkiLCJpc0RhdGUiLCJpc0Vycm9yIiwiY29uc3RydWN0b3JOYW1lIiwiY3Rvck5hbWUiLCJzbGljZSIsInRvTG93ZXJDYXNlIiwicmVwbGFjZSIsImNvbnN0cnVjdG9yIiwibmFtZSIsIkVycm9yIiwibWVzc2FnZSIsInN0YWNrVHJhY2VMaW1pdCIsIkRhdGUiLCJ0b0RhdGVTdHJpbmciLCJnZXREYXRlIiwic2V0RGF0ZSIsImtpbmRPZiIsInR5cGVPZlZhbCIsInByb2Nlc3MiLCJjcmVhdGVTdG9yZSIsInJlZHVjZXIiLCJwcmVsb2FkZWRTdGF0ZSIsImVuaGFuY2VyIiwiX3JlZjIiLCJhcmd1bWVudHMiLCJ1bmRlZmluZWQiLCJjdXJyZW50UmVkdWNlciIsImN1cnJlbnRTdGF0ZSIsImN1cnJlbnRMaXN0ZW5lcnMiLCJuZXh0TGlzdGVuZXJzIiwiaXNEaXNwYXRjaGluZyIsImVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMiLCJnZXRTdGF0ZSIsInN1YnNjcmliZSIsImxpc3RlbmVyIiwiaXNTdWJzY3JpYmVkIiwicHVzaCIsInVuc3Vic2NyaWJlIiwiaW5kZXgiLCJpbmRleE9mIiwic3BsaWNlIiwiZGlzcGF0Y2giLCJhY3Rpb24iLCJsaXN0ZW5lcnMiLCJpIiwibGVuZ3RoIiwicmVwbGFjZVJlZHVjZXIiLCJuZXh0UmVkdWNlciIsIl9yZWYiLCJvdXRlclN1YnNjcmliZSIsIm9ic2VydmVyIiwib2JzZXJ2ZVN0YXRlIiwibmV4dCIsImxlZ2FjeV9jcmVhdGVTdG9yZSIsIndhcm5pbmciLCJjb25zb2xlIiwiZXJyb3IiLCJlIiwiZ2V0VW5leHBlY3RlZFN0YXRlU2hhcGVXYXJuaW5nTWVzc2FnZSIsImlucHV0U3RhdGUiLCJyZWR1Y2VycyIsInVuZXhwZWN0ZWRLZXlDYWNoZSIsInJlZHVjZXJLZXlzIiwia2V5cyIsImFyZ3VtZW50TmFtZSIsInVuZXhwZWN0ZWRLZXlzIiwiZmlsdGVyIiwia2V5IiwiaGFzT3duUHJvcGVydHkiLCJmb3JFYWNoIiwiYXNzZXJ0UmVkdWNlclNoYXBlIiwiaW5pdGlhbFN0YXRlIiwiY29tYmluZVJlZHVjZXJzIiwiZmluYWxSZWR1Y2VycyIsImZpbmFsUmVkdWNlcktleXMiLCJzaGFwZUFzc2VydGlvbkVycm9yIiwiY29tYmluYXRpb24iLCJzdGF0ZSIsIndhcm5pbmdNZXNzYWdlIiwiaGFzQ2hhbmdlZCIsIm5leHRTdGF0ZSIsIl9pIiwiX2tleSIsInByZXZpb3VzU3RhdGVGb3JLZXkiLCJuZXh0U3RhdGVGb3JLZXkiLCJhY3Rpb25UeXBlIiwiU3RyaW5nIiwiYmluZEFjdGlvbkNyZWF0b3IiLCJhY3Rpb25DcmVhdG9yIiwiYXBwbHkiLCJiaW5kQWN0aW9uQ3JlYXRvcnMiLCJhY3Rpb25DcmVhdG9ycyIsImJvdW5kQWN0aW9uQ3JlYXRvcnMiLCJjb21wb3NlIiwiX2xlbiIsImZ1bmNzIiwiYXJnIiwicmVkdWNlIiwiYSIsImIiLCJhcHBseU1pZGRsZXdhcmUiLCJtaWRkbGV3YXJlcyIsInN0b3JlIiwiX2Rpc3BhdGNoIiwibWlkZGxld2FyZUFQSSIsImNoYWluIiwibWFwIiwibWlkZGxld2FyZSIsIl9fRE9fTk9UX1VTRV9fQWN0aW9uVHlwZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/redux/es/redux.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/reselect/es/defaultMemoize.js":
/*!****************************************************!*\
  !*** ./node_modules/reselect/es/defaultMemoize.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCacheKeyComparator: function() { return /* binding */ createCacheKeyComparator; },\n/* harmony export */   defaultEqualityCheck: function() { return /* binding */ defaultEqualityCheck; },\n/* harmony export */   defaultMemoize: function() { return /* binding */ defaultMemoize; }\n/* harmony export */ });\n// Cache implementation based on Erik Rasmussen's `lru-memoize`:\n// https://github.com/erikras/lru-memoize\nvar NOT_FOUND = \"NOT_FOUND\";\nfunction createSingletonCache(equals) {\n    var entry;\n    return {\n        get: function get(key) {\n            if (entry && equals(entry.key, key)) {\n                return entry.value;\n            }\n            return NOT_FOUND;\n        },\n        put: function put(key, value) {\n            entry = {\n                key: key,\n                value: value\n            };\n        },\n        getEntries: function getEntries() {\n            return entry ? [\n                entry\n            ] : [];\n        },\n        clear: function clear() {\n            entry = undefined;\n        }\n    };\n}\nfunction createLruCache(maxSize, equals) {\n    var entries = [];\n    function get(key) {\n        var cacheIndex = entries.findIndex(function(entry) {\n            return equals(key, entry.key);\n        }); // We found a cached entry\n        if (cacheIndex > -1) {\n            var entry = entries[cacheIndex]; // Cached entry not at top of cache, move it to the top\n            if (cacheIndex > 0) {\n                entries.splice(cacheIndex, 1);\n                entries.unshift(entry);\n            }\n            return entry.value;\n        } // No entry found in cache, return sentinel\n        return NOT_FOUND;\n    }\n    function put(key, value) {\n        if (get(key) === NOT_FOUND) {\n            // TODO Is unshift slow?\n            entries.unshift({\n                key: key,\n                value: value\n            });\n            if (entries.length > maxSize) {\n                entries.pop();\n            }\n        }\n    }\n    function getEntries() {\n        return entries;\n    }\n    function clear() {\n        entries = [];\n    }\n    return {\n        get: get,\n        put: put,\n        getEntries: getEntries,\n        clear: clear\n    };\n}\nvar defaultEqualityCheck = function defaultEqualityCheck(a, b) {\n    return a === b;\n};\nfunction createCacheKeyComparator(equalityCheck) {\n    return function areArgumentsShallowlyEqual(prev, next) {\n        if (prev === null || next === null || prev.length !== next.length) {\n            return false;\n        } // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.\n        var length = prev.length;\n        for(var i = 0; i < length; i++){\n            if (!equalityCheck(prev[i], next[i])) {\n                return false;\n            }\n        }\n        return true;\n    };\n}\n// defaultMemoize now supports a configurable cache size with LRU behavior,\n// and optional comparison of the result value with existing values\nfunction defaultMemoize(func, equalityCheckOrOptions) {\n    var providedOptions = typeof equalityCheckOrOptions === \"object\" ? equalityCheckOrOptions : {\n        equalityCheck: equalityCheckOrOptions\n    };\n    var _providedOptions$equa = providedOptions.equalityCheck, equalityCheck = _providedOptions$equa === void 0 ? defaultEqualityCheck : _providedOptions$equa, _providedOptions$maxS = providedOptions.maxSize, maxSize = _providedOptions$maxS === void 0 ? 1 : _providedOptions$maxS, resultEqualityCheck = providedOptions.resultEqualityCheck;\n    var comparator = createCacheKeyComparator(equalityCheck);\n    var cache = maxSize === 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator); // we reference arguments instead of spreading them for performance reasons\n    function memoized() {\n        var value = cache.get(arguments);\n        if (value === NOT_FOUND) {\n            // @ts-ignore\n            value = func.apply(null, arguments);\n            if (resultEqualityCheck) {\n                var entries = cache.getEntries();\n                var matchingEntry = entries.find(function(entry) {\n                    return resultEqualityCheck(entry.value, value);\n                });\n                if (matchingEntry) {\n                    value = matchingEntry.value;\n                }\n            }\n            cache.put(arguments, value);\n        }\n        return value;\n    }\n    memoized.clearCache = function() {\n        return cache.clear();\n    };\n    return memoized;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZXNlbGVjdC9lcy9kZWZhdWx0TWVtb2l6ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxnRUFBZ0U7QUFDaEUseUNBQXlDO0FBQ3pDLElBQUlBLFlBQVk7QUFFaEIsU0FBU0MscUJBQXFCQyxNQUFNO0lBQ2xDLElBQUlDO0lBQ0osT0FBTztRQUNMQyxLQUFLLFNBQVNBLElBQUlDLEdBQUc7WUFDbkIsSUFBSUYsU0FBU0QsT0FBT0MsTUFBTUUsR0FBRyxFQUFFQSxNQUFNO2dCQUNuQyxPQUFPRixNQUFNRyxLQUFLO1lBQ3BCO1lBRUEsT0FBT047UUFDVDtRQUNBTyxLQUFLLFNBQVNBLElBQUlGLEdBQUcsRUFBRUMsS0FBSztZQUMxQkgsUUFBUTtnQkFDTkUsS0FBS0E7Z0JBQ0xDLE9BQU9BO1lBQ1Q7UUFDRjtRQUNBRSxZQUFZLFNBQVNBO1lBQ25CLE9BQU9MLFFBQVE7Z0JBQUNBO2FBQU0sR0FBRyxFQUFFO1FBQzdCO1FBQ0FNLE9BQU8sU0FBU0E7WUFDZE4sUUFBUU87UUFDVjtJQUNGO0FBQ0Y7QUFFQSxTQUFTQyxlQUFlQyxPQUFPLEVBQUVWLE1BQU07SUFDckMsSUFBSVcsVUFBVSxFQUFFO0lBRWhCLFNBQVNULElBQUlDLEdBQUc7UUFDZCxJQUFJUyxhQUFhRCxRQUFRRSxTQUFTLENBQUMsU0FBVVosS0FBSztZQUNoRCxPQUFPRCxPQUFPRyxLQUFLRixNQUFNRSxHQUFHO1FBQzlCLElBQUksMEJBQTBCO1FBRTlCLElBQUlTLGFBQWEsQ0FBQyxHQUFHO1lBQ25CLElBQUlYLFFBQVFVLE9BQU8sQ0FBQ0MsV0FBVyxFQUFFLHVEQUF1RDtZQUV4RixJQUFJQSxhQUFhLEdBQUc7Z0JBQ2xCRCxRQUFRRyxNQUFNLENBQUNGLFlBQVk7Z0JBQzNCRCxRQUFRSSxPQUFPLENBQUNkO1lBQ2xCO1lBRUEsT0FBT0EsTUFBTUcsS0FBSztRQUNwQixFQUFFLDJDQUEyQztRQUc3QyxPQUFPTjtJQUNUO0lBRUEsU0FBU08sSUFBSUYsR0FBRyxFQUFFQyxLQUFLO1FBQ3JCLElBQUlGLElBQUlDLFNBQVNMLFdBQVc7WUFDMUIsd0JBQXdCO1lBQ3hCYSxRQUFRSSxPQUFPLENBQUM7Z0JBQ2RaLEtBQUtBO2dCQUNMQyxPQUFPQTtZQUNUO1lBRUEsSUFBSU8sUUFBUUssTUFBTSxHQUFHTixTQUFTO2dCQUM1QkMsUUFBUU0sR0FBRztZQUNiO1FBQ0Y7SUFDRjtJQUVBLFNBQVNYO1FBQ1AsT0FBT0s7SUFDVDtJQUVBLFNBQVNKO1FBQ1BJLFVBQVUsRUFBRTtJQUNkO0lBRUEsT0FBTztRQUNMVCxLQUFLQTtRQUNMRyxLQUFLQTtRQUNMQyxZQUFZQTtRQUNaQyxPQUFPQTtJQUNUO0FBQ0Y7QUFFTyxJQUFJVyx1QkFBdUIsU0FBU0EscUJBQXFCQyxDQUFDLEVBQUVDLENBQUM7SUFDbEUsT0FBT0QsTUFBTUM7QUFDZixFQUFFO0FBQ0ssU0FBU0MseUJBQXlCQyxhQUFhO0lBQ3BELE9BQU8sU0FBU0MsMkJBQTJCQyxJQUFJLEVBQUVDLElBQUk7UUFDbkQsSUFBSUQsU0FBUyxRQUFRQyxTQUFTLFFBQVFELEtBQUtSLE1BQU0sS0FBS1MsS0FBS1QsTUFBTSxFQUFFO1lBQ2pFLE9BQU87UUFDVCxFQUFFLDhHQUE4RztRQUdoSCxJQUFJQSxTQUFTUSxLQUFLUixNQUFNO1FBRXhCLElBQUssSUFBSVUsSUFBSSxHQUFHQSxJQUFJVixRQUFRVSxJQUFLO1lBQy9CLElBQUksQ0FBQ0osY0FBY0UsSUFBSSxDQUFDRSxFQUFFLEVBQUVELElBQUksQ0FBQ0MsRUFBRSxHQUFHO2dCQUNwQyxPQUFPO1lBQ1Q7UUFDRjtRQUVBLE9BQU87SUFDVDtBQUNGO0FBQ0EsMkVBQTJFO0FBQzNFLG1FQUFtRTtBQUM1RCxTQUFTQyxlQUFlQyxJQUFJLEVBQUVDLHNCQUFzQjtJQUN6RCxJQUFJQyxrQkFBa0IsT0FBT0QsMkJBQTJCLFdBQVdBLHlCQUF5QjtRQUMxRlAsZUFBZU87SUFDakI7SUFDQSxJQUFJRSx3QkFBd0JELGdCQUFnQlIsYUFBYSxFQUNyREEsZ0JBQWdCUywwQkFBMEIsS0FBSyxJQUFJYix1QkFBdUJhLHVCQUMxRUMsd0JBQXdCRixnQkFBZ0JwQixPQUFPLEVBQy9DQSxVQUFVc0IsMEJBQTBCLEtBQUssSUFBSSxJQUFJQSx1QkFDakRDLHNCQUFzQkgsZ0JBQWdCRyxtQkFBbUI7SUFDN0QsSUFBSUMsYUFBYWIseUJBQXlCQztJQUMxQyxJQUFJYSxRQUFRekIsWUFBWSxJQUFJWCxxQkFBcUJtQyxjQUFjekIsZUFBZUMsU0FBU3dCLGFBQWEsMkVBQTJFO0lBRS9LLFNBQVNFO1FBQ1AsSUFBSWhDLFFBQVErQixNQUFNakMsR0FBRyxDQUFDbUM7UUFFdEIsSUFBSWpDLFVBQVVOLFdBQVc7WUFDdkIsYUFBYTtZQUNiTSxRQUFRd0IsS0FBS1UsS0FBSyxDQUFDLE1BQU1EO1lBRXpCLElBQUlKLHFCQUFxQjtnQkFDdkIsSUFBSXRCLFVBQVV3QixNQUFNN0IsVUFBVTtnQkFDOUIsSUFBSWlDLGdCQUFnQjVCLFFBQVE2QixJQUFJLENBQUMsU0FBVXZDLEtBQUs7b0JBQzlDLE9BQU9nQyxvQkFBb0JoQyxNQUFNRyxLQUFLLEVBQUVBO2dCQUMxQztnQkFFQSxJQUFJbUMsZUFBZTtvQkFDakJuQyxRQUFRbUMsY0FBY25DLEtBQUs7Z0JBQzdCO1lBQ0Y7WUFFQStCLE1BQU05QixHQUFHLENBQUNnQyxXQUFXakM7UUFDdkI7UUFFQSxPQUFPQTtJQUNUO0lBRUFnQyxTQUFTSyxVQUFVLEdBQUc7UUFDcEIsT0FBT04sTUFBTTVCLEtBQUs7SUFDcEI7SUFFQSxPQUFPNkI7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVzZWxlY3QvZXMvZGVmYXVsdE1lbW9pemUuanM/ZWM0NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDYWNoZSBpbXBsZW1lbnRhdGlvbiBiYXNlZCBvbiBFcmlrIFJhc211c3NlbidzIGBscnUtbWVtb2l6ZWA6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZXJpa3Jhcy9scnUtbWVtb2l6ZVxudmFyIE5PVF9GT1VORCA9ICdOT1RfRk9VTkQnO1xuXG5mdW5jdGlvbiBjcmVhdGVTaW5nbGV0b25DYWNoZShlcXVhbHMpIHtcbiAgdmFyIGVudHJ5O1xuICByZXR1cm4ge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgICAgaWYgKGVudHJ5ICYmIGVxdWFscyhlbnRyeS5rZXksIGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGVudHJ5LnZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gTk9UX0ZPVU5EO1xuICAgIH0sXG4gICAgcHV0OiBmdW5jdGlvbiBwdXQoa2V5LCB2YWx1ZSkge1xuICAgICAgZW50cnkgPSB7XG4gICAgICAgIGtleToga2V5LFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXRFbnRyaWVzOiBmdW5jdGlvbiBnZXRFbnRyaWVzKCkge1xuICAgICAgcmV0dXJuIGVudHJ5ID8gW2VudHJ5XSA6IFtdO1xuICAgIH0sXG4gICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgZW50cnkgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMcnVDYWNoZShtYXhTaXplLCBlcXVhbHMpIHtcbiAgdmFyIGVudHJpZXMgPSBbXTtcblxuICBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgdmFyIGNhY2hlSW5kZXggPSBlbnRyaWVzLmZpbmRJbmRleChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgIHJldHVybiBlcXVhbHMoa2V5LCBlbnRyeS5rZXkpO1xuICAgIH0pOyAvLyBXZSBmb3VuZCBhIGNhY2hlZCBlbnRyeVxuXG4gICAgaWYgKGNhY2hlSW5kZXggPiAtMSkge1xuICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tjYWNoZUluZGV4XTsgLy8gQ2FjaGVkIGVudHJ5IG5vdCBhdCB0b3Agb2YgY2FjaGUsIG1vdmUgaXQgdG8gdGhlIHRvcFxuXG4gICAgICBpZiAoY2FjaGVJbmRleCA+IDApIHtcbiAgICAgICAgZW50cmllcy5zcGxpY2UoY2FjaGVJbmRleCwgMSk7XG4gICAgICAgIGVudHJpZXMudW5zaGlmdChlbnRyeSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbnRyeS52YWx1ZTtcbiAgICB9IC8vIE5vIGVudHJ5IGZvdW5kIGluIGNhY2hlLCByZXR1cm4gc2VudGluZWxcblxuXG4gICAgcmV0dXJuIE5PVF9GT1VORDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1dChrZXksIHZhbHVlKSB7XG4gICAgaWYgKGdldChrZXkpID09PSBOT1RfRk9VTkQpIHtcbiAgICAgIC8vIFRPRE8gSXMgdW5zaGlmdCBzbG93P1xuICAgICAgZW50cmllcy51bnNoaWZ0KHtcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChlbnRyaWVzLmxlbmd0aCA+IG1heFNpemUpIHtcbiAgICAgICAgZW50cmllcy5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRFbnRyaWVzKCkge1xuICAgIHJldHVybiBlbnRyaWVzO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgZW50cmllcyA9IFtdO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBnZXQ6IGdldCxcbiAgICBwdXQ6IHB1dCxcbiAgICBnZXRFbnRyaWVzOiBnZXRFbnRyaWVzLFxuICAgIGNsZWFyOiBjbGVhclxuICB9O1xufVxuXG5leHBvcnQgdmFyIGRlZmF1bHRFcXVhbGl0eUNoZWNrID0gZnVuY3Rpb24gZGVmYXVsdEVxdWFsaXR5Q2hlY2soYSwgYikge1xuICByZXR1cm4gYSA9PT0gYjtcbn07XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2FjaGVLZXlDb21wYXJhdG9yKGVxdWFsaXR5Q2hlY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGFyZUFyZ3VtZW50c1NoYWxsb3dseUVxdWFsKHByZXYsIG5leHQpIHtcbiAgICBpZiAocHJldiA9PT0gbnVsbCB8fCBuZXh0ID09PSBudWxsIHx8IHByZXYubGVuZ3RoICE9PSBuZXh0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gRG8gdGhpcyBpbiBhIGZvciBsb29wIChhbmQgbm90IGEgYGZvckVhY2hgIG9yIGFuIGBldmVyeWApIHNvIHdlIGNhbiBkZXRlcm1pbmUgZXF1YWxpdHkgYXMgZmFzdCBhcyBwb3NzaWJsZS5cblxuXG4gICAgdmFyIGxlbmd0aCA9IHByZXYubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFlcXVhbGl0eUNoZWNrKHByZXZbaV0sIG5leHRbaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cbi8vIGRlZmF1bHRNZW1vaXplIG5vdyBzdXBwb3J0cyBhIGNvbmZpZ3VyYWJsZSBjYWNoZSBzaXplIHdpdGggTFJVIGJlaGF2aW9yLFxuLy8gYW5kIG9wdGlvbmFsIGNvbXBhcmlzb24gb2YgdGhlIHJlc3VsdCB2YWx1ZSB3aXRoIGV4aXN0aW5nIHZhbHVlc1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRNZW1vaXplKGZ1bmMsIGVxdWFsaXR5Q2hlY2tPck9wdGlvbnMpIHtcbiAgdmFyIHByb3ZpZGVkT3B0aW9ucyA9IHR5cGVvZiBlcXVhbGl0eUNoZWNrT3JPcHRpb25zID09PSAnb2JqZWN0JyA/IGVxdWFsaXR5Q2hlY2tPck9wdGlvbnMgOiB7XG4gICAgZXF1YWxpdHlDaGVjazogZXF1YWxpdHlDaGVja09yT3B0aW9uc1xuICB9O1xuICB2YXIgX3Byb3ZpZGVkT3B0aW9ucyRlcXVhID0gcHJvdmlkZWRPcHRpb25zLmVxdWFsaXR5Q2hlY2ssXG4gICAgICBlcXVhbGl0eUNoZWNrID0gX3Byb3ZpZGVkT3B0aW9ucyRlcXVhID09PSB2b2lkIDAgPyBkZWZhdWx0RXF1YWxpdHlDaGVjayA6IF9wcm92aWRlZE9wdGlvbnMkZXF1YSxcbiAgICAgIF9wcm92aWRlZE9wdGlvbnMkbWF4UyA9IHByb3ZpZGVkT3B0aW9ucy5tYXhTaXplLFxuICAgICAgbWF4U2l6ZSA9IF9wcm92aWRlZE9wdGlvbnMkbWF4UyA9PT0gdm9pZCAwID8gMSA6IF9wcm92aWRlZE9wdGlvbnMkbWF4UyxcbiAgICAgIHJlc3VsdEVxdWFsaXR5Q2hlY2sgPSBwcm92aWRlZE9wdGlvbnMucmVzdWx0RXF1YWxpdHlDaGVjaztcbiAgdmFyIGNvbXBhcmF0b3IgPSBjcmVhdGVDYWNoZUtleUNvbXBhcmF0b3IoZXF1YWxpdHlDaGVjayk7XG4gIHZhciBjYWNoZSA9IG1heFNpemUgPT09IDEgPyBjcmVhdGVTaW5nbGV0b25DYWNoZShjb21wYXJhdG9yKSA6IGNyZWF0ZUxydUNhY2hlKG1heFNpemUsIGNvbXBhcmF0b3IpOyAvLyB3ZSByZWZlcmVuY2UgYXJndW1lbnRzIGluc3RlYWQgb2Ygc3ByZWFkaW5nIHRoZW0gZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcblxuICBmdW5jdGlvbiBtZW1vaXplZCgpIHtcbiAgICB2YXIgdmFsdWUgPSBjYWNoZS5nZXQoYXJndW1lbnRzKTtcblxuICAgIGlmICh2YWx1ZSA9PT0gTk9UX0ZPVU5EKSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB2YWx1ZSA9IGZ1bmMuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcblxuICAgICAgaWYgKHJlc3VsdEVxdWFsaXR5Q2hlY2spIHtcbiAgICAgICAgdmFyIGVudHJpZXMgPSBjYWNoZS5nZXRFbnRyaWVzKCk7XG4gICAgICAgIHZhciBtYXRjaGluZ0VudHJ5ID0gZW50cmllcy5maW5kKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgIHJldHVybiByZXN1bHRFcXVhbGl0eUNoZWNrKGVudHJ5LnZhbHVlLCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChtYXRjaGluZ0VudHJ5KSB7XG4gICAgICAgICAgdmFsdWUgPSBtYXRjaGluZ0VudHJ5LnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNhY2hlLnB1dChhcmd1bWVudHMsIHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBtZW1vaXplZC5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjYWNoZS5jbGVhcigpO1xuICB9O1xuXG4gIHJldHVybiBtZW1vaXplZDtcbn0iXSwibmFtZXMiOlsiTk9UX0ZPVU5EIiwiY3JlYXRlU2luZ2xldG9uQ2FjaGUiLCJlcXVhbHMiLCJlbnRyeSIsImdldCIsImtleSIsInZhbHVlIiwicHV0IiwiZ2V0RW50cmllcyIsImNsZWFyIiwidW5kZWZpbmVkIiwiY3JlYXRlTHJ1Q2FjaGUiLCJtYXhTaXplIiwiZW50cmllcyIsImNhY2hlSW5kZXgiLCJmaW5kSW5kZXgiLCJzcGxpY2UiLCJ1bnNoaWZ0IiwibGVuZ3RoIiwicG9wIiwiZGVmYXVsdEVxdWFsaXR5Q2hlY2siLCJhIiwiYiIsImNyZWF0ZUNhY2hlS2V5Q29tcGFyYXRvciIsImVxdWFsaXR5Q2hlY2siLCJhcmVBcmd1bWVudHNTaGFsbG93bHlFcXVhbCIsInByZXYiLCJuZXh0IiwiaSIsImRlZmF1bHRNZW1vaXplIiwiZnVuYyIsImVxdWFsaXR5Q2hlY2tPck9wdGlvbnMiLCJwcm92aWRlZE9wdGlvbnMiLCJfcHJvdmlkZWRPcHRpb25zJGVxdWEiLCJfcHJvdmlkZWRPcHRpb25zJG1heFMiLCJyZXN1bHRFcXVhbGl0eUNoZWNrIiwiY29tcGFyYXRvciIsImNhY2hlIiwibWVtb2l6ZWQiLCJhcmd1bWVudHMiLCJhcHBseSIsIm1hdGNoaW5nRW50cnkiLCJmaW5kIiwiY2xlYXJDYWNoZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/reselect/es/defaultMemoize.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/reselect/es/index.js":
/*!*******************************************!*\
  !*** ./node_modules/reselect/es/index.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSelector: function() { return /* binding */ createSelector; },\n/* harmony export */   createSelectorCreator: function() { return /* binding */ createSelectorCreator; },\n/* harmony export */   createStructuredSelector: function() { return /* binding */ createStructuredSelector; },\n/* harmony export */   defaultEqualityCheck: function() { return /* reexport safe */ _defaultMemoize__WEBPACK_IMPORTED_MODULE_0__.defaultEqualityCheck; },\n/* harmony export */   defaultMemoize: function() { return /* reexport safe */ _defaultMemoize__WEBPACK_IMPORTED_MODULE_0__.defaultMemoize; }\n/* harmony export */ });\n/* harmony import */ var _defaultMemoize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defaultMemoize */ \"(app-pages-browser)/./node_modules/reselect/es/defaultMemoize.js\");\n\n\nfunction getDependencies(funcs) {\n    var dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;\n    if (!dependencies.every(function(dep) {\n        return typeof dep === \"function\";\n    })) {\n        var dependencyTypes = dependencies.map(function(dep) {\n            return typeof dep === \"function\" ? \"function \" + (dep.name || \"unnamed\") + \"()\" : typeof dep;\n        }).join(\", \");\n        throw new Error(\"createSelector expects all input-selectors to be functions, but received the following types: [\" + dependencyTypes + \"]\");\n    }\n    return dependencies;\n}\nfunction createSelectorCreator(memoize) {\n    for(var _len = arguments.length, memoizeOptionsFromArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        memoizeOptionsFromArgs[_key - 1] = arguments[_key];\n    }\n    var createSelector = function createSelector() {\n        for(var _len2 = arguments.length, funcs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){\n            funcs[_key2] = arguments[_key2];\n        }\n        var _recomputations = 0;\n        var _lastResult; // Due to the intricacies of rest params, we can't do an optional arg after `...funcs`.\n        // So, start by declaring the default value here.\n        // (And yes, the words 'memoize' and 'options' appear too many times in this next sequence.)\n        var directlyPassedOptions = {\n            memoizeOptions: undefined\n        }; // Normally, the result func or \"output selector\" is the last arg\n        var resultFunc = funcs.pop(); // If the result func is actually an _object_, assume it's our options object\n        if (typeof resultFunc === \"object\") {\n            directlyPassedOptions = resultFunc; // and pop the real result func off\n            resultFunc = funcs.pop();\n        }\n        if (typeof resultFunc !== \"function\") {\n            throw new Error(\"createSelector expects an output function after the inputs, but received: [\" + typeof resultFunc + \"]\");\n        } // Determine which set of options we're using. Prefer options passed directly,\n        // but fall back to options given to createSelectorCreator.\n        var _directlyPassedOption = directlyPassedOptions, _directlyPassedOption2 = _directlyPassedOption.memoizeOptions, memoizeOptions = _directlyPassedOption2 === void 0 ? memoizeOptionsFromArgs : _directlyPassedOption2; // Simplifying assumption: it's unlikely that the first options arg of the provided memoizer\n        // is an array. In most libs I've looked at, it's an equality function or options object.\n        // Based on that, if `memoizeOptions` _is_ an array, we assume it's a full\n        // user-provided array of options. Otherwise, it must be just the _first_ arg, and so\n        // we wrap it in an array so we can apply it.\n        var finalMemoizeOptions = Array.isArray(memoizeOptions) ? memoizeOptions : [\n            memoizeOptions\n        ];\n        var dependencies = getDependencies(funcs);\n        var memoizedResultFunc = memoize.apply(void 0, [\n            function recomputationWrapper() {\n                _recomputations++; // apply arguments instead of spreading for performance.\n                return resultFunc.apply(null, arguments);\n            }\n        ].concat(finalMemoizeOptions)); // If a selector is called with the exact same arguments we don't need to traverse our dependencies again.\n        var selector = memoize(function dependenciesChecker() {\n            var params = [];\n            var length = dependencies.length;\n            for(var i = 0; i < length; i++){\n                // apply arguments instead of spreading and mutate a local list of params for performance.\n                // @ts-ignore\n                params.push(dependencies[i].apply(null, arguments));\n            } // apply arguments instead of spreading for performance.\n            _lastResult = memoizedResultFunc.apply(null, params);\n            return _lastResult;\n        });\n        Object.assign(selector, {\n            resultFunc: resultFunc,\n            memoizedResultFunc: memoizedResultFunc,\n            dependencies: dependencies,\n            lastResult: function lastResult() {\n                return _lastResult;\n            },\n            recomputations: function recomputations() {\n                return _recomputations;\n            },\n            resetRecomputations: function resetRecomputations() {\n                return _recomputations = 0;\n            }\n        });\n        return selector;\n    }; // @ts-ignore\n    return createSelector;\n}\nvar createSelector = /* #__PURE__ */ createSelectorCreator(_defaultMemoize__WEBPACK_IMPORTED_MODULE_0__.defaultMemoize);\n// Manual definition of state and output arguments\nvar createStructuredSelector = function createStructuredSelector(selectors, selectorCreator) {\n    if (selectorCreator === void 0) {\n        selectorCreator = createSelector;\n    }\n    if (typeof selectors !== \"object\") {\n        throw new Error(\"createStructuredSelector expects first argument to be an object \" + (\"where each property is a selector, instead received a \" + typeof selectors));\n    }\n    var objectKeys = Object.keys(selectors);\n    var resultSelector = selectorCreator(objectKeys.map(function(key) {\n        return selectors[key];\n    }), function() {\n        for(var _len3 = arguments.length, values = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++){\n            values[_key3] = arguments[_key3];\n        }\n        return values.reduce(function(composition, value, index) {\n            composition[objectKeys[index]] = value;\n            return composition;\n        }, {});\n    });\n    return resultSelector;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZXNlbGVjdC9lcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBd0U7QUFDeEI7QUFFaEQsU0FBU0UsZ0JBQWdCQyxLQUFLO0lBQzVCLElBQUlDLGVBQWVDLE1BQU1DLE9BQU8sQ0FBQ0gsS0FBSyxDQUFDLEVBQUUsSUFBSUEsS0FBSyxDQUFDLEVBQUUsR0FBR0E7SUFFeEQsSUFBSSxDQUFDQyxhQUFhRyxLQUFLLENBQUMsU0FBVUMsR0FBRztRQUNuQyxPQUFPLE9BQU9BLFFBQVE7SUFDeEIsSUFBSTtRQUNGLElBQUlDLGtCQUFrQkwsYUFBYU0sR0FBRyxDQUFDLFNBQVVGLEdBQUc7WUFDbEQsT0FBTyxPQUFPQSxRQUFRLGFBQWEsY0FBZUEsQ0FBQUEsSUFBSUcsSUFBSSxJQUFJLFNBQVEsSUFBSyxPQUFPLE9BQU9IO1FBQzNGLEdBQUdJLElBQUksQ0FBQztRQUNSLE1BQU0sSUFBSUMsTUFBTSxvR0FBb0dKLGtCQUFrQjtJQUN4STtJQUVBLE9BQU9MO0FBQ1Q7QUFFTyxTQUFTVSxzQkFBc0JDLE9BQU87SUFDM0MsSUFBSyxJQUFJQyxPQUFPQyxVQUFVQyxNQUFNLEVBQUVDLHlCQUF5QixJQUFJZCxNQUFNVyxPQUFPLElBQUlBLE9BQU8sSUFBSSxJQUFJSSxPQUFPLEdBQUdBLE9BQU9KLE1BQU1JLE9BQVE7UUFDNUhELHNCQUFzQixDQUFDQyxPQUFPLEVBQUUsR0FBR0gsU0FBUyxDQUFDRyxLQUFLO0lBQ3BEO0lBRUEsSUFBSUMsaUJBQWlCLFNBQVNBO1FBQzVCLElBQUssSUFBSUMsUUFBUUwsVUFBVUMsTUFBTSxFQUFFZixRQUFRLElBQUlFLE1BQU1pQixRQUFRQyxRQUFRLEdBQUdBLFFBQVFELE9BQU9DLFFBQVM7WUFDOUZwQixLQUFLLENBQUNvQixNQUFNLEdBQUdOLFNBQVMsQ0FBQ00sTUFBTTtRQUNqQztRQUVBLElBQUlDLGtCQUFrQjtRQUV0QixJQUFJQyxhQUFhLHVGQUF1RjtR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QVVDLFdBQVcsRUFBRUMsS0FBSyxFQUFFQyxLQUFLO1lBQ3RERixXQUFXLENBQUNSLFVBQVUsQ0FBQ1UsTUFBTSxDQUFDLEdBQUdEO1lBQ2pDLE9BQU9EO1FBQ1QsR0FBRyxDQUFDO0lBQ047SUFDQSxPQUFPTjtBQUNULEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Jlc2VsZWN0L2VzL2luZGV4LmpzPzVkNjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVmYXVsdE1lbW9pemUsIGRlZmF1bHRFcXVhbGl0eUNoZWNrIH0gZnJvbSAnLi9kZWZhdWx0TWVtb2l6ZSc7XG5leHBvcnQgeyBkZWZhdWx0TWVtb2l6ZSwgZGVmYXVsdEVxdWFsaXR5Q2hlY2sgfTtcblxuZnVuY3Rpb24gZ2V0RGVwZW5kZW5jaWVzKGZ1bmNzKSB7XG4gIHZhciBkZXBlbmRlbmNpZXMgPSBBcnJheS5pc0FycmF5KGZ1bmNzWzBdKSA/IGZ1bmNzWzBdIDogZnVuY3M7XG5cbiAgaWYgKCFkZXBlbmRlbmNpZXMuZXZlcnkoZnVuY3Rpb24gKGRlcCkge1xuICAgIHJldHVybiB0eXBlb2YgZGVwID09PSAnZnVuY3Rpb24nO1xuICB9KSkge1xuICAgIHZhciBkZXBlbmRlbmN5VHlwZXMgPSBkZXBlbmRlbmNpZXMubWFwKGZ1bmN0aW9uIChkZXApIHtcbiAgICAgIHJldHVybiB0eXBlb2YgZGVwID09PSAnZnVuY3Rpb24nID8gXCJmdW5jdGlvbiBcIiArIChkZXAubmFtZSB8fCAndW5uYW1lZCcpICsgXCIoKVwiIDogdHlwZW9mIGRlcDtcbiAgICB9KS5qb2luKCcsICcpO1xuICAgIHRocm93IG5ldyBFcnJvcihcImNyZWF0ZVNlbGVjdG9yIGV4cGVjdHMgYWxsIGlucHV0LXNlbGVjdG9ycyB0byBiZSBmdW5jdGlvbnMsIGJ1dCByZWNlaXZlZCB0aGUgZm9sbG93aW5nIHR5cGVzOiBbXCIgKyBkZXBlbmRlbmN5VHlwZXMgKyBcIl1cIik7XG4gIH1cblxuICByZXR1cm4gZGVwZW5kZW5jaWVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2VsZWN0b3JDcmVhdG9yKG1lbW9pemUpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG1lbW9pemVPcHRpb25zRnJvbUFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIG1lbW9pemVPcHRpb25zRnJvbUFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgdmFyIGNyZWF0ZVNlbGVjdG9yID0gZnVuY3Rpb24gY3JlYXRlU2VsZWN0b3IoKSB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBmdW5jcyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgZnVuY3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICB2YXIgX3JlY29tcHV0YXRpb25zID0gMDtcblxuICAgIHZhciBfbGFzdFJlc3VsdDsgLy8gRHVlIHRvIHRoZSBpbnRyaWNhY2llcyBvZiByZXN0IHBhcmFtcywgd2UgY2FuJ3QgZG8gYW4gb3B0aW9uYWwgYXJnIGFmdGVyIGAuLi5mdW5jc2AuXG4gICAgLy8gU28sIHN0YXJ0IGJ5IGRlY2xhcmluZyB0aGUgZGVmYXVsdCB2YWx1ZSBoZXJlLlxuICAgIC8vIChBbmQgeWVzLCB0aGUgd29yZHMgJ21lbW9pemUnIGFuZCAnb3B0aW9ucycgYXBwZWFyIHRvbyBtYW55IHRpbWVzIGluIHRoaXMgbmV4dCBzZXF1ZW5jZS4pXG5cblxuICAgIHZhciBkaXJlY3RseVBhc3NlZE9wdGlvbnMgPSB7XG4gICAgICBtZW1vaXplT3B0aW9uczogdW5kZWZpbmVkXG4gICAgfTsgLy8gTm9ybWFsbHksIHRoZSByZXN1bHQgZnVuYyBvciBcIm91dHB1dCBzZWxlY3RvclwiIGlzIHRoZSBsYXN0IGFyZ1xuXG4gICAgdmFyIHJlc3VsdEZ1bmMgPSBmdW5jcy5wb3AoKTsgLy8gSWYgdGhlIHJlc3VsdCBmdW5jIGlzIGFjdHVhbGx5IGFuIF9vYmplY3RfLCBhc3N1bWUgaXQncyBvdXIgb3B0aW9ucyBvYmplY3RcblxuICAgIGlmICh0eXBlb2YgcmVzdWx0RnVuYyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGRpcmVjdGx5UGFzc2VkT3B0aW9ucyA9IHJlc3VsdEZ1bmM7IC8vIGFuZCBwb3AgdGhlIHJlYWwgcmVzdWx0IGZ1bmMgb2ZmXG5cbiAgICAgIHJlc3VsdEZ1bmMgPSBmdW5jcy5wb3AoKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHJlc3VsdEZ1bmMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNyZWF0ZVNlbGVjdG9yIGV4cGVjdHMgYW4gb3V0cHV0IGZ1bmN0aW9uIGFmdGVyIHRoZSBpbnB1dHMsIGJ1dCByZWNlaXZlZDogW1wiICsgdHlwZW9mIHJlc3VsdEZ1bmMgKyBcIl1cIik7XG4gICAgfSAvLyBEZXRlcm1pbmUgd2hpY2ggc2V0IG9mIG9wdGlvbnMgd2UncmUgdXNpbmcuIFByZWZlciBvcHRpb25zIHBhc3NlZCBkaXJlY3RseSxcbiAgICAvLyBidXQgZmFsbCBiYWNrIHRvIG9wdGlvbnMgZ2l2ZW4gdG8gY3JlYXRlU2VsZWN0b3JDcmVhdG9yLlxuXG5cbiAgICB2YXIgX2RpcmVjdGx5UGFzc2VkT3B0aW9uID0gZGlyZWN0bHlQYXNzZWRPcHRpb25zLFxuICAgICAgICBfZGlyZWN0bHlQYXNzZWRPcHRpb24yID0gX2RpcmVjdGx5UGFzc2VkT3B0aW9uLm1lbW9pemVPcHRpb25zLFxuICAgICAgICBtZW1vaXplT3B0aW9ucyA9IF9kaXJlY3RseVBhc3NlZE9wdGlvbjIgPT09IHZvaWQgMCA/IG1lbW9pemVPcHRpb25zRnJvbUFyZ3MgOiBfZGlyZWN0bHlQYXNzZWRPcHRpb24yOyAvLyBTaW1wbGlmeWluZyBhc3N1bXB0aW9uOiBpdCdzIHVubGlrZWx5IHRoYXQgdGhlIGZpcnN0IG9wdGlvbnMgYXJnIG9mIHRoZSBwcm92aWRlZCBtZW1vaXplclxuICAgIC8vIGlzIGFuIGFycmF5LiBJbiBtb3N0IGxpYnMgSSd2ZSBsb29rZWQgYXQsIGl0J3MgYW4gZXF1YWxpdHkgZnVuY3Rpb24gb3Igb3B0aW9ucyBvYmplY3QuXG4gICAgLy8gQmFzZWQgb24gdGhhdCwgaWYgYG1lbW9pemVPcHRpb25zYCBfaXNfIGFuIGFycmF5LCB3ZSBhc3N1bWUgaXQncyBhIGZ1bGxcbiAgICAvLyB1c2VyLXByb3ZpZGVkIGFycmF5IG9mIG9wdGlvbnMuIE90aGVyd2lzZSwgaXQgbXVzdCBiZSBqdXN0IHRoZSBfZmlyc3RfIGFyZywgYW5kIHNvXG4gICAgLy8gd2Ugd3JhcCBpdCBpbiBhbiBhcnJheSBzbyB3ZSBjYW4gYXBwbHkgaXQuXG5cbiAgICB2YXIgZmluYWxNZW1vaXplT3B0aW9ucyA9IEFycmF5LmlzQXJyYXkobWVtb2l6ZU9wdGlvbnMpID8gbWVtb2l6ZU9wdGlvbnMgOiBbbWVtb2l6ZU9wdGlvbnNdO1xuICAgIHZhciBkZXBlbmRlbmNpZXMgPSBnZXREZXBlbmRlbmNpZXMoZnVuY3MpO1xuICAgIHZhciBtZW1vaXplZFJlc3VsdEZ1bmMgPSBtZW1vaXplLmFwcGx5KHZvaWQgMCwgW2Z1bmN0aW9uIHJlY29tcHV0YXRpb25XcmFwcGVyKCkge1xuICAgICAgX3JlY29tcHV0YXRpb25zKys7IC8vIGFwcGx5IGFyZ3VtZW50cyBpbnN0ZWFkIG9mIHNwcmVhZGluZyBmb3IgcGVyZm9ybWFuY2UuXG5cbiAgICAgIHJldHVybiByZXN1bHRGdW5jLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfV0uY29uY2F0KGZpbmFsTWVtb2l6ZU9wdGlvbnMpKTsgLy8gSWYgYSBzZWxlY3RvciBpcyBjYWxsZWQgd2l0aCB0aGUgZXhhY3Qgc2FtZSBhcmd1bWVudHMgd2UgZG9uJ3QgbmVlZCB0byB0cmF2ZXJzZSBvdXIgZGVwZW5kZW5jaWVzIGFnYWluLlxuXG4gICAgdmFyIHNlbGVjdG9yID0gbWVtb2l6ZShmdW5jdGlvbiBkZXBlbmRlbmNpZXNDaGVja2VyKCkge1xuICAgICAgdmFyIHBhcmFtcyA9IFtdO1xuICAgICAgdmFyIGxlbmd0aCA9IGRlcGVuZGVuY2llcy5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gYXBwbHkgYXJndW1lbnRzIGluc3RlYWQgb2Ygc3ByZWFkaW5nIGFuZCBtdXRhdGUgYSBsb2NhbCBsaXN0IG9mIHBhcmFtcyBmb3IgcGVyZm9ybWFuY2UuXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcGFyYW1zLnB1c2goZGVwZW5kZW5jaWVzW2ldLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICAgICAgfSAvLyBhcHBseSBhcmd1bWVudHMgaW5zdGVhZCBvZiBzcHJlYWRpbmcgZm9yIHBlcmZvcm1hbmNlLlxuXG5cbiAgICAgIF9sYXN0UmVzdWx0ID0gbWVtb2l6ZWRSZXN1bHRGdW5jLmFwcGx5KG51bGwsIHBhcmFtcyk7XG4gICAgICByZXR1cm4gX2xhc3RSZXN1bHQ7XG4gICAgfSk7XG4gICAgT2JqZWN0LmFzc2lnbihzZWxlY3Rvciwge1xuICAgICAgcmVzdWx0RnVuYzogcmVzdWx0RnVuYyxcbiAgICAgIG1lbW9pemVkUmVzdWx0RnVuYzogbWVtb2l6ZWRSZXN1bHRGdW5jLFxuICAgICAgZGVwZW5kZW5jaWVzOiBkZXBlbmRlbmNpZXMsXG4gICAgICBsYXN0UmVzdWx0OiBmdW5jdGlvbiBsYXN0UmVzdWx0KCkge1xuICAgICAgICByZXR1cm4gX2xhc3RSZXN1bHQ7XG4gICAgICB9LFxuICAgICAgcmVjb21wdXRhdGlvbnM6IGZ1bmN0aW9uIHJlY29tcHV0YXRpb25zKCkge1xuICAgICAgICByZXR1cm4gX3JlY29tcHV0YXRpb25zO1xuICAgICAgfSxcbiAgICAgIHJlc2V0UmVjb21wdXRhdGlvbnM6IGZ1bmN0aW9uIHJlc2V0UmVjb21wdXRhdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBfcmVjb21wdXRhdGlvbnMgPSAwO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzZWxlY3RvcjtcbiAgfTsgLy8gQHRzLWlnbm9yZVxuXG5cbiAgcmV0dXJuIGNyZWF0ZVNlbGVjdG9yO1xufVxuZXhwb3J0IHZhciBjcmVhdGVTZWxlY3RvciA9IC8qICNfX1BVUkVfXyAqL2NyZWF0ZVNlbGVjdG9yQ3JlYXRvcihkZWZhdWx0TWVtb2l6ZSk7XG4vLyBNYW51YWwgZGVmaW5pdGlvbiBvZiBzdGF0ZSBhbmQgb3V0cHV0IGFyZ3VtZW50c1xuZXhwb3J0IHZhciBjcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3IgPSBmdW5jdGlvbiBjcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3Ioc2VsZWN0b3JzLCBzZWxlY3RvckNyZWF0b3IpIHtcbiAgaWYgKHNlbGVjdG9yQ3JlYXRvciA9PT0gdm9pZCAwKSB7XG4gICAgc2VsZWN0b3JDcmVhdG9yID0gY3JlYXRlU2VsZWN0b3I7XG4gIH1cblxuICBpZiAodHlwZW9mIHNlbGVjdG9ycyAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyZWF0ZVN0cnVjdHVyZWRTZWxlY3RvciBleHBlY3RzIGZpcnN0IGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCAnICsgKFwid2hlcmUgZWFjaCBwcm9wZXJ0eSBpcyBhIHNlbGVjdG9yLCBpbnN0ZWFkIHJlY2VpdmVkIGEgXCIgKyB0eXBlb2Ygc2VsZWN0b3JzKSk7XG4gIH1cblxuICB2YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzKHNlbGVjdG9ycyk7XG4gIHZhciByZXN1bHRTZWxlY3RvciA9IHNlbGVjdG9yQ3JlYXRvciggLy8gQHRzLWlnbm9yZVxuICBvYmplY3RLZXlzLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHNlbGVjdG9yc1trZXldO1xuICB9KSwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgdmFsdWVzID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICB2YWx1ZXNbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVzLnJlZHVjZShmdW5jdGlvbiAoY29tcG9zaXRpb24sIHZhbHVlLCBpbmRleCkge1xuICAgICAgY29tcG9zaXRpb25bb2JqZWN0S2V5c1tpbmRleF1dID0gdmFsdWU7XG4gICAgICByZXR1cm4gY29tcG9zaXRpb247XG4gICAgfSwge30pO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdFNlbGVjdG9yO1xufTsiXSwibmFtZXMiOlsiZGVmYXVsdE1lbW9pemUiLCJkZWZhdWx0RXF1YWxpdHlDaGVjayIsImdldERlcGVuZGVuY2llcyIsImZ1bmNzIiwiZGVwZW5kZW5jaWVzIiwiQXJyYXkiLCJpc0FycmF5IiwiZXZlcnkiLCJkZXAiLCJkZXBlbmRlbmN5VHlwZXMiLCJtYXAiLCJuYW1lIiwiam9pbiIsIkVycm9yIiwiY3JlYXRlU2VsZWN0b3JDcmVhdG9yIiwibWVtb2l6ZSIsIl9sZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJtZW1vaXplT3B0aW9uc0Zyb21BcmdzIiwiX2tleSIsImNyZWF0ZVNlbGVjdG9yIiwiX2xlbjIiLCJfa2V5MiIsIl9yZWNvbXB1dGF0aW9ucyIsIl9sYXN0UmVzdWx0IiwiZGlyZWN0bHlQYXNzZWRPcHRpb25zIiwibWVtb2l6ZU9wdGlvbnMiLCJ1bmRlZmluZWQiLCJyZXN1bHRGdW5jIiwicG9wIiwiX2RpcmVjdGx5UGFzc2VkT3B0aW9uIiwiX2RpcmVjdGx5UGFzc2VkT3B0aW9uMiIsImZpbmFsTWVtb2l6ZU9wdGlvbnMiLCJtZW1vaXplZFJlc3VsdEZ1bmMiLCJhcHBseSIsInJlY29tcHV0YXRpb25XcmFwcGVyIiwiY29uY2F0Iiwic2VsZWN0b3IiLCJkZXBlbmRlbmNpZXNDaGVja2VyIiwicGFyYW1zIiwiaSIsInB1c2giLCJPYmplY3QiLCJhc3NpZ24iLCJsYXN0UmVzdWx0IiwicmVjb21wdXRhdGlvbnMiLCJyZXNldFJlY29tcHV0YXRpb25zIiwiY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yIiwic2VsZWN0b3JzIiwic2VsZWN0b3JDcmVhdG9yIiwib2JqZWN0S2V5cyIsImtleXMiLCJyZXN1bHRTZWxlY3RvciIsImtleSIsIl9sZW4zIiwidmFsdWVzIiwiX2tleTMiLCJyZWR1Y2UiLCJjb21wb3NpdGlvbiIsInZhbHVlIiwiaW5kZXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/reselect/es/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js ***!
  \*******************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * use-sync-external-store-with-selector.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \n true && function() {\n    var _s = $RefreshSig$();\n    function is(x, y) {\n        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && \"function\" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    var React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"), objectIs = \"function\" === typeof Object.is ? Object.is : is, useSyncExternalStore = React.useSyncExternalStore, useRef = React.useRef, useEffect = React.useEffect, useMemo = React.useMemo, useDebugValue = React.useDebugValue;\n    exports.useSyncExternalStoreWithSelector = _s(function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {\n        _s();\n        var instRef = useRef(null);\n        if (null === instRef.current) {\n            var inst = {\n                hasValue: !1,\n                value: null\n            };\n            instRef.current = inst;\n        } else inst = instRef.current;\n        instRef = useMemo(function() {\n            function memoizedSelector(nextSnapshot) {\n                if (!hasMemo) {\n                    hasMemo = !0;\n                    memoizedSnapshot = nextSnapshot;\n                    nextSnapshot = selector(nextSnapshot);\n                    if (void 0 !== isEqual && inst.hasValue) {\n                        var currentSelection = inst.value;\n                        if (isEqual(currentSelection, nextSnapshot)) return memoizedSelection = currentSelection;\n                    }\n                    return memoizedSelection = nextSnapshot;\n                }\n                currentSelection = memoizedSelection;\n                if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;\n                var nextSelection = selector(nextSnapshot);\n                if (void 0 !== isEqual && isEqual(currentSelection, nextSelection)) return memoizedSnapshot = nextSnapshot, currentSelection;\n                memoizedSnapshot = nextSnapshot;\n                return memoizedSelection = nextSelection;\n            }\n            var hasMemo = !1, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;\n            return [\n                function() {\n                    return memoizedSelector(getSnapshot());\n                },\n                null === maybeGetServerSnapshot ? void 0 : function() {\n                    return memoizedSelector(maybeGetServerSnapshot());\n                }\n            ];\n        }, [\n            getSnapshot,\n            getServerSnapshot,\n            selector,\n            isEqual\n        ]);\n        var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);\n        useEffect(function() {\n            inst.hasValue = !0;\n            inst.value = value;\n        }, [\n            value\n        ]);\n        useDebugValue(value);\n        return value;\n    }, \"56MPPqMubdRYjFvuNhAgiSms4oQ=\", false, function() {\n        return [\n            useSyncExternalStore\n        ];\n    });\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && \"function\" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtd2l0aC1zZWxlY3Rvci5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVZO0FBQ2IsS0FYQSxJQVlFOztJQUNFLFNBQVNBLEdBQUdDLENBQUMsRUFBRUMsQ0FBQztRQUNkLE9BQU8sTUFBT0EsS0FBTSxPQUFNRCxLQUFLLElBQUlBLE1BQU0sSUFBSUMsQ0FBQUEsS0FBUUQsTUFBTUEsS0FBS0MsTUFBTUE7SUFDeEU7SUFDQSxnQkFBZ0IsT0FBT0Msa0NBQ3JCLGVBQ0UsT0FBT0EsK0JBQStCQywyQkFBMkIsSUFDbkVELCtCQUErQkMsMkJBQTJCLENBQUNDO0lBQzdELElBQUlDLFFBQVFDLG1CQUFPQSxDQUFDLG1GQUFPLEdBQ3pCQyxXQUFXLGVBQWUsT0FBT0MsT0FBT1QsRUFBRSxHQUFHUyxPQUFPVCxFQUFFLEdBQUdBLElBQ3pEVSx1QkFBdUJKLE1BQU1JLG9CQUFvQixFQUNqREMsU0FBU0wsTUFBTUssTUFBTSxFQUNyQkMsWUFBWU4sTUFBTU0sU0FBUyxFQUMzQkMsVUFBVVAsTUFBTU8sT0FBTyxFQUN2QkMsZ0JBQWdCUixNQUFNUSxhQUFhO0lBQ3JDQyx3Q0FBd0MsTUFBRyxTQUN6Q0UsU0FBUyxFQUNUQyxXQUFXLEVBQ1hDLGlCQUFpQixFQUNqQkMsUUFBUSxFQUNSQyxPQUFPOztRQUVQLElBQUlDLFVBQVVYLE9BQU87UUFDckIsSUFBSSxTQUFTVyxRQUFRQyxPQUFPLEVBQUU7WUFDNUIsSUFBSUMsT0FBTztnQkFBRUMsVUFBVSxDQUFDO2dCQUFHQyxPQUFPO1lBQUs7WUFDdkNKLFFBQVFDLE9BQU8sR0FBR0M7UUFDcEIsT0FBT0EsT0FBT0YsUUFBUUMsT0FBTztRQUM3QkQsVUFBVVQsUUFDUjtZQUNFLFNBQVNjLGlCQUFpQkMsWUFBWTtnQkFDcEMsSUFBSSxDQUFDQyxTQUFTO29CQUNaQSxVQUFVLENBQUM7b0JBQ1hDLG1CQUFtQkY7b0JBQ25CQSxlQUFlUixTQUFTUTtvQkFDeEIsSUFBSSxLQUFLLE1BQU1QLFdBQVdHLEtBQUtDLFFBQVEsRUFBRTt3QkFDdkMsSUFBSU0sbUJBQW1CUCxLQUFLRSxLQUFLO3dCQUNqQyxJQUFJTCxRQUFRVSxrQkFBa0JILGVBQzVCLE9BQVFJLG9CQUFvQkQ7b0JBQ2hDO29CQUNBLE9BQVFDLG9CQUFvQko7Z0JBQzlCO2dCQUNBRyxtQkFBbUJDO2dCQUNuQixJQUFJeEIsU0FBU3NCLGtCQUFrQkYsZUFDN0IsT0FBT0c7Z0JBQ1QsSUFBSUUsZ0JBQWdCYixTQUFTUTtnQkFDN0IsSUFBSSxLQUFLLE1BQU1QLFdBQVdBLFFBQVFVLGtCQUFrQkUsZ0JBQ2xELE9BQU8sbUJBQW9CTCxjQUFlRztnQkFDNUNELG1CQUFtQkY7Z0JBQ25CLE9BQVFJLG9CQUFvQkM7WUFDOUI7WUFDQSxJQUFJSixVQUFVLENBQUMsR0FDYkMsa0JBQ0FFLG1CQUNBRSx5QkFDRSxLQUFLLE1BQU1mLG9CQUFvQixPQUFPQTtZQUMxQyxPQUFPO2dCQUNMO29CQUNFLE9BQU9RLGlCQUFpQlQ7Z0JBQzFCO2dCQUNBLFNBQVNnQix5QkFDTCxLQUFLLElBQ0w7b0JBQ0UsT0FBT1AsaUJBQWlCTztnQkFDMUI7YUFDTDtRQUNILEdBQ0E7WUFBQ2hCO1lBQWFDO1lBQW1CQztZQUFVQztTQUFRO1FBRXJELElBQUlLLFFBQVFoQixxQkFBcUJPLFdBQVdLLE9BQU8sQ0FBQyxFQUFFLEVBQUVBLE9BQU8sQ0FBQyxFQUFFO1FBQ2xFVixVQUNFO1lBQ0VZLEtBQUtDLFFBQVEsR0FBRyxDQUFDO1lBQ2pCRCxLQUFLRSxLQUFLLEdBQUdBO1FBQ2YsR0FDQTtZQUFDQTtTQUFNO1FBRVRaLGNBQWNZO1FBQ2QsT0FBT0E7SUFDVDs7WUFWY2hCOzs7SUFXZCxnQkFBZ0IsT0FBT1Asa0NBQ3JCLGVBQ0UsT0FBT0EsK0JBQStCZ0MsMEJBQTBCLElBQ2xFaEMsK0JBQStCZ0MsMEJBQTBCLENBQUM5QjtBQUM5RCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvY2pzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXdpdGgtc2VsZWN0b3IuZGV2ZWxvcG1lbnQuanM/MzgyYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiB1c2Utc3luYy1leHRlcm5hbC1zdG9yZS13aXRoLXNlbGVjdG9yLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJlxuICAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgICAgIHJldHVybiAoeCA9PT0geSAmJiAoMCAhPT0geCB8fCAxIC8geCA9PT0gMSAvIHkpKSB8fCAoeCAhPT0geCAmJiB5ICE9PSB5KTtcbiAgICB9XG4gICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydCAmJlxuICAgICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydChFcnJvcigpKTtcbiAgICB2YXIgUmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIiksXG4gICAgICBvYmplY3RJcyA9IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIE9iamVjdC5pcyA/IE9iamVjdC5pcyA6IGlzLFxuICAgICAgdXNlU3luY0V4dGVybmFsU3RvcmUgPSBSZWFjdC51c2VTeW5jRXh0ZXJuYWxTdG9yZSxcbiAgICAgIHVzZVJlZiA9IFJlYWN0LnVzZVJlZixcbiAgICAgIHVzZUVmZmVjdCA9IFJlYWN0LnVzZUVmZmVjdCxcbiAgICAgIHVzZU1lbW8gPSBSZWFjdC51c2VNZW1vLFxuICAgICAgdXNlRGVidWdWYWx1ZSA9IFJlYWN0LnVzZURlYnVnVmFsdWU7XG4gICAgZXhwb3J0cy51c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvciA9IGZ1bmN0aW9uIChcbiAgICAgIHN1YnNjcmliZSxcbiAgICAgIGdldFNuYXBzaG90LFxuICAgICAgZ2V0U2VydmVyU25hcHNob3QsXG4gICAgICBzZWxlY3RvcixcbiAgICAgIGlzRXF1YWxcbiAgICApIHtcbiAgICAgIHZhciBpbnN0UmVmID0gdXNlUmVmKG51bGwpO1xuICAgICAgaWYgKG51bGwgPT09IGluc3RSZWYuY3VycmVudCkge1xuICAgICAgICB2YXIgaW5zdCA9IHsgaGFzVmFsdWU6ICExLCB2YWx1ZTogbnVsbCB9O1xuICAgICAgICBpbnN0UmVmLmN1cnJlbnQgPSBpbnN0O1xuICAgICAgfSBlbHNlIGluc3QgPSBpbnN0UmVmLmN1cnJlbnQ7XG4gICAgICBpbnN0UmVmID0gdXNlTWVtbyhcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGZ1bmN0aW9uIG1lbW9pemVkU2VsZWN0b3IobmV4dFNuYXBzaG90KSB7XG4gICAgICAgICAgICBpZiAoIWhhc01lbW8pIHtcbiAgICAgICAgICAgICAgaGFzTWVtbyA9ICEwO1xuICAgICAgICAgICAgICBtZW1vaXplZFNuYXBzaG90ID0gbmV4dFNuYXBzaG90O1xuICAgICAgICAgICAgICBuZXh0U25hcHNob3QgPSBzZWxlY3RvcihuZXh0U25hcHNob3QpO1xuICAgICAgICAgICAgICBpZiAodm9pZCAwICE9PSBpc0VxdWFsICYmIGluc3QuaGFzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IGluc3QudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGlzRXF1YWwoY3VycmVudFNlbGVjdGlvbiwgbmV4dFNuYXBzaG90KSlcbiAgICAgICAgICAgICAgICAgIHJldHVybiAobWVtb2l6ZWRTZWxlY3Rpb24gPSBjdXJyZW50U2VsZWN0aW9uKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gKG1lbW9pemVkU2VsZWN0aW9uID0gbmV4dFNuYXBzaG90KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRTZWxlY3Rpb24gPSBtZW1vaXplZFNlbGVjdGlvbjtcbiAgICAgICAgICAgIGlmIChvYmplY3RJcyhtZW1vaXplZFNuYXBzaG90LCBuZXh0U25hcHNob3QpKVxuICAgICAgICAgICAgICByZXR1cm4gY3VycmVudFNlbGVjdGlvbjtcbiAgICAgICAgICAgIHZhciBuZXh0U2VsZWN0aW9uID0gc2VsZWN0b3IobmV4dFNuYXBzaG90KTtcbiAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGlzRXF1YWwgJiYgaXNFcXVhbChjdXJyZW50U2VsZWN0aW9uLCBuZXh0U2VsZWN0aW9uKSlcbiAgICAgICAgICAgICAgcmV0dXJuIChtZW1vaXplZFNuYXBzaG90ID0gbmV4dFNuYXBzaG90KSwgY3VycmVudFNlbGVjdGlvbjtcbiAgICAgICAgICAgIG1lbW9pemVkU25hcHNob3QgPSBuZXh0U25hcHNob3Q7XG4gICAgICAgICAgICByZXR1cm4gKG1lbW9pemVkU2VsZWN0aW9uID0gbmV4dFNlbGVjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBoYXNNZW1vID0gITEsXG4gICAgICAgICAgICBtZW1vaXplZFNuYXBzaG90LFxuICAgICAgICAgICAgbWVtb2l6ZWRTZWxlY3Rpb24sXG4gICAgICAgICAgICBtYXliZUdldFNlcnZlclNuYXBzaG90ID1cbiAgICAgICAgICAgICAgdm9pZCAwID09PSBnZXRTZXJ2ZXJTbmFwc2hvdCA/IG51bGwgOiBnZXRTZXJ2ZXJTbmFwc2hvdDtcbiAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gbWVtb2l6ZWRTZWxlY3RvcihnZXRTbmFwc2hvdCgpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBudWxsID09PSBtYXliZUdldFNlcnZlclNuYXBzaG90XG4gICAgICAgICAgICAgID8gdm9pZCAwXG4gICAgICAgICAgICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lbW9pemVkU2VsZWN0b3IobWF5YmVHZXRTZXJ2ZXJTbmFwc2hvdCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgXTtcbiAgICAgICAgfSxcbiAgICAgICAgW2dldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCwgc2VsZWN0b3IsIGlzRXF1YWxdXG4gICAgICApO1xuICAgICAgdmFyIHZhbHVlID0gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBpbnN0UmVmWzBdLCBpbnN0UmVmWzFdKTtcbiAgICAgIHVzZUVmZmVjdChcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGluc3QuaGFzVmFsdWUgPSAhMDtcbiAgICAgICAgICBpbnN0LnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIFt2YWx1ZV1cbiAgICAgICk7XG4gICAgICB1c2VEZWJ1Z1ZhbHVlKHZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gJiZcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcCAmJlxuICAgICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wKEVycm9yKCkpO1xuICB9KSgpO1xuIl0sIm5hbWVzIjpbImlzIiwieCIsInkiLCJfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJyZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQiLCJFcnJvciIsIlJlYWN0IiwicmVxdWlyZSIsIm9iamVjdElzIiwiT2JqZWN0IiwidXNlU3luY0V4dGVybmFsU3RvcmUiLCJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJ1c2VNZW1vIiwidXNlRGVidWdWYWx1ZSIsImV4cG9ydHMiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvciIsInN1YnNjcmliZSIsImdldFNuYXBzaG90IiwiZ2V0U2VydmVyU25hcHNob3QiLCJzZWxlY3RvciIsImlzRXF1YWwiLCJpbnN0UmVmIiwiY3VycmVudCIsImluc3QiLCJoYXNWYWx1ZSIsInZhbHVlIiwibWVtb2l6ZWRTZWxlY3RvciIsIm5leHRTbmFwc2hvdCIsImhhc01lbW8iLCJtZW1vaXplZFNuYXBzaG90IiwiY3VycmVudFNlbGVjdGlvbiIsIm1lbW9pemVkU2VsZWN0aW9uIiwibmV4dFNlbGVjdGlvbiIsIm1heWJlR2V0U2VydmVyU25hcHNob3QiLCJyZWdpc3RlckludGVybmFsTW9kdWxlU3RvcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/use-sync-external-store/with-selector.js":
/*!***************************************************************!*\
  !*** ./node_modules/use-sync-external-store/with-selector.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/use-sync-external-store-with-selector.development.js */ \"(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS93aXRoLXNlbGVjdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsS0FBeUIsRUFBYyxFQUUxQyxNQUFNO0lBQ0xDLDZOQUF5QjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvd2l0aC1zZWxlY3Rvci5qcz83ZWNkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS13aXRoLXNlbGVjdG9yLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtd2l0aC1zZWxlY3Rvci5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/use-sync-external-store/with-selector.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/common/social/Social.jsx":
/*!*********************************************!*\
  !*** ./components/common/social/Social.jsx ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n\nconst Social = ()=>{\n    const socialContent = [\n        {\n            id: 1,\n            icon: \"icon-facebook\",\n            link: \"https://facebok.com/\"\n        },\n        {\n            id: 2,\n            icon: \"icon-twitter\",\n            link: \"https://twitter.com/\"\n        },\n        {\n            id: 3,\n            icon: \"icon-instagram\",\n            link: \"https://instagram.com/\"\n        },\n        {\n            id: 4,\n            icon: \"icon-linkedin\",\n            link: \"https://linkedin.com/\"\n        }\n    ];\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: socialContent.map((item)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                href: item.link,\n                target: \"_blank\",\n                rel: \"noopener noreferrer\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"i\", {\n                    className: \"\".concat(item.icon, \" text-14\")\n                }, void 0, false, {\n                    fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/common/social/Social.jsx\",\n                    lineNumber: 17,\n                    columnNumber: 11\n                }, undefined)\n            }, item.id, false, {\n                fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/common/social/Social.jsx\",\n                lineNumber: 11,\n                columnNumber: 9\n            }, undefined))\n    }, void 0, false);\n};\n_c = Social;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Social);\nvar _c;\n$RefreshReg$(_c, \"Social\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvY29tbW9uL3NvY2lhbC9Tb2NpYWwuanN4IiwibWFwcGluZ3MiOiI7OztBQUFBLE1BQU1BLFNBQVM7SUFDYixNQUFNQyxnQkFBZ0I7UUFDcEI7WUFBRUMsSUFBSTtZQUFHQyxNQUFNO1lBQWlCQyxNQUFNO1FBQXVCO1FBQzdEO1lBQUVGLElBQUk7WUFBR0MsTUFBTTtZQUFnQkMsTUFBTTtRQUF1QjtRQUM1RDtZQUFFRixJQUFJO1lBQUdDLE1BQU07WUFBa0JDLE1BQU07UUFBeUI7UUFDaEU7WUFBRUYsSUFBSTtZQUFHQyxNQUFNO1lBQWlCQyxNQUFNO1FBQXdCO0tBQy9EO0lBQ0QscUJBQ0U7a0JBQ0dILGNBQWNJLEdBQUcsQ0FBQyxDQUFDQyxxQkFDbEIsOERBQUNDO2dCQUNDQyxNQUFNRixLQUFLRixJQUFJO2dCQUNmSyxRQUFPO2dCQUNQQyxLQUFJOzBCQUdKLDRFQUFDQztvQkFBRUMsV0FBVyxHQUFhLE9BQVZOLEtBQUtILElBQUksRUFBQzs7Ozs7O2VBRnRCRyxLQUFLSixFQUFFOzs7Ozs7QUFPdEI7S0FyQk1GO0FBdUJOLCtEQUFlQSxNQUFNQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvY29tbW9uL3NvY2lhbC9Tb2NpYWwuanN4PzMwNTEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgU29jaWFsID0gKCkgPT4ge1xuICBjb25zdCBzb2NpYWxDb250ZW50ID0gW1xuICAgIHsgaWQ6IDEsIGljb246IFwiaWNvbi1mYWNlYm9va1wiLCBsaW5rOiBcImh0dHBzOi8vZmFjZWJvay5jb20vXCIgfSxcbiAgICB7IGlkOiAyLCBpY29uOiBcImljb24tdHdpdHRlclwiLCBsaW5rOiBcImh0dHBzOi8vdHdpdHRlci5jb20vXCIgfSxcbiAgICB7IGlkOiAzLCBpY29uOiBcImljb24taW5zdGFncmFtXCIsIGxpbms6IFwiaHR0cHM6Ly9pbnN0YWdyYW0uY29tL1wiIH0sXG4gICAgeyBpZDogNCwgaWNvbjogXCJpY29uLWxpbmtlZGluXCIsIGxpbms6IFwiaHR0cHM6Ly9saW5rZWRpbi5jb20vXCIgfSxcbiAgXTtcbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAge3NvY2lhbENvbnRlbnQubWFwKChpdGVtKSA9PiAoXG4gICAgICAgIDxhXG4gICAgICAgICAgaHJlZj17aXRlbS5saW5rfVxuICAgICAgICAgIHRhcmdldD1cIl9ibGFua1wiXG4gICAgICAgICAgcmVsPVwibm9vcGVuZXIgbm9yZWZlcnJlclwiXG4gICAgICAgICAga2V5PXtpdGVtLmlkfVxuICAgICAgICA+XG4gICAgICAgICAgPGkgY2xhc3NOYW1lPXtgJHtpdGVtLmljb259IHRleHQtMTRgfSAvPlxuICAgICAgICA8L2E+XG4gICAgICApKX1cbiAgICA8Lz5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFNvY2lhbDtcbiJdLCJuYW1lcyI6WyJTb2NpYWwiLCJzb2NpYWxDb250ZW50IiwiaWQiLCJpY29uIiwibGluayIsIm1hcCIsIml0ZW0iLCJhIiwiaHJlZiIsInRhcmdldCIsInJlbCIsImkiLCJjbGFzc05hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/common/social/Social.jsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/header/ContactInfo.jsx":
/*!*******************************************!*\
  !*** ./components/header/ContactInfo.jsx ***!
  \*******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n\nconst ContactInfo = ()=>{\n    const contactContent = [\n        {\n            id: 1,\n            title: \"Toll Free Customer Care\",\n            action: \"tel:+(1) 123 456 7890\",\n            text: \"+(1) 123 456 7890\"\n        },\n        {\n            id: 2,\n            title: \"Need live support?\",\n            action: \"mailto:xyz@abc.com\",\n            text: \"hi@gotrip.com\"\n        }\n    ];\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: contactContent.map((item)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"mb-20\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"text-14\",\n                        children: item.title\n                    }, void 0, false, {\n                        fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/ContactInfo.jsx\",\n                        lineNumber: 20,\n                        columnNumber: 11\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                        href: item.action,\n                        className: \"text-18 fw-500 text-dark-1 mt-5\",\n                        children: item.text\n                    }, void 0, false, {\n                        fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/ContactInfo.jsx\",\n                        lineNumber: 21,\n                        columnNumber: 11\n                    }, undefined)\n                ]\n            }, item.id, true, {\n                fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/ContactInfo.jsx\",\n                lineNumber: 19,\n                columnNumber: 9\n            }, undefined))\n    }, void 0, false);\n};\n_c = ContactInfo;\n/* harmony default export */ __webpack_exports__[\"default\"] = (ContactInfo);\nvar _c;\n$RefreshReg$(_c, \"ContactInfo\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvaGVhZGVyL0NvbnRhY3RJbmZvLmpzeCIsIm1hcHBpbmdzIjoiOzs7QUFBQSxNQUFNQSxjQUFjO0lBQ2xCLE1BQU1DLGlCQUFpQjtRQUNyQjtZQUNFQyxJQUFJO1lBQ0pDLE9BQU87WUFDUEMsUUFBUTtZQUNSQyxNQUFNO1FBQ1I7UUFDQTtZQUNFSCxJQUFJO1lBQ0pDLE9BQU87WUFDUEMsUUFBUTtZQUNSQyxNQUFNO1FBQ1I7S0FDRDtJQUNELHFCQUNFO2tCQUNHSixlQUFlSyxHQUFHLENBQUMsQ0FBQ0MscUJBQ25CLDhEQUFDQztnQkFBSUMsV0FBVTs7a0NBQ2IsOERBQUNEO3dCQUFJQyxXQUFXO2tDQUFZRixLQUFLSixLQUFLOzs7Ozs7a0NBQ3RDLDhEQUFDTzt3QkFBRUMsTUFBTUosS0FBS0gsTUFBTTt3QkFBRUssV0FBVTtrQ0FDN0JGLEtBQUtGLElBQUk7Ozs7Ozs7ZUFIY0UsS0FBS0wsRUFBRTs7Ozs7O0FBUzNDO0tBM0JNRjtBQTZCTiwrREFBZUEsV0FBV0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL2hlYWRlci9Db250YWN0SW5mby5qc3g/YWMxMSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBDb250YWN0SW5mbyA9ICgpID0+IHtcbiAgY29uc3QgY29udGFjdENvbnRlbnQgPSBbXG4gICAge1xuICAgICAgaWQ6IDEsXG4gICAgICB0aXRsZTogXCJUb2xsIEZyZWUgQ3VzdG9tZXIgQ2FyZVwiLFxuICAgICAgYWN0aW9uOiBcInRlbDorKDEpIDEyMyA0NTYgNzg5MFwiLFxuICAgICAgdGV4dDogXCIrKDEpIDEyMyA0NTYgNzg5MFwiLFxuICAgIH0sXG4gICAge1xuICAgICAgaWQ6IDIsXG4gICAgICB0aXRsZTogXCJOZWVkIGxpdmUgc3VwcG9ydD9cIixcbiAgICAgIGFjdGlvbjogXCJtYWlsdG86eHl6QGFiYy5jb21cIixcbiAgICAgIHRleHQ6IFwiaGlAZ290cmlwLmNvbVwiLFxuICAgIH0sXG4gIF07XG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIHtjb250YWN0Q29udGVudC5tYXAoKGl0ZW0pID0+IChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYi0yMFwiIGtleT17aXRlbS5pZH0+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e1widGV4dC0xNFwifT57aXRlbS50aXRsZX08L2Rpdj5cbiAgICAgICAgICA8YSBocmVmPXtpdGVtLmFjdGlvbn0gY2xhc3NOYW1lPVwidGV4dC0xOCBmdy01MDAgdGV4dC1kYXJrLTEgbXQtNVwiPlxuICAgICAgICAgICAge2l0ZW0udGV4dH1cbiAgICAgICAgICA8L2E+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKSl9XG4gICAgPC8+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBDb250YWN0SW5mbztcbiJdLCJuYW1lcyI6WyJDb250YWN0SW5mbyIsImNvbnRhY3RDb250ZW50IiwiaWQiLCJ0aXRsZSIsImFjdGlvbiIsInRleHQiLCJtYXAiLCJpdGVtIiwiZGl2IiwiY2xhc3NOYW1lIiwiYSIsImhyZWYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/header/ContactInfo.jsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/header/MainMenu.jsx":
/*!****************************************!*\
  !*** ./components/header/MainMenu.jsx ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/link */ \"(app-pages-browser)/./node_modules/next/dist/api/link.js\");\n/* harmony import */ var _data_mainMenuData__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../data/mainMenuData */ \"(app-pages-browser)/./data/mainMenuData.js\");\n/* harmony import */ var _utils_linkActiveChecker__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/linkActiveChecker */ \"(app-pages-browser)/./utils/linkActiveChecker.js\");\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_5__);\n\nvar _s = $RefreshSig$();\n\n\n\n\n\nconst MainMenu = (param)=>{\n    let { style = \"\" } = param;\n    _s();\n    const pathname = (0,next_navigation__WEBPACK_IMPORTED_MODULE_4__.usePathname)();\n    const [isActiveParent, setIsActiveParent] = (0,react__WEBPACK_IMPORTED_MODULE_5__.useState)(false);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"nav\", {\n        className: \"menu js-navList\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n            className: \"menu__nav \".concat(style, \" -is-active\"),\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                    className: pathname === \"/home_10\" ? \"current\" : \"\",\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n                        href: \"/home_10\",\n                        children: \"Home\"\n                    }, void 0, false, {\n                        fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/MainMenu.jsx\",\n                        lineNumber: 28,\n                        columnNumber: 11\n                    }, undefined)\n                }, void 0, false, {\n                    fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/MainMenu.jsx\",\n                    lineNumber: 27,\n                    columnNumber: 9\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                    className: pathname === \"/flight-list-v1\" ? \"current\" : \"\",\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n                        href: \"/flight-list-v1\",\n                        children: \"Flight List\"\n                    }, void 0, false, {\n                        fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/MainMenu.jsx\",\n                        lineNumber: 33,\n                        columnNumber: 11\n                    }, undefined)\n                }, void 0, false, {\n                    fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/MainMenu.jsx\",\n                    lineNumber: 32,\n                    columnNumber: 9\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                    className: \"\".concat((0,_utils_linkActiveChecker__WEBPACK_IMPORTED_MODULE_3__.isActiveParentChaild)(_data_mainMenuData__WEBPACK_IMPORTED_MODULE_2__.pageItems, pathname) ? \"current\" : \"\", \" menu-item-has-children\"),\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                            href: \"#\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: \"mr-10\",\n                                    children: \"Pages\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/MainMenu.jsx\",\n                                    lineNumber: 42,\n                                    columnNumber: 13\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"i\", {\n                                    className: \"icon icon-chevron-sm-down\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/MainMenu.jsx\",\n                                    lineNumber: 43,\n                                    columnNumber: 13\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/MainMenu.jsx\",\n                            lineNumber: 41,\n                            columnNumber: 11\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                            className: \"subnav\",\n                            children: _data_mainMenuData__WEBPACK_IMPORTED_MODULE_2__.pageItems.map((menu, i)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                    className: (0,_utils_linkActiveChecker__WEBPACK_IMPORTED_MODULE_3__.isActiveLink)(menu.routePath, pathname) ? \"current\" : \"\",\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n                                        href: menu.routePath,\n                                        children: menu.name\n                                    }, void 0, false, {\n                                        fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/MainMenu.jsx\",\n                                        lineNumber: 53,\n                                        columnNumber: 17\n                                    }, undefined)\n                                }, i, false, {\n                                    fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/MainMenu.jsx\",\n                                    lineNumber: 47,\n                                    columnNumber: 15\n                                }, undefined))\n                        }, void 0, false, {\n                            fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/MainMenu.jsx\",\n                            lineNumber: 45,\n                            columnNumber: 11\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/MainMenu.jsx\",\n                    lineNumber: 36,\n                    columnNumber: 9\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                    className: \"\".concat(pathname.split(\"/\")[1] == \"dashboard\" || pathname.split(\"/\")[1] == \"vendor-dashboard\" ? \"current\" : \"\", \" menu-item-has-children\"),\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                            href: \"#\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: \"mr-10\",\n                                    children: \"Dashboard\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/MainMenu.jsx\",\n                                    lineNumber: 66,\n                                    columnNumber: 13\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"i\", {\n                                    className: \"icon icon-chevron-sm-down\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/MainMenu.jsx\",\n                                    lineNumber: 67,\n                                    columnNumber: 13\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/MainMenu.jsx\",\n                            lineNumber: 65,\n                            columnNumber: 11\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                            className: \"subnav \",\n                            children: _data_mainMenuData__WEBPACK_IMPORTED_MODULE_2__.dashboardItems.map((menu, i)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                    className: (0,_utils_linkActiveChecker__WEBPACK_IMPORTED_MODULE_3__.isActiveLink)(menu.routePath, pathname) ? \"current\" : \"\",\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n                                        href: menu.routePath,\n                                        children: menu.name\n                                    }, void 0, false, {\n                                        fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/MainMenu.jsx\",\n                                        lineNumber: 78,\n                                        columnNumber: 17\n                                    }, undefined)\n                                }, i, false, {\n                                    fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/MainMenu.jsx\",\n                                    lineNumber: 72,\n                                    columnNumber: 15\n                                }, undefined))\n                        }, void 0, false, {\n                            fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/MainMenu.jsx\",\n                            lineNumber: 70,\n                            columnNumber: 11\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/MainMenu.jsx\",\n                    lineNumber: 60,\n                    columnNumber: 9\n                }, undefined)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/MainMenu.jsx\",\n            lineNumber: 22,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/MainMenu.jsx\",\n        lineNumber: 21,\n        columnNumber: 5\n    }, undefined);\n};\n_s(MainMenu, \"bgot8xMcWOc+gSvVdyDuRDXw7p0=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_4__.usePathname\n    ];\n});\n_c = MainMenu;\n/* harmony default export */ __webpack_exports__[\"default\"] = (MainMenu);\nvar _c;\n$RefreshReg$(_c, \"MainMenu\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvaGVhZGVyL01haW5NZW51LmpzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQTZCO0FBS0k7QUFLTTtBQUVPO0FBQ2I7QUFFakMsTUFBTVEsV0FBVztRQUFDLEVBQUVDLFFBQVEsRUFBRSxFQUFFOztJQUM5QixNQUFNQyxXQUFXSiw0REFBV0E7SUFDNUIsTUFBTSxDQUFDSCxnQkFBZ0JRLGtCQUFrQixHQUFHSiwrQ0FBUUEsQ0FBQztJQUVyRCxxQkFDRSw4REFBQ0s7UUFBSUMsV0FBVTtrQkFDYiw0RUFBQ0M7WUFBR0QsV0FBVyxhQUFtQixPQUFOSixPQUFNOzs4QkFLaEMsOERBQUNNO29CQUFHRixXQUFXSCxhQUFhLGFBQWEsWUFBWTs4QkFDbkQsNEVBQUNWLGlEQUFJQTt3QkFBQ2dCLE1BQUs7a0NBQVc7Ozs7Ozs7Ozs7OzhCQUl4Qiw4REFBQ0Q7b0JBQUdGLFdBQVdILGFBQWEsb0JBQW9CLFlBQVk7OEJBQzFELDRFQUFDVixpREFBSUE7d0JBQUNnQixNQUFLO2tDQUFrQjs7Ozs7Ozs7Ozs7OEJBRy9CLDhEQUFDRDtvQkFDQ0YsV0FBVyxHQUVWLE9BRENSLDhFQUFvQkEsQ0FBQ0oseURBQVNBLEVBQUVTLFlBQVksWUFBWSxJQUN6RDs7c0NBRUQsOERBQUNPOzRCQUFFRCxNQUFLOzs4Q0FDTiw4REFBQ0U7b0NBQUtMLFdBQVU7OENBQVE7Ozs7Ozs4Q0FDeEIsOERBQUNNO29DQUFFTixXQUFVOzs7Ozs7Ozs7Ozs7c0NBRWYsOERBQUNDOzRCQUFHRCxXQUFVO3NDQUNYWix5REFBU0EsQ0FBQ21CLEdBQUcsQ0FBQyxDQUFDQyxNQUFNRixrQkFDcEIsOERBQUNKO29DQUVDRixXQUNFVCxzRUFBWUEsQ0FBQ2lCLEtBQUtDLFNBQVMsRUFBRVosWUFBWSxZQUFZOzhDQUd2RCw0RUFBQ1YsaURBQUlBO3dDQUFDZ0IsTUFBTUssS0FBS0MsU0FBUztrREFBR0QsS0FBS0UsSUFBSTs7Ozs7O21DQUxqQ0o7Ozs7Ozs7Ozs7Ozs7Ozs7OEJBWWIsOERBQUNKO29CQUNDRixXQUFXLEdBRVYsT0FEQ0gsU0FBU2MsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLElBQUksZUFBZ0JkLFNBQVNjLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxJQUFJLHFCQUFxQixZQUFZLElBQ3RHOztzQ0FFRCw4REFBQ1A7NEJBQUVELE1BQUs7OzhDQUNOLDhEQUFDRTtvQ0FBS0wsV0FBVTs4Q0FBUTs7Ozs7OzhDQUN4Qiw4REFBQ007b0NBQUVOLFdBQVU7Ozs7Ozs7Ozs7OztzQ0FHZiw4REFBQ0M7NEJBQUdELFdBQVU7c0NBQ1hYLDhEQUFjQSxDQUFDa0IsR0FBRyxDQUFDLENBQUNDLE1BQU1GLGtCQUN6Qiw4REFBQ0o7b0NBRUNGLFdBQ0VULHNFQUFZQSxDQUFDaUIsS0FBS0MsU0FBUyxFQUFFWixZQUFZLFlBQVk7OENBR3ZELDRFQUFDVixpREFBSUE7d0NBQUNnQixNQUFNSyxLQUFLQyxTQUFTO2tEQUFHRCxLQUFLRSxJQUFJOzs7Ozs7bUNBTGpDSjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZXJCO0dBeEVNWDs7UUFDYUYsd0RBQVdBOzs7S0FEeEJFO0FBMEVOLCtEQUFlQSxRQUFRQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvaGVhZGVyL01haW5NZW51LmpzeD8wMGMzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBMaW5rIGZyb20gXCJuZXh0L2xpbmtcIjtcblxuaW1wb3J0IHtcbiAgcGFnZUl0ZW1zLFxuICBkYXNoYm9hcmRJdGVtcyxcbn0gZnJvbSBcIi4uLy4uL2RhdGEvbWFpbk1lbnVEYXRhXCI7XG5pbXBvcnQge1xuICBpc0FjdGl2ZVBhcmVudCxcbiAgaXNBY3RpdmVMaW5rLFxuICBpc0FjdGl2ZVBhcmVudENoYWlsZCxcbn0gZnJvbSBcIi4uLy4uL3V0aWxzL2xpbmtBY3RpdmVDaGVja2VyXCI7XG5cbmltcG9ydCB7IHVzZVBhdGhuYW1lIH0gZnJvbSBcIm5leHQvbmF2aWdhdGlvblwiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcblxuY29uc3QgTWFpbk1lbnUgPSAoeyBzdHlsZSA9IFwiXCIgfSkgPT4ge1xuICBjb25zdCBwYXRobmFtZSA9IHVzZVBhdGhuYW1lKCk7XG4gIGNvbnN0IFtpc0FjdGl2ZVBhcmVudCwgc2V0SXNBY3RpdmVQYXJlbnRdID0gdXNlU3RhdGUoZmFsc2UpXG5cbiAgcmV0dXJuIChcbiAgICA8bmF2IGNsYXNzTmFtZT1cIm1lbnUganMtbmF2TGlzdFwiPlxuICAgICAgPHVsIGNsYXNzTmFtZT17YG1lbnVfX25hdiAke3N0eWxlfSAtaXMtYWN0aXZlYH0+XG4gICAgICAgIFxuXG5cblxuICAgICAgICA8bGkgY2xhc3NOYW1lPXtwYXRobmFtZSA9PT0gXCIvaG9tZV8xMFwiID8gXCJjdXJyZW50XCIgOiBcIlwifT5cbiAgICAgICAgICA8TGluayBocmVmPVwiL2hvbWVfMTBcIj5Ib21lPC9MaW5rPlxuICAgICAgICA8L2xpPlxuICAgICAgICB7LyogRW5kIERlc3RpbmF0aW5vcyBzaW5nbGUgbWVudSAqL31cblxuICAgICAgICA8bGkgY2xhc3NOYW1lPXtwYXRobmFtZSA9PT0gXCIvZmxpZ2h0LWxpc3QtdjFcIiA/IFwiY3VycmVudFwiIDogXCJcIn0+XG4gICAgICAgICAgPExpbmsgaHJlZj1cIi9mbGlnaHQtbGlzdC12MVwiPkZsaWdodCBMaXN0PC9MaW5rPlxuICAgICAgICA8L2xpPlxuXG4gICAgICAgIDxsaVxuICAgICAgICAgIGNsYXNzTmFtZT17YCR7XG4gICAgICAgICAgICBpc0FjdGl2ZVBhcmVudENoYWlsZChwYWdlSXRlbXMsIHBhdGhuYW1lKSA/IFwiY3VycmVudFwiIDogXCJcIlxuICAgICAgICAgIH0gbWVudS1pdGVtLWhhcy1jaGlsZHJlbmB9XG4gICAgICAgID5cbiAgICAgICAgICA8YSBocmVmPVwiI1wiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwibXItMTBcIj5QYWdlczwvc3Bhbj5cbiAgICAgICAgICAgIDxpIGNsYXNzTmFtZT1cImljb24gaWNvbi1jaGV2cm9uLXNtLWRvd25cIiAvPlxuICAgICAgICAgIDwvYT5cbiAgICAgICAgICA8dWwgY2xhc3NOYW1lPVwic3VibmF2XCI+XG4gICAgICAgICAgICB7cGFnZUl0ZW1zLm1hcCgobWVudSwgaSkgPT4gKFxuICAgICAgICAgICAgICA8bGlcbiAgICAgICAgICAgICAgICBrZXk9e2l9XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtcbiAgICAgICAgICAgICAgICAgIGlzQWN0aXZlTGluayhtZW51LnJvdXRlUGF0aCwgcGF0aG5hbWUpID8gXCJjdXJyZW50XCIgOiBcIlwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPExpbmsgaHJlZj17bWVudS5yb3V0ZVBhdGh9PnttZW51Lm5hbWV9PC9MaW5rPlxuICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgKSl9XG4gICAgICAgICAgPC91bD5cbiAgICAgICAgPC9saT5cbiAgICAgICAgey8qIEVuZCBwYWdlcyBpdGVtcyAqL31cblxuICAgICAgICA8bGlcbiAgICAgICAgICBjbGFzc05hbWU9e2Ake1xuICAgICAgICAgICAgcGF0aG5hbWUuc3BsaXQoJy8nKVsxXSA9PSAnZGFzaGJvYXJkJyAgfHwgcGF0aG5hbWUuc3BsaXQoJy8nKVsxXSA9PSAndmVuZG9yLWRhc2hib2FyZCcgPyBcImN1cnJlbnRcIiA6IFwiXCJcbiAgICAgICAgICB9IG1lbnUtaXRlbS1oYXMtY2hpbGRyZW5gfVxuICAgICAgICA+XG4gICAgICAgICAgPGEgaHJlZj1cIiNcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cIm1yLTEwXCI+RGFzaGJvYXJkPC9zcGFuPlxuICAgICAgICAgICAgPGkgY2xhc3NOYW1lPVwiaWNvbiBpY29uLWNoZXZyb24tc20tZG93blwiIC8+XG4gICAgICAgICAgXG4gICAgICAgICAgPC9hPlxuICAgICAgICAgIDx1bCBjbGFzc05hbWU9XCJzdWJuYXYgXCI+XG4gICAgICAgICAgICB7ZGFzaGJvYXJkSXRlbXMubWFwKChtZW51LCBpKSA9PiAoXG4gICAgICAgICAgICAgIDxsaVxuICAgICAgICAgICAgICAgIGtleT17aX1cbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e1xuICAgICAgICAgICAgICAgICAgaXNBY3RpdmVMaW5rKG1lbnUucm91dGVQYXRoLCBwYXRobmFtZSkgPyBcImN1cnJlbnRcIiA6IFwiXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8TGluayBocmVmPXttZW51LnJvdXRlUGF0aH0+e21lbnUubmFtZX08L0xpbms+XG4gICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICApKX1cbiAgICAgICAgICA8L3VsPlxuICAgICAgICA8L2xpPlxuXG4gICAgICAgXG4gICAgICA8L3VsPlxuICAgIDwvbmF2PlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgTWFpbk1lbnU7XG4iXSwibmFtZXMiOlsiTGluayIsInBhZ2VJdGVtcyIsImRhc2hib2FyZEl0ZW1zIiwiaXNBY3RpdmVQYXJlbnQiLCJpc0FjdGl2ZUxpbmsiLCJpc0FjdGl2ZVBhcmVudENoYWlsZCIsInVzZVBhdGhuYW1lIiwidXNlU3RhdGUiLCJNYWluTWVudSIsInN0eWxlIiwicGF0aG5hbWUiLCJzZXRJc0FjdGl2ZVBhcmVudCIsIm5hdiIsImNsYXNzTmFtZSIsInVsIiwibGkiLCJocmVmIiwiYSIsInNwYW4iLCJpIiwibWFwIiwibWVudSIsInJvdXRlUGF0aCIsIm5hbWUiLCJzcGxpdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/header/MainMenu.jsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/header/MobileMenu.jsx":
/*!******************************************!*\
  !*** ./components/header/MobileMenu.jsx ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/link */ \"(app-pages-browser)/./node_modules/next/dist/api/link.js\");\n/* harmony import */ var react_pro_sidebar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-pro-sidebar */ \"(app-pages-browser)/./node_modules/react-pro-sidebar/dist/index.es.js\");\n/* harmony import */ var _data_mainMenuData__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../data/mainMenuData */ \"(app-pages-browser)/./data/mainMenuData.js\");\n/* harmony import */ var _utils_linkActiveChecker__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/linkActiveChecker */ \"(app-pages-browser)/./utils/linkActiveChecker.js\");\n/* harmony import */ var _common_social_Social__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/social/Social */ \"(app-pages-browser)/./components/common/social/Social.jsx\");\n/* harmony import */ var _ContactInfo__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ContactInfo */ \"(app-pages-browser)/./components/header/ContactInfo.jsx\");\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_8__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\nconst MobileMenu = ()=>{\n    _s();\n    const pathname = (0,next_navigation__WEBPACK_IMPORTED_MODULE_7__.usePathname)();\n    const [isActiveParent, setIsActiveParent] = (0,react__WEBPACK_IMPORTED_MODULE_8__.useState)(false);\n    const [isActiveNestedParentTwo, setisActiveNestedParentTwo] = (0,react__WEBPACK_IMPORTED_MODULE_8__.useState)(false);\n    const [isActiveNestedParent, setisActiveNestedParent] = (0,react__WEBPACK_IMPORTED_MODULE_8__.useState)(false);\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_7__.useRouter)();\n    (0,react__WEBPACK_IMPORTED_MODULE_8__.useEffect)(()=>{}, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"pro-header d-flex align-items-center justify-between border-bottom-light\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n                        href: \"/\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                            src: \"/img/general/logo-dark.svg\",\n                            alt: \"brand\"\n                        }, void 0, false, {\n                            fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/MobileMenu.jsx\",\n                            lineNumber: 50,\n                            columnNumber: 11\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/MobileMenu.jsx\",\n                        lineNumber: 49,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"fix-icon\",\n                        \"data-bs-dismiss\": \"offcanvas\",\n                        \"aria-label\": \"Close\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"i\", {\n                            className: \"icon icon-close\"\n                        }, void 0, false, {\n                            fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/MobileMenu.jsx\",\n                            lineNumber: 59,\n                            columnNumber: 11\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/MobileMenu.jsx\",\n                        lineNumber: 54,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/MobileMenu.jsx\",\n                lineNumber: 48,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_pro_sidebar__WEBPACK_IMPORTED_MODULE_2__.Sidebar, {\n                width: \"400\",\n                backgroundColor: \"#fff\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_pro_sidebar__WEBPACK_IMPORTED_MODULE_2__.Menu, {\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_pro_sidebar__WEBPACK_IMPORTED_MODULE_2__.MenuItem, {\n                            onClick: ()=>router.push(\"/home_10\"),\n                            className: pathname === \"/home_10\" ? \"menu-active-link\" : \"\",\n                            children: \"Home\"\n                        }, void 0, false, {\n                            fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/MobileMenu.jsx\",\n                            lineNumber: 72,\n                            columnNumber: 13\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_pro_sidebar__WEBPACK_IMPORTED_MODULE_2__.MenuItem, {\n                            onClick: ()=>router.push(\"/flight-list-v1\"),\n                            className: pathname === \"/flight-list-v1\" ? \"menu-active-link\" : \"\",\n                            children: \"Flight List\"\n                        }, void 0, false, {\n                            fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/MobileMenu.jsx\",\n                            lineNumber: 85,\n                            columnNumber: 13\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_pro_sidebar__WEBPACK_IMPORTED_MODULE_2__.SubMenu, {\n                            label: \"Pages\",\n                            className: _data_mainMenuData__WEBPACK_IMPORTED_MODULE_3__.pageItems.some((item)=>{\n                                var _item_routePath;\n                                return ((_item_routePath = item.routePath) === null || _item_routePath === void 0 ? void 0 : _item_routePath.split(\"/\")[1]) == pathname.split(\"/\")[1];\n                            }) ? \"menu-active-link\" : \"\",\n                            children: _data_mainMenuData__WEBPACK_IMPORTED_MODULE_3__.pageItems.map((item, i)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_pro_sidebar__WEBPACK_IMPORTED_MODULE_2__.MenuItem, {\n                                    onClick: ()=>router.push(item.routePath),\n                                    className: (0,_utils_linkActiveChecker__WEBPACK_IMPORTED_MODULE_4__.isActiveLink)(item.routePath, pathname) ? \"menu-active-link\" : \"inactive-menu\",\n                                    children: item.name\n                                }, i, false, {\n                                    fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/MobileMenu.jsx\",\n                                    lineNumber: 99,\n                                    columnNumber: 17\n                                }, undefined))\n                        }, void 0, false, {\n                            fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/MobileMenu.jsx\",\n                            lineNumber: 97,\n                            columnNumber: 13\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_pro_sidebar__WEBPACK_IMPORTED_MODULE_2__.SubMenu, {\n                            label: \"Dashboard\",\n                            className: pathname.split(\"/\")[1] == \"dashboard\" || pathname.split(\"/\")[1] == \"vendor-dashboard\" ? \"menu-active-link\" : \"\",\n                            children: _data_mainMenuData__WEBPACK_IMPORTED_MODULE_3__.dashboardItems.map((item, i)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_pro_sidebar__WEBPACK_IMPORTED_MODULE_2__.MenuItem, {\n                                    onClick: ()=>router.push(item.routePath),\n                                    className: (0,_utils_linkActiveChecker__WEBPACK_IMPORTED_MODULE_4__.isActiveLink)(item.routePath, pathname) ? \"menu-active-link\" : \"inactive-menu\",\n                                    children: item.name\n                                }, i, false, {\n                                    fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/MobileMenu.jsx\",\n                                    lineNumber: 116,\n                                    columnNumber: 17\n                                }, undefined))\n                        }, void 0, false, {\n                            fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/MobileMenu.jsx\",\n                            lineNumber: 114,\n                            columnNumber: 13\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/MobileMenu.jsx\",\n                    lineNumber: 68,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/MobileMenu.jsx\",\n                lineNumber: 66,\n                columnNumber: 9\n            }, undefined)\n        ]\n    }, void 0, true);\n};\n_s(MobileMenu, \"kEA6N3ngdfVGdiPYTEVgPw2BJOQ=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_7__.usePathname,\n        next_navigation__WEBPACK_IMPORTED_MODULE_7__.useRouter\n    ];\n});\n_c = MobileMenu;\n/* harmony default export */ __webpack_exports__[\"default\"] = (MobileMenu);\nvar _c;\n$RefreshReg$(_c, \"MobileMenu\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvaGVhZGVyL01vYmlsZU1lbnUuanN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFFNkI7QUFRRjtBQVFNO0FBSU07QUFDTTtBQUNMO0FBQ2lCO0FBQ2I7QUFFNUMsTUFBTWtCLGFBQWE7O0lBQ2pCLE1BQU1DLFdBQVdMLDREQUFXQTtJQUU1QixNQUFNLENBQUNNLGdCQUFnQkMsa0JBQWtCLEdBQUdKLCtDQUFRQSxDQUFDO0lBQ3JELE1BQU0sQ0FBQ0sseUJBQXlCQywyQkFBMkIsR0FBR04sK0NBQVFBLENBQUM7SUFDdkUsTUFBTSxDQUFDTyxzQkFBc0JDLHdCQUF3QixHQUFHUiwrQ0FBUUEsQ0FBQztJQUVqRSxNQUFNUyxTQUFTWCwwREFBU0E7SUFFdkJDLGdEQUFTQSxDQUFDLEtBTVosR0FBRyxFQUFFO0lBRUoscUJBQ0U7OzBCQUNFLDhEQUFDVztnQkFBSUMsV0FBVTs7a0NBQ2IsOERBQUM1QixpREFBSUE7d0JBQUM2QixNQUFLO2tDQUNULDRFQUFDQzs0QkFBSUMsS0FBSTs0QkFBNkJDLEtBQUk7Ozs7Ozs7Ozs7O2tDQUk1Qyw4REFBQ0w7d0JBQ0NDLFdBQVU7d0JBQ1ZLLG1CQUFnQjt3QkFDaEJDLGNBQVc7a0NBRVgsNEVBQUNDOzRCQUFFUCxXQUFVOzs7Ozs7Ozs7Ozs7Ozs7OzswQkFPZiw4REFBQzNCLHNEQUFPQTtnQkFBQ21DLE9BQU07Z0JBQU1DLGlCQUFnQjswQkFFbkMsNEVBQUNuQyxtREFBSUE7O3NDQUlILDhEQUFDQyx1REFBUUE7NEJBQ1JtQyxTQUFTLElBQUlaLE9BQU9hLElBQUksQ0FBQzs0QkFDekJYLFdBQ0NULGFBQWEsYUFDVCxxQkFDQTtzQ0FHTDs7Ozs7O3NDQUtELDhEQUFDaEIsdURBQVFBOzRCQUNSbUMsU0FBUyxJQUFJWixPQUFPYSxJQUFJLENBQUM7NEJBQ3pCWCxXQUNDVCxhQUFhLG9CQUNULHFCQUNBO3NDQUdMOzs7Ozs7c0NBSUQsOERBQUNmLHNEQUFPQTs0QkFBQ29DLE9BQU07NEJBQVFaLFdBQVlyQix5REFBU0EsQ0FBQ2tDLElBQUksQ0FBRUMsQ0FBQUE7b0NBQU1BO3VDQUFBQSxFQUFBQSxrQkFBQUEsS0FBS0MsU0FBUyxjQUFkRCxzQ0FBQUEsZ0JBQWdCRSxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsS0FBSXpCLFNBQVN5QixLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7aUNBQUsscUJBQW1CO3NDQUNySXJDLHlEQUFTQSxDQUFDc0MsR0FBRyxDQUFDLENBQUNILE1BQU1QLGtCQUNwQiw4REFBQ2hDLHVEQUFRQTtvQ0FFUG1DLFNBQVMsSUFBSVosT0FBT2EsSUFBSSxDQUFDRyxLQUFLQyxTQUFTO29DQUN2Q2YsV0FDRWpCLHNFQUFZQSxDQUFDK0IsS0FBS0MsU0FBUyxFQUFFeEIsWUFDekIscUJBQ0E7OENBR0x1QixLQUFLSSxJQUFJO21DQVJMWDs7Ozs7Ozs7OztzQ0FjWCw4REFBQy9CLHNEQUFPQTs0QkFBQ29DLE9BQU07NEJBQVlaLFdBQVlULFNBQVN5QixLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsSUFBSSxlQUFnQnpCLFNBQVN5QixLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsSUFBSSxxQkFBcUIscUJBQW1CO3NDQUNoSnBDLDhEQUFjQSxDQUFDcUMsR0FBRyxDQUFDLENBQUNILE1BQU1QLGtCQUN6Qiw4REFBQ2hDLHVEQUFRQTtvQ0FFUG1DLFNBQVMsSUFBSVosT0FBT2EsSUFBSSxDQUFDRyxLQUFLQyxTQUFTO29DQUN2Q2YsV0FDRWpCLHNFQUFZQSxDQUFDK0IsS0FBS0MsU0FBUyxFQUFFeEIsWUFDekIscUJBQ0E7OENBR0x1QixLQUFLSSxJQUFJO21DQVJMWDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQnZCO0dBN0dNakI7O1FBQ2FKLHdEQUFXQTtRQU1iQyxzREFBU0E7OztLQVBwQkc7QUFnSE4sK0RBQWVBLFVBQVVBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9oZWFkZXIvTW9iaWxlTWVudS5qc3g/MTE3MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IExpbmsgZnJvbSBcIm5leHQvbGlua1wiO1xuXG5pbXBvcnQge1xuXG4gIFNpZGViYXIsXG4gIE1lbnUsXG4gIE1lbnVJdGVtLFxuICBTdWJNZW51LFxufSBmcm9tIFwicmVhY3QtcHJvLXNpZGViYXJcIjtcbmltcG9ydCB7XG4gIGhvbWVJdGVtcyxcbiAgYmxvZ0l0ZW1zLFxuICBwYWdlSXRlbXMsXG4gIGRhc2hib2FyZEl0ZW1zLFxuICBjYXRlZ29yaWVNb2JpbGVJdGVtcyxcbiAgY2F0ZWdvcmllTWVnYU1lbnVJdGVtcyxcbn0gZnJvbSBcIi4uLy4uL2RhdGEvbWFpbk1lbnVEYXRhXCI7XG5pbXBvcnQge1xuICBpc0FjdGl2ZUxpbmssXG5cbn0gZnJvbSBcIi4uLy4uL3V0aWxzL2xpbmtBY3RpdmVDaGVja2VyXCI7XG5pbXBvcnQgU29jaWFsIGZyb20gXCIuLi9jb21tb24vc29jaWFsL1NvY2lhbFwiO1xuaW1wb3J0IENvbnRhY3RJbmZvIGZyb20gXCIuL0NvbnRhY3RJbmZvXCI7XG5pbXBvcnQgeyB1c2VQYXRobmFtZSwgdXNlUm91dGVyIH0gZnJvbSBcIm5leHQvbmF2aWdhdGlvblwiO1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuXG5jb25zdCBNb2JpbGVNZW51ID0gKCkgPT4ge1xuICBjb25zdCBwYXRobmFtZSA9IHVzZVBhdGhuYW1lKCk7XG5cbiAgY29uc3QgW2lzQWN0aXZlUGFyZW50LCBzZXRJc0FjdGl2ZVBhcmVudF0gPSB1c2VTdGF0ZShmYWxzZSlcbiAgY29uc3QgW2lzQWN0aXZlTmVzdGVkUGFyZW50VHdvLCBzZXRpc0FjdGl2ZU5lc3RlZFBhcmVudFR3b10gPSB1c2VTdGF0ZShmYWxzZSlcbiAgY29uc3QgW2lzQWN0aXZlTmVzdGVkUGFyZW50LCBzZXRpc0FjdGl2ZU5lc3RlZFBhcmVudF0gPSB1c2VTdGF0ZShmYWxzZSlcblxuICBjb25zdCByb3V0ZXIgPSB1c2VSb3V0ZXIoKVxuXG4gICB1c2VFZmZlY3QoKCkgPT4ge1xuXG5cblxuXG4gICBcbiB9LCBbXSlcblxuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInByby1oZWFkZXIgZC1mbGV4IGFsaWduLWl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW4gYm9yZGVyLWJvdHRvbS1saWdodFwiPlxuICAgICAgICA8TGluayBocmVmPVwiL1wiPlxuICAgICAgICAgIDxpbWcgc3JjPVwiL2ltZy9nZW5lcmFsL2xvZ28tZGFyay5zdmdcIiBhbHQ9XCJicmFuZFwiIC8+XG4gICAgICAgIDwvTGluaz5cbiAgICAgICAgey8qIEVuZCBsb2dvICovfVxuXG4gICAgICAgIDxkaXZcbiAgICAgICAgICBjbGFzc05hbWU9XCJmaXgtaWNvblwiXG4gICAgICAgICAgZGF0YS1icy1kaXNtaXNzPVwib2ZmY2FudmFzXCJcbiAgICAgICAgICBhcmlhLWxhYmVsPVwiQ2xvc2VcIlxuICAgICAgICA+XG4gICAgICAgICAgPGkgY2xhc3NOYW1lPVwiaWNvbiBpY29uLWNsb3NlXCI+PC9pPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgey8qIGljb24gY2xvc2UgKi99XG4gICAgICA8L2Rpdj5cbiAgICAgIHsvKiBFbmQgcHJvLWhlYWRlciAqL31cblxuICAgIFxuICAgICAgICA8U2lkZWJhciB3aWR0aD1cIjQwMFwiIGJhY2tncm91bmRDb2xvcj1cIiNmZmZcIj5cblxuICAgICAgICAgIDxNZW51PlxuICAgXG5cblxuICAgICAgICAgICAgPE1lbnVJdGVtXG4gICAgICAgICAgICAgb25DbGljaz17KCk9PnJvdXRlci5wdXNoKFwiL2hvbWVfMTBcIil9XG4gICAgICAgICAgICAgY2xhc3NOYW1lPXtcbiAgICAgICAgICAgICAgcGF0aG5hbWUgPT09IFwiL2hvbWVfMTBcIlxuICAgICAgICAgICAgICAgID8gXCJtZW51LWFjdGl2ZS1saW5rXCJcbiAgICAgICAgICAgICAgICA6IFwiXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIEhvbWVcbiAgICAgICAgICAgIDwvTWVudUl0ZW0+XG4gICAgICAgICAgICB7LyogRW5kICBEZXNpdGluYXRpb25zIE1lbnUgKi99XG5cbiAgICAgICAgICAgIDxNZW51SXRlbVxuICAgICAgICAgICAgIG9uQ2xpY2s9eygpPT5yb3V0ZXIucHVzaChcIi9mbGlnaHQtbGlzdC12MVwiKX1cbiAgICAgICAgICAgICBjbGFzc05hbWU9e1xuICAgICAgICAgICAgICBwYXRobmFtZSA9PT0gXCIvZmxpZ2h0LWxpc3QtdjFcIlxuICAgICAgICAgICAgICAgID8gXCJtZW51LWFjdGl2ZS1saW5rXCJcbiAgICAgICAgICAgICAgICA6IFwiXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIEZsaWdodCBMaXN0XG4gICAgICAgICAgICA8L01lbnVJdGVtPlxuXG4gICAgICAgICAgICA8U3ViTWVudSBsYWJlbD1cIlBhZ2VzXCIgY2xhc3NOYW1lPXsgcGFnZUl0ZW1zLnNvbWUoKGl0ZW09Pml0ZW0ucm91dGVQYXRoPy5zcGxpdCgnLycpWzFdID09IHBhdGhuYW1lLnNwbGl0KCcvJylbMV0pKSA/IFwibWVudS1hY3RpdmUtbGlua1wiOicnfT5cbiAgICAgICAgICAgICAge3BhZ2VJdGVtcy5tYXAoKGl0ZW0sIGkpID0+IChcbiAgICAgICAgICAgICAgICA8TWVudUl0ZW1cbiAgICAgICAgICAgICAgICAgIGtleT17aX1cbiAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpPT5yb3V0ZXIucHVzaChpdGVtLnJvdXRlUGF0aCl9XG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e1xuICAgICAgICAgICAgICAgICAgICBpc0FjdGl2ZUxpbmsoaXRlbS5yb3V0ZVBhdGgsIHBhdGhuYW1lKVxuICAgICAgICAgICAgICAgICAgICAgID8gXCJtZW51LWFjdGl2ZS1saW5rXCJcbiAgICAgICAgICAgICAgICAgICAgICA6IFwiaW5hY3RpdmUtbWVudVwiXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAge2l0ZW0ubmFtZX1cbiAgICAgICAgICAgICAgICA8L01lbnVJdGVtPlxuICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgIDwvU3ViTWVudT5cbiAgICAgICAgICAgIHsvKiBFbmQgIEFsbCBQYWdlcyBNZW51ICovfVxuXG4gICAgICAgICAgICA8U3ViTWVudSBsYWJlbD1cIkRhc2hib2FyZFwiIGNsYXNzTmFtZT17IHBhdGhuYW1lLnNwbGl0KCcvJylbMV0gPT0gJ2Rhc2hib2FyZCcgIHx8IHBhdGhuYW1lLnNwbGl0KCcvJylbMV0gPT0gJ3ZlbmRvci1kYXNoYm9hcmQnID8gXCJtZW51LWFjdGl2ZS1saW5rXCI6Jyd9PlxuICAgICAgICAgICAgICB7ZGFzaGJvYXJkSXRlbXMubWFwKChpdGVtLCBpKSA9PiAoXG4gICAgICAgICAgICAgICAgPE1lbnVJdGVtXG4gICAgICAgICAgICAgICAgICBrZXk9e2l9XG4gICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKT0+cm91dGVyLnB1c2goaXRlbS5yb3V0ZVBhdGgpfVxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtcbiAgICAgICAgICAgICAgICAgICAgaXNBY3RpdmVMaW5rKGl0ZW0ucm91dGVQYXRoLCBwYXRobmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICA/IFwibWVudS1hY3RpdmUtbGlua1wiXG4gICAgICAgICAgICAgICAgICAgICAgOiBcImluYWN0aXZlLW1lbnVcIlxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIHtpdGVtLm5hbWV9XG4gICAgICAgICAgICAgICAgPC9NZW51SXRlbT5cbiAgICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICA8L1N1Yk1lbnU+XG4gICAgICAgICAgICB7LyogRW5kICBBbGwgRGFzaGJvYXJkIE1lbnUgKi99XG5cbiAgICAgICAgICA8L01lbnU+XG4gICAgICAgIDwvU2lkZWJhcj5cblxuXG5cbiAgICA8Lz5cbiAgKTtcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgTW9iaWxlTWVudTtcbiJdLCJuYW1lcyI6WyJMaW5rIiwiU2lkZWJhciIsIk1lbnUiLCJNZW51SXRlbSIsIlN1Yk1lbnUiLCJob21lSXRlbXMiLCJibG9nSXRlbXMiLCJwYWdlSXRlbXMiLCJkYXNoYm9hcmRJdGVtcyIsImNhdGVnb3JpZU1vYmlsZUl0ZW1zIiwiY2F0ZWdvcmllTWVnYU1lbnVJdGVtcyIsImlzQWN0aXZlTGluayIsIlNvY2lhbCIsIkNvbnRhY3RJbmZvIiwidXNlUGF0aG5hbWUiLCJ1c2VSb3V0ZXIiLCJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsIk1vYmlsZU1lbnUiLCJwYXRobmFtZSIsImlzQWN0aXZlUGFyZW50Iiwic2V0SXNBY3RpdmVQYXJlbnQiLCJpc0FjdGl2ZU5lc3RlZFBhcmVudFR3byIsInNldGlzQWN0aXZlTmVzdGVkUGFyZW50VHdvIiwiaXNBY3RpdmVOZXN0ZWRQYXJlbnQiLCJzZXRpc0FjdGl2ZU5lc3RlZFBhcmVudCIsInJvdXRlciIsImRpdiIsImNsYXNzTmFtZSIsImhyZWYiLCJpbWciLCJzcmMiLCJhbHQiLCJkYXRhLWJzLWRpc21pc3MiLCJhcmlhLWxhYmVsIiwiaSIsIndpZHRoIiwiYmFja2dyb3VuZENvbG9yIiwib25DbGljayIsInB1c2giLCJsYWJlbCIsInNvbWUiLCJpdGVtIiwicm91dGVQYXRoIiwic3BsaXQiLCJtYXAiLCJuYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/header/MobileMenu.jsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/header/header-10/index.jsx":
/*!***********************************************!*\
  !*** ./components/header/header-10/index.jsx ***!
  \***********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/link */ \"(app-pages-browser)/./node_modules/next/dist/api/link.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _MainMenu__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../MainMenu */ \"(app-pages-browser)/./components/header/MainMenu.jsx\");\n/* harmony import */ var _MobileMenu__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../MobileMenu */ \"(app-pages-browser)/./components/header/MobileMenu.jsx\");\n/* harmony import */ var js_cookie__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! js-cookie */ \"(app-pages-browser)/./node_modules/js-cookie/dist/js.cookie.mjs\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\nconst Header1 = ()=>{\n    _s();\n    const [navbar, setNavbar] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    const [auth, setAuth] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    const changeBackground = ()=>{\n        if (window.scrollY >= 10) {\n            setNavbar(true);\n        } else {\n            setNavbar(false);\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>{\n        window.addEventListener(\"scroll\", changeBackground);\n        return ()=>{\n            window.removeEventListener(\"scroll\", changeBackground);\n        };\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>{\n        if (js_cookie__WEBPACK_IMPORTED_MODULE_5__[\"default\"].get(\"jwt_token\")) {\n            setAuth(true);\n        }\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            \" \",\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"header\", {\n                className: \"header \".concat(navbar ? \"is-sticky bg-white\" : \"\"),\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"header__container header__container-1500 mx-auto px-30 sm:px-20\",\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"row justify-between items-center\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"col-auto\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"d-flex items-center\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n                                            href: \"/\",\n                                            className: \"header-logo mr-50\",\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                                                    src: \"/img/general/logo-dark-3.svg\",\n                                                    alt: \"logo icon\"\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/header-10/index.jsx\",\n                                                    lineNumber: 42,\n                                                    columnNumber: 19\n                                                }, undefined),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                                                    src: \"/img/general/logo-dark-3.svg\",\n                                                    alt: \"logo icon\"\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/header-10/index.jsx\",\n                                                    lineNumber: 43,\n                                                    columnNumber: 19\n                                                }, undefined)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/header-10/index.jsx\",\n                                            lineNumber: 41,\n                                            columnNumber: 17\n                                        }, undefined),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"header-menu\",\n                                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"header-menu__content\",\n                                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_MainMenu__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                                                    style: \"text-dark-1\"\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/header-10/index.jsx\",\n                                                    lineNumber: 49,\n                                                    columnNumber: 21\n                                                }, undefined)\n                                            }, void 0, false, {\n                                                fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/header-10/index.jsx\",\n                                                lineNumber: 48,\n                                                columnNumber: 19\n                                            }, undefined)\n                                        }, void 0, false, {\n                                            fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/header-10/index.jsx\",\n                                            lineNumber: 47,\n                                            columnNumber: 17\n                                        }, undefined)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/header-10/index.jsx\",\n                                    lineNumber: 40,\n                                    columnNumber: 15\n                                }, undefined)\n                            }, void 0, false, {\n                                fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/header-10/index.jsx\",\n                                lineNumber: 39,\n                                columnNumber: 13\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"col-auto\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"d-flex items-center\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"d-flex items-center is-menu-opened-hide md:d-none\",\n                                            children: !auth && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n                                                href: \"/signup\",\n                                                className: \"button px-30 fw-400 text-14 border-dark-4 -blue-1 h-50 text-dark-4 ml-20\",\n                                                children: \"Sign In / Register\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/header-10/index.jsx\",\n                                                lineNumber: 62,\n                                                columnNumber: 30\n                                            }, undefined)\n                                        }, void 0, false, {\n                                            fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/header-10/index.jsx\",\n                                            lineNumber: 60,\n                                            columnNumber: 17\n                                        }, undefined),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"d-none xl:d-flex x-gap-20 items-center pl-30 text-dark-1\",\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                    children: !auth && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n                                                        href: \"/login\",\n                                                        className: \"d-flex items-center icon-user text-inherit text-22\"\n                                                    }, void 0, false, {\n                                                        fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/header-10/index.jsx\",\n                                                        lineNumber: 74,\n                                                        columnNumber: 32\n                                                    }, undefined)\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/header-10/index.jsx\",\n                                                    lineNumber: 73,\n                                                    columnNumber: 19\n                                                }, undefined),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                    children: [\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                            className: \"d-flex items-center icon-menu text-inherit text-20\",\n                                                            \"data-bs-toggle\": \"offcanvas\",\n                                                            \"aria-controls\": \"mobile-sidebar_menu\",\n                                                            \"data-bs-target\": \"#mobile-sidebar_menu\"\n                                                        }, void 0, false, {\n                                                            fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/header-10/index.jsx\",\n                                                            lineNumber: 81,\n                                                            columnNumber: 21\n                                                        }, undefined),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                            className: \"offcanvas offcanvas-start  mobile_menu-contnet\",\n                                                            tabIndex: \"-1\",\n                                                            id: \"mobile-sidebar_menu\",\n                                                            \"aria-labelledby\": \"offcanvasMenuLabel\",\n                                                            \"data-bs-scroll\": \"true\",\n                                                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_MobileMenu__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {}, void 0, false, {\n                                                                fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/header-10/index.jsx\",\n                                                                lineNumber: 95,\n                                                                columnNumber: 23\n                                                            }, undefined)\n                                                        }, void 0, false, {\n                                                            fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/header-10/index.jsx\",\n                                                            lineNumber: 88,\n                                                            columnNumber: 21\n                                                        }, undefined)\n                                                    ]\n                                                }, void 0, true, {\n                                                    fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/header-10/index.jsx\",\n                                                    lineNumber: 80,\n                                                    columnNumber: 19\n                                                }, undefined)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/header-10/index.jsx\",\n                                            lineNumber: 72,\n                                            columnNumber: 17\n                                        }, undefined)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/header-10/index.jsx\",\n                                    lineNumber: 59,\n                                    columnNumber: 15\n                                }, undefined)\n                            }, void 0, false, {\n                                fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/header-10/index.jsx\",\n                                lineNumber: 58,\n                                columnNumber: 13\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/header-10/index.jsx\",\n                        lineNumber: 38,\n                        columnNumber: 11\n                    }, undefined)\n                }, void 0, false, {\n                    fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/header-10/index.jsx\",\n                    lineNumber: 37,\n                    columnNumber: 9\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/header/header-10/index.jsx\",\n                lineNumber: 36,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true);\n};\n_s(Header1, \"m8lYRyZuGWRFh+r1Agy2bAT4Wpg=\");\n_c = Header1;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Header1);\nvar _c;\n$RefreshReg$(_c, \"Header1\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvaGVhZGVyL2hlYWRlci0xMC9pbmRleC5qc3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUU2QjtBQUNlO0FBQ1Q7QUFDSTtBQUNQO0FBR2hDLE1BQU1NLFVBQVU7O0lBQ2QsTUFBTSxDQUFDQyxRQUFRQyxVQUFVLEdBQUdOLCtDQUFRQSxDQUFDO0lBQ3JDLE1BQU0sQ0FBQ08sTUFBTUMsUUFBUSxHQUFHUiwrQ0FBUUEsQ0FBQztJQUVqQyxNQUFNUyxtQkFBbUI7UUFDdkIsSUFBSUMsT0FBT0MsT0FBTyxJQUFJLElBQUk7WUFDeEJMLFVBQVU7UUFDWixPQUFPO1lBQ0xBLFVBQVU7UUFDWjtJQUNGO0lBRUFQLGdEQUFTQSxDQUFDO1FBQ1JXLE9BQU9FLGdCQUFnQixDQUFDLFVBQVVIO1FBQ2xDLE9BQU87WUFDTEMsT0FBT0csbUJBQW1CLENBQUMsVUFBVUo7UUFDdkM7SUFDRixHQUFHLEVBQUU7SUFFTFYsZ0RBQVNBLENBQUM7UUFDUixJQUFHSSxpREFBT0EsQ0FBQ1csR0FBRyxDQUFDLGNBQWE7WUFBQ04sUUFBUTtRQUFNO0lBQzdDLEdBQUUsRUFBRTtJQUVKLHFCQUNFOztZQUNHOzBCQUNELDhEQUFDTztnQkFBT0MsV0FBVyxVQUE2QyxPQUFuQ1gsU0FBUyx1QkFBdUI7MEJBQzNELDRFQUFDWTtvQkFBSUQsV0FBVTs4QkFDYiw0RUFBQ0M7d0JBQUlELFdBQVU7OzBDQUNiLDhEQUFDQztnQ0FBSUQsV0FBVTswQ0FDYiw0RUFBQ0M7b0NBQUlELFdBQVU7O3NEQUNiLDhEQUFDbEIsaURBQUlBOzRDQUFDb0IsTUFBSzs0Q0FBSUYsV0FBVTs7OERBQ3ZCLDhEQUFDRztvREFBSUMsS0FBSTtvREFBK0JDLEtBQUk7Ozs7Ozs4REFDNUMsOERBQUNGO29EQUFJQyxLQUFJO29EQUErQkMsS0FBSTs7Ozs7Ozs7Ozs7O3NEQUk5Qyw4REFBQ0o7NENBQUlELFdBQVU7c0RBQ2IsNEVBQUNDO2dEQUFJRCxXQUFVOzBEQUNiLDRFQUFDZixpREFBUUE7b0RBQUNxQixPQUFNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MENBU3hCLDhEQUFDTDtnQ0FBSUQsV0FBVTswQ0FDYiw0RUFBQ0M7b0NBQUlELFdBQVU7O3NEQUNiLDhEQUFDQzs0Q0FBSUQsV0FBVTtzREFFWixDQUFDVCxzQkFBUyw4REFBQ1QsaURBQUlBO2dEQUNkb0IsTUFBSztnREFDTEYsV0FBVTswREFDWDs7Ozs7Ozs7Ozs7c0RBT0gsOERBQUNDOzRDQUFJRCxXQUFVOzs4REFDYiw4REFBQ0M7OERBQ0UsQ0FBQ1Ysc0JBQVMsOERBQUNULGlEQUFJQTt3REFDZG9CLE1BQUs7d0RBQ0xGLFdBQVU7Ozs7Ozs7Ozs7OzhEQUlkLDhEQUFDQzs7c0VBQ0MsOERBQUNNOzREQUNDUCxXQUFVOzREQUNWUSxrQkFBZTs0REFDZkMsaUJBQWM7NERBQ2RDLGtCQUFlOzs7Ozs7c0VBR2pCLDhEQUFDVDs0REFDQ0QsV0FBVTs0REFDVlcsVUFBUzs0REFDVEMsSUFBRzs0REFDSEMsbUJBQWdCOzREQUNoQkMsa0JBQWU7c0VBRWYsNEVBQUM1QixtREFBVUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtCakM7R0F2R01FO0tBQUFBO0FBeUdOLCtEQUFlQSxPQUFPQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvaGVhZGVyL2hlYWRlci0xMC9pbmRleC5qc3g/MzdjYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IExpbmsgZnJvbSBcIm5leHQvbGlua1wiO1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IE1haW5NZW51IGZyb20gXCIuLi9NYWluTWVudVwiO1xuaW1wb3J0IE1vYmlsZU1lbnUgZnJvbSBcIi4uL01vYmlsZU1lbnVcIjtcbmltcG9ydCBDb29raWVzIGZyb20gXCJqcy1jb29raWVcIjtcblxuXG5jb25zdCBIZWFkZXIxID0gKCkgPT4ge1xuICBjb25zdCBbbmF2YmFyLCBzZXROYXZiYXJdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbYXV0aCwgc2V0QXV0aF0gPSB1c2VTdGF0ZShmYWxzZSlcblxuICBjb25zdCBjaGFuZ2VCYWNrZ3JvdW5kID0gKCkgPT4ge1xuICAgIGlmICh3aW5kb3cuc2Nyb2xsWSA+PSAxMCkge1xuICAgICAgc2V0TmF2YmFyKHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXROYXZiYXIoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGNoYW5nZUJhY2tncm91bmQpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBjaGFuZ2VCYWNrZ3JvdW5kKTtcbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgdXNlRWZmZWN0KCgpPT57XG4gICAgaWYoQ29va2llcy5nZXQoJ2p3dF90b2tlbicpKXtzZXRBdXRoKHRydWUpIH1cbiAgfSxbXSlcblxuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICB7XCIgXCJ9XG4gICAgICA8aGVhZGVyIGNsYXNzTmFtZT17YGhlYWRlciAke25hdmJhciA/IFwiaXMtc3RpY2t5IGJnLXdoaXRlXCIgOiBcIlwifWB9PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImhlYWRlcl9fY29udGFpbmVyIGhlYWRlcl9fY29udGFpbmVyLTE1MDAgbXgtYXV0byBweC0zMCBzbTpweC0yMFwiPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicm93IGp1c3RpZnktYmV0d2VlbiBpdGVtcy1jZW50ZXJcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29sLWF1dG9cIj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJkLWZsZXggaXRlbXMtY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgPExpbmsgaHJlZj1cIi9cIiBjbGFzc05hbWU9XCJoZWFkZXItbG9nbyBtci01MFwiPlxuICAgICAgICAgICAgICAgICAgPGltZyBzcmM9XCIvaW1nL2dlbmVyYWwvbG9nby1kYXJrLTMuc3ZnXCIgYWx0PVwibG9nbyBpY29uXCIgLz5cbiAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPVwiL2ltZy9nZW5lcmFsL2xvZ28tZGFyay0zLnN2Z1wiIGFsdD1cImxvZ28gaWNvblwiIC8+XG4gICAgICAgICAgICAgICAgPC9MaW5rPlxuICAgICAgICAgICAgICAgIHsvKiBFbmQgbG9nbyAqL31cblxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaGVhZGVyLW1lbnVcIj5cbiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaGVhZGVyLW1lbnVfX2NvbnRlbnRcIj5cbiAgICAgICAgICAgICAgICAgICAgPE1haW5NZW51IHN0eWxlPVwidGV4dC1kYXJrLTFcIiAvPlxuICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgey8qIEVuZCBoZWFkZXItbWVudSAqL31cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIHsvKiBFbmQgZC1mbGV4ICovfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICB7LyogRW5kIGNvbCAqL31cblxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb2wtYXV0b1wiPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImQtZmxleCBpdGVtcy1jZW50ZXJcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImQtZmxleCBpdGVtcy1jZW50ZXIgaXMtbWVudS1vcGVuZWQtaGlkZSBtZDpkLW5vbmVcIj5cbiAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIHshYXV0aCAmJiAoPExpbmtcbiAgICAgICAgICAgICAgICAgICAgaHJlZj1cIi9zaWdudXBcIlxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJidXR0b24gcHgtMzAgZnctNDAwIHRleHQtMTQgYm9yZGVyLWRhcmstNCAtYmx1ZS0xIGgtNTAgdGV4dC1kYXJrLTQgbWwtMjBcIlxuICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICBTaWduIEluIC8gUmVnaXN0ZXJcbiAgICAgICAgICAgICAgICAgIDwvTGluaz4pfVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIHsvKiBFbmQgZC1mbGV4ICovfVxuXG4gICAgICAgICAgICAgICAgey8qIFN0YXJ0IG1vYmlsZSBtZW51IGljb24gKi99XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJkLW5vbmUgeGw6ZC1mbGV4IHgtZ2FwLTIwIGl0ZW1zLWNlbnRlciBwbC0zMCB0ZXh0LWRhcmstMVwiPlxuICAgICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgICAgeyFhdXRoICYmICg8TGlua1xuICAgICAgICAgICAgICAgICAgICAgIGhyZWY9XCIvbG9naW5cIlxuICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImQtZmxleCBpdGVtcy1jZW50ZXIgaWNvbi11c2VyIHRleHQtaW5oZXJpdCB0ZXh0LTIyXCJcbiAgICAgICAgICAgICAgICAgICAgLz4pfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJkLWZsZXggaXRlbXMtY2VudGVyIGljb24tbWVudSB0ZXh0LWluaGVyaXQgdGV4dC0yMFwiXG4gICAgICAgICAgICAgICAgICAgICAgZGF0YS1icy10b2dnbGU9XCJvZmZjYW52YXNcIlxuICAgICAgICAgICAgICAgICAgICAgIGFyaWEtY29udHJvbHM9XCJtb2JpbGUtc2lkZWJhcl9tZW51XCJcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhLWJzLXRhcmdldD1cIiNtb2JpbGUtc2lkZWJhcl9tZW51XCJcbiAgICAgICAgICAgICAgICAgICAgLz5cblxuICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwib2ZmY2FudmFzIG9mZmNhbnZhcy1zdGFydCAgbW9iaWxlX21lbnUtY29udG5ldFwiXG4gICAgICAgICAgICAgICAgICAgICAgdGFiSW5kZXg9XCItMVwiXG4gICAgICAgICAgICAgICAgICAgICAgaWQ9XCJtb2JpbGUtc2lkZWJhcl9tZW51XCJcbiAgICAgICAgICAgICAgICAgICAgICBhcmlhLWxhYmVsbGVkYnk9XCJvZmZjYW52YXNNZW51TGFiZWxcIlxuICAgICAgICAgICAgICAgICAgICAgIGRhdGEtYnMtc2Nyb2xsPVwidHJ1ZVwiXG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICA8TW9iaWxlTWVudSAvPlxuICAgICAgICAgICAgICAgICAgICAgIHsvKiBFbmQgTW9iaWxlTWVudSAqL31cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICB7LyogRW5kIG1vYmlsZSBtZW51IGljb24gKi99XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICB7LyogRW5kIGQtZmxleCAqL31cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgey8qIEVuZCBjb2wtYXV0byAqL31cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICB7LyogRW5kIC5yb3cgKi99XG4gICAgICAgIDwvZGl2PlxuICAgICAgICB7LyogRW5kIGhlYWRlcl9jb250YWluZXIgKi99XG4gICAgICA8L2hlYWRlcj5cbiAgICAgIHsvKiBFbmQgaGVhZGVyICovfVxuICAgIDwvPlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgSGVhZGVyMTtcbiJdLCJuYW1lcyI6WyJMaW5rIiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJNYWluTWVudSIsIk1vYmlsZU1lbnUiLCJDb29raWVzIiwiSGVhZGVyMSIsIm5hdmJhciIsInNldE5hdmJhciIsImF1dGgiLCJzZXRBdXRoIiwiY2hhbmdlQmFja2dyb3VuZCIsIndpbmRvdyIsInNjcm9sbFkiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImdldCIsImhlYWRlciIsImNsYXNzTmFtZSIsImRpdiIsImhyZWYiLCJpbWciLCJzcmMiLCJhbHQiLCJzdHlsZSIsImJ1dHRvbiIsImRhdGEtYnMtdG9nZ2xlIiwiYXJpYS1jb250cm9scyIsImRhdGEtYnMtdGFyZ2V0IiwidGFiSW5kZXgiLCJpZCIsImFyaWEtbGFiZWxsZWRieSIsImRhdGEtYnMtc2Nyb2xsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/header/header-10/index.jsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/hero/DateSearch.jsx":
/*!****************************************!*\
  !*** ./components/hero/DateSearch.jsx ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_multi_date_picker__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-multi-date-picker */ \"(app-pages-browser)/./node_modules/react-multi-date-picker/build/index.js\");\n/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-redux */ \"(app-pages-browser)/./node_modules/react-redux/dist/react-redux.mjs\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\nconst DateSearch = (param)=>{\n    let { setDate } = param;\n    _s();\n    const filters = (0,react_redux__WEBPACK_IMPORTED_MODULE_3__.useSelector)((state)=>state.flightFilter);\n    // const [dates, setDates] = useState([\n    //   new DateObject({ year: 2023, month: 1, day: 22 }),\n    //   \"December 09 2020\",\n    //   1597994736000, //unix time in milliseconds (August 21 2020)\n    // ]);\n    const [date, setDates] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(new react_multi_date_picker__WEBPACK_IMPORTED_MODULE_2__.DateObject());\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        setDate(date.format(\"YYYY-MM-DD\"));\n    }, [\n        date\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"text-15 text-light-1 ls-2 lh-16 custom_dual_datepicker\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_multi_date_picker__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n            inputClass: \"custom_input-picker\",\n            containerClassName: \"custom_container-picker\",\n            value: date,\n            onChange: setDates,\n            format: \"MMMM DD\"\n        }, void 0, false, {\n            fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/DateSearch.jsx\",\n            lineNumber: 22,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/DateSearch.jsx\",\n        lineNumber: 21,\n        columnNumber: 5\n    }, undefined);\n};\n_s(DateSearch, \"tt1R78176G+AbLTpxnVGOTJPGWc=\", false, function() {\n    return [\n        react_redux__WEBPACK_IMPORTED_MODULE_3__.useSelector\n    ];\n});\n_c = DateSearch;\n/* harmony default export */ __webpack_exports__[\"default\"] = (DateSearch);\nvar _c;\n$RefreshReg$(_c, \"DateSearch\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvaGVyby9EYXRlU2VhcmNoLmpzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUVtRDtBQUNjO0FBQ1Y7QUFFdkQsTUFBTU8sYUFBYTtRQUFDLEVBQUNDLE9BQU8sRUFBQzs7SUFDM0IsTUFBTUMsVUFBVUgsd0RBQVdBLENBQUMsQ0FBQ0ksUUFBVUEsTUFBTUMsWUFBWTtJQUN6RCx1Q0FBdUM7SUFDdkMsdURBQXVEO0lBQ3ZELHdCQUF3QjtJQUN4QixnRUFBZ0U7SUFDaEUsTUFBTTtJQUNOLE1BQU0sQ0FBQ0MsTUFBTUMsU0FBUyxHQUFHWCwrQ0FBUUEsQ0FBQyxJQUFJRSwrREFBVUE7SUFFaERILGdEQUFTQSxDQUFDO1FBQ1JPLFFBQVFJLEtBQUtFLE1BQU0sQ0FBQztJQUN0QixHQUFHO1FBQUNGO0tBQUs7SUFFVCxxQkFDRSw4REFBQ0c7UUFBSUMsV0FBVTtrQkFDYiw0RUFBQ2IsK0RBQVVBO1lBQ1RjLFlBQVc7WUFDWEMsb0JBQW1CO1lBQ25CQyxPQUFPUDtZQUNQUSxVQUFVUDtZQUNWQyxRQUFPOzs7Ozs7Ozs7OztBQUlmO0dBeEJNUDs7UUFDWUQsb0RBQVdBOzs7S0FEdkJDO0FBMEJOLCtEQUFlQSxVQUFVQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvaGVyby9EYXRlU2VhcmNoLmpzeD8wMTQyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IERhdGVQaWNrZXIsIHsgRGF0ZU9iamVjdCB9IGZyb20gXCJyZWFjdC1tdWx0aS1kYXRlLXBpY2tlclwiO1xuaW1wb3J0IHsgdXNlRGlzcGF0Y2gsIHVzZVNlbGVjdG9yIH0gZnJvbSBcInJlYWN0LXJlZHV4XCI7XG5cbmNvbnN0IERhdGVTZWFyY2ggPSAoe3NldERhdGV9KSA9PiB7XG4gIGNvbnN0IGZpbHRlcnMgPSB1c2VTZWxlY3Rvcigoc3RhdGUpID0+IHN0YXRlLmZsaWdodEZpbHRlcik7XG4gIC8vIGNvbnN0IFtkYXRlcywgc2V0RGF0ZXNdID0gdXNlU3RhdGUoW1xuICAvLyAgIG5ldyBEYXRlT2JqZWN0KHsgeWVhcjogMjAyMywgbW9udGg6IDEsIGRheTogMjIgfSksXG4gIC8vICAgXCJEZWNlbWJlciAwOSAyMDIwXCIsXG4gIC8vICAgMTU5Nzk5NDczNjAwMCwgLy91bml4IHRpbWUgaW4gbWlsbGlzZWNvbmRzIChBdWd1c3QgMjEgMjAyMClcbiAgLy8gXSk7XG4gIGNvbnN0IFtkYXRlLCBzZXREYXRlc10gPSB1c2VTdGF0ZShuZXcgRGF0ZU9iamVjdCgpKTtcblxuICB1c2VFZmZlY3QoKCk9PntcbiAgICBzZXREYXRlKGRhdGUuZm9ybWF0KCdZWVlZLU1NLUREJykpO1xuICB9LCBbZGF0ZV0pO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LTE1IHRleHQtbGlnaHQtMSBscy0yIGxoLTE2IGN1c3RvbV9kdWFsX2RhdGVwaWNrZXJcIj5cbiAgICAgIDxEYXRlUGlja2VyXG4gICAgICAgIGlucHV0Q2xhc3M9XCJjdXN0b21faW5wdXQtcGlja2VyXCJcbiAgICAgICAgY29udGFpbmVyQ2xhc3NOYW1lPVwiY3VzdG9tX2NvbnRhaW5lci1waWNrZXJcIlxuICAgICAgICB2YWx1ZT17ZGF0ZX1cbiAgICAgICAgb25DaGFuZ2U9e3NldERhdGVzfVxuICAgICAgICBmb3JtYXQ9XCJNTU1NIEREXCJcbiAgICAgIC8+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBEYXRlU2VhcmNoO1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJEYXRlUGlja2VyIiwiRGF0ZU9iamVjdCIsInVzZURpc3BhdGNoIiwidXNlU2VsZWN0b3IiLCJEYXRlU2VhcmNoIiwic2V0RGF0ZSIsImZpbHRlcnMiLCJzdGF0ZSIsImZsaWdodEZpbHRlciIsImRhdGUiLCJzZXREYXRlcyIsImZvcm1hdCIsImRpdiIsImNsYXNzTmFtZSIsImlucHV0Q2xhc3MiLCJjb250YWluZXJDbGFzc05hbWUiLCJ2YWx1ZSIsIm9uQ2hhbmdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/hero/DateSearch.jsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/hero/FilterSelect.jsx":
/*!******************************************!*\
  !*** ./components/hero/FilterSelect.jsx ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-redux */ \"(app-pages-browser)/./node_modules/react-redux/dist/react-redux.mjs\");\n/* harmony import */ var _features_flight_flightFilterSlice__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../features/flight/flightFilterSlice */ \"(app-pages-browser)/./features/flight/flightFilterSlice.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\nconst FilterSelect = ()=>{\n    _s();\n    const [returnValue, setReturnValue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"One-Way\");\n    const [economyValue, setEconomyValue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"Economy\");\n    const dispatch = (0,react_redux__WEBPACK_IMPORTED_MODULE_3__.useDispatch)();\n    const handleReturnValueChange = (value)=>{\n        dispatch((0,_features_flight_flightFilterSlice__WEBPACK_IMPORTED_MODULE_2__.setTrip_type)(value));\n        setReturnValue(value);\n    };\n    const handleEconomyValueChange = (value)=>{\n        dispatch((0,_features_flight_flightFilterSlice__WEBPACK_IMPORTED_MODULE_2__.setCabin_class)(value));\n        setEconomyValue(value);\n    };\n    const handleBagsValueChange = (value)=>{\n        setBagsValue(value);\n    };\n    const dropdownOptions = [\n        {\n            title: \"Type\",\n            value: returnValue,\n            list: [\n                {\n                    label: \"One-Way\"\n                },\n                {\n                    label: \"Round Trip\"\n                },\n                {\n                    label: \"Multi-City\"\n                },\n                {\n                    label: \"Calendar Fare\"\n                }\n            ],\n            onChange: handleReturnValueChange\n        },\n        {\n            title: \"Economy\",\n            value: economyValue,\n            list: [\n                {\n                    label: \"Economy\"\n                },\n                {\n                    label: \"Flexi\"\n                },\n                {\n                    label: \"Business\"\n                }\n            ],\n            onChange: handleEconomyValueChange\n        }\n    ];\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: dropdownOptions.map((option, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"col-auto\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"dropdown js-dropdown\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"dropdown__button d-flex items-center text-15\",\n                            \"data-bs-toggle\": \"dropdown\",\n                            \"data-bs-auto-close\": \"true\",\n                            \"data-bs-offset\": \"0,0\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: \"js-dropdown-title\",\n                                    children: option.value\n                                }, void 0, false, {\n                                    fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/FilterSelect.jsx\",\n                                    lineNumber: 61,\n                                    columnNumber: 15\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"i\", {\n                                    className: \"icon icon-chevron-sm-down text-7 ml-10\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/FilterSelect.jsx\",\n                                    lineNumber: 63,\n                                    columnNumber: 15\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/FilterSelect.jsx\",\n                            lineNumber: 55,\n                            columnNumber: 13\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"toggle-element -dropdown js-click-dropdown dropdown-menu\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"text-14 y-gap-15 js-dropdown-list\",\n                                children: option.list.map((item, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            role: \"button\",\n                                            className: \"\".concat(item.label === option.value ? \"text-blue-1 \" : \"\", \"d-block js-dropdown-link\"),\n                                            onClick: ()=>option.onChange(item.label),\n                                            children: item.label\n                                        }, void 0, false, {\n                                            fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/FilterSelect.jsx\",\n                                            lineNumber: 69,\n                                            columnNumber: 21\n                                        }, undefined)\n                                    }, index, false, {\n                                        fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/FilterSelect.jsx\",\n                                        lineNumber: 68,\n                                        columnNumber: 19\n                                    }, undefined))\n                            }, void 0, false, {\n                                fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/FilterSelect.jsx\",\n                                lineNumber: 66,\n                                columnNumber: 15\n                            }, undefined)\n                        }, void 0, false, {\n                            fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/FilterSelect.jsx\",\n                            lineNumber: 65,\n                            columnNumber: 13\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/FilterSelect.jsx\",\n                    lineNumber: 54,\n                    columnNumber: 11\n                }, undefined)\n            }, index, false, {\n                fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/FilterSelect.jsx\",\n                lineNumber: 53,\n                columnNumber: 9\n            }, undefined))\n    }, void 0, false);\n};\n_s(FilterSelect, \"HERNKsqQjJrt2GuMV2gxyFt/7OE=\", false, function() {\n    return [\n        react_redux__WEBPACK_IMPORTED_MODULE_3__.useDispatch\n    ];\n});\n_c = FilterSelect;\n/* harmony default export */ __webpack_exports__[\"default\"] = (FilterSelect);\nvar _c;\n$RefreshReg$(_c, \"FilterSelect\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvaGVyby9GaWx0ZXJTZWxlY3QuanN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBR2lDO0FBQ3NCO0FBQ2dDO0FBRXZGLE1BQU1LLGVBQWU7O0lBQ25CLE1BQU0sQ0FBQ0MsYUFBYUMsZUFBZSxHQUFHUCwrQ0FBUUEsQ0FBQztJQUMvQyxNQUFNLENBQUNRLGNBQWNDLGdCQUFnQixHQUFHVCwrQ0FBUUEsQ0FBQztJQUVqRCxNQUFNVSxXQUFXUix3REFBV0E7SUFFNUIsTUFBTVMsMEJBQTBCLENBQUNDO1FBQy9CRixTQUFTUCxnRkFBWUEsQ0FBQ1M7UUFDdEJMLGVBQWVLO0lBQ2pCO0lBRUEsTUFBTUMsMkJBQTJCLENBQUNEO1FBQ2hDRixTQUFTTixrRkFBY0EsQ0FBQ1E7UUFDeEJILGdCQUFnQkc7SUFDbEI7SUFFQSxNQUFNRSx3QkFBd0IsQ0FBQ0Y7UUFDN0JHLGFBQWFIO0lBQ2Y7SUFFQSxNQUFNSSxrQkFBa0I7UUFDdEI7WUFDRUMsT0FBTztZQUNQTCxPQUFPTjtZQUNQWSxNQUFNO2dCQUNKO29CQUFFQyxPQUFPO2dCQUFVO2dCQUNuQjtvQkFBRUEsT0FBTztnQkFBYTtnQkFDdEI7b0JBQUVBLE9BQU87Z0JBQWE7Z0JBQ3RCO29CQUFFQSxPQUFPO2dCQUFnQjthQUMxQjtZQUNEQyxVQUFVVDtRQUNaO1FBRUE7WUFDRU0sT0FBTztZQUNQTCxPQUFPSjtZQUNQVSxNQUFNO2dCQUFDO29CQUFFQyxPQUFPO2dCQUFVO2dCQUFHO29CQUFFQSxPQUFPO2dCQUFRO2dCQUFHO29CQUFFQSxPQUFPO2dCQUFXO2FBQUU7WUFDdkVDLFVBQVVQO1FBQ1o7S0FFRDtJQUVELHFCQUNFO2tCQUNHRyxnQkFBZ0JLLEdBQUcsQ0FBQyxDQUFDQyxRQUFRQyxzQkFDNUIsOERBQUNDO2dCQUFJQyxXQUFVOzBCQUNiLDRFQUFDRDtvQkFBSUMsV0FBVTs7c0NBQ2IsOERBQUNEOzRCQUNDQyxXQUFVOzRCQUNWQyxrQkFBZTs0QkFDZkMsc0JBQW1COzRCQUNuQkMsa0JBQWU7OzhDQUVmLDhEQUFDQztvQ0FBS0osV0FBVTs4Q0FBcUJILE9BQU9WLEtBQUs7Ozs7Ozs4Q0FFakQsOERBQUNrQjtvQ0FBRUwsV0FBVTs7Ozs7Ozs7Ozs7O3NDQUVmLDhEQUFDRDs0QkFBSUMsV0FBVTtzQ0FDYiw0RUFBQ0Q7Z0NBQUlDLFdBQVU7MENBQ1pILE9BQU9KLElBQUksQ0FBQ0csR0FBRyxDQUFDLENBQUNVLE1BQU1SLHNCQUN0Qiw4REFBQ0M7a0RBQ0MsNEVBQUNBOzRDQUNDUSxNQUFLOzRDQUNMUCxXQUFXLEdBRVYsT0FEQ00sS0FBS1osS0FBSyxLQUFLRyxPQUFPVixLQUFLLEdBQUcsaUJBQWlCLElBQ2hEOzRDQUNEcUIsU0FBUyxJQUFNWCxPQUFPRixRQUFRLENBQUNXLEtBQUtaLEtBQUs7c0RBRXhDWSxLQUFLWixLQUFLOzs7Ozs7dUNBUkxJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7ZUFmV0E7Ozs7OztBQWtDdkM7R0EvRU1sQjs7UUFJYUgsb0RBQVdBOzs7S0FKeEJHO0FBaUZOLCtEQUFlQSxZQUFZQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvaGVyby9GaWx0ZXJTZWxlY3QuanN4Pzk1YTIiXSwic291cmNlc0NvbnRlbnQiOlsiXG4ndXNlIGNsaWVudCdcblxuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVNlbGVjdG9yLCB1c2VEaXNwYXRjaCB9IGZyb20gXCJyZWFjdC1yZWR1eFwiO1xuaW1wb3J0IHsgc2V0VHJpcF90eXBlLCBzZXRDYWJpbl9jbGFzcyx9IGZyb20gJy4uLy4uL2ZlYXR1cmVzL2ZsaWdodC9mbGlnaHRGaWx0ZXJTbGljZSc7XG5cbmNvbnN0IEZpbHRlclNlbGVjdCA9ICgpID0+IHtcbiAgY29uc3QgW3JldHVyblZhbHVlLCBzZXRSZXR1cm5WYWx1ZV0gPSB1c2VTdGF0ZShcIk9uZS1XYXlcIik7XG4gIGNvbnN0IFtlY29ub215VmFsdWUsIHNldEVjb25vbXlWYWx1ZV0gPSB1c2VTdGF0ZShcIkVjb25vbXlcIik7XG5cbiAgY29uc3QgZGlzcGF0Y2ggPSB1c2VEaXNwYXRjaCgpO1xuXG4gIGNvbnN0IGhhbmRsZVJldHVyblZhbHVlQ2hhbmdlID0gKHZhbHVlKSA9PiB7XG4gICAgZGlzcGF0Y2goc2V0VHJpcF90eXBlKHZhbHVlKSk7XG4gICAgc2V0UmV0dXJuVmFsdWUodmFsdWUpO1xuICB9O1xuXG4gIGNvbnN0IGhhbmRsZUVjb25vbXlWYWx1ZUNoYW5nZSA9ICh2YWx1ZSkgPT4ge1xuICAgIGRpc3BhdGNoKHNldENhYmluX2NsYXNzKHZhbHVlKSk7XG4gICAgc2V0RWNvbm9teVZhbHVlKHZhbHVlKTtcbiAgfTtcblxuICBjb25zdCBoYW5kbGVCYWdzVmFsdWVDaGFuZ2UgPSAodmFsdWUpID0+IHtcbiAgICBzZXRCYWdzVmFsdWUodmFsdWUpO1xuICB9O1xuXG4gIGNvbnN0IGRyb3Bkb3duT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICB0aXRsZTogXCJUeXBlXCIsXG4gICAgICB2YWx1ZTogcmV0dXJuVmFsdWUsXG4gICAgICBsaXN0OiBbXG4gICAgICAgIHsgbGFiZWw6IFwiT25lLVdheVwiIH0sXG4gICAgICAgIHsgbGFiZWw6IFwiUm91bmQgVHJpcFwiIH0sXG4gICAgICAgIHsgbGFiZWw6IFwiTXVsdGktQ2l0eVwiIH0sXG4gICAgICAgIHsgbGFiZWw6IFwiQ2FsZW5kYXIgRmFyZVwiIH0sXG4gICAgICBdLFxuICAgICAgb25DaGFuZ2U6IGhhbmRsZVJldHVyblZhbHVlQ2hhbmdlLFxuICAgIH0sXG5cbiAgICB7XG4gICAgICB0aXRsZTogXCJFY29ub215XCIsXG4gICAgICB2YWx1ZTogZWNvbm9teVZhbHVlLFxuICAgICAgbGlzdDogW3sgbGFiZWw6IFwiRWNvbm9teVwiIH0sIHsgbGFiZWw6IFwiRmxleGlcIiB9LCB7IGxhYmVsOiBcIkJ1c2luZXNzXCIgfV0sXG4gICAgICBvbkNoYW5nZTogaGFuZGxlRWNvbm9teVZhbHVlQ2hhbmdlLFxuICAgIH0sXG5cbiAgXTtcblxuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICB7ZHJvcGRvd25PcHRpb25zLm1hcCgob3B0aW9uLCBpbmRleCkgPT4gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbC1hdXRvXCIga2V5PXtpbmRleH0+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJkcm9wZG93biBqcy1kcm9wZG93blwiPlxuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJkcm9wZG93bl9fYnV0dG9uIGQtZmxleCBpdGVtcy1jZW50ZXIgdGV4dC0xNVwiXG4gICAgICAgICAgICAgIGRhdGEtYnMtdG9nZ2xlPVwiZHJvcGRvd25cIlxuICAgICAgICAgICAgICBkYXRhLWJzLWF1dG8tY2xvc2U9XCJ0cnVlXCJcbiAgICAgICAgICAgICAgZGF0YS1icy1vZmZzZXQ9XCIwLDBcIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJqcy1kcm9wZG93bi10aXRsZVwiPntvcHRpb24udmFsdWV9PC9zcGFuPlxuXG4gICAgICAgICAgICAgIDxpIGNsYXNzTmFtZT1cImljb24gaWNvbi1jaGV2cm9uLXNtLWRvd24gdGV4dC03IG1sLTEwXCIgLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0b2dnbGUtZWxlbWVudCAtZHJvcGRvd24ganMtY2xpY2stZHJvcGRvd24gZHJvcGRvd24tbWVudVwiPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtMTQgeS1nYXAtMTUganMtZHJvcGRvd24tbGlzdFwiPlxuICAgICAgICAgICAgICAgIHtvcHRpb24ubGlzdC5tYXAoKGl0ZW0sIGluZGV4KSA9PiAoXG4gICAgICAgICAgICAgICAgICA8ZGl2IGtleT17aW5kZXh9PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgcm9sZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgJHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ubGFiZWwgPT09IG9wdGlvbi52YWx1ZSA/IFwidGV4dC1ibHVlLTEgXCIgOiBcIlwiXG4gICAgICAgICAgICAgICAgICAgICAgfWQtYmxvY2sganMtZHJvcGRvd24tbGlua2B9XG4gICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gb3B0aW9uLm9uQ2hhbmdlKGl0ZW0ubGFiZWwpfVxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAge2l0ZW0ubGFiZWx9XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKSl9XG4gICAgPC8+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBGaWx0ZXJTZWxlY3Q7XG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VTZWxlY3RvciIsInVzZURpc3BhdGNoIiwic2V0VHJpcF90eXBlIiwic2V0Q2FiaW5fY2xhc3MiLCJGaWx0ZXJTZWxlY3QiLCJyZXR1cm5WYWx1ZSIsInNldFJldHVyblZhbHVlIiwiZWNvbm9teVZhbHVlIiwic2V0RWNvbm9teVZhbHVlIiwiZGlzcGF0Y2giLCJoYW5kbGVSZXR1cm5WYWx1ZUNoYW5nZSIsInZhbHVlIiwiaGFuZGxlRWNvbm9teVZhbHVlQ2hhbmdlIiwiaGFuZGxlQmFnc1ZhbHVlQ2hhbmdlIiwic2V0QmFnc1ZhbHVlIiwiZHJvcGRvd25PcHRpb25zIiwidGl0bGUiLCJsaXN0IiwibGFiZWwiLCJvbkNoYW5nZSIsIm1hcCIsIm9wdGlvbiIsImluZGV4IiwiZGl2IiwiY2xhc3NOYW1lIiwiZGF0YS1icy10b2dnbGUiLCJkYXRhLWJzLWF1dG8tY2xvc2UiLCJkYXRhLWJzLW9mZnNldCIsInNwYW4iLCJpIiwiaXRlbSIsInJvbGUiLCJvbkNsaWNrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/hero/FilterSelect.jsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/hero/FlyingFromLocation.jsx":
/*!************************************************!*\
  !*** ./components/hero/FlyingFromLocation.jsx ***!
  \************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-redux */ \"(app-pages-browser)/./node_modules/react-redux/dist/react-redux.mjs\");\n/* harmony import */ var _features_flight_flightFilterSlice__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../features/flight/flightFilterSlice */ \"(app-pages-browser)/./features/flight/flightFilterSlice.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\nconst FlyingFromLocation = ()=>{\n    _s();\n    const dispatch = (0,react_redux__WEBPACK_IMPORTED_MODULE_3__.useDispatch)();\n    const locationSearchContent = [\n        {\n            id: 1,\n            name: \"London\",\n            address: \"Greater London, United Kingdom\"\n        },\n        {\n            id: 2,\n            name: \"New York\",\n            address: \"New York State, United States\"\n        },\n        {\n            id: 3,\n            name: \"Paris\",\n            address: \"France\"\n        },\n        {\n            id: 4,\n            name: \"Madrid\",\n            address: \"Spain\"\n        },\n        {\n            id: 5,\n            name: \"Santorini\",\n            address: \"Greece\"\n        }\n    ];\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"searchMenu-loc px-24 lg:py-20 lg:px-0 js-form-dd js-liverSearch\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    \"data-bs-toggle\": \"dropdown\",\n                    \"data-bs-auto-close\": \"true\",\n                    \"data-bs-offset\": \"0,22\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h4\", {\n                            className: \"text-15 fw-500 ls-2 lh-16\",\n                            children: \"Flying From\"\n                        }, void 0, false, {\n                            fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/FlyingFromLocation.jsx\",\n                            lineNumber: 47,\n                            columnNumber: 11\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"text-15 text-light-1 ls-2 lh-16\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                autoComplete: \"off\",\n                                type: \"search\",\n                                placeholder: \"Where are you going?\",\n                                className: \"js-search js-dd-focus\",\n                                onChange: (e)=>dispatch((0,_features_flight_flightFilterSlice__WEBPACK_IMPORTED_MODULE_2__.setFlying_from)(e.target.value))\n                            }, void 0, false, {\n                                fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/FlyingFromLocation.jsx\",\n                                lineNumber: 49,\n                                columnNumber: 13\n                            }, undefined)\n                        }, void 0, false, {\n                            fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/FlyingFromLocation.jsx\",\n                            lineNumber: 48,\n                            columnNumber: 11\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/FlyingFromLocation.jsx\",\n                    lineNumber: 42,\n                    columnNumber: 9\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"shadow-2 dropdown-menu min-width-400\",\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"bg-white px-20 py-20 sm:px-0 sm:py-15 rounded-4\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                            className: \"y-gap-5 js-results\",\n                            children: locationSearchContent.map((item)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                    className: \"-link d-block col-12 text-left rounded-4 px-20 py-15 js-search-option mb-1 \",\n                                    role: \"button\",\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"d-flex\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"icon-location-2 text-light-1 text-20 pt-4\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/FlyingFromLocation.jsx\",\n                                                lineNumber: 69,\n                                                columnNumber: 21\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"ml-10\",\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                        className: \"text-15 lh-12 fw-500 js-search-option-target\",\n                                                        children: item.name\n                                                    }, void 0, false, {\n                                                        fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/FlyingFromLocation.jsx\",\n                                                        lineNumber: 71,\n                                                        columnNumber: 23\n                                                    }, undefined),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                        className: \"text-14 lh-12 text-light-1 mt-5\",\n                                                        children: item.address\n                                                    }, void 0, false, {\n                                                        fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/FlyingFromLocation.jsx\",\n                                                        lineNumber: 74,\n                                                        columnNumber: 23\n                                                    }, undefined)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/FlyingFromLocation.jsx\",\n                                                lineNumber: 70,\n                                                columnNumber: 21\n                                            }, undefined)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/FlyingFromLocation.jsx\",\n                                        lineNumber: 68,\n                                        columnNumber: 19\n                                    }, undefined)\n                                }, item.id, false, {\n                                    fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/FlyingFromLocation.jsx\",\n                                    lineNumber: 63,\n                                    columnNumber: 17\n                                }, undefined))\n                        }, void 0, false, {\n                            fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/FlyingFromLocation.jsx\",\n                            lineNumber: 61,\n                            columnNumber: 13\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/FlyingFromLocation.jsx\",\n                        lineNumber: 60,\n                        columnNumber: 11\n                    }, undefined)\n                }, void 0, false, {\n                    fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/FlyingFromLocation.jsx\",\n                    lineNumber: 59,\n                    columnNumber: 9\n                }, undefined)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/FlyingFromLocation.jsx\",\n            lineNumber: 41,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false);\n};\n_s(FlyingFromLocation, \"rgTLoBID190wEKCp9+G8W6F7A5M=\", false, function() {\n    return [\n        react_redux__WEBPACK_IMPORTED_MODULE_3__.useDispatch\n    ];\n});\n_c = FlyingFromLocation;\n/* harmony default export */ __webpack_exports__[\"default\"] = (FlyingFromLocation);\nvar _c;\n$RefreshReg$(_c, \"FlyingFromLocation\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvaGVyby9GbHlpbmdGcm9tTG9jYXRpb24uanN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBR2lDO0FBQ3NCO0FBQ2lCO0FBR3hFLE1BQU1JLHFCQUFxQjs7SUFFekIsTUFBTUMsV0FBV0gsd0RBQVdBO0lBQzVCLE1BQU1JLHdCQUF3QjtRQUM1QjtZQUNFQyxJQUFJO1lBQ0pDLE1BQU07WUFDTkMsU0FBUztRQUNYO1FBQ0E7WUFDRUYsSUFBSTtZQUNKQyxNQUFNO1lBQ05DLFNBQVM7UUFDWDtRQUNBO1lBQ0VGLElBQUk7WUFDSkMsTUFBTTtZQUNOQyxTQUFTO1FBQ1g7UUFDQTtZQUNFRixJQUFJO1lBQ0pDLE1BQU07WUFDTkMsU0FBUztRQUNYO1FBQ0E7WUFDRUYsSUFBSTtZQUNKQyxNQUFNO1lBQ05DLFNBQVM7UUFDWDtLQUNEO0lBQ0QscUJBQ0U7a0JBQ0UsNEVBQUNDO1lBQUlDLFdBQVU7OzhCQUNiLDhEQUFDRDtvQkFDQ0Usa0JBQWU7b0JBQ2ZDLHNCQUFtQjtvQkFDbkJDLGtCQUFlOztzQ0FFZiw4REFBQ0M7NEJBQUdKLFdBQVU7c0NBQTRCOzs7Ozs7c0NBQzFDLDhEQUFDRDs0QkFBSUMsV0FBVTtzQ0FDYiw0RUFBQ0s7Z0NBQ0NDLGNBQWE7Z0NBQ2JDLE1BQUs7Z0NBQ0xDLGFBQVk7Z0NBQ1pSLFdBQVU7Z0NBQ1ZTLFVBQVUsQ0FBQ0MsSUFBTWhCLFNBQVNGLGtGQUFjQSxDQUFDa0IsRUFBRUMsTUFBTSxDQUFDQyxLQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs4QkFLN0QsOERBQUNiO29CQUFJQyxXQUFVOzhCQUNiLDRFQUFDRDt3QkFBSUMsV0FBVTtrQ0FDYiw0RUFBQ2E7NEJBQUdiLFdBQVU7c0NBQ1hMLHNCQUFzQm1CLEdBQUcsQ0FBQyxDQUFDQyxxQkFDMUIsOERBQUNDO29DQUNDaEIsV0FBWTtvQ0FFWmlCLE1BQUs7OENBRUwsNEVBQUNsQjt3Q0FBSUMsV0FBVTs7MERBQ2IsOERBQUNEO2dEQUFJQyxXQUFVOzs7Ozs7MERBQ2YsOERBQUNEO2dEQUFJQyxXQUFVOztrRUFDYiw4REFBQ0Q7d0RBQUlDLFdBQVU7a0VBQ1plLEtBQUtsQixJQUFJOzs7Ozs7a0VBRVosOERBQUNFO3dEQUFJQyxXQUFVO2tFQUNaZSxLQUFLakIsT0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7O21DQVZkaUIsS0FBS25CLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNCOUI7R0E5RU1IOztRQUVhRixvREFBV0E7OztLQUZ4QkU7QUFnRk4sK0RBQWVBLGtCQUFrQkEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL2hlcm8vRmx5aW5nRnJvbUxvY2F0aW9uLmpzeD9jNzhhIl0sInNvdXJjZXNDb250ZW50IjpbIlxuJ3VzZSBjbGllbnQnXG5cbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VTZWxlY3RvciwgdXNlRGlzcGF0Y2ggfSBmcm9tIFwicmVhY3QtcmVkdXhcIjtcbmltcG9ydCB7IHNldEZseWluZ19mcm9tfSBmcm9tICcuLi8uLi9mZWF0dXJlcy9mbGlnaHQvZmxpZ2h0RmlsdGVyU2xpY2UnO1xuXG5cbmNvbnN0IEZseWluZ0Zyb21Mb2NhdGlvbiA9ICgpID0+IHtcblxuICBjb25zdCBkaXNwYXRjaCA9IHVzZURpc3BhdGNoKCk7XG4gIGNvbnN0IGxvY2F0aW9uU2VhcmNoQ29udGVudCA9IFtcbiAgICB7XG4gICAgICBpZDogMSxcbiAgICAgIG5hbWU6IFwiTG9uZG9uXCIsXG4gICAgICBhZGRyZXNzOiBcIkdyZWF0ZXIgTG9uZG9uLCBVbml0ZWQgS2luZ2RvbVwiLFxuICAgIH0sXG4gICAge1xuICAgICAgaWQ6IDIsXG4gICAgICBuYW1lOiBcIk5ldyBZb3JrXCIsXG4gICAgICBhZGRyZXNzOiBcIk5ldyBZb3JrIFN0YXRlLCBVbml0ZWQgU3RhdGVzXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogMyxcbiAgICAgIG5hbWU6IFwiUGFyaXNcIixcbiAgICAgIGFkZHJlc3M6IFwiRnJhbmNlXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogNCxcbiAgICAgIG5hbWU6IFwiTWFkcmlkXCIsXG4gICAgICBhZGRyZXNzOiBcIlNwYWluXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogNSxcbiAgICAgIG5hbWU6IFwiU2FudG9yaW5pXCIsXG4gICAgICBhZGRyZXNzOiBcIkdyZWVjZVwiLFxuICAgIH0sXG4gIF07XG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwic2VhcmNoTWVudS1sb2MgcHgtMjQgbGc6cHktMjAgbGc6cHgtMCBqcy1mb3JtLWRkIGpzLWxpdmVyU2VhcmNoXCI+XG4gICAgICAgIDxkaXZcbiAgICAgICAgICBkYXRhLWJzLXRvZ2dsZT1cImRyb3Bkb3duXCJcbiAgICAgICAgICBkYXRhLWJzLWF1dG8tY2xvc2U9XCJ0cnVlXCJcbiAgICAgICAgICBkYXRhLWJzLW9mZnNldD1cIjAsMjJcIlxuICAgICAgICA+XG4gICAgICAgICAgPGg0IGNsYXNzTmFtZT1cInRleHQtMTUgZnctNTAwIGxzLTIgbGgtMTZcIj5GbHlpbmcgRnJvbTwvaDQ+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LTE1IHRleHQtbGlnaHQtMSBscy0yIGxoLTE2XCI+XG4gICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgYXV0b0NvbXBsZXRlPVwib2ZmXCJcbiAgICAgICAgICAgICAgdHlwZT1cInNlYXJjaFwiXG4gICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiV2hlcmUgYXJlIHlvdSBnb2luZz9cIlxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJqcy1zZWFyY2gganMtZGQtZm9jdXNcIlxuICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IGRpc3BhdGNoKHNldEZseWluZ19mcm9tKGUudGFyZ2V0LnZhbHVlKSl9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNoYWRvdy0yIGRyb3Bkb3duLW1lbnUgbWluLXdpZHRoLTQwMFwiPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYmctd2hpdGUgcHgtMjAgcHktMjAgc206cHgtMCBzbTpweS0xNSByb3VuZGVkLTRcIj5cbiAgICAgICAgICAgIDx1bCBjbGFzc05hbWU9XCJ5LWdhcC01IGpzLXJlc3VsdHNcIj5cbiAgICAgICAgICAgICAge2xvY2F0aW9uU2VhcmNoQ29udGVudC5tYXAoKGl0ZW0pID0+IChcbiAgICAgICAgICAgICAgICA8bGlcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17YC1saW5rIGQtYmxvY2sgY29sLTEyIHRleHQtbGVmdCByb3VuZGVkLTQgcHgtMjAgcHktMTUganMtc2VhcmNoLW9wdGlvbiBtYi0xIGB9XG4gICAgICAgICAgICAgICAgICBrZXk9e2l0ZW0uaWR9XG4gICAgICAgICAgICAgICAgICByb2xlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImQtZmxleFwiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImljb24tbG9jYXRpb24tMiB0ZXh0LWxpZ2h0LTEgdGV4dC0yMCBwdC00XCIgLz5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtbC0xMFwiPlxuICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC0xNSBsaC0xMiBmdy01MDAganMtc2VhcmNoLW9wdGlvbi10YXJnZXRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtpdGVtLm5hbWV9XG4gICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LTE0IGxoLTEyIHRleHQtbGlnaHQtMSBtdC01XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICB7aXRlbS5hZGRyZXNzfVxuICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICAgICkpfVxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8Lz5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEZseWluZ0Zyb21Mb2NhdGlvbjtcbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZVNlbGVjdG9yIiwidXNlRGlzcGF0Y2giLCJzZXRGbHlpbmdfZnJvbSIsIkZseWluZ0Zyb21Mb2NhdGlvbiIsImRpc3BhdGNoIiwibG9jYXRpb25TZWFyY2hDb250ZW50IiwiaWQiLCJuYW1lIiwiYWRkcmVzcyIsImRpdiIsImNsYXNzTmFtZSIsImRhdGEtYnMtdG9nZ2xlIiwiZGF0YS1icy1hdXRvLWNsb3NlIiwiZGF0YS1icy1vZmZzZXQiLCJoNCIsImlucHV0IiwiYXV0b0NvbXBsZXRlIiwidHlwZSIsInBsYWNlaG9sZGVyIiwib25DaGFuZ2UiLCJlIiwidGFyZ2V0IiwidmFsdWUiLCJ1bCIsIm1hcCIsIml0ZW0iLCJsaSIsInJvbGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/hero/FlyingFromLocation.jsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/hero/FlyingToLocation.jsx":
/*!**********************************************!*\
  !*** ./components/hero/FlyingToLocation.jsx ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-redux */ \"(app-pages-browser)/./node_modules/react-redux/dist/react-redux.mjs\");\n/* harmony import */ var _features_flight_flightFilterSlice__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../features/flight/flightFilterSlice */ \"(app-pages-browser)/./features/flight/flightFilterSlice.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\nconst FlyingToLocation = ()=>{\n    _s();\n    const dispatch = (0,react_redux__WEBPACK_IMPORTED_MODULE_3__.useDispatch)();\n    const locationSearchContent = [\n        {\n            id: 1,\n            name: \"London\",\n            address: \"Greater London, United Kingdom\"\n        },\n        {\n            id: 2,\n            name: \"New York\",\n            address: \"New York State, United States\"\n        },\n        {\n            id: 3,\n            name: \"Paris\",\n            address: \"France\"\n        },\n        {\n            id: 4,\n            name: \"Madrid\",\n            address: \"Spain\"\n        },\n        {\n            id: 5,\n            name: \"Santorini\",\n            address: \"Greece\"\n        }\n    ];\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"searchMenu-loc px-24 lg:py-20 lg:px-0 js-form-dd js-liverSearch\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    \"data-bs-toggle\": \"dropdown\",\n                    \"data-bs-auto-close\": \"true\",\n                    \"data-bs-offset\": \"0,22\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h4\", {\n                            className: \"text-15 fw-500 ls-2 lh-16\",\n                            children: \"Flying To\"\n                        }, void 0, false, {\n                            fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/FlyingToLocation.jsx\",\n                            lineNumber: 48,\n                            columnNumber: 11\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"text-15 text-light-1 ls-2 lh-16\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                autoComplete: \"off\",\n                                type: \"search\",\n                                placeholder: \"Where are you going?\",\n                                className: \"js-search js-dd-focus\",\n                                onChange: (e)=>dispatch((0,_features_flight_flightFilterSlice__WEBPACK_IMPORTED_MODULE_2__.setFlying_to)(e.target.value))\n                            }, void 0, false, {\n                                fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/FlyingToLocation.jsx\",\n                                lineNumber: 50,\n                                columnNumber: 13\n                            }, undefined)\n                        }, void 0, false, {\n                            fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/FlyingToLocation.jsx\",\n                            lineNumber: 49,\n                            columnNumber: 11\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/FlyingToLocation.jsx\",\n                    lineNumber: 43,\n                    columnNumber: 9\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"shadow-2 dropdown-menu min-width-400\",\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"bg-white px-20 py-20 sm:px-0 sm:py-15 rounded-4\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                            className: \"y-gap-5 js-results\",\n                            children: locationSearchContent.map((item)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                    className: \"-link d-block col-12 text-left rounded-4 px-20 py-15 js-search-option mb-1\",\n                                    role: \"button\",\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"d-flex\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"icon-location-2 text-light-1 text-20 pt-4\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/FlyingToLocation.jsx\",\n                                                lineNumber: 70,\n                                                columnNumber: 21\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"ml-10\",\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                        className: \"text-15 lh-12 fw-500 js-search-option-target\",\n                                                        children: item.name\n                                                    }, void 0, false, {\n                                                        fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/FlyingToLocation.jsx\",\n                                                        lineNumber: 72,\n                                                        columnNumber: 23\n                                                    }, undefined),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                        className: \"text-14 lh-12 text-light-1 mt-5\",\n                                                        children: item.address\n                                                    }, void 0, false, {\n                                                        fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/FlyingToLocation.jsx\",\n                                                        lineNumber: 75,\n                                                        columnNumber: 23\n                                                    }, undefined)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/FlyingToLocation.jsx\",\n                                                lineNumber: 71,\n                                                columnNumber: 21\n                                            }, undefined)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/FlyingToLocation.jsx\",\n                                        lineNumber: 69,\n                                        columnNumber: 19\n                                    }, undefined)\n                                }, item.id, false, {\n                                    fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/FlyingToLocation.jsx\",\n                                    lineNumber: 64,\n                                    columnNumber: 17\n                                }, undefined))\n                        }, void 0, false, {\n                            fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/FlyingToLocation.jsx\",\n                            lineNumber: 62,\n                            columnNumber: 13\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/FlyingToLocation.jsx\",\n                        lineNumber: 61,\n                        columnNumber: 11\n                    }, undefined)\n                }, void 0, false, {\n                    fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/FlyingToLocation.jsx\",\n                    lineNumber: 60,\n                    columnNumber: 9\n                }, undefined)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/FlyingToLocation.jsx\",\n            lineNumber: 42,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false);\n};\n_s(FlyingToLocation, \"rgTLoBID190wEKCp9+G8W6F7A5M=\", false, function() {\n    return [\n        react_redux__WEBPACK_IMPORTED_MODULE_3__.useDispatch\n    ];\n});\n_c = FlyingToLocation;\n/* harmony default export */ __webpack_exports__[\"default\"] = (FlyingToLocation);\nvar _c;\n$RefreshReg$(_c, \"FlyingToLocation\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvaGVyby9GbHlpbmdUb0xvY2F0aW9uLmpzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUdpQztBQUNzQjtBQUNlO0FBR3RFLE1BQU1JLG1CQUFtQjs7SUFDdkIsTUFBTUMsV0FBV0gsd0RBQVdBO0lBRTVCLE1BQU1JLHdCQUF3QjtRQUM1QjtZQUNFQyxJQUFJO1lBQ0pDLE1BQU07WUFDTkMsU0FBUztRQUNYO1FBQ0E7WUFDRUYsSUFBSTtZQUNKQyxNQUFNO1lBQ05DLFNBQVM7UUFDWDtRQUNBO1lBQ0VGLElBQUk7WUFDSkMsTUFBTTtZQUNOQyxTQUFTO1FBQ1g7UUFDQTtZQUNFRixJQUFJO1lBQ0pDLE1BQU07WUFDTkMsU0FBUztRQUNYO1FBQ0E7WUFDRUYsSUFBSTtZQUNKQyxNQUFNO1lBQ05DLFNBQVM7UUFDWDtLQUNEO0lBRUQscUJBQ0U7a0JBQ0UsNEVBQUNDO1lBQUlDLFdBQVU7OzhCQUNiLDhEQUFDRDtvQkFDQ0Usa0JBQWU7b0JBQ2ZDLHNCQUFtQjtvQkFDbkJDLGtCQUFlOztzQ0FFZiw4REFBQ0M7NEJBQUdKLFdBQVU7c0NBQTRCOzs7Ozs7c0NBQzFDLDhEQUFDRDs0QkFBSUMsV0FBVTtzQ0FDYiw0RUFBQ0s7Z0NBQ0NDLGNBQWE7Z0NBQ2JDLE1BQUs7Z0NBQ0xDLGFBQVk7Z0NBQ1pSLFdBQVU7Z0NBQ1ZTLFVBQVUsQ0FBQ0MsSUFBS2hCLFNBQVNGLGdGQUFZQSxDQUFDa0IsRUFBRUMsTUFBTSxDQUFDQyxLQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs4QkFLMUQsOERBQUNiO29CQUFJQyxXQUFVOzhCQUNiLDRFQUFDRDt3QkFBSUMsV0FBVTtrQ0FDYiw0RUFBQ2E7NEJBQUdiLFdBQVU7c0NBQ1hMLHNCQUFzQm1CLEdBQUcsQ0FBQyxDQUFDQyxxQkFDMUIsOERBQUNDO29DQUNDaEIsV0FBWTtvQ0FFWmlCLE1BQUs7OENBRUwsNEVBQUNsQjt3Q0FBSUMsV0FBVTs7MERBQ2IsOERBQUNEO2dEQUFJQyxXQUFVOzs7Ozs7MERBQ2YsOERBQUNEO2dEQUFJQyxXQUFVOztrRUFDYiw4REFBQ0Q7d0RBQUlDLFdBQVU7a0VBQ1plLEtBQUtsQixJQUFJOzs7Ozs7a0VBRVosOERBQUNFO3dEQUFJQyxXQUFVO2tFQUNaZSxLQUFLakIsT0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7O21DQVZkaUIsS0FBS25CLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNCOUI7R0EvRU1IOztRQUNhRixvREFBV0E7OztLQUR4QkU7QUFpRk4sK0RBQWVBLGdCQUFnQkEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL2hlcm8vRmx5aW5nVG9Mb2NhdGlvbi5qc3g/YThlYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbid1c2UgY2xpZW50J1xuXG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlU2VsZWN0b3IsIHVzZURpc3BhdGNoIH0gZnJvbSBcInJlYWN0LXJlZHV4XCI7XG5pbXBvcnQgeyBzZXRGbHlpbmdfdG99IGZyb20gJy4uLy4uL2ZlYXR1cmVzL2ZsaWdodC9mbGlnaHRGaWx0ZXJTbGljZSc7XG5cblxuY29uc3QgRmx5aW5nVG9Mb2NhdGlvbiA9ICgpID0+IHtcbiAgY29uc3QgZGlzcGF0Y2ggPSB1c2VEaXNwYXRjaCgpO1xuXG4gIGNvbnN0IGxvY2F0aW9uU2VhcmNoQ29udGVudCA9IFtcbiAgICB7XG4gICAgICBpZDogMSxcbiAgICAgIG5hbWU6IFwiTG9uZG9uXCIsXG4gICAgICBhZGRyZXNzOiBcIkdyZWF0ZXIgTG9uZG9uLCBVbml0ZWQgS2luZ2RvbVwiLFxuICAgIH0sXG4gICAge1xuICAgICAgaWQ6IDIsXG4gICAgICBuYW1lOiBcIk5ldyBZb3JrXCIsXG4gICAgICBhZGRyZXNzOiBcIk5ldyBZb3JrIFN0YXRlLCBVbml0ZWQgU3RhdGVzXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogMyxcbiAgICAgIG5hbWU6IFwiUGFyaXNcIixcbiAgICAgIGFkZHJlc3M6IFwiRnJhbmNlXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogNCxcbiAgICAgIG5hbWU6IFwiTWFkcmlkXCIsXG4gICAgICBhZGRyZXNzOiBcIlNwYWluXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogNSxcbiAgICAgIG5hbWU6IFwiU2FudG9yaW5pXCIsXG4gICAgICBhZGRyZXNzOiBcIkdyZWVjZVwiLFxuICAgIH0sXG4gIF07XG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJzZWFyY2hNZW51LWxvYyBweC0yNCBsZzpweS0yMCBsZzpweC0wIGpzLWZvcm0tZGQganMtbGl2ZXJTZWFyY2hcIj5cbiAgICAgICAgPGRpdlxuICAgICAgICAgIGRhdGEtYnMtdG9nZ2xlPVwiZHJvcGRvd25cIlxuICAgICAgICAgIGRhdGEtYnMtYXV0by1jbG9zZT1cInRydWVcIlxuICAgICAgICAgIGRhdGEtYnMtb2Zmc2V0PVwiMCwyMlwiXG4gICAgICAgID5cbiAgICAgICAgICA8aDQgY2xhc3NOYW1lPVwidGV4dC0xNSBmdy01MDAgbHMtMiBsaC0xNlwiPkZseWluZyBUbzwvaDQ+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LTE1IHRleHQtbGlnaHQtMSBscy0yIGxoLTE2XCI+XG4gICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgYXV0b0NvbXBsZXRlPVwib2ZmXCJcbiAgICAgICAgICAgICAgdHlwZT1cInNlYXJjaFwiXG4gICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiV2hlcmUgYXJlIHlvdSBnb2luZz9cIlxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJqcy1zZWFyY2gganMtZGQtZm9jdXNcIlxuICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpPT4gZGlzcGF0Y2goc2V0Rmx5aW5nX3RvKGUudGFyZ2V0LnZhbHVlKSl9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNoYWRvdy0yIGRyb3Bkb3duLW1lbnUgbWluLXdpZHRoLTQwMFwiPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYmctd2hpdGUgcHgtMjAgcHktMjAgc206cHgtMCBzbTpweS0xNSByb3VuZGVkLTRcIj5cbiAgICAgICAgICAgIDx1bCBjbGFzc05hbWU9XCJ5LWdhcC01IGpzLXJlc3VsdHNcIj5cbiAgICAgICAgICAgICAge2xvY2F0aW9uU2VhcmNoQ29udGVudC5tYXAoKGl0ZW0pID0+IChcbiAgICAgICAgICAgICAgICA8bGlcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17YC1saW5rIGQtYmxvY2sgY29sLTEyIHRleHQtbGVmdCByb3VuZGVkLTQgcHgtMjAgcHktMTUganMtc2VhcmNoLW9wdGlvbiBtYi0xYH1cbiAgICAgICAgICAgICAgICAgIGtleT17aXRlbS5pZH1cbiAgICAgICAgICAgICAgICAgIHJvbGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZC1mbGV4XCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaWNvbi1sb2NhdGlvbi0yIHRleHQtbGlnaHQtMSB0ZXh0LTIwIHB0LTRcIiAvPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1sLTEwXCI+XG4gICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LTE1IGxoLTEyIGZ3LTUwMCBqcy1zZWFyY2gtb3B0aW9uLXRhcmdldFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAge2l0ZW0ubmFtZX1cbiAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtMTQgbGgtMTIgdGV4dC1saWdodC0xIG10LTVcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtpdGVtLmFkZHJlc3N9XG4gICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvPlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgRmx5aW5nVG9Mb2NhdGlvbjtcbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZVNlbGVjdG9yIiwidXNlRGlzcGF0Y2giLCJzZXRGbHlpbmdfdG8iLCJGbHlpbmdUb0xvY2F0aW9uIiwiZGlzcGF0Y2giLCJsb2NhdGlvblNlYXJjaENvbnRlbnQiLCJpZCIsIm5hbWUiLCJhZGRyZXNzIiwiZGl2IiwiY2xhc3NOYW1lIiwiZGF0YS1icy10b2dnbGUiLCJkYXRhLWJzLWF1dG8tY2xvc2UiLCJkYXRhLWJzLW9mZnNldCIsImg0IiwiaW5wdXQiLCJhdXRvQ29tcGxldGUiLCJ0eXBlIiwicGxhY2Vob2xkZXIiLCJvbkNoYW5nZSIsImUiLCJ0YXJnZXQiLCJ2YWx1ZSIsInVsIiwibWFwIiwiaXRlbSIsImxpIiwicm9sZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/hero/FlyingToLocation.jsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/hero/GuestSearch.jsx":
/*!*****************************************!*\
  !*** ./components/hero/GuestSearch.jsx ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-redux */ \"(app-pages-browser)/./node_modules/react-redux/dist/react-redux.mjs\");\n/* harmony import */ var _features_flight_flightFilterSlice__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../features/flight/flightFilterSlice */ \"(app-pages-browser)/./features/flight/flightFilterSlice.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\nconst counters = [\n    {\n        name: \"Adults\",\n        defaultValue: 2\n    },\n    {\n        name: \"Children\",\n        defaultValue: 0\n    },\n    {\n        name: \"Infants\",\n        defaultValue: 0\n    }\n];\nconst Counter = (param)=>{\n    let { name, defaultValue, onCounterChange } = param;\n    _s();\n    const [count, setCount] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(defaultValue);\n    const incrementCount = ()=>{\n        setCount(count + 1);\n        onCounterChange(name, count + 1);\n    };\n    const decrementCount = ()=>{\n        if (count > 0) {\n            setCount(count - 1);\n            onCounterChange(name, count - 1);\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"row y-gap-10 justify-between items-center\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"col-auto\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"text-15 lh-12 fw-500\",\n                                children: name\n                            }, void 0, false, {\n                                fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/GuestSearch.jsx\",\n                                lineNumber: 33,\n                                columnNumber: 11\n                            }, undefined),\n                            name === \"Children\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"text-14 lh-12 text-light-1 mt-5\",\n                                children: \"Ages 0 - 17\"\n                            }, void 0, false, {\n                                fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/GuestSearch.jsx\",\n                                lineNumber: 35,\n                                columnNumber: 13\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/GuestSearch.jsx\",\n                        lineNumber: 32,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"col-auto\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"d-flex items-center js-counter\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    className: \"button -outline-blue-1 text-blue-1 size-38 rounded-4 js-down\",\n                                    onClick: decrementCount,\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"i\", {\n                                        className: \"icon-minus text-12\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/GuestSearch.jsx\",\n                                        lineNumber: 45,\n                                        columnNumber: 15\n                                    }, undefined)\n                                }, void 0, false, {\n                                    fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/GuestSearch.jsx\",\n                                    lineNumber: 41,\n                                    columnNumber: 13\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"flex-center size-20 ml-15 mr-15\",\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"text-15 js-count\",\n                                        children: count\n                                    }, void 0, false, {\n                                        fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/GuestSearch.jsx\",\n                                        lineNumber: 49,\n                                        columnNumber: 15\n                                    }, undefined)\n                                }, void 0, false, {\n                                    fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/GuestSearch.jsx\",\n                                    lineNumber: 48,\n                                    columnNumber: 13\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    className: \"button -outline-blue-1 text-blue-1 size-38 rounded-4 js-up\",\n                                    onClick: incrementCount,\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"i\", {\n                                        className: \"icon-plus text-12\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/GuestSearch.jsx\",\n                                        lineNumber: 56,\n                                        columnNumber: 15\n                                    }, undefined)\n                                }, void 0, false, {\n                                    fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/GuestSearch.jsx\",\n                                    lineNumber: 52,\n                                    columnNumber: 13\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/GuestSearch.jsx\",\n                            lineNumber: 40,\n                            columnNumber: 11\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/GuestSearch.jsx\",\n                        lineNumber: 39,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/GuestSearch.jsx\",\n                lineNumber: 31,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"border-top-light mt-24 mb-24\"\n            }, void 0, false, {\n                fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/GuestSearch.jsx\",\n                lineNumber: 64,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true);\n};\n_s(Counter, \"xkJadGcOryQq8NwnRig7xPL3evE=\");\n_c = Counter;\nconst GuestSearch = ()=>{\n    _s1();\n    const [guestCounts, setGuestCounts] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        Adults: 2,\n        Children: 0,\n        Infants: 0\n    });\n    const dispatch = (0,react_redux__WEBPACK_IMPORTED_MODULE_3__.useDispatch)();\n    const handleCounterChange = (name, value)=>{\n        setGuestCounts((prevState)=>({\n                ...prevState,\n                [name]: value\n            }));\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        dispatch((0,_features_flight_flightFilterSlice__WEBPACK_IMPORTED_MODULE_2__.setTravellers)(guestCounts));\n    }, [\n        guestCounts\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"searchMenu-guests px-24 lg:py-20 lg:px-0 js-form-dd js-form-counters\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                \"data-bs-toggle\": \"dropdown\",\n                \"data-bs-auto-close\": \"outside\",\n                \"aria-expanded\": \"false\",\n                \"data-bs-offset\": \"0,22\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h4\", {\n                        className: \"text-15 fw-500 ls-2 lh-16\",\n                        children: \"Travellers\"\n                    }, void 0, false, {\n                        fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/GuestSearch.jsx\",\n                        lineNumber: 94,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"text-15 text-light-1 ls-2 lh-16\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"js-count-adult\",\n                                children: guestCounts.Adults\n                            }, void 0, false, {\n                                fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/GuestSearch.jsx\",\n                                lineNumber: 96,\n                                columnNumber: 11\n                            }, undefined),\n                            \" adults -\",\n                            \" \",\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"js-count-child\",\n                                children: guestCounts.Children\n                            }, void 0, false, {\n                                fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/GuestSearch.jsx\",\n                                lineNumber: 97,\n                                columnNumber: 11\n                            }, undefined),\n                            \" children -\",\n                            \" \",\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"js-count-infant\",\n                                children: guestCounts.Infants\n                            }, void 0, false, {\n                                fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/GuestSearch.jsx\",\n                                lineNumber: 98,\n                                columnNumber: 11\n                            }, undefined),\n                            \" infants\"\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/GuestSearch.jsx\",\n                        lineNumber: 95,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/GuestSearch.jsx\",\n                lineNumber: 88,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"shadow-2 dropdown-menu min-width-400\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"bg-white px-30 py-30 rounded-4 counter-box\",\n                    children: counters.map((counter)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Counter, {\n                            name: counter.name,\n                            defaultValue: counter.defaultValue,\n                            onCounterChange: handleCounterChange\n                        }, counter.name, false, {\n                            fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/GuestSearch.jsx\",\n                            lineNumber: 106,\n                            columnNumber: 13\n                        }, undefined))\n                }, void 0, false, {\n                    fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/GuestSearch.jsx\",\n                    lineNumber: 104,\n                    columnNumber: 9\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/GuestSearch.jsx\",\n                lineNumber: 103,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/GuestSearch.jsx\",\n        lineNumber: 87,\n        columnNumber: 5\n    }, undefined);\n};\n_s1(GuestSearch, \"2USR+RQxk/9GLaEN0suEYGPUD2o=\", false, function() {\n    return [\n        react_redux__WEBPACK_IMPORTED_MODULE_3__.useDispatch\n    ];\n});\n_c1 = GuestSearch;\n/* harmony default export */ __webpack_exports__[\"default\"] = (GuestSearch);\nvar _c, _c1;\n$RefreshReg$(_c, \"Counter\");\n$RefreshReg$(_c1, \"GuestSearch\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvaGVyby9HdWVzdFNlYXJjaC5qc3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFFbUQ7QUFDSTtBQUNlO0FBR3RFLE1BQU1NLFdBQVc7SUFDZjtRQUFFQyxNQUFNO1FBQVVDLGNBQWM7SUFBRTtJQUNsQztRQUFFRCxNQUFNO1FBQVlDLGNBQWM7SUFBRTtJQUNwQztRQUFFRCxNQUFNO1FBQVdDLGNBQWM7SUFBRTtDQUNwQztBQUVELE1BQU1DLFVBQVU7UUFBQyxFQUFFRixJQUFJLEVBQUVDLFlBQVksRUFBRUUsZUFBZSxFQUFFOztJQUN0RCxNQUFNLENBQUNDLE9BQU9DLFNBQVMsR0FBR1YsK0NBQVFBLENBQUNNO0lBRW5DLE1BQU1LLGlCQUFpQjtRQUNyQkQsU0FBU0QsUUFBUTtRQUNqQkQsZ0JBQWdCSCxNQUFNSSxRQUFRO0lBQ2hDO0lBRUEsTUFBTUcsaUJBQWlCO1FBQ3JCLElBQUlILFFBQVEsR0FBRztZQUNiQyxTQUFTRCxRQUFRO1lBQ2pCRCxnQkFBZ0JILE1BQU1JLFFBQVE7UUFDaEM7SUFDRjtJQUVBLHFCQUNFOzswQkFDRSw4REFBQ0k7Z0JBQUlDLFdBQVU7O2tDQUNiLDhEQUFDRDt3QkFBSUMsV0FBVTs7MENBQ2IsOERBQUNEO2dDQUFJQyxXQUFVOzBDQUF3QlQ7Ozs7Ozs0QkFDdENBLFNBQVMsNEJBQ1IsOERBQUNRO2dDQUFJQyxXQUFVOzBDQUFrQzs7Ozs7Ozs7Ozs7O2tDQUlyRCw4REFBQ0Q7d0JBQUlDLFdBQVU7a0NBQ2IsNEVBQUNEOzRCQUFJQyxXQUFVOzs4Q0FDYiw4REFBQ0M7b0NBQ0NELFdBQVU7b0NBQ1ZFLFNBQVNKOzhDQUVULDRFQUFDSzt3Q0FBRUgsV0FBVTs7Ozs7Ozs7Ozs7OENBR2YsOERBQUNEO29DQUFJQyxXQUFVOzhDQUNiLDRFQUFDRDt3Q0FBSUMsV0FBVTtrREFBb0JMOzs7Ozs7Ozs7Ozs4Q0FHckMsOERBQUNNO29DQUNDRCxXQUFVO29DQUNWRSxTQUFTTDs4Q0FFVCw0RUFBQ007d0NBQUVILFdBQVU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBUXJCLDhEQUFDRDtnQkFBSUMsV0FBVTs7Ozs7Ozs7QUFHckI7R0FyRE1QO0tBQUFBO0FBdUROLE1BQU1XLGNBQWM7O0lBQ2xCLE1BQU0sQ0FBQ0MsYUFBYUMsZUFBZSxHQUFHcEIsK0NBQVFBLENBQUM7UUFDN0NxQixRQUFRO1FBQ1JDLFVBQVU7UUFDVkMsU0FBUztJQUNYO0lBRUEsTUFBTUMsV0FBV3RCLHdEQUFXQTtJQUU1QixNQUFNdUIsc0JBQXNCLENBQUNwQixNQUFNcUI7UUFDakNOLGVBQWUsQ0FBQ08sWUFBZTtnQkFBRSxHQUFHQSxTQUFTO2dCQUFFLENBQUN0QixLQUFLLEVBQUVxQjtZQUFNO0lBQy9EO0lBQ0EzQixnREFBU0EsQ0FBQztRQUNSeUIsU0FBU3JCLGlGQUFhQSxDQUFDZ0I7SUFDekIsR0FBRztRQUFDQTtLQUFZO0lBR2hCLHFCQUNFLDhEQUFDTjtRQUFJQyxXQUFVOzswQkFDYiw4REFBQ0Q7Z0JBQ0NlLGtCQUFlO2dCQUNmQyxzQkFBbUI7Z0JBQ25CQyxpQkFBYztnQkFDZEMsa0JBQWU7O2tDQUVmLDhEQUFDQzt3QkFBR2xCLFdBQVU7a0NBQTRCOzs7Ozs7a0NBQzFDLDhEQUFDRDt3QkFBSUMsV0FBVTs7MENBQ2IsOERBQUNtQjtnQ0FBS25CLFdBQVU7MENBQWtCSyxZQUFZRSxNQUFNOzs7Ozs7NEJBQVE7NEJBQVU7MENBQ3RFLDhEQUFDWTtnQ0FBS25CLFdBQVU7MENBQWtCSyxZQUFZRyxRQUFROzs7Ozs7NEJBQVE7NEJBQVk7MENBQzFFLDhEQUFDVztnQ0FBS25CLFdBQVU7MENBQW1CSyxZQUFZSSxPQUFPOzs7Ozs7NEJBQVE7Ozs7Ozs7Ozs7Ozs7MEJBS2xFLDhEQUFDVjtnQkFBSUMsV0FBVTswQkFDYiw0RUFBQ0Q7b0JBQUlDLFdBQVU7OEJBQ1pWLFNBQVM4QixHQUFHLENBQUMsQ0FBQ0Msd0JBQ2IsOERBQUM1Qjs0QkFFQ0YsTUFBTThCLFFBQVE5QixJQUFJOzRCQUNsQkMsY0FBYzZCLFFBQVE3QixZQUFZOzRCQUNsQ0UsaUJBQWlCaUI7MkJBSFpVLFFBQVE5QixJQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFVL0I7SUFoRE1hOztRQU9haEIsb0RBQVdBOzs7TUFQeEJnQjtBQWtETiwrREFBZUEsV0FBV0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL2hlcm8vR3Vlc3RTZWFyY2guanN4PzVkZDUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VTZWxlY3RvciwgdXNlRGlzcGF0Y2ggfSBmcm9tIFwicmVhY3QtcmVkdXhcIjtcbmltcG9ydCB7c2V0VHJhdmVsbGVyc30gZnJvbSAnLi4vLi4vZmVhdHVyZXMvZmxpZ2h0L2ZsaWdodEZpbHRlclNsaWNlJztcblxuXG5jb25zdCBjb3VudGVycyA9IFtcbiAgeyBuYW1lOiBcIkFkdWx0c1wiLCBkZWZhdWx0VmFsdWU6IDIgfSxcbiAgeyBuYW1lOiBcIkNoaWxkcmVuXCIsIGRlZmF1bHRWYWx1ZTogMCB9LFxuICB7IG5hbWU6IFwiSW5mYW50c1wiLCBkZWZhdWx0VmFsdWU6IDAgfSxcbl07XG5cbmNvbnN0IENvdW50ZXIgPSAoeyBuYW1lLCBkZWZhdWx0VmFsdWUsIG9uQ291bnRlckNoYW5nZSB9KSA9PiB7XG4gIGNvbnN0IFtjb3VudCwgc2V0Q291bnRdID0gdXNlU3RhdGUoZGVmYXVsdFZhbHVlKTtcblxuICBjb25zdCBpbmNyZW1lbnRDb3VudCA9ICgpID0+IHtcbiAgICBzZXRDb3VudChjb3VudCArIDEpO1xuICAgIG9uQ291bnRlckNoYW5nZShuYW1lLCBjb3VudCArIDEpO1xuICB9O1xuXG4gIGNvbnN0IGRlY3JlbWVudENvdW50ID0gKCkgPT4ge1xuICAgIGlmIChjb3VudCA+IDApIHtcbiAgICAgIHNldENvdW50KGNvdW50IC0gMSk7XG4gICAgICBvbkNvdW50ZXJDaGFuZ2UobmFtZSwgY291bnQgLSAxKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJyb3cgeS1nYXAtMTAganVzdGlmeS1iZXR3ZWVuIGl0ZW1zLWNlbnRlclwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbC1hdXRvXCI+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LTE1IGxoLTEyIGZ3LTUwMFwiPntuYW1lfTwvZGl2PlxuICAgICAgICAgIHtuYW1lID09PSBcIkNoaWxkcmVuXCIgJiYgKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LTE0IGxoLTEyIHRleHQtbGlnaHQtMSBtdC01XCI+QWdlcyAwIC0gMTc8L2Rpdj5cbiAgICAgICAgICApfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgey8qIEVuZCAuY29sLWF1dG8gKi99XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29sLWF1dG9cIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImQtZmxleCBpdGVtcy1jZW50ZXIganMtY291bnRlclwiPlxuICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJidXR0b24gLW91dGxpbmUtYmx1ZS0xIHRleHQtYmx1ZS0xIHNpemUtMzggcm91bmRlZC00IGpzLWRvd25cIlxuICAgICAgICAgICAgICBvbkNsaWNrPXtkZWNyZW1lbnRDb3VudH1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPGkgY2xhc3NOYW1lPVwiaWNvbi1taW51cyB0ZXh0LTEyXCIgLz5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgey8qIGRlY3JlbWVudCBidXR0b24gKi99XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXgtY2VudGVyIHNpemUtMjAgbWwtMTUgbXItMTVcIj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LTE1IGpzLWNvdW50XCI+e2NvdW50fTwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICB7LyogY291bnRlciB0ZXh0ICovfVxuICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJidXR0b24gLW91dGxpbmUtYmx1ZS0xIHRleHQtYmx1ZS0xIHNpemUtMzggcm91bmRlZC00IGpzLXVwXCJcbiAgICAgICAgICAgICAgb25DbGljaz17aW5jcmVtZW50Q291bnR9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDxpIGNsYXNzTmFtZT1cImljb24tcGx1cyB0ZXh0LTEyXCIgLz5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgey8qIGluY3JlbWVudCBidXR0b24gKi99XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICB7LyogRW5kIC5jb2wtYXV0byAqL31cbiAgICAgIDwvZGl2PlxuICAgICAgey8qIEVuZCAucm93ICovfVxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJib3JkZXItdG9wLWxpZ2h0IG10LTI0IG1iLTI0XCIgLz5cbiAgICA8Lz5cbiAgKTtcbn07XG5cbmNvbnN0IEd1ZXN0U2VhcmNoID0gKCkgPT4ge1xuICBjb25zdCBbZ3Vlc3RDb3VudHMsIHNldEd1ZXN0Q291bnRzXSA9IHVzZVN0YXRlKHtcbiAgICBBZHVsdHM6IDIsXG4gICAgQ2hpbGRyZW46IDAsXG4gICAgSW5mYW50czogMCwgLy8g4pyFIEZpeGVkOiBFbnN1cmluZyBcIkluZmFudHNcIiBpcyBwYXJ0IG9mIHN0YXRlXG4gIH0pO1xuXG4gIGNvbnN0IGRpc3BhdGNoID0gdXNlRGlzcGF0Y2goKTtcblxuICBjb25zdCBoYW5kbGVDb3VudGVyQ2hhbmdlID0gKG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgc2V0R3Vlc3RDb3VudHMoKHByZXZTdGF0ZSkgPT4gKHsgLi4ucHJldlN0YXRlLCBbbmFtZV06IHZhbHVlIH0pKTtcbiAgfTtcbiAgdXNlRWZmZWN0KCgpPT57XG4gICAgZGlzcGF0Y2goc2V0VHJhdmVsbGVycyhndWVzdENvdW50cykpO1xuICB9LCBbZ3Vlc3RDb3VudHNdKTtcbiAgXG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInNlYXJjaE1lbnUtZ3Vlc3RzIHB4LTI0IGxnOnB5LTIwIGxnOnB4LTAganMtZm9ybS1kZCBqcy1mb3JtLWNvdW50ZXJzXCI+XG4gICAgICA8ZGl2XG4gICAgICAgIGRhdGEtYnMtdG9nZ2xlPVwiZHJvcGRvd25cIlxuICAgICAgICBkYXRhLWJzLWF1dG8tY2xvc2U9XCJvdXRzaWRlXCJcbiAgICAgICAgYXJpYS1leHBhbmRlZD1cImZhbHNlXCJcbiAgICAgICAgZGF0YS1icy1vZmZzZXQ9XCIwLDIyXCJcbiAgICAgID5cbiAgICAgICAgPGg0IGNsYXNzTmFtZT1cInRleHQtMTUgZnctNTAwIGxzLTIgbGgtMTZcIj5UcmF2ZWxsZXJzPC9oND5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LTE1IHRleHQtbGlnaHQtMSBscy0yIGxoLTE2XCI+XG4gICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwianMtY291bnQtYWR1bHRcIj57Z3Vlc3RDb3VudHMuQWR1bHRzfTwvc3Bhbj4gYWR1bHRzIC17XCIgXCJ9XG4gICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwianMtY291bnQtY2hpbGRcIj57Z3Vlc3RDb3VudHMuQ2hpbGRyZW59PC9zcGFuPiBjaGlsZHJlbiAte1wiIFwifVxuICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImpzLWNvdW50LWluZmFudFwiPntndWVzdENvdW50cy5JbmZhbnRzfTwvc3Bhbj4gaW5mYW50c1xuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAgey8qIEVuZCBndWVzdCAqL31cblxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJzaGFkb3ctMiBkcm9wZG93bi1tZW51IG1pbi13aWR0aC00MDBcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJiZy13aGl0ZSBweC0zMCBweS0zMCByb3VuZGVkLTQgY291bnRlci1ib3hcIj5cbiAgICAgICAgICB7Y291bnRlcnMubWFwKChjb3VudGVyKSA9PiAoXG4gICAgICAgICAgICA8Q291bnRlclxuICAgICAgICAgICAgICBrZXk9e2NvdW50ZXIubmFtZX1cbiAgICAgICAgICAgICAgbmFtZT17Y291bnRlci5uYW1lfVxuICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU9e2NvdW50ZXIuZGVmYXVsdFZhbHVlfVxuICAgICAgICAgICAgICBvbkNvdW50ZXJDaGFuZ2U9e2hhbmRsZUNvdW50ZXJDaGFuZ2V9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICkpfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgR3Vlc3RTZWFyY2g7XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsInVzZVNlbGVjdG9yIiwidXNlRGlzcGF0Y2giLCJzZXRUcmF2ZWxsZXJzIiwiY291bnRlcnMiLCJuYW1lIiwiZGVmYXVsdFZhbHVlIiwiQ291bnRlciIsIm9uQ291bnRlckNoYW5nZSIsImNvdW50Iiwic2V0Q291bnQiLCJpbmNyZW1lbnRDb3VudCIsImRlY3JlbWVudENvdW50IiwiZGl2IiwiY2xhc3NOYW1lIiwiYnV0dG9uIiwib25DbGljayIsImkiLCJHdWVzdFNlYXJjaCIsImd1ZXN0Q291bnRzIiwic2V0R3Vlc3RDb3VudHMiLCJBZHVsdHMiLCJDaGlsZHJlbiIsIkluZmFudHMiLCJkaXNwYXRjaCIsImhhbmRsZUNvdW50ZXJDaGFuZ2UiLCJ2YWx1ZSIsInByZXZTdGF0ZSIsImRhdGEtYnMtdG9nZ2xlIiwiZGF0YS1icy1hdXRvLWNsb3NlIiwiYXJpYS1leHBhbmRlZCIsImRhdGEtYnMtb2Zmc2V0IiwiaDQiLCJzcGFuIiwibWFwIiwiY291bnRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/hero/GuestSearch.jsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/hero/MainFilterSearchBox.jsx":
/*!*************************************************!*\
  !*** ./components/hero/MainFilterSearchBox.jsx ***!
  \*************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _DateSearch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DateSearch */ \"(app-pages-browser)/./components/hero/DateSearch.jsx\");\n/* harmony import */ var _GuestSearch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GuestSearch */ \"(app-pages-browser)/./components/hero/GuestSearch.jsx\");\n/* harmony import */ var _FlyingFromLocation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./FlyingFromLocation */ \"(app-pages-browser)/./components/hero/FlyingFromLocation.jsx\");\n/* harmony import */ var _FlyingToLocation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./FlyingToLocation */ \"(app-pages-browser)/./components/hero/FlyingToLocation.jsx\");\n/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! react-redux */ \"(app-pages-browser)/./node_modules/react-redux/dist/react-redux.mjs\");\n/* harmony import */ var _features_flight_flightFilterSlice__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../features/flight/flightFilterSlice */ \"(app-pages-browser)/./features/flight/flightFilterSlice.js\");\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var js_cookie__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! js-cookie */ \"(app-pages-browser)/./node_modules/js-cookie/dist/js.cookie.mjs\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n\nconst MainFilterSearchBox = ()=>{\n    _s();\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_6__.useRouter)();\n    const dispatch = (0,react_redux__WEBPACK_IMPORTED_MODULE_9__.useDispatch)();\n    const [Auth, setAuth] = (0,react__WEBPACK_IMPORTED_MODULE_7__.useState)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_7__.useEffect)(()=>{\n        if (js_cookie__WEBPACK_IMPORTED_MODULE_8__[\"default\"].get(\"jwt_token\")) {\n            setAuth(true);\n        }\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"mainSearch -col-4 -w-1070 bg-white shadow-1 rounded-4 pr-20 py-20 lg:px-20 lg:pt-5 lg:pb-20 mt-15\",\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"button-grid items-center\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_FlyingFromLocation__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {}, void 0, false, {\n                        fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/MainFilterSearchBox.jsx\",\n                        lineNumber: 28,\n                        columnNumber: 11\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_FlyingToLocation__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {}, void 0, false, {\n                        fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/MainFilterSearchBox.jsx\",\n                        lineNumber: 31,\n                        columnNumber: 11\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"searchMenu-date px-30 lg:py-20 lg:px-0 js-form-dd js-calendar\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h4\", {\n                                    className: \"text-15 fw-500 ls-2 lh-16\",\n                                    children: \"Depart\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/MainFilterSearchBox.jsx\",\n                                    lineNumber: 36,\n                                    columnNumber: 15\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_DateSearch__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n                                    setDate: (date)=>dispatch((0,_features_flight_flightFilterSlice__WEBPACK_IMPORTED_MODULE_5__.setDepart_date)(date))\n                                }, void 0, false, {\n                                    fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/MainFilterSearchBox.jsx\",\n                                    lineNumber: 37,\n                                    columnNumber: 15\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/MainFilterSearchBox.jsx\",\n                            lineNumber: 35,\n                            columnNumber: 13\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/MainFilterSearchBox.jsx\",\n                        lineNumber: 34,\n                        columnNumber: 11\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"searchMenu-date px-30 lg:py-20 lg:px-0 js-form-dd js-calendar\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h4\", {\n                                    className: \"text-15 fw-500 ls-2 lh-16\",\n                                    children: \"Return\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/MainFilterSearchBox.jsx\",\n                                    lineNumber: 44,\n                                    columnNumber: 15\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_DateSearch__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n                                    setDate: (date)=>dispatch((0,_features_flight_flightFilterSlice__WEBPACK_IMPORTED_MODULE_5__.setReturn_date)(date))\n                                }, void 0, false, {\n                                    fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/MainFilterSearchBox.jsx\",\n                                    lineNumber: 45,\n                                    columnNumber: 15\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/MainFilterSearchBox.jsx\",\n                            lineNumber: 43,\n                            columnNumber: 13\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/MainFilterSearchBox.jsx\",\n                        lineNumber: 42,\n                        columnNumber: 11\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_GuestSearch__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {}, void 0, false, {\n                        fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/MainFilterSearchBox.jsx\",\n                        lineNumber: 50,\n                        columnNumber: 11\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"button-item\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                            className: \"mainSearch__submit button -blue-1 py-15 px-35 h-60 col-12 rounded-4 bg-dark-1 text-white\",\n                            onClick: ()=>{\n                                Auth ? router.push(\"/flight-list-v1\") : router.push(\"/login\");\n                            },\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"i\", {\n                                    className: \"icon-search text-20 mr-10\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/MainFilterSearchBox.jsx\",\n                                    lineNumber: 57,\n                                    columnNumber: 15\n                                }, undefined),\n                                \"Search\"\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/MainFilterSearchBox.jsx\",\n                            lineNumber: 54,\n                            columnNumber: 13\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/MainFilterSearchBox.jsx\",\n                        lineNumber: 53,\n                        columnNumber: 11\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/MainFilterSearchBox.jsx\",\n                lineNumber: 27,\n                columnNumber: 9\n            }, undefined)\n        }, void 0, false, {\n            fileName: \"/Users/sirishasadhu/Desktop/projects/Full-stack-projects/flight-bookings/Frontend/components/hero/MainFilterSearchBox.jsx\",\n            lineNumber: 26,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false);\n};\n_s(MainFilterSearchBox, \"R1aU1faRv1V1c6rGRGJQLwNfQCk=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_6__.useRouter,\n        react_redux__WEBPACK_IMPORTED_MODULE_9__.useDispatch\n    ];\n});\n_c = MainFilterSearchBox;\n/* harmony default export */ __webpack_exports__[\"default\"] = (MainFilterSearchBox);\nvar _c;\n$RefreshReg$(_c, \"MainFilterSearchBox\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvaGVyby9NYWluRmlsdGVyU2VhcmNoQm94LmpzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUVzQztBQUNFO0FBQ2M7QUFDSjtBQUVLO0FBQ2lDO0FBQzVDO0FBQ0E7QUFDWjtBQUdoQyxNQUFNWSxzQkFBc0I7O0lBQzFCLE1BQU1DLFNBQVNMLDBEQUFTQTtJQUN4QixNQUFNTSxXQUFXVCx3REFBV0E7SUFDNUIsTUFBTSxDQUFDVSxNQUFNQyxRQUFRLEdBQUdOLCtDQUFRQSxDQUFDO0lBRWpDRCxnREFBU0EsQ0FBQztRQUNOLElBQUdFLGlEQUFPQSxDQUFDTSxHQUFHLENBQUMsY0FBYTtZQUFDRCxRQUFRO1FBQU07SUFDN0MsR0FBRSxFQUFFO0lBRU4scUJBQ0U7a0JBQ0UsNEVBQUNFO1lBQUlDLFdBQVU7c0JBQ2IsNEVBQUNEO2dCQUFJQyxXQUFVOztrQ0FDYiw4REFBQ2pCLDJEQUFrQkE7Ozs7O2tDQUduQiw4REFBQ0MseURBQWdCQTs7Ozs7a0NBR2pCLDhEQUFDZTt3QkFBSUMsV0FBVTtrQ0FDYiw0RUFBQ0Q7OzhDQUNDLDhEQUFDRTtvQ0FBR0QsV0FBVTs4Q0FBNEI7Ozs7Ozs4Q0FDMUMsOERBQUNuQixtREFBVUE7b0NBQUNxQixTQUFTLENBQUNDLE9BQVFSLFNBQVNSLGtGQUFjQSxDQUFDZ0I7Ozs7Ozs7Ozs7Ozs7Ozs7O2tDQUsxRCw4REFBQ0o7d0JBQUlDLFdBQVU7a0NBQ2IsNEVBQUNEOzs4Q0FDQyw4REFBQ0U7b0NBQUdELFdBQVU7OENBQTRCOzs7Ozs7OENBQzFDLDhEQUFDbkIsbURBQVVBO29DQUFDcUIsU0FBUyxDQUFDQyxPQUFRUixTQUFTUCxrRkFBY0EsQ0FBQ2U7Ozs7Ozs7Ozs7Ozs7Ozs7O2tDQUsxRCw4REFBQ3JCLG9EQUFXQTs7Ozs7a0NBR1osOERBQUNpQjt3QkFBSUMsV0FBVTtrQ0FDYiw0RUFBQ0k7NEJBQ0NKLFdBQVU7NEJBQ1ZLLFNBQVM7Z0NBQU9ULE9BQU1GLE9BQU9ZLElBQUksQ0FBQyxxQkFBb0JaLE9BQU9ZLElBQUksQ0FBQzs0QkFBUzs7OENBQzNFLDhEQUFDQztvQ0FBRVAsV0FBVTs7Ozs7O2dDQUE4Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBVXpEO0dBcERNUDs7UUFDV0osc0RBQVNBO1FBQ1BILG9EQUFXQTs7O0tBRnhCTztBQXNETiwrREFBZUEsbUJBQW1CQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvaGVyby9NYWluRmlsdGVyU2VhcmNoQm94LmpzeD8xN2MyIl0sInNvdXJjZXNDb250ZW50IjpbIlxuJ3VzZSBjbGllbnQnXG5pbXBvcnQgRGF0ZVNlYXJjaCBmcm9tIFwiLi9EYXRlU2VhcmNoXCI7XG5pbXBvcnQgR3Vlc3RTZWFyY2ggZnJvbSBcIi4vR3Vlc3RTZWFyY2hcIjtcbmltcG9ydCBGbHlpbmdGcm9tTG9jYXRpb24gZnJvbSBcIi4vRmx5aW5nRnJvbUxvY2F0aW9uXCI7XG5pbXBvcnQgRmx5aW5nVG9Mb2NhdGlvbiBmcm9tIFwiLi9GbHlpbmdUb0xvY2F0aW9uXCI7XG5cbmltcG9ydCB7IHVzZVNlbGVjdG9yLCB1c2VEaXNwYXRjaCB9IGZyb20gXCJyZWFjdC1yZWR1eFwiO1xuaW1wb3J0IHsgc2V0RGVwYXJ0X2RhdGUsIHNldFJldHVybl9kYXRlfSBmcm9tICcuLi8uLi9mZWF0dXJlcy9mbGlnaHQvZmxpZ2h0RmlsdGVyU2xpY2UnO1xuaW1wb3J0IHsgdXNlUm91dGVyIH0gZnJvbSBcIm5leHQvbmF2aWdhdGlvblwiO1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IENvb2tpZXMgZnJvbSBcImpzLWNvb2tpZVwiO1xuXG5cbmNvbnN0IE1haW5GaWx0ZXJTZWFyY2hCb3ggPSAoKSA9PiB7XG4gIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpO1xuICBjb25zdCBkaXNwYXRjaCA9IHVzZURpc3BhdGNoKCk7XG4gIGNvbnN0IFtBdXRoLCBzZXRBdXRoXSA9IHVzZVN0YXRlKGZhbHNlKVxuXG4gIHVzZUVmZmVjdCgoKT0+e1xuICAgICAgaWYoQ29va2llcy5nZXQoJ2p3dF90b2tlbicpKXtzZXRBdXRoKHRydWUpIH1cbiAgICB9LFtdKVxuXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwibWFpblNlYXJjaCAtY29sLTQgLXctMTA3MCBiZy13aGl0ZSBzaGFkb3ctMSByb3VuZGVkLTQgcHItMjAgcHktMjAgbGc6cHgtMjAgbGc6cHQtNSBsZzpwYi0yMCBtdC0xNVwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJ1dHRvbi1ncmlkIGl0ZW1zLWNlbnRlclwiPlxuICAgICAgICAgIDxGbHlpbmdGcm9tTG9jYXRpb24gLz5cbiAgICAgICAgICB7LyogRW5kIExvY2F0aW9uIEZseWluZyBGcm9tICovfVxuXG4gICAgICAgICAgPEZseWluZ1RvTG9jYXRpb24gLz5cbiAgICAgICAgICB7LyogRW5kIExvY2F0aW9uIEZseWluZyBUbyAqL31cblxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic2VhcmNoTWVudS1kYXRlIHB4LTMwIGxnOnB5LTIwIGxnOnB4LTAganMtZm9ybS1kZCBqcy1jYWxlbmRhclwiPlxuICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgPGg0IGNsYXNzTmFtZT1cInRleHQtMTUgZnctNTAwIGxzLTIgbGgtMTZcIj5EZXBhcnQ8L2g0PlxuICAgICAgICAgICAgICA8RGF0ZVNlYXJjaCBzZXREYXRlPXsoZGF0ZSk9PiBkaXNwYXRjaChzZXREZXBhcnRfZGF0ZShkYXRlKSl9IC8+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICB7LyogRW5kIERlcGFydCAqL31cblxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic2VhcmNoTWVudS1kYXRlIHB4LTMwIGxnOnB5LTIwIGxnOnB4LTAganMtZm9ybS1kZCBqcy1jYWxlbmRhclwiPlxuICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgPGg0IGNsYXNzTmFtZT1cInRleHQtMTUgZnctNTAwIGxzLTIgbGgtMTZcIj5SZXR1cm48L2g0PlxuICAgICAgICAgICAgICA8RGF0ZVNlYXJjaCBzZXREYXRlPXsoZGF0ZSk9PiBkaXNwYXRjaChzZXRSZXR1cm5fZGF0ZShkYXRlKSl9Lz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIHsvKiBFbmQgUmV0dXJuICovfVxuXG4gICAgICAgICAgPEd1ZXN0U2VhcmNoIC8+XG4gICAgICAgICAgey8qIEVuZCBndWVzdCAqL31cblxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYnV0dG9uLWl0ZW1cIj5cbiAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwibWFpblNlYXJjaF9fc3VibWl0IGJ1dHRvbiAtYmx1ZS0xIHB5LTE1IHB4LTM1IGgtNjAgY29sLTEyIHJvdW5kZWQtNCBiZy1kYXJrLTEgdGV4dC13aGl0ZVwiXG4gICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHtBdXRoPyByb3V0ZXIucHVzaChcIi9mbGlnaHQtbGlzdC12MVwiKTogcm91dGVyLnB1c2goJy9sb2dpbicpfX0+XG4gICAgICAgICAgICAgIDxpIGNsYXNzTmFtZT1cImljb24tc2VhcmNoIHRleHQtMjAgbXItMTBcIiAvPlxuICAgICAgICAgICAgICBTZWFyY2hcbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIHsvKiBFbmQgc2VhcmNoIGJ1dHRvbl9pdGVtICovfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAgey8qIEVuZCAubWFpblNlYXJjaCAqL31cbiAgICA8Lz5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IE1haW5GaWx0ZXJTZWFyY2hCb3g7XG4iXSwibmFtZXMiOlsiRGF0ZVNlYXJjaCIsIkd1ZXN0U2VhcmNoIiwiRmx5aW5nRnJvbUxvY2F0aW9uIiwiRmx5aW5nVG9Mb2NhdGlvbiIsInVzZVNlbGVjdG9yIiwidXNlRGlzcGF0Y2giLCJzZXREZXBhcnRfZGF0ZSIsInNldFJldHVybl9kYXRlIiwidXNlUm91dGVyIiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJDb29raWVzIiwiTWFpbkZpbHRlclNlYXJjaEJveCIsInJvdXRlciIsImRpc3BhdGNoIiwiQXV0aCIsInNldEF1dGgiLCJnZXQiLCJkaXYiLCJjbGFzc05hbWUiLCJoNCIsInNldERhdGUiLCJkYXRlIiwiYnV0dG9uIiwib25DbGljayIsInB1c2giLCJpIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/hero/MainFilterSearchBox.jsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./data/mainMenuData.js":
/*!******************************!*\
  !*** ./data/mainMenuData.js ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dashboardItems: function() { return /* binding */ dashboardItems; },\n/* harmony export */   pageItems: function() { return /* binding */ pageItems; }\n/* harmony export */ });\nconst pageItems = [\n    {\n        name: \"Login\",\n        routePath: \"/login\"\n    },\n    {\n        name: \"Register\",\n        routePath: \"/signup\"\n    },\n    {\n        name: \"Booking-Page\",\n        routePath: \"/booking-page\"\n    }\n];\nconst dashboardItems = [\n    {\n        name: \"Dashboard\",\n        routePath: \"/dashboard/db-dashboard\"\n    },\n    {\n        name: \"Booking History\",\n        routePath: \"/dashboard/db-booking\"\n    },\n    {\n        name: \"Settings\",\n        routePath: \"/dashboard/db-settings\"\n    },\n    {\n        name: \"Logout\",\n        routePath: \"/login\"\n    }\n];\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2RhdGEvbWFpbk1lbnVEYXRhLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQ08sTUFBTUEsWUFBWTtJQUV2QjtRQUNFQyxNQUFNO1FBQ05DLFdBQVc7SUFDYjtJQUNBO1FBQ0VELE1BQU07UUFDTkMsV0FBVztJQUNiO0lBQ0E7UUFDRUQsTUFBTTtRQUNOQyxXQUFXO0lBQ2I7Q0FFRCxDQUFDO0FBQ0ssTUFBTUMsaUJBQWlCO0lBRTVCO1FBQ0VGLE1BQU07UUFDTkMsV0FBVztJQUNiO0lBQ0E7UUFDRUQsTUFBTTtRQUNOQyxXQUFXO0lBQ2I7SUFFQTtRQUNFRCxNQUFNO1FBQ05DLFdBQVc7SUFDYjtJQUNBO1FBQ0VELE1BQU07UUFDTkMsV0FBVztJQUNiO0NBQ0QsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9kYXRhL21haW5NZW51RGF0YS5qcz84ZGQ5Il0sInNvdXJjZXNDb250ZW50IjpbIlxuZXhwb3J0IGNvbnN0IHBhZ2VJdGVtcyA9IFtcblxuICB7XG4gICAgbmFtZTogXCJMb2dpblwiLFxuICAgIHJvdXRlUGF0aDogXCIvbG9naW5cIixcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiUmVnaXN0ZXJcIixcbiAgICByb3V0ZVBhdGg6IFwiL3NpZ251cFwiLFxuICB9LFxuICB7XG4gICAgbmFtZTogXCJCb29raW5nLVBhZ2VcIixcbiAgICByb3V0ZVBhdGg6IFwiL2Jvb2tpbmctcGFnZVwiLFxuICB9LFxuXG5dO1xuZXhwb3J0IGNvbnN0IGRhc2hib2FyZEl0ZW1zID0gW1xuICBcbiAge1xuICAgIG5hbWU6IFwiRGFzaGJvYXJkXCIsXG4gICAgcm91dGVQYXRoOiBcIi9kYXNoYm9hcmQvZGItZGFzaGJvYXJkXCIsXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIkJvb2tpbmcgSGlzdG9yeVwiLFxuICAgIHJvdXRlUGF0aDogXCIvZGFzaGJvYXJkL2RiLWJvb2tpbmdcIixcbiAgfSxcblxuICB7XG4gICAgbmFtZTogXCJTZXR0aW5nc1wiLFxuICAgIHJvdXRlUGF0aDogXCIvZGFzaGJvYXJkL2RiLXNldHRpbmdzXCIsXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIkxvZ291dFwiLFxuICAgIHJvdXRlUGF0aDogXCIvbG9naW5cIixcbiAgfSxcbl07XG5cbiJdLCJuYW1lcyI6WyJwYWdlSXRlbXMiLCJuYW1lIiwicm91dGVQYXRoIiwiZGFzaGJvYXJkSXRlbXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./data/mainMenuData.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./features/flight/flightFilterSlice.js":
/*!**********************************************!*\
  !*** ./features/flight/flightFilterSlice.js ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   flightFilterSlice: function() { return /* binding */ flightFilterSlice; },\n/* harmony export */   setCabin_class: function() { return /* binding */ setCabin_class; },\n/* harmony export */   setDepart_date: function() { return /* binding */ setDepart_date; },\n/* harmony export */   setFlying_from: function() { return /* binding */ setFlying_from; },\n/* harmony export */   setFlying_to: function() { return /* binding */ setFlying_to; },\n/* harmony export */   setReturn_date: function() { return /* binding */ setReturn_date; },\n/* harmony export */   setTravellers: function() { return /* binding */ setTravellers; },\n/* harmony export */   setTrip_type: function() { return /* binding */ setTrip_type; }\n/* harmony export */ });\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(app-pages-browser)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js\");\n\nconst initialState = {\n    tripType: \"one-way\",\n    cabinClass: \"economy\",\n    flyingFrom: \"BLR\",\n    flyingTo: \"SIN\",\n    departDate: \"2025-02-11\",\n    returnDate: \"\",\n    travellers: {\n        adults: 1,\n        children: 0,\n        infants: 0\n    }\n};\nconst flightFilterSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.createSlice)({\n    name: \"flight-filter\",\n    initialState,\n    reducers: {\n        setFlying_from: (state, param)=>{\n            let { payload } = param;\n            state.flyingFrom = payload;\n        },\n        setFlying_to: (state, param)=>{\n            let { payload } = param;\n            state.flyingTo = payload;\n        },\n        setTrip_type: (state, param)=>{\n            let { payload } = param;\n            state.tripType = payload;\n        },\n        setCabin_class: (state, param)=>{\n            let { payload } = param;\n            state.cabinClass = payload;\n        },\n        setDepart_date: (state, param)=>{\n            let { payload } = param;\n            state.departDate = payload;\n        },\n        setReturn_date: (state, param)=>{\n            let { payload } = param;\n            state.returnDate = payload;\n        },\n        setTravellers: (state, param)=>{\n            let { payload } = param;\n            state.travellers = payload;\n        }\n    }\n});\nconst { setTrip_type, setCabin_class, setDepart_date, setFlying_from, setFlying_to, setReturn_date, setTravellers } = flightFilterSlice.actions;\n/* harmony default export */ __webpack_exports__[\"default\"] = (flightFilterSlice.reducer);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2ZlYXR1cmVzL2ZsaWdodC9mbGlnaHRGaWx0ZXJTbGljZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBK0M7QUFFL0MsTUFBTUMsZUFBZTtJQUNqQkMsVUFBVTtJQUNWQyxZQUFZO0lBQ1pDLFlBQVk7SUFDWkMsVUFBVTtJQUNWQyxZQUFZO0lBQ1pDLFlBQVk7SUFDWkMsWUFBWTtRQUNSQyxRQUFRO1FBQ1JDLFVBQVU7UUFDVkMsU0FBUztJQUNiO0FBQ0o7QUFFTyxNQUFNQyxvQkFBb0JaLDZEQUFXQSxDQUFDO0lBQ3pDYSxNQUFNO0lBQ05aO0lBQ0FhLFVBQVM7UUFDTEMsZ0JBQWdCLENBQUNDO2dCQUFPLEVBQUNDLE9BQU8sRUFBQztZQUM3QkQsTUFBTVosVUFBVSxHQUFHYTtRQUN2QjtRQUNBQyxjQUFjLENBQUNGO2dCQUFPLEVBQUNDLE9BQU8sRUFBQztZQUMzQkQsTUFBTVgsUUFBUSxHQUFHWTtRQUNyQjtRQUNBRSxjQUFjLENBQUNIO2dCQUFPLEVBQUNDLE9BQU8sRUFBQztZQUMzQkQsTUFBTWQsUUFBUSxHQUFHZTtRQUNyQjtRQUNBRyxnQkFBZ0IsQ0FBQ0o7Z0JBQU8sRUFBQ0MsT0FBTyxFQUFDO1lBQzdCRCxNQUFNYixVQUFVLEdBQUdjO1FBQ3ZCO1FBQ0FJLGdCQUFnQixDQUFDTDtnQkFBTyxFQUFDQyxPQUFPLEVBQUM7WUFDN0JELE1BQU1WLFVBQVUsR0FBR1c7UUFDdkI7UUFDQUssZ0JBQWdCLENBQUNOO2dCQUFPLEVBQUNDLE9BQU8sRUFBQztZQUM3QkQsTUFBTVQsVUFBVSxHQUFHVTtRQUN2QjtRQUNBTSxlQUFlLENBQUNQO2dCQUFPLEVBQUNDLE9BQU8sRUFBQztZQUM1QkQsTUFBTVIsVUFBVSxHQUFHUztRQUN2QjtJQUVKO0FBQ0osR0FBRztBQUVJLE1BQU0sRUFBRUUsWUFBWSxFQUFFQyxjQUFjLEVBQUVDLGNBQWMsRUFBRU4sY0FBYyxFQUFFRyxZQUFZLEVBQUVJLGNBQWMsRUFBRUMsYUFBYSxFQUFFLEdBQUdYLGtCQUFrQlksT0FBTyxDQUFDO0FBQ3ZKLCtEQUFlWixrQkFBa0JhLE9BQU8sRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9mZWF0dXJlcy9mbGlnaHQvZmxpZ2h0RmlsdGVyU2xpY2UuanM/YTY0NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVTbGljZSB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0XCI7XG5cbmNvbnN0IGluaXRpYWxTdGF0ZSA9IHtcbiAgICB0cmlwVHlwZTogXCJvbmUtd2F5XCIsIC8vIENhbiBiZSBcIm9uZS13YXlcIiBvciBcInJvdW5kLXRyaXBcIlxuICAgIGNhYmluQ2xhc3M6IFwiZWNvbm9teVwiLCAvLyBDYW4gYmUgXCJlY29ub215XCIsIFwiYnVzaW5lc3NcIiwgZXRjLlxuICAgIGZseWluZ0Zyb206IFwiQkxSXCIsXG4gICAgZmx5aW5nVG86IFwiU0lOXCIsXG4gICAgZGVwYXJ0RGF0ZTogJzIwMjUtMDItMTEnLFxuICAgIHJldHVybkRhdGU6ICcnLFxuICAgIHRyYXZlbGxlcnM6IHtcbiAgICAgICAgYWR1bHRzOiAxLFxuICAgICAgICBjaGlsZHJlbjogMCxcbiAgICAgICAgaW5mYW50czogMCxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IGZsaWdodEZpbHRlclNsaWNlID0gY3JlYXRlU2xpY2Uoe1xuICAgIG5hbWU6ICdmbGlnaHQtZmlsdGVyJyxcbiAgICBpbml0aWFsU3RhdGUsXG4gICAgcmVkdWNlcnM6e1xuICAgICAgICBzZXRGbHlpbmdfZnJvbTogKHN0YXRlLCB7cGF5bG9hZH0pID0+e1xuICAgICAgICAgICAgc3RhdGUuZmx5aW5nRnJvbSA9IHBheWxvYWQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldEZseWluZ190bzogKHN0YXRlLCB7cGF5bG9hZH0pID0+e1xuICAgICAgICAgICAgc3RhdGUuZmx5aW5nVG8gPSBwYXlsb2FkO1xuICAgICAgICB9LFxuICAgICAgICBzZXRUcmlwX3R5cGU6IChzdGF0ZSwge3BheWxvYWR9KSA9PntcbiAgICAgICAgICAgIHN0YXRlLnRyaXBUeXBlID0gcGF5bG9hZDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0Q2FiaW5fY2xhc3M6IChzdGF0ZSwge3BheWxvYWR9KSA9PntcbiAgICAgICAgICAgIHN0YXRlLmNhYmluQ2xhc3MgPSBwYXlsb2FkO1xuICAgICAgICB9LFxuICAgICAgICBzZXREZXBhcnRfZGF0ZTogKHN0YXRlLCB7cGF5bG9hZH0pID0+e1xuICAgICAgICAgICAgc3RhdGUuZGVwYXJ0RGF0ZSA9IHBheWxvYWQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldFJldHVybl9kYXRlOiAoc3RhdGUsIHtwYXlsb2FkfSkgPT57XG4gICAgICAgICAgICBzdGF0ZS5yZXR1cm5EYXRlID0gcGF5bG9hZDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0VHJhdmVsbGVyczogKHN0YXRlLCB7cGF5bG9hZH0pID0+e1xuICAgICAgICAgICAgc3RhdGUudHJhdmVsbGVycyA9IHBheWxvYWQ7XG4gICAgICAgIH0sXG5cbiAgICB9XG59KTtcblxuZXhwb3J0IGNvbnN0IHsgc2V0VHJpcF90eXBlLCBzZXRDYWJpbl9jbGFzcywgc2V0RGVwYXJ0X2RhdGUsIHNldEZseWluZ19mcm9tLCBzZXRGbHlpbmdfdG8sIHNldFJldHVybl9kYXRlLCBzZXRUcmF2ZWxsZXJzIH0gPSBmbGlnaHRGaWx0ZXJTbGljZS5hY3Rpb25zO1xuZXhwb3J0IGRlZmF1bHQgZmxpZ2h0RmlsdGVyU2xpY2UucmVkdWNlcjtcblxuIl0sIm5hbWVzIjpbImNyZWF0ZVNsaWNlIiwiaW5pdGlhbFN0YXRlIiwidHJpcFR5cGUiLCJjYWJpbkNsYXNzIiwiZmx5aW5nRnJvbSIsImZseWluZ1RvIiwiZGVwYXJ0RGF0ZSIsInJldHVybkRhdGUiLCJ0cmF2ZWxsZXJzIiwiYWR1bHRzIiwiY2hpbGRyZW4iLCJpbmZhbnRzIiwiZmxpZ2h0RmlsdGVyU2xpY2UiLCJuYW1lIiwicmVkdWNlcnMiLCJzZXRGbHlpbmdfZnJvbSIsInN0YXRlIiwicGF5bG9hZCIsInNldEZseWluZ190byIsInNldFRyaXBfdHlwZSIsInNldENhYmluX2NsYXNzIiwic2V0RGVwYXJ0X2RhdGUiLCJzZXRSZXR1cm5fZGF0ZSIsInNldFRyYXZlbGxlcnMiLCJhY3Rpb25zIiwicmVkdWNlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./features/flight/flightFilterSlice.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/add-locale.js":
/*!*****************************************************!*\
  !*** ./node_modules/next/dist/client/add-locale.js ***!
  \*****************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"addLocale\", ({\n    enumerable: true,\n    get: function() {\n        return addLocale;\n    }\n}));\nconst _normalizetrailingslash = __webpack_require__(/*! ./normalize-trailing-slash */ \"(app-pages-browser)/./node_modules/next/dist/client/normalize-trailing-slash.js\");\nconst addLocale = function(path) {\n    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        args[_key - 1] = arguments[_key];\n    }\n    if (false) {}\n    return path;\n};\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=add-locale.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2FkZC1sb2NhbGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILDZDQUE0QztJQUN4Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLDBCQUEwQkMsbUJBQU9BLENBQUMsbUhBQTRCO0FBQ3BFLE1BQU1GLFlBQVksU0FBU0csSUFBSTtJQUMzQixJQUFJLElBQUlDLE9BQU9DLFVBQVVDLE1BQU0sRUFBRUMsT0FBTyxJQUFJQyxNQUFNSixPQUFPLElBQUlBLE9BQU8sSUFBSSxJQUFJSyxPQUFPLEdBQUdBLE9BQU9MLE1BQU1LLE9BQU87UUFDdEdGLElBQUksQ0FBQ0UsT0FBTyxFQUFFLEdBQUdKLFNBQVMsQ0FBQ0ksS0FBSztJQUNwQztJQUNBLElBQUlDLEtBQStCLEVBQUUsRUFFcEM7SUFDRCxPQUFPUDtBQUNYO0FBRUEsSUFBSSxDQUFDLE9BQU9QLFFBQVFrQixPQUFPLEtBQUssY0FBZSxPQUFPbEIsUUFBUWtCLE9BQU8sS0FBSyxZQUFZbEIsUUFBUWtCLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT2xCLFFBQVFrQixPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLckIsT0FBT0MsY0FBYyxDQUFDQyxRQUFRa0IsT0FBTyxFQUFFLGNBQWM7UUFBRWpCLE9BQU87SUFBSztJQUNuRUgsT0FBT3NCLE1BQU0sQ0FBQ3BCLFFBQVFrQixPQUFPLEVBQUVsQjtJQUMvQnFCLE9BQU9yQixPQUFPLEdBQUdBLFFBQVFrQixPQUFPO0FBQ2xDLEVBRUEsc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2FkZC1sb2NhbGUuanM/ZTJkOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFkZExvY2FsZVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYWRkTG9jYWxlO1xuICAgIH1cbn0pO1xuY29uc3QgX25vcm1hbGl6ZXRyYWlsaW5nc2xhc2ggPSByZXF1aXJlKFwiLi9ub3JtYWxpemUtdHJhaWxpbmctc2xhc2hcIik7XG5jb25zdCBhZGRMb2NhbGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgIHJldHVybiAoMCwgX25vcm1hbGl6ZXRyYWlsaW5nc2xhc2gubm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2gpKHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9hZGQtbG9jYWxlXCIpLmFkZExvY2FsZShwYXRoLCAuLi5hcmdzKSk7XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufTtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkLWxvY2FsZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiYWRkTG9jYWxlIiwiX25vcm1hbGl6ZXRyYWlsaW5nc2xhc2giLCJyZXF1aXJlIiwicGF0aCIsIl9sZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9JMThOX1NVUFBPUlQiLCJub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/add-locale.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/get-domain-locale.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/client/get-domain-locale.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getDomainLocale\", ({\n    enumerable: true,\n    get: function() {\n        return getDomainLocale;\n    }\n}));\nconst _normalizetrailingslash = __webpack_require__(/*! ./normalize-trailing-slash */ \"(app-pages-browser)/./node_modules/next/dist/client/normalize-trailing-slash.js\");\nconst basePath =  false || \"\";\nfunction getDomainLocale(path, locale, locales, domainLocales) {\n    if (false) {} else {\n        return false;\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=get-domain-locale.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2dldC1kb21haW4tbG9jYWxlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCxtREFBa0Q7SUFDOUNJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQywwQkFBMEJDLG1CQUFPQSxDQUFDLG1IQUE0QjtBQUNwRSxNQUFNQyxXQUFXQyxNQUFrQyxJQUFJO0FBQ3ZELFNBQVNKLGdCQUFnQk8sSUFBSSxFQUFFQyxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsYUFBYTtJQUN6RCxJQUFJTixLQUErQixFQUFFLEVBV3BDLE1BQU07UUFDSCxPQUFPO0lBQ1g7QUFDSjtBQUVBLElBQUksQ0FBQyxPQUFPUixRQUFRMkIsT0FBTyxLQUFLLGNBQWUsT0FBTzNCLFFBQVEyQixPQUFPLEtBQUssWUFBWTNCLFFBQVEyQixPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU8zQixRQUFRMkIsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNySzlCLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUTJCLE9BQU8sRUFBRSxjQUFjO1FBQUUxQixPQUFPO0lBQUs7SUFDbkVILE9BQU8rQixNQUFNLENBQUM3QixRQUFRMkIsT0FBTyxFQUFFM0I7SUFDL0I4QixPQUFPOUIsT0FBTyxHQUFHQSxRQUFRMkIsT0FBTztBQUNsQyxFQUVBLDZDQUE2QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9nZXQtZG9tYWluLWxvY2FsZS5qcz81YzI3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0RG9tYWluTG9jYWxlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXREb21haW5Mb2NhbGU7XG4gICAgfVxufSk7XG5jb25zdCBfbm9ybWFsaXpldHJhaWxpbmdzbGFzaCA9IHJlcXVpcmUoXCIuL25vcm1hbGl6ZS10cmFpbGluZy1zbGFzaFwiKTtcbmNvbnN0IGJhc2VQYXRoID0gcHJvY2Vzcy5lbnYuX19ORVhUX1JPVVRFUl9CQVNFUEFUSCB8fCBcIlwiO1xuZnVuY3Rpb24gZ2V0RG9tYWluTG9jYWxlKHBhdGgsIGxvY2FsZSwgbG9jYWxlcywgZG9tYWluTG9jYWxlcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZUxvY2FsZVBhdGggPSByZXF1aXJlKFwiLi9ub3JtYWxpemUtbG9jYWxlLXBhdGhcIikubm9ybWFsaXplTG9jYWxlUGF0aDtcbiAgICAgICAgY29uc3QgZGV0ZWN0RG9tYWluTG9jYWxlID0gcmVxdWlyZShcIi4vZGV0ZWN0LWRvbWFpbi1sb2NhbGVcIikuZGV0ZWN0RG9tYWluTG9jYWxlO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBsb2NhbGUgfHwgbm9ybWFsaXplTG9jYWxlUGF0aChwYXRoLCBsb2NhbGVzKS5kZXRlY3RlZExvY2FsZTtcbiAgICAgICAgY29uc3QgZG9tYWluID0gZGV0ZWN0RG9tYWluTG9jYWxlKGRvbWFpbkxvY2FsZXMsIHVuZGVmaW5lZCwgdGFyZ2V0KTtcbiAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgY29uc3QgcHJvdG8gPSBcImh0dHBcIiArIChkb21haW4uaHR0cCA/IFwiXCIgOiBcInNcIikgKyBcIjovL1wiO1xuICAgICAgICAgICAgY29uc3QgZmluYWxMb2NhbGUgPSB0YXJnZXQgPT09IGRvbWFpbi5kZWZhdWx0TG9jYWxlID8gXCJcIiA6IFwiL1wiICsgdGFyZ2V0O1xuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyBwcm90byArIGRvbWFpbi5kb21haW4gKyAoMCwgX25vcm1hbGl6ZXRyYWlsaW5nc2xhc2gubm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2gpKFwiXCIgKyBiYXNlUGF0aCArIGZpbmFsTG9jYWxlICsgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC1kb21haW4tbG9jYWxlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJnZXREb21haW5Mb2NhbGUiLCJfbm9ybWFsaXpldHJhaWxpbmdzbGFzaCIsInJlcXVpcmUiLCJiYXNlUGF0aCIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfUk9VVEVSX0JBU0VQQVRIIiwicGF0aCIsImxvY2FsZSIsImxvY2FsZXMiLCJkb21haW5Mb2NhbGVzIiwiX19ORVhUX0kxOE5fU1VQUE9SVCIsIm5vcm1hbGl6ZUxvY2FsZVBhdGgiLCJkZXRlY3REb21haW5Mb2NhbGUiLCJ0YXJnZXQiLCJkZXRlY3RlZExvY2FsZSIsImRvbWFpbiIsInVuZGVmaW5lZCIsInByb3RvIiwiaHR0cCIsImZpbmFsTG9jYWxlIiwiZGVmYXVsdExvY2FsZSIsIm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/get-domain-locale.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/link.js":
/*!***********************************************!*\
  !*** ./node_modules/next/dist/client/link.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return _default;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _resolvehref = __webpack_require__(/*! ./resolve-href */ \"(app-pages-browser)/./node_modules/next/dist/client/resolve-href.js\");\nconst _islocalurl = __webpack_require__(/*! ../shared/lib/router/utils/is-local-url */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nconst _formaturl = __webpack_require__(/*! ../shared/lib/router/utils/format-url */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nconst _utils = __webpack_require__(/*! ../shared/lib/utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nconst _addlocale = __webpack_require__(/*! ./add-locale */ \"(app-pages-browser)/./node_modules/next/dist/client/add-locale.js\");\nconst _routercontextsharedruntime = __webpack_require__(/*! ../shared/lib/router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js\");\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nconst _useintersection = __webpack_require__(/*! ./use-intersection */ \"(app-pages-browser)/./node_modules/next/dist/client/use-intersection.js\");\nconst _getdomainlocale = __webpack_require__(/*! ./get-domain-locale */ \"(app-pages-browser)/./node_modules/next/dist/client/get-domain-locale.js\");\nconst _addbasepath = __webpack_require__(/*! ./add-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/add-base-path.js\");\nconst _routerreducertypes = __webpack_require__(/*! ./components/router-reducer/router-reducer-types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst prefetched = new Set();\nfunction prefetch(router, href, as, options, appOptions, isAppRouter) {\n    if (false) {}\n    // app-router supports external urls out of the box so it shouldn't short-circuit here as support for e.g. `replace` is added in the app-router.\n    if (!isAppRouter && !(0, _islocalurl.isLocalURL)(href)) {\n        return;\n    }\n    // We should only dedupe requests when experimental.optimisticClientCache is\n    // disabled.\n    if (!options.bypassPrefetchedCheck) {\n        const locale = typeof options.locale !== \"undefined\" ? options.locale : \"locale\" in router ? router.locale : undefined;\n        const prefetchedKey = href + \"%\" + as + \"%\" + locale;\n        // If we've already fetched the key, then don't prefetch it again!\n        if (prefetched.has(prefetchedKey)) {\n            return;\n        }\n        // Mark this URL as prefetched.\n        prefetched.add(prefetchedKey);\n    }\n    const prefetchPromise = isAppRouter ? router.prefetch(href, appOptions) : router.prefetch(href, as, options);\n    // Prefetch the JSON page if asked (only in the client)\n    // We need to handle a prefetch error here since we may be\n    // loading with priority which can reject but we don't\n    // want to force navigation since this is only a prefetch\n    Promise.resolve(prefetchPromise).catch((err)=>{\n        if (true) {\n            // rethrow to show invalid URL errors\n            throw err;\n        }\n    });\n}\nfunction isModifiedEvent(event) {\n    const eventTarget = event.currentTarget;\n    const target = eventTarget.getAttribute(\"target\");\n    return target && target !== \"_self\" || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download\n    event.nativeEvent && event.nativeEvent.which === 2;\n}\nfunction linkClicked(e, router, href, as, replace, shallow, scroll, locale, isAppRouter) {\n    const { nodeName } = e.currentTarget;\n    // anchors inside an svg have a lowercase nodeName\n    const isAnchorNodeName = nodeName.toUpperCase() === \"A\";\n    if (isAnchorNodeName && (isModifiedEvent(e) || // app-router supports external urls out of the box so it shouldn't short-circuit here as support for e.g. `replace` is added in the app-router.\n    !isAppRouter && !(0, _islocalurl.isLocalURL)(href))) {\n        // ignore click for browser’s default behavior\n        return;\n    }\n    e.preventDefault();\n    const navigate = ()=>{\n        // If the router is an NextRouter instance it will have `beforePopState`\n        const routerScroll = scroll != null ? scroll : true;\n        if (\"beforePopState\" in router) {\n            router[replace ? \"replace\" : \"push\"](href, as, {\n                shallow,\n                locale,\n                scroll: routerScroll\n            });\n        } else {\n            router[replace ? \"replace\" : \"push\"](as || href, {\n                scroll: routerScroll\n            });\n        }\n    };\n    if (isAppRouter) {\n        _react.default.startTransition(navigate);\n    } else {\n        navigate();\n    }\n}\nfunction formatStringOrUrl(urlObjOrString) {\n    if (typeof urlObjOrString === \"string\") {\n        return urlObjOrString;\n    }\n    return (0, _formaturl.formatUrl)(urlObjOrString);\n}\n/**\n * React Component that enables client-side transitions between routes.\n */ const Link = /*#__PURE__*/ _s(_react.default.forwardRef(_c = _s(function LinkComponent(props, forwardedRef) {\n    _s();\n    let children;\n    const { href: hrefProp, as: asProp, children: childrenProp, prefetch: prefetchProp = null, passHref, replace, shallow, scroll, locale, onClick, onMouseEnter: onMouseEnterProp, onTouchStart: onTouchStartProp, legacyBehavior = false, ...restProps } = props;\n    children = childrenProp;\n    if (legacyBehavior && (typeof children === \"string\" || typeof children === \"number\")) {\n        children = /*#__PURE__*/ (0, _jsxruntime.jsx)(\"a\", {\n            children: children\n        });\n    }\n    const pagesRouter = _react.default.useContext(_routercontextsharedruntime.RouterContext);\n    const appRouter = _react.default.useContext(_approutercontextsharedruntime.AppRouterContext);\n    const router = pagesRouter != null ? pagesRouter : appRouter;\n    // We're in the app directory if there is no pages router.\n    const isAppRouter = !pagesRouter;\n    const prefetchEnabled = prefetchProp !== false;\n    /**\n     * The possible states for prefetch are:\n     * - null: this is the default \"auto\" mode, where we will prefetch partially if the link is in the viewport\n     * - true: we will prefetch if the link is visible and prefetch the full page, not just partially\n     * - false: we will not prefetch if in the viewport at all\n     */ const appPrefetchKind = prefetchProp === null ? _routerreducertypes.PrefetchKind.AUTO : _routerreducertypes.PrefetchKind.FULL;\n    if (true) {\n        function createPropError(args) {\n            return new Error(\"Failed prop type: The prop `\" + args.key + \"` expects a \" + args.expected + \" in `<Link>`, but got `\" + args.actual + \"` instead.\" + ( true ? \"\\nOpen your browser's console to view the Component stack trace.\" : 0));\n        }\n        // TypeScript trick for type-guarding:\n        const requiredPropsGuard = {\n            href: true\n        };\n        const requiredProps = Object.keys(requiredPropsGuard);\n        requiredProps.forEach((key)=>{\n            if (key === \"href\") {\n                if (props[key] == null || typeof props[key] !== \"string\" && typeof props[key] !== \"object\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`string` or `object`\",\n                        actual: props[key] === null ? \"null\" : typeof props[key]\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const _ = key;\n            }\n        });\n        // TypeScript trick for type-guarding:\n        const optionalPropsGuard = {\n            as: true,\n            replace: true,\n            scroll: true,\n            shallow: true,\n            passHref: true,\n            prefetch: true,\n            locale: true,\n            onClick: true,\n            onMouseEnter: true,\n            onTouchStart: true,\n            legacyBehavior: true\n        };\n        const optionalProps = Object.keys(optionalPropsGuard);\n        optionalProps.forEach((key)=>{\n            const valType = typeof props[key];\n            if (key === \"as\") {\n                if (props[key] && valType !== \"string\" && valType !== \"object\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`string` or `object`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"locale\") {\n                if (props[key] && valType !== \"string\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`string`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"onClick\" || key === \"onMouseEnter\" || key === \"onTouchStart\") {\n                if (props[key] && valType !== \"function\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`function`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"replace\" || key === \"scroll\" || key === \"shallow\" || key === \"passHref\" || key === \"prefetch\" || key === \"legacyBehavior\") {\n                if (props[key] != null && valType !== \"boolean\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`boolean`\",\n                        actual: valType\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const _ = key;\n            }\n        });\n        // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const hasWarned = _react.default.useRef(false);\n        if (props.prefetch && !hasWarned.current && !isAppRouter) {\n            hasWarned.current = true;\n            console.warn(\"Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://nextjs.org/docs/messages/prefetch-true-deprecated\");\n        }\n    }\n    if (true) {\n        if (isAppRouter && !asProp) {\n            let href;\n            if (typeof hrefProp === \"string\") {\n                href = hrefProp;\n            } else if (typeof hrefProp === \"object\" && typeof hrefProp.pathname === \"string\") {\n                href = hrefProp.pathname;\n            }\n            if (href) {\n                const hasDynamicSegment = href.split(\"/\").some((segment)=>segment.startsWith(\"[\") && segment.endsWith(\"]\"));\n                if (hasDynamicSegment) {\n                    throw new Error(\"Dynamic href `\" + href + \"` found in <Link> while using the `/app` router, this is not supported. Read more: https://nextjs.org/docs/messages/app-dir-dynamic-href\");\n                }\n            }\n        }\n    }\n    const { href, as } = _react.default.useMemo(()=>{\n        if (!pagesRouter) {\n            const resolvedHref = formatStringOrUrl(hrefProp);\n            return {\n                href: resolvedHref,\n                as: asProp ? formatStringOrUrl(asProp) : resolvedHref\n            };\n        }\n        const [resolvedHref, resolvedAs] = (0, _resolvehref.resolveHref)(pagesRouter, hrefProp, true);\n        return {\n            href: resolvedHref,\n            as: asProp ? (0, _resolvehref.resolveHref)(pagesRouter, asProp) : resolvedAs || resolvedHref\n        };\n    }, [\n        pagesRouter,\n        hrefProp,\n        asProp\n    ]);\n    const previousHref = _react.default.useRef(href);\n    const previousAs = _react.default.useRef(as);\n    // This will return the first child, if multiple are provided it will throw an error\n    let child;\n    if (legacyBehavior) {\n        if (true) {\n            if (onClick) {\n                console.warn('\"onClick\" was passed to <Link> with `href` of `' + hrefProp + '` but \"legacyBehavior\" was set. The legacy behavior requires onClick be set on the child of next/link');\n            }\n            if (onMouseEnterProp) {\n                console.warn('\"onMouseEnter\" was passed to <Link> with `href` of `' + hrefProp + '` but \"legacyBehavior\" was set. The legacy behavior requires onMouseEnter be set on the child of next/link');\n            }\n            try {\n                child = _react.default.Children.only(children);\n            } catch (err) {\n                if (!children) {\n                    throw new Error(\"No children were passed to <Link> with `href` of `\" + hrefProp + \"` but one child is required https://nextjs.org/docs/messages/link-no-children\");\n                }\n                throw new Error(\"Multiple children were passed to <Link> with `href` of `\" + hrefProp + \"` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children\" + ( true ? \" \\nOpen your browser's console to view the Component stack trace.\" : 0));\n            }\n        } else {}\n    } else {\n        if (true) {\n            if ((children == null ? void 0 : children.type) === \"a\") {\n                throw new Error(\"Invalid <Link> with <a> child. Please remove <a> or use <Link legacyBehavior>.\\nLearn more: https://nextjs.org/docs/messages/invalid-new-link-with-extra-anchor\");\n            }\n        }\n    }\n    const childRef = legacyBehavior ? child && typeof child === \"object\" && child.ref : forwardedRef;\n    const [setIntersectionRef, isVisible, resetVisible] = (0, _useintersection.useIntersection)({\n        rootMargin: \"200px\"\n    });\n    const setRef = _react.default.useCallback((el)=>{\n        // Before the link getting observed, check if visible state need to be reset\n        if (previousAs.current !== as || previousHref.current !== href) {\n            resetVisible();\n            previousAs.current = as;\n            previousHref.current = href;\n        }\n        setIntersectionRef(el);\n        if (childRef) {\n            if (typeof childRef === \"function\") childRef(el);\n            else if (typeof childRef === \"object\") {\n                childRef.current = el;\n            }\n        }\n    }, [\n        as,\n        childRef,\n        href,\n        resetVisible,\n        setIntersectionRef\n    ]);\n    // Prefetch the URL if we haven't already and it's visible.\n    _react.default.useEffect(()=>{\n        // in dev, we only prefetch on hover to avoid wasting resources as the prefetch will trigger compiling the page.\n        if (true) {\n            return;\n        }\n        if (!router) {\n            return;\n        }\n        // If we don't need to prefetch the URL, don't do prefetch.\n        if (!isVisible || !prefetchEnabled) {\n            return;\n        }\n        // Prefetch the URL.\n        prefetch(router, href, as, {\n            locale\n        }, {\n            kind: appPrefetchKind\n        }, isAppRouter);\n    }, [\n        as,\n        href,\n        isVisible,\n        locale,\n        prefetchEnabled,\n        pagesRouter == null ? void 0 : pagesRouter.locale,\n        router,\n        isAppRouter,\n        appPrefetchKind\n    ]);\n    const childProps = {\n        ref: setRef,\n        onClick (e) {\n            if (true) {\n                if (!e) {\n                    throw new Error('Component rendered inside next/link has to pass click event to \"onClick\" prop.');\n                }\n            }\n            if (!legacyBehavior && typeof onClick === \"function\") {\n                onClick(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onClick === \"function\") {\n                child.props.onClick(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (e.defaultPrevented) {\n                return;\n            }\n            linkClicked(e, router, href, as, replace, shallow, scroll, locale, isAppRouter);\n        },\n        onMouseEnter (e) {\n            if (!legacyBehavior && typeof onMouseEnterProp === \"function\") {\n                onMouseEnterProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onMouseEnter === \"function\") {\n                child.props.onMouseEnter(e);\n            }\n            if (!router) {\n                return;\n            }\n            if ((!prefetchEnabled || \"development\" === \"development\") && isAppRouter) {\n                return;\n            }\n            prefetch(router, href, as, {\n                locale,\n                priority: true,\n                // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}\n                bypassPrefetchedCheck: true\n            }, {\n                kind: appPrefetchKind\n            }, isAppRouter);\n        },\n        onTouchStart (e) {\n            if (!legacyBehavior && typeof onTouchStartProp === \"function\") {\n                onTouchStartProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onTouchStart === \"function\") {\n                child.props.onTouchStart(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (!prefetchEnabled && isAppRouter) {\n                return;\n            }\n            prefetch(router, href, as, {\n                locale,\n                priority: true,\n                // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}\n                bypassPrefetchedCheck: true\n            }, {\n                kind: appPrefetchKind\n            }, isAppRouter);\n        }\n    };\n    // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is\n    // defined, we specify the current 'href', so that repetition is not needed by the user.\n    // If the url is absolute, we can bypass the logic to prepend the domain and locale.\n    if ((0, _utils.isAbsoluteUrl)(as)) {\n        childProps.href = as;\n    } else if (!legacyBehavior || passHref || child.type === \"a\" && !(\"href\" in child.props)) {\n        const curLocale = typeof locale !== \"undefined\" ? locale : pagesRouter == null ? void 0 : pagesRouter.locale;\n        // we only render domain locales if we are currently on a domain locale\n        // so that locale links are still visitable in development/preview envs\n        const localeDomain = (pagesRouter == null ? void 0 : pagesRouter.isLocaleDomain) && (0, _getdomainlocale.getDomainLocale)(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.locales, pagesRouter == null ? void 0 : pagesRouter.domainLocales);\n        childProps.href = localeDomain || (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.defaultLocale));\n    }\n    return legacyBehavior ? /*#__PURE__*/ _react.default.cloneElement(child, childProps) : /*#__PURE__*/ (0, _jsxruntime.jsx)(\"a\", {\n        ...restProps,\n        ...childProps,\n        children: children\n    });\n}, \"wKD5mb5mk47bkaStGb/Fvd6RWZE=\")), \"wKD5mb5mk47bkaStGb/Fvd6RWZE=\");\n_c1 = Link;\nconst _default = Link;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=link.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"Link$_react.default.forwardRef\");\n$RefreshReg$(_c1, \"Link\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2xpbmsuanMiLCJtYXBwaW5ncyI6Ijs7QUFFQTtBQUNBQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsMkNBQTBDO0lBQ3RDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsMkJBQTJCQyxtQkFBT0EsQ0FBQyxnSUFBeUM7QUFDbEYsTUFBTUMsY0FBY0QsbUJBQU9BLENBQUMscUdBQW1CO0FBQy9DLE1BQU1FLFNBQVMsV0FBVyxHQUFHSCx5QkFBeUJJLENBQUMsQ0FBQ0gsbUJBQU9BLENBQUMsbUZBQU87QUFDdkUsTUFBTUksZUFBZUosbUJBQU9BLENBQUMsMkZBQWdCO0FBQzdDLE1BQU1LLGNBQWNMLG1CQUFPQSxDQUFDLHFJQUF5QztBQUNyRSxNQUFNTSxhQUFhTixtQkFBT0EsQ0FBQyxpSUFBdUM7QUFDbEUsTUFBTU8sU0FBU1AsbUJBQU9BLENBQUMsNkZBQXFCO0FBQzVDLE1BQU1RLGFBQWFSLG1CQUFPQSxDQUFDLHVGQUFjO0FBQ3pDLE1BQU1TLDhCQUE4QlQsbUJBQU9BLENBQUMsNklBQTZDO0FBQ3pGLE1BQU1VLGlDQUFpQ1YsbUJBQU9BLENBQUMscUpBQWlEO0FBQ2hHLE1BQU1XLG1CQUFtQlgsbUJBQU9BLENBQUMsbUdBQW9CO0FBQ3JELE1BQU1ZLG1CQUFtQlosbUJBQU9BLENBQUMscUdBQXFCO0FBQ3RELE1BQU1hLGVBQWViLG1CQUFPQSxDQUFDLDZGQUFpQjtBQUM5QyxNQUFNYyxzQkFBc0JkLG1CQUFPQSxDQUFDLCtKQUFrRDtBQUN0RixNQUFNZSxhQUFhLElBQUlDO0FBQ3ZCLFNBQVNDLFNBQVNDLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxFQUFFLEVBQUVDLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxXQUFXO0lBQ2hFLElBQUksS0FBNkIsRUFBRSxFQUVsQztJQUNELGdK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LE9BQU8sRUFBRSxjQUFjO1FBQUVqRSxPQUFPO0lBQUs7SUFDbkVILE9BQU9vSyxNQUFNLENBQUNsSyxRQUFRa0UsT0FBTyxFQUFFbEU7SUFDL0JtSyxPQUFPbkssT0FBTyxHQUFHQSxRQUFRa0UsT0FBTztBQUNsQyxFQUVBLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9saW5rLmpzP2U0ZjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVmYXVsdFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2RlZmF1bHQ7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0XCIpO1xuY29uc3QgX2pzeHJ1bnRpbWUgPSByZXF1aXJlKFwicmVhY3QvanN4LXJ1bnRpbWVcIik7XG5jb25zdCBfcmVhY3QgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5jb25zdCBfcmVzb2x2ZWhyZWYgPSByZXF1aXJlKFwiLi9yZXNvbHZlLWhyZWZcIik7XG5jb25zdCBfaXNsb2NhbHVybCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9pcy1sb2NhbC11cmxcIik7XG5jb25zdCBfZm9ybWF0dXJsID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2Zvcm1hdC11cmxcIik7XG5jb25zdCBfdXRpbHMgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi91dGlsc1wiKTtcbmNvbnN0IF9hZGRsb2NhbGUgPSByZXF1aXJlKFwiLi9hZGQtbG9jYWxlXCIpO1xuY29uc3QgX3JvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWVcIik7XG5jb25zdCBfYXBwcm91dGVyY29udGV4dHNoYXJlZHJ1bnRpbWUgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWVcIik7XG5jb25zdCBfdXNlaW50ZXJzZWN0aW9uID0gcmVxdWlyZShcIi4vdXNlLWludGVyc2VjdGlvblwiKTtcbmNvbnN0IF9nZXRkb21haW5sb2NhbGUgPSByZXF1aXJlKFwiLi9nZXQtZG9tYWluLWxvY2FsZVwiKTtcbmNvbnN0IF9hZGRiYXNlcGF0aCA9IHJlcXVpcmUoXCIuL2FkZC1iYXNlLXBhdGhcIik7XG5jb25zdCBfcm91dGVycmVkdWNlcnR5cGVzID0gcmVxdWlyZShcIi4vY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yb3V0ZXItcmVkdWNlci10eXBlc1wiKTtcbmNvbnN0IHByZWZldGNoZWQgPSBuZXcgU2V0KCk7XG5mdW5jdGlvbiBwcmVmZXRjaChyb3V0ZXIsIGhyZWYsIGFzLCBvcHRpb25zLCBhcHBPcHRpb25zLCBpc0FwcFJvdXRlcikge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gYXBwLXJvdXRlciBzdXBwb3J0cyBleHRlcm5hbCB1cmxzIG91dCBvZiB0aGUgYm94IHNvIGl0IHNob3VsZG4ndCBzaG9ydC1jaXJjdWl0IGhlcmUgYXMgc3VwcG9ydCBmb3IgZS5nLiBgcmVwbGFjZWAgaXMgYWRkZWQgaW4gdGhlIGFwcC1yb3V0ZXIuXG4gICAgaWYgKCFpc0FwcFJvdXRlciAmJiAhKDAsIF9pc2xvY2FsdXJsLmlzTG9jYWxVUkwpKGhyZWYpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gV2Ugc2hvdWxkIG9ubHkgZGVkdXBlIHJlcXVlc3RzIHdoZW4gZXhwZXJpbWVudGFsLm9wdGltaXN0aWNDbGllbnRDYWNoZSBpc1xuICAgIC8vIGRpc2FibGVkLlxuICAgIGlmICghb3B0aW9ucy5ieXBhc3NQcmVmZXRjaGVkQ2hlY2spIHtcbiAgICAgICAgY29uc3QgbG9jYWxlID0gLy8gTGV0IHRoZSBsaW5rJ3MgbG9jYWxlIHByb3Agb3ZlcnJpZGUgdGhlIGRlZmF1bHQgcm91dGVyIGxvY2FsZS5cbiAgICAgICAgdHlwZW9mIG9wdGlvbnMubG9jYWxlICE9PSBcInVuZGVmaW5lZFwiID8gb3B0aW9ucy5sb2NhbGUgOiBcImxvY2FsZVwiIGluIHJvdXRlciA/IHJvdXRlci5sb2NhbGUgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHByZWZldGNoZWRLZXkgPSBocmVmICsgXCIlXCIgKyBhcyArIFwiJVwiICsgbG9jYWxlO1xuICAgICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGZldGNoZWQgdGhlIGtleSwgdGhlbiBkb24ndCBwcmVmZXRjaCBpdCBhZ2FpbiFcbiAgICAgICAgaWYgKHByZWZldGNoZWQuaGFzKHByZWZldGNoZWRLZXkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFyayB0aGlzIFVSTCBhcyBwcmVmZXRjaGVkLlxuICAgICAgICBwcmVmZXRjaGVkLmFkZChwcmVmZXRjaGVkS2V5KTtcbiAgICB9XG4gICAgY29uc3QgcHJlZmV0Y2hQcm9taXNlID0gaXNBcHBSb3V0ZXIgPyByb3V0ZXIucHJlZmV0Y2goaHJlZiwgYXBwT3B0aW9ucykgOiByb3V0ZXIucHJlZmV0Y2goaHJlZiwgYXMsIG9wdGlvbnMpO1xuICAgIC8vIFByZWZldGNoIHRoZSBKU09OIHBhZ2UgaWYgYXNrZWQgKG9ubHkgaW4gdGhlIGNsaWVudClcbiAgICAvLyBXZSBuZWVkIHRvIGhhbmRsZSBhIHByZWZldGNoIGVycm9yIGhlcmUgc2luY2Ugd2UgbWF5IGJlXG4gICAgLy8gbG9hZGluZyB3aXRoIHByaW9yaXR5IHdoaWNoIGNhbiByZWplY3QgYnV0IHdlIGRvbid0XG4gICAgLy8gd2FudCB0byBmb3JjZSBuYXZpZ2F0aW9uIHNpbmNlIHRoaXMgaXMgb25seSBhIHByZWZldGNoXG4gICAgUHJvbWlzZS5yZXNvbHZlKHByZWZldGNoUHJvbWlzZSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgLy8gcmV0aHJvdyB0byBzaG93IGludmFsaWQgVVJMIGVycm9yc1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBpc01vZGlmaWVkRXZlbnQoZXZlbnQpIHtcbiAgICBjb25zdCBldmVudFRhcmdldCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKFwidGFyZ2V0XCIpO1xuICAgIHJldHVybiB0YXJnZXQgJiYgdGFyZ2V0ICE9PSBcIl9zZWxmXCIgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50LmFsdEtleSB8fCAvLyB0cmlnZ2VycyByZXNvdXJjZSBkb3dubG9hZFxuICAgIGV2ZW50Lm5hdGl2ZUV2ZW50ICYmIGV2ZW50Lm5hdGl2ZUV2ZW50LndoaWNoID09PSAyO1xufVxuZnVuY3Rpb24gbGlua0NsaWNrZWQoZSwgcm91dGVyLCBocmVmLCBhcywgcmVwbGFjZSwgc2hhbGxvdywgc2Nyb2xsLCBsb2NhbGUsIGlzQXBwUm91dGVyKSB7XG4gICAgY29uc3QgeyBub2RlTmFtZSB9ID0gZS5jdXJyZW50VGFyZ2V0O1xuICAgIC8vIGFuY2hvcnMgaW5zaWRlIGFuIHN2ZyBoYXZlIGEgbG93ZXJjYXNlIG5vZGVOYW1lXG4gICAgY29uc3QgaXNBbmNob3JOb2RlTmFtZSA9IG5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09IFwiQVwiO1xuICAgIGlmIChpc0FuY2hvck5vZGVOYW1lICYmIChpc01vZGlmaWVkRXZlbnQoZSkgfHwgLy8gYXBwLXJvdXRlciBzdXBwb3J0cyBleHRlcm5hbCB1cmxzIG91dCBvZiB0aGUgYm94IHNvIGl0IHNob3VsZG4ndCBzaG9ydC1jaXJjdWl0IGhlcmUgYXMgc3VwcG9ydCBmb3IgZS5nLiBgcmVwbGFjZWAgaXMgYWRkZWQgaW4gdGhlIGFwcC1yb3V0ZXIuXG4gICAgIWlzQXBwUm91dGVyICYmICEoMCwgX2lzbG9jYWx1cmwuaXNMb2NhbFVSTCkoaHJlZikpKSB7XG4gICAgICAgIC8vIGlnbm9yZSBjbGljayBmb3IgYnJvd3NlcuKAmXMgZGVmYXVsdCBiZWhhdmlvclxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCBuYXZpZ2F0ZSA9ICgpPT57XG4gICAgICAgIC8vIElmIHRoZSByb3V0ZXIgaXMgYW4gTmV4dFJvdXRlciBpbnN0YW5jZSBpdCB3aWxsIGhhdmUgYGJlZm9yZVBvcFN0YXRlYFxuICAgICAgICBjb25zdCByb3V0ZXJTY3JvbGwgPSBzY3JvbGwgIT0gbnVsbCA/IHNjcm9sbCA6IHRydWU7XG4gICAgICAgIGlmIChcImJlZm9yZVBvcFN0YXRlXCIgaW4gcm91dGVyKSB7XG4gICAgICAgICAgICByb3V0ZXJbcmVwbGFjZSA/IFwicmVwbGFjZVwiIDogXCJwdXNoXCJdKGhyZWYsIGFzLCB7XG4gICAgICAgICAgICAgICAgc2hhbGxvdyxcbiAgICAgICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICAgICAgc2Nyb2xsOiByb3V0ZXJTY3JvbGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcm91dGVyW3JlcGxhY2UgPyBcInJlcGxhY2VcIiA6IFwicHVzaFwiXShhcyB8fCBocmVmLCB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsOiByb3V0ZXJTY3JvbGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpZiAoaXNBcHBSb3V0ZXIpIHtcbiAgICAgICAgX3JlYWN0LmRlZmF1bHQuc3RhcnRUcmFuc2l0aW9uKG5hdmlnYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBuYXZpZ2F0ZSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZvcm1hdFN0cmluZ09yVXJsKHVybE9iak9yU3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZiB1cmxPYmpPclN0cmluZyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gdXJsT2JqT3JTdHJpbmc7XG4gICAgfVxuICAgIHJldHVybiAoMCwgX2Zvcm1hdHVybC5mb3JtYXRVcmwpKHVybE9iak9yU3RyaW5nKTtcbn1cbi8qKlxuICogUmVhY3QgQ29tcG9uZW50IHRoYXQgZW5hYmxlcyBjbGllbnQtc2lkZSB0cmFuc2l0aW9ucyBiZXR3ZWVuIHJvdXRlcy5cbiAqLyBjb25zdCBMaW5rID0gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIExpbmtDb21wb25lbnQocHJvcHMsIGZvcndhcmRlZFJlZikge1xuICAgIGxldCBjaGlsZHJlbjtcbiAgICBjb25zdCB7IGhyZWY6IGhyZWZQcm9wLCBhczogYXNQcm9wLCBjaGlsZHJlbjogY2hpbGRyZW5Qcm9wLCBwcmVmZXRjaDogcHJlZmV0Y2hQcm9wID0gbnVsbCwgcGFzc0hyZWYsIHJlcGxhY2UsIHNoYWxsb3csIHNjcm9sbCwgbG9jYWxlLCBvbkNsaWNrLCBvbk1vdXNlRW50ZXI6IG9uTW91c2VFbnRlclByb3AsIG9uVG91Y2hTdGFydDogb25Ub3VjaFN0YXJ0UHJvcCwgbGVnYWN5QmVoYXZpb3IgPSBmYWxzZSwgLi4ucmVzdFByb3BzIH0gPSBwcm9wcztcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuUHJvcDtcbiAgICBpZiAobGVnYWN5QmVoYXZpb3IgJiYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgY2hpbGRyZW4gPT09IFwibnVtYmVyXCIpKSB7XG4gICAgICAgIGNoaWxkcmVuID0gLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4KShcImFcIiwge1xuICAgICAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBwYWdlc1JvdXRlciA9IF9yZWFjdC5kZWZhdWx0LnVzZUNvbnRleHQoX3JvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lLlJvdXRlckNvbnRleHQpO1xuICAgIGNvbnN0IGFwcFJvdXRlciA9IF9yZWFjdC5kZWZhdWx0LnVzZUNvbnRleHQoX2FwcHJvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lLkFwcFJvdXRlckNvbnRleHQpO1xuICAgIGNvbnN0IHJvdXRlciA9IHBhZ2VzUm91dGVyICE9IG51bGwgPyBwYWdlc1JvdXRlciA6IGFwcFJvdXRlcjtcbiAgICAvLyBXZSdyZSBpbiB0aGUgYXBwIGRpcmVjdG9yeSBpZiB0aGVyZSBpcyBubyBwYWdlcyByb3V0ZXIuXG4gICAgY29uc3QgaXNBcHBSb3V0ZXIgPSAhcGFnZXNSb3V0ZXI7XG4gICAgY29uc3QgcHJlZmV0Y2hFbmFibGVkID0gcHJlZmV0Y2hQcm9wICE9PSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBUaGUgcG9zc2libGUgc3RhdGVzIGZvciBwcmVmZXRjaCBhcmU6XG4gICAgICogLSBudWxsOiB0aGlzIGlzIHRoZSBkZWZhdWx0IFwiYXV0b1wiIG1vZGUsIHdoZXJlIHdlIHdpbGwgcHJlZmV0Y2ggcGFydGlhbGx5IGlmIHRoZSBsaW5rIGlzIGluIHRoZSB2aWV3cG9ydFxuICAgICAqIC0gdHJ1ZTogd2Ugd2lsbCBwcmVmZXRjaCBpZiB0aGUgbGluayBpcyB2aXNpYmxlIGFuZCBwcmVmZXRjaCB0aGUgZnVsbCBwYWdlLCBub3QganVzdCBwYXJ0aWFsbHlcbiAgICAgKiAtIGZhbHNlOiB3ZSB3aWxsIG5vdCBwcmVmZXRjaCBpZiBpbiB0aGUgdmlld3BvcnQgYXQgYWxsXG4gICAgICovIGNvbnN0IGFwcFByZWZldGNoS2luZCA9IHByZWZldGNoUHJvcCA9PT0gbnVsbCA/IF9yb3V0ZXJyZWR1Y2VydHlwZXMuUHJlZmV0Y2hLaW5kLkFVVE8gOiBfcm91dGVycmVkdWNlcnR5cGVzLlByZWZldGNoS2luZC5GVUxMO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlUHJvcEVycm9yKGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXCJGYWlsZWQgcHJvcCB0eXBlOiBUaGUgcHJvcCBgXCIgKyBhcmdzLmtleSArIFwiYCBleHBlY3RzIGEgXCIgKyBhcmdzLmV4cGVjdGVkICsgXCIgaW4gYDxMaW5rPmAsIGJ1dCBnb3QgYFwiICsgYXJncy5hY3R1YWwgKyBcImAgaW5zdGVhZC5cIiArICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gXCJcXG5PcGVuIHlvdXIgYnJvd3NlcidzIGNvbnNvbGUgdG8gdmlldyB0aGUgQ29tcG9uZW50IHN0YWNrIHRyYWNlLlwiIDogXCJcIikpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgIGNvbnN0IHJlcXVpcmVkUHJvcHNHdWFyZCA9IHtcbiAgICAgICAgICAgIGhyZWY6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVxdWlyZWRQcm9wcyA9IE9iamVjdC5rZXlzKHJlcXVpcmVkUHJvcHNHdWFyZCk7XG4gICAgICAgIHJlcXVpcmVkUHJvcHMuZm9yRWFjaCgoa2V5KT0+e1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJocmVmXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHNba2V5XSA9PSBudWxsIHx8IHR5cGVvZiBwcm9wc1trZXldICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBwcm9wc1trZXldICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogXCJgc3RyaW5nYCBvciBgb2JqZWN0YFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiBwcm9wc1trZXldID09PSBudWxsID8gXCJudWxsXCIgOiB0eXBlb2YgcHJvcHNba2V5XVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICAgICAgICAgIGNvbnN0IF8gPSBrZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUeXBlU2NyaXB0IHRyaWNrIGZvciB0eXBlLWd1YXJkaW5nOlxuICAgICAgICBjb25zdCBvcHRpb25hbFByb3BzR3VhcmQgPSB7XG4gICAgICAgICAgICBhczogdHJ1ZSxcbiAgICAgICAgICAgIHJlcGxhY2U6IHRydWUsXG4gICAgICAgICAgICBzY3JvbGw6IHRydWUsXG4gICAgICAgICAgICBzaGFsbG93OiB0cnVlLFxuICAgICAgICAgICAgcGFzc0hyZWY6IHRydWUsXG4gICAgICAgICAgICBwcmVmZXRjaDogdHJ1ZSxcbiAgICAgICAgICAgIGxvY2FsZTogdHJ1ZSxcbiAgICAgICAgICAgIG9uQ2xpY2s6IHRydWUsXG4gICAgICAgICAgICBvbk1vdXNlRW50ZXI6IHRydWUsXG4gICAgICAgICAgICBvblRvdWNoU3RhcnQ6IHRydWUsXG4gICAgICAgICAgICBsZWdhY3lCZWhhdmlvcjogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvcHRpb25hbFByb3BzID0gT2JqZWN0LmtleXMob3B0aW9uYWxQcm9wc0d1YXJkKTtcbiAgICAgICAgb3B0aW9uYWxQcm9wcy5mb3JFYWNoKChrZXkpPT57XG4gICAgICAgICAgICBjb25zdCB2YWxUeXBlID0gdHlwZW9mIHByb3BzW2tleV07XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcImFzXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHNba2V5XSAmJiB2YWxUeXBlICE9PSBcInN0cmluZ1wiICYmIHZhbFR5cGUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBcImBzdHJpbmdgIG9yIGBvYmplY3RgXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwibG9jYWxlXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHNba2V5XSAmJiB2YWxUeXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogXCJgc3RyaW5nYFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIm9uQ2xpY2tcIiB8fCBrZXkgPT09IFwib25Nb3VzZUVudGVyXCIgfHwga2V5ID09PSBcIm9uVG91Y2hTdGFydFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzW2tleV0gJiYgdmFsVHlwZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogXCJgZnVuY3Rpb25gXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwicmVwbGFjZVwiIHx8IGtleSA9PT0gXCJzY3JvbGxcIiB8fCBrZXkgPT09IFwic2hhbGxvd1wiIHx8IGtleSA9PT0gXCJwYXNzSHJlZlwiIHx8IGtleSA9PT0gXCJwcmVmZXRjaFwiIHx8IGtleSA9PT0gXCJsZWdhY3lCZWhhdmlvclwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzW2tleV0gIT0gbnVsbCAmJiB2YWxUeXBlICE9PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwiYGJvb2xlYW5gXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUeXBlU2NyaXB0IHRyaWNrIGZvciB0eXBlLWd1YXJkaW5nOlxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgICAgICAgICBjb25zdCBfID0ga2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVGhpcyBob29rIGlzIGluIGEgY29uZGl0aW9uYWwgYnV0IHRoYXQgaXMgb2sgYmVjYXVzZSBgcHJvY2Vzcy5lbnYuTk9ERV9FTlZgIG5ldmVyIGNoYW5nZXNcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgICAgIGNvbnN0IGhhc1dhcm5lZCA9IF9yZWFjdC5kZWZhdWx0LnVzZVJlZihmYWxzZSk7XG4gICAgICAgIGlmIChwcm9wcy5wcmVmZXRjaCAmJiAhaGFzV2FybmVkLmN1cnJlbnQgJiYgIWlzQXBwUm91dGVyKSB7XG4gICAgICAgICAgICBoYXNXYXJuZWQuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJOZXh0LmpzIGF1dG8tcHJlZmV0Y2hlcyBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIHZpZXdwb3J0LiBUaGUgcHJlZmV0Y2ggYXR0cmlidXRlIGlzIG5vIGxvbmdlciBuZWVkZWQuIE1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3ByZWZldGNoLXRydWUtZGVwcmVjYXRlZFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGlmIChpc0FwcFJvdXRlciAmJiAhYXNQcm9wKSB7XG4gICAgICAgICAgICBsZXQgaHJlZjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaHJlZlByb3AgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBocmVmID0gaHJlZlByb3A7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBocmVmUHJvcCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgaHJlZlByb3AucGF0aG5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBocmVmID0gaHJlZlByb3AucGF0aG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaHJlZikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc0R5bmFtaWNTZWdtZW50ID0gaHJlZi5zcGxpdChcIi9cIikuc29tZSgoc2VnbWVudCk9PnNlZ21lbnQuc3RhcnRzV2l0aChcIltcIikgJiYgc2VnbWVudC5lbmRzV2l0aChcIl1cIikpO1xuICAgICAgICAgICAgICAgIGlmIChoYXNEeW5hbWljU2VnbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEeW5hbWljIGhyZWYgYFwiICsgaHJlZiArIFwiYCBmb3VuZCBpbiA8TGluaz4gd2hpbGUgdXNpbmcgdGhlIGAvYXBwYCByb3V0ZXIsIHRoaXMgaXMgbm90IHN1cHBvcnRlZC4gUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9hcHAtZGlyLWR5bmFtaWMtaHJlZlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgeyBocmVmLCBhcyB9ID0gX3JlYWN0LmRlZmF1bHQudXNlTWVtbygoKT0+e1xuICAgICAgICBpZiAoIXBhZ2VzUm91dGVyKSB7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZEhyZWYgPSBmb3JtYXRTdHJpbmdPclVybChocmVmUHJvcCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGhyZWY6IHJlc29sdmVkSHJlZixcbiAgICAgICAgICAgICAgICBhczogYXNQcm9wID8gZm9ybWF0U3RyaW5nT3JVcmwoYXNQcm9wKSA6IHJlc29sdmVkSHJlZlxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbcmVzb2x2ZWRIcmVmLCByZXNvbHZlZEFzXSA9ICgwLCBfcmVzb2x2ZWhyZWYucmVzb2x2ZUhyZWYpKHBhZ2VzUm91dGVyLCBocmVmUHJvcCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBocmVmOiByZXNvbHZlZEhyZWYsXG4gICAgICAgICAgICBhczogYXNQcm9wID8gKDAsIF9yZXNvbHZlaHJlZi5yZXNvbHZlSHJlZikocGFnZXNSb3V0ZXIsIGFzUHJvcCkgOiByZXNvbHZlZEFzIHx8IHJlc29sdmVkSHJlZlxuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgcGFnZXNSb3V0ZXIsXG4gICAgICAgIGhyZWZQcm9wLFxuICAgICAgICBhc1Byb3BcbiAgICBdKTtcbiAgICBjb25zdCBwcmV2aW91c0hyZWYgPSBfcmVhY3QuZGVmYXVsdC51c2VSZWYoaHJlZik7XG4gICAgY29uc3QgcHJldmlvdXNBcyA9IF9yZWFjdC5kZWZhdWx0LnVzZVJlZihhcyk7XG4gICAgLy8gVGhpcyB3aWxsIHJldHVybiB0aGUgZmlyc3QgY2hpbGQsIGlmIG11bHRpcGxlIGFyZSBwcm92aWRlZCBpdCB3aWxsIHRocm93IGFuIGVycm9yXG4gICAgbGV0IGNoaWxkO1xuICAgIGlmIChsZWdhY3lCZWhhdmlvcikge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgICAgICAgaWYgKG9uQ2xpY2spIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1wib25DbGlja1wiIHdhcyBwYXNzZWQgdG8gPExpbms+IHdpdGggYGhyZWZgIG9mIGAnICsgaHJlZlByb3AgKyAnYCBidXQgXCJsZWdhY3lCZWhhdmlvclwiIHdhcyBzZXQuIFRoZSBsZWdhY3kgYmVoYXZpb3IgcmVxdWlyZXMgb25DbGljayBiZSBzZXQgb24gdGhlIGNoaWxkIG9mIG5leHQvbGluaycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uTW91c2VFbnRlclByb3ApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1wib25Nb3VzZUVudGVyXCIgd2FzIHBhc3NlZCB0byA8TGluaz4gd2l0aCBgaHJlZmAgb2YgYCcgKyBocmVmUHJvcCArICdgIGJ1dCBcImxlZ2FjeUJlaGF2aW9yXCIgd2FzIHNldC4gVGhlIGxlZ2FjeSBiZWhhdmlvciByZXF1aXJlcyBvbk1vdXNlRW50ZXIgYmUgc2V0IG9uIHRoZSBjaGlsZCBvZiBuZXh0L2xpbmsnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBfcmVhY3QuZGVmYXVsdC5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gY2hpbGRyZW4gd2VyZSBwYXNzZWQgdG8gPExpbms+IHdpdGggYGhyZWZgIG9mIGBcIiArIGhyZWZQcm9wICsgXCJgIGJ1dCBvbmUgY2hpbGQgaXMgcmVxdWlyZWQgaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbGluay1uby1jaGlsZHJlblwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVsdGlwbGUgY2hpbGRyZW4gd2VyZSBwYXNzZWQgdG8gPExpbms+IHdpdGggYGhyZWZgIG9mIGBcIiArIGhyZWZQcm9wICsgXCJgIGJ1dCBvbmx5IG9uZSBjaGlsZCBpcyBzdXBwb3J0ZWQgaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbGluay1tdWx0aXBsZS1jaGlsZHJlblwiICsgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyBcIiBcXG5PcGVuIHlvdXIgYnJvd3NlcidzIGNvbnNvbGUgdG8gdmlldyB0aGUgQ29tcG9uZW50IHN0YWNrIHRyYWNlLlwiIDogXCJcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hpbGQgPSBfcmVhY3QuZGVmYXVsdC5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XG4gICAgICAgICAgICBpZiAoKGNoaWxkcmVuID09IG51bGwgPyB2b2lkIDAgOiBjaGlsZHJlbi50eXBlKSA9PT0gXCJhXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIDxMaW5rPiB3aXRoIDxhPiBjaGlsZC4gUGxlYXNlIHJlbW92ZSA8YT4gb3IgdXNlIDxMaW5rIGxlZ2FjeUJlaGF2aW9yPi5cXG5MZWFybiBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9pbnZhbGlkLW5ldy1saW5rLXdpdGgtZXh0cmEtYW5jaG9yXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkUmVmID0gbGVnYWN5QmVoYXZpb3IgPyBjaGlsZCAmJiB0eXBlb2YgY2hpbGQgPT09IFwib2JqZWN0XCIgJiYgY2hpbGQucmVmIDogZm9yd2FyZGVkUmVmO1xuICAgIGNvbnN0IFtzZXRJbnRlcnNlY3Rpb25SZWYsIGlzVmlzaWJsZSwgcmVzZXRWaXNpYmxlXSA9ICgwLCBfdXNlaW50ZXJzZWN0aW9uLnVzZUludGVyc2VjdGlvbikoe1xuICAgICAgICByb290TWFyZ2luOiBcIjIwMHB4XCJcbiAgICB9KTtcbiAgICBjb25zdCBzZXRSZWYgPSBfcmVhY3QuZGVmYXVsdC51c2VDYWxsYmFjaygoZWwpPT57XG4gICAgICAgIC8vIEJlZm9yZSB0aGUgbGluayBnZXR0aW5nIG9ic2VydmVkLCBjaGVjayBpZiB2aXNpYmxlIHN0YXRlIG5lZWQgdG8gYmUgcmVzZXRcbiAgICAgICAgaWYgKHByZXZpb3VzQXMuY3VycmVudCAhPT0gYXMgfHwgcHJldmlvdXNIcmVmLmN1cnJlbnQgIT09IGhyZWYpIHtcbiAgICAgICAgICAgIHJlc2V0VmlzaWJsZSgpO1xuICAgICAgICAgICAgcHJldmlvdXNBcy5jdXJyZW50ID0gYXM7XG4gICAgICAgICAgICBwcmV2aW91c0hyZWYuY3VycmVudCA9IGhyZWY7XG4gICAgICAgIH1cbiAgICAgICAgc2V0SW50ZXJzZWN0aW9uUmVmKGVsKTtcbiAgICAgICAgaWYgKGNoaWxkUmVmKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNoaWxkUmVmID09PSBcImZ1bmN0aW9uXCIpIGNoaWxkUmVmKGVsKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjaGlsZFJlZiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGNoaWxkUmVmLmN1cnJlbnQgPSBlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgYXMsXG4gICAgICAgIGNoaWxkUmVmLFxuICAgICAgICBocmVmLFxuICAgICAgICByZXNldFZpc2libGUsXG4gICAgICAgIHNldEludGVyc2VjdGlvblJlZlxuICAgIF0pO1xuICAgIC8vIFByZWZldGNoIHRoZSBVUkwgaWYgd2UgaGF2ZW4ndCBhbHJlYWR5IGFuZCBpdCdzIHZpc2libGUuXG4gICAgX3JlYWN0LmRlZmF1bHQudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIC8vIGluIGRldiwgd2Ugb25seSBwcmVmZXRjaCBvbiBob3ZlciB0byBhdm9pZCB3YXN0aW5nIHJlc291cmNlcyBhcyB0aGUgcHJlZmV0Y2ggd2lsbCB0cmlnZ2VyIGNvbXBpbGluZyB0aGUgcGFnZS5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcm91dGVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgZG9uJ3QgbmVlZCB0byBwcmVmZXRjaCB0aGUgVVJMLCBkb24ndCBkbyBwcmVmZXRjaC5cbiAgICAgICAgaWYgKCFpc1Zpc2libGUgfHwgIXByZWZldGNoRW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZWZldGNoIHRoZSBVUkwuXG4gICAgICAgIHByZWZldGNoKHJvdXRlciwgaHJlZiwgYXMsIHtcbiAgICAgICAgICAgIGxvY2FsZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBraW5kOiBhcHBQcmVmZXRjaEtpbmRcbiAgICAgICAgfSwgaXNBcHBSb3V0ZXIpO1xuICAgIH0sIFtcbiAgICAgICAgYXMsXG4gICAgICAgIGhyZWYsXG4gICAgICAgIGlzVmlzaWJsZSxcbiAgICAgICAgbG9jYWxlLFxuICAgICAgICBwcmVmZXRjaEVuYWJsZWQsXG4gICAgICAgIHBhZ2VzUm91dGVyID09IG51bGwgPyB2b2lkIDAgOiBwYWdlc1JvdXRlci5sb2NhbGUsXG4gICAgICAgIHJvdXRlcixcbiAgICAgICAgaXNBcHBSb3V0ZXIsXG4gICAgICAgIGFwcFByZWZldGNoS2luZFxuICAgIF0pO1xuICAgIGNvbnN0IGNoaWxkUHJvcHMgPSB7XG4gICAgICAgIHJlZjogc2V0UmVmLFxuICAgICAgICBvbkNsaWNrIChlKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29tcG9uZW50IHJlbmRlcmVkIGluc2lkZSBuZXh0L2xpbmsgaGFzIHRvIHBhc3MgY2xpY2sgZXZlbnQgdG8gXCJvbkNsaWNrXCIgcHJvcC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWxlZ2FjeUJlaGF2aW9yICYmIHR5cGVvZiBvbkNsaWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBvbkNsaWNrKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlZ2FjeUJlaGF2aW9yICYmIGNoaWxkLnByb3BzICYmIHR5cGVvZiBjaGlsZC5wcm9wcy5vbkNsaWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5wcm9wcy5vbkNsaWNrKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyb3V0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlua0NsaWNrZWQoZSwgcm91dGVyLCBocmVmLCBhcywgcmVwbGFjZSwgc2hhbGxvdywgc2Nyb2xsLCBsb2NhbGUsIGlzQXBwUm91dGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Nb3VzZUVudGVyIChlKSB7XG4gICAgICAgICAgICBpZiAoIWxlZ2FjeUJlaGF2aW9yICYmIHR5cGVvZiBvbk1vdXNlRW50ZXJQcm9wID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBvbk1vdXNlRW50ZXJQcm9wKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlZ2FjeUJlaGF2aW9yICYmIGNoaWxkLnByb3BzICYmIHR5cGVvZiBjaGlsZC5wcm9wcy5vbk1vdXNlRW50ZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGNoaWxkLnByb3BzLm9uTW91c2VFbnRlcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcm91dGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCghcHJlZmV0Y2hFbmFibGVkIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpICYmIGlzQXBwUm91dGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJlZmV0Y2gocm91dGVyLCBocmVmLCBhcywge1xuICAgICAgICAgICAgICAgIGxvY2FsZSxcbiAgICAgICAgICAgICAgICBwcmlvcml0eTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAvLyBAc2VlIHtodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL25leHQuanMvZGlzY3Vzc2lvbnMvNDAyNjg/c29ydD10b3AjZGlzY3Vzc2lvbmNvbW1lbnQtMzU3MjY0Mn1cbiAgICAgICAgICAgICAgICBieXBhc3NQcmVmZXRjaGVkQ2hlY2s6IHRydWVcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBraW5kOiBhcHBQcmVmZXRjaEtpbmRcbiAgICAgICAgICAgIH0sIGlzQXBwUm91dGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Ub3VjaFN0YXJ0IChlKSB7XG4gICAgICAgICAgICBpZiAoIWxlZ2FjeUJlaGF2aW9yICYmIHR5cGVvZiBvblRvdWNoU3RhcnRQcm9wID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBvblRvdWNoU3RhcnRQcm9wKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlZ2FjeUJlaGF2aW9yICYmIGNoaWxkLnByb3BzICYmIHR5cGVvZiBjaGlsZC5wcm9wcy5vblRvdWNoU3RhcnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGNoaWxkLnByb3BzLm9uVG91Y2hTdGFydChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcm91dGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwcmVmZXRjaEVuYWJsZWQgJiYgaXNBcHBSb3V0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmVmZXRjaChyb3V0ZXIsIGhyZWYsIGFzLCB7XG4gICAgICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgICAgIHByaW9yaXR5OiB0cnVlLFxuICAgICAgICAgICAgICAgIC8vIEBzZWUge2h0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qcy9kaXNjdXNzaW9ucy80MDI2OD9zb3J0PXRvcCNkaXNjdXNzaW9uY29tbWVudC0zNTcyNjQyfVxuICAgICAgICAgICAgICAgIGJ5cGFzc1ByZWZldGNoZWRDaGVjazogdHJ1ZVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGtpbmQ6IGFwcFByZWZldGNoS2luZFxuICAgICAgICAgICAgfSwgaXNBcHBSb3V0ZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBJZiBjaGlsZCBpcyBhbiA8YT4gdGFnIGFuZCBkb2Vzbid0IGhhdmUgYSBocmVmIGF0dHJpYnV0ZSwgb3IgaWYgdGhlICdwYXNzSHJlZicgcHJvcGVydHkgaXNcbiAgICAvLyBkZWZpbmVkLCB3ZSBzcGVjaWZ5IHRoZSBjdXJyZW50ICdocmVmJywgc28gdGhhdCByZXBldGl0aW9uIGlzIG5vdCBuZWVkZWQgYnkgdGhlIHVzZXIuXG4gICAgLy8gSWYgdGhlIHVybCBpcyBhYnNvbHV0ZSwgd2UgY2FuIGJ5cGFzcyB0aGUgbG9naWMgdG8gcHJlcGVuZCB0aGUgZG9tYWluIGFuZCBsb2NhbGUuXG4gICAgaWYgKCgwLCBfdXRpbHMuaXNBYnNvbHV0ZVVybCkoYXMpKSB7XG4gICAgICAgIGNoaWxkUHJvcHMuaHJlZiA9IGFzO1xuICAgIH0gZWxzZSBpZiAoIWxlZ2FjeUJlaGF2aW9yIHx8IHBhc3NIcmVmIHx8IGNoaWxkLnR5cGUgPT09IFwiYVwiICYmICEoXCJocmVmXCIgaW4gY2hpbGQucHJvcHMpKSB7XG4gICAgICAgIGNvbnN0IGN1ckxvY2FsZSA9IHR5cGVvZiBsb2NhbGUgIT09IFwidW5kZWZpbmVkXCIgPyBsb2NhbGUgOiBwYWdlc1JvdXRlciA9PSBudWxsID8gdm9pZCAwIDogcGFnZXNSb3V0ZXIubG9jYWxlO1xuICAgICAgICAvLyB3ZSBvbmx5IHJlbmRlciBkb21haW4gbG9jYWxlcyBpZiB3ZSBhcmUgY3VycmVudGx5IG9uIGEgZG9tYWluIGxvY2FsZVxuICAgICAgICAvLyBzbyB0aGF0IGxvY2FsZSBsaW5rcyBhcmUgc3RpbGwgdmlzaXRhYmxlIGluIGRldmVsb3BtZW50L3ByZXZpZXcgZW52c1xuICAgICAgICBjb25zdCBsb2NhbGVEb21haW4gPSAocGFnZXNSb3V0ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHBhZ2VzUm91dGVyLmlzTG9jYWxlRG9tYWluKSAmJiAoMCwgX2dldGRvbWFpbmxvY2FsZS5nZXREb21haW5Mb2NhbGUpKGFzLCBjdXJMb2NhbGUsIHBhZ2VzUm91dGVyID09IG51bGwgPyB2b2lkIDAgOiBwYWdlc1JvdXRlci5sb2NhbGVzLCBwYWdlc1JvdXRlciA9PSBudWxsID8gdm9pZCAwIDogcGFnZXNSb3V0ZXIuZG9tYWluTG9jYWxlcyk7XG4gICAgICAgIGNoaWxkUHJvcHMuaHJlZiA9IGxvY2FsZURvbWFpbiB8fCAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKGFzLCBjdXJMb2NhbGUsIHBhZ2VzUm91dGVyID09IG51bGwgPyB2b2lkIDAgOiBwYWdlc1JvdXRlci5kZWZhdWx0TG9jYWxlKSk7XG4gICAgfVxuICAgIHJldHVybiBsZWdhY3lCZWhhdmlvciA/IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY2xvbmVFbGVtZW50KGNoaWxkLCBjaGlsZFByb3BzKSA6IC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoXCJhXCIsIHtcbiAgICAgICAgLi4ucmVzdFByb3BzLFxuICAgICAgICAuLi5jaGlsZFByb3BzLFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICB9KTtcbn0pO1xuY29uc3QgX2RlZmF1bHQgPSBMaW5rO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1saW5rLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJfZGVmYXVsdCIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJfanN4cnVudGltZSIsIl9yZWFjdCIsIl8iLCJfcmVzb2x2ZWhyZWYiLCJfaXNsb2NhbHVybCIsIl9mb3JtYXR1cmwiLCJfdXRpbHMiLCJfYWRkbG9jYWxlIiwiX3JvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lIiwiX2FwcHJvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lIiwiX3VzZWludGVyc2VjdGlvbiIsIl9nZXRkb21haW5sb2NhbGUiLCJfYWRkYmFzZXBhdGgiLCJfcm91dGVycmVkdWNlcnR5cGVzIiwicHJlZmV0Y2hlZCIsIlNldCIsInByZWZldGNoIiwicm91dGVyIiwiaHJlZiIsImFzIiwib3B0aW9ucyIsImFwcE9wdGlvbnMiLCJpc0FwcFJvdXRlciIsImlzTG9jYWxVUkwiLCJieXBhc3NQcmVmZXRjaGVkQ2hlY2siLCJsb2NhbGUiLCJ1bmRlZmluZWQiLCJwcmVmZXRjaGVkS2V5IiwiaGFzIiwiYWRkIiwicHJlZmV0Y2hQcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJjYXRjaCIsImVyciIsInByb2Nlc3MiLCJpc01vZGlmaWVkRXZlbnQiLCJldmVudCIsImV2ZW50VGFyZ2V0IiwiY3VycmVudFRhcmdldCIsInRhcmdldCIsImdldEF0dHJpYnV0ZSIsIm1ldGFLZXkiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJhbHRLZXkiLCJuYXRpdmVFdmVudCIsIndoaWNoIiwibGlua0NsaWNrZWQiLCJlIiwicmVwbGFjZSIsInNoYWxsb3ciLCJzY3JvbGwiLCJub2RlTmFtZSIsImlzQW5jaG9yTm9kZU5hbWUiLCJ0b1VwcGVyQ2FzZSIsInByZXZlbnREZWZhdWx0IiwibmF2aWdhdGUiLCJyb3V0ZXJTY3JvbGwiLCJkZWZhdWx0Iiwic3RhcnRUcmFuc2l0aW9uIiwiZm9ybWF0U3RyaW5nT3JVcmwiLCJ1cmxPYmpPclN0cmluZyIsImZvcm1hdFVybCIsIkxpbmsiLCJmb3J3YXJkUmVmIiwiTGlua0NvbXBvbmVudCIsInByb3BzIiwiZm9yd2FyZGVkUmVmIiwiY2hpbGRyZW4iLCJocmVmUHJvcCIsImFzUHJvcCIsImNoaWxkcmVuUHJvcCIsInByZWZldGNoUHJvcCIsInBhc3NIcmVmIiwib25DbGljayIsIm9uTW91c2VFbnRlciIsIm9uTW91c2VFbnRlclByb3AiLCJvblRvdWNoU3RhcnQiLCJvblRvdWNoU3RhcnRQcm9wIiwibGVnYWN5QmVoYXZpb3IiLCJyZXN0UHJvcHMiLCJqc3giLCJwYWdlc1JvdXRlciIsInVzZUNvbnRleHQiLCJSb3V0ZXJDb250ZXh0IiwiYXBwUm91dGVyIiwiQXBwUm91dGVyQ29udGV4dCIsInByZWZldGNoRW5hYmxlZCIsImFwcFByZWZldGNoS2luZCIsIlByZWZldGNoS2luZCIsIkFVVE8iLCJGVUxMIiwiY3JlYXRlUHJvcEVycm9yIiwiYXJncyIsIkVycm9yIiwia2V5IiwiZXhwZWN0ZWQiLCJhY3R1YWwiLCJyZXF1aXJlZFByb3BzR3VhcmQiLCJyZXF1aXJlZFByb3BzIiwia2V5cyIsImZvckVhY2giLCJvcHRpb25hbFByb3BzR3VhcmQiLCJvcHRpb25hbFByb3BzIiwidmFsVHlwZSIsImhhc1dhcm5lZCIsInVzZVJlZiIsImN1cnJlbnQiLCJjb25zb2xlIiwid2FybiIsInBhdGhuYW1lIiwiaGFzRHluYW1pY1NlZ21lbnQiLCJzcGxpdCIsInNvbWUiLCJzZWdtZW50Iiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwidXNlTWVtbyIsInJlc29sdmVkSHJlZiIsInJlc29sdmVkQXMiLCJyZXNvbHZlSHJlZiIsInByZXZpb3VzSHJlZiIsInByZXZpb3VzQXMiLCJjaGlsZCIsIkNoaWxkcmVuIiwib25seSIsInR5cGUiLCJjaGlsZFJlZiIsInJlZiIsInNldEludGVyc2VjdGlvblJlZiIsImlzVmlzaWJsZSIsInJlc2V0VmlzaWJsZSIsInVzZUludGVyc2VjdGlvbiIsInJvb3RNYXJnaW4iLCJzZXRSZWYiLCJ1c2VDYWxsYmFjayIsImVsIiwidXNlRWZmZWN0Iiwia2luZCIsImNoaWxkUHJvcHMiLCJkZWZhdWx0UHJldmVudGVkIiwicHJpb3JpdHkiLCJpc0Fic29sdXRlVXJsIiwiY3VyTG9jYWxlIiwibG9jYWxlRG9tYWluIiwiaXNMb2NhbGVEb21haW4iLCJnZXREb21haW5Mb2NhbGUiLCJsb2NhbGVzIiwiZG9tYWluTG9jYWxlcyIsImFkZEJhc2VQYXRoIiwiYWRkTG9jYWxlIiwiZGVmYXVsdExvY2FsZSIsImNsb25lRWxlbWVudCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/link.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/request-idle-callback.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/request-idle-callback.js ***!
  \****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    requestIdleCallback: function() {\n        return requestIdleCallback;\n    },\n    cancelIdleCallback: function() {\n        return cancelIdleCallback;\n    }\n});\nconst requestIdleCallback = typeof self !== \"undefined\" && self.requestIdleCallback && self.requestIdleCallback.bind(window) || function(cb) {\n    let start = Date.now();\n    return self.setTimeout(function() {\n        cb({\n            didTimeout: false,\n            timeRemaining: function() {\n                return Math.max(0, 50 - (Date.now() - start));\n            }\n        });\n    }, 1);\n};\nconst cancelIdleCallback = typeof self !== \"undefined\" && self.cancelIdleCallback && self.cancelIdleCallback.bind(window) || function(id) {\n    return clearTimeout(id);\n};\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=request-idle-callback.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JlcXVlc3QtaWRsZS1jYWxsYmFjay5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUdOO0FBQ0EsU0FBU0csUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVQsT0FBT0MsY0FBYyxDQUFDTyxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFMLFNBQVM7SUFDYkcscUJBQXFCO1FBQ2pCLE9BQU9BO0lBQ1g7SUFDQUMsb0JBQW9CO1FBQ2hCLE9BQU9BO0lBQ1g7QUFDSjtBQUNBLE1BQU1ELHNCQUFzQixPQUFPUSxTQUFTLGVBQWVBLEtBQUtSLG1CQUFtQixJQUFJUSxLQUFLUixtQkFBbUIsQ0FBQ1MsSUFBSSxDQUFDQyxXQUFXLFNBQVNDLEVBQUU7SUFDdkksSUFBSUMsUUFBUUMsS0FBS0MsR0FBRztJQUNwQixPQUFPTixLQUFLTyxVQUFVLENBQUM7UUFDbkJKLEdBQUc7WUFDQ0ssWUFBWTtZQUNaQyxlQUFlO2dCQUNYLE9BQU9DLEtBQUtDLEdBQUcsQ0FBQyxHQUFHLEtBQU1OLENBQUFBLEtBQUtDLEdBQUcsS0FBS0YsS0FBSTtZQUM5QztRQUNKO0lBQ0osR0FBRztBQUNQO0FBQ0EsTUFBTVgscUJBQXFCLE9BQU9PLFNBQVMsZUFBZUEsS0FBS1Asa0JBQWtCLElBQUlPLEtBQUtQLGtCQUFrQixDQUFDUSxJQUFJLENBQUNDLFdBQVcsU0FBU1UsRUFBRTtJQUNwSSxPQUFPQyxhQUFhRDtBQUN4QjtBQUVBLElBQUksQ0FBQyxPQUFPdkIsUUFBUXlCLE9BQU8sS0FBSyxjQUFlLE9BQU96QixRQUFReUIsT0FBTyxLQUFLLFlBQVl6QixRQUFReUIsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPekIsUUFBUXlCLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcks1QixPQUFPQyxjQUFjLENBQUNDLFFBQVF5QixPQUFPLEVBQUUsY0FBYztRQUFFeEIsT0FBTztJQUFLO0lBQ25FSCxPQUFPNkIsTUFBTSxDQUFDM0IsUUFBUXlCLE9BQU8sRUFBRXpCO0lBQy9CRSxPQUFPRixPQUFPLEdBQUdBLFFBQVF5QixPQUFPO0FBQ2xDLEVBRUEsaURBQWlEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JlcXVlc3QtaWRsZS1jYWxsYmFjay5qcz8xZTIwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgcmVxdWVzdElkbGVDYWxsYmFjazogbnVsbCxcbiAgICBjYW5jZWxJZGxlQ2FsbGJhY2s6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgcmVxdWVzdElkbGVDYWxsYmFjazogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByZXF1ZXN0SWRsZUNhbGxiYWNrO1xuICAgIH0sXG4gICAgY2FuY2VsSWRsZUNhbGxiYWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNhbmNlbElkbGVDYWxsYmFjaztcbiAgICB9XG59KTtcbmNvbnN0IHJlcXVlc3RJZGxlQ2FsbGJhY2sgPSB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLnJlcXVlc3RJZGxlQ2FsbGJhY2sgJiYgc2VsZi5yZXF1ZXN0SWRsZUNhbGxiYWNrLmJpbmQod2luZG93KSB8fCBmdW5jdGlvbihjYikge1xuICAgIGxldCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgcmV0dXJuIHNlbGYuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgY2Ioe1xuICAgICAgICAgICAgZGlkVGltZW91dDogZmFsc2UsXG4gICAgICAgICAgICB0aW1lUmVtYWluaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgNTAgLSAoRGF0ZS5ub3coKSAtIHN0YXJ0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sIDEpO1xufTtcbmNvbnN0IGNhbmNlbElkbGVDYWxsYmFjayA9IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuY2FuY2VsSWRsZUNhbGxiYWNrICYmIHNlbGYuY2FuY2VsSWRsZUNhbGxiYWNrLmJpbmQod2luZG93KSB8fCBmdW5jdGlvbihpZCkge1xuICAgIHJldHVybiBjbGVhclRpbWVvdXQoaWQpO1xufTtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVxdWVzdC1pZGxlLWNhbGxiYWNrLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsInJlcXVlc3RJZGxlQ2FsbGJhY2siLCJjYW5jZWxJZGxlQ2FsbGJhY2siLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJzZWxmIiwiYmluZCIsIndpbmRvdyIsImNiIiwic3RhcnQiLCJEYXRlIiwibm93Iiwic2V0VGltZW91dCIsImRpZFRpbWVvdXQiLCJ0aW1lUmVtYWluaW5nIiwiTWF0aCIsIm1heCIsImlkIiwiY2xlYXJUaW1lb3V0IiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/request-idle-callback.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/resolve-href.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/resolve-href.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"resolveHref\", ({\n    enumerable: true,\n    get: function() {\n        return resolveHref;\n    }\n}));\nconst _querystring = __webpack_require__(/*! ../shared/lib/router/utils/querystring */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js\");\nconst _formaturl = __webpack_require__(/*! ../shared/lib/router/utils/format-url */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nconst _omit = __webpack_require__(/*! ../shared/lib/router/utils/omit */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/omit.js\");\nconst _utils = __webpack_require__(/*! ../shared/lib/utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nconst _normalizetrailingslash = __webpack_require__(/*! ./normalize-trailing-slash */ \"(app-pages-browser)/./node_modules/next/dist/client/normalize-trailing-slash.js\");\nconst _islocalurl = __webpack_require__(/*! ../shared/lib/router/utils/is-local-url */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nconst _utils1 = __webpack_require__(/*! ../shared/lib/router/utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/index.js\");\nconst _interpolateas = __webpack_require__(/*! ../shared/lib/router/utils/interpolate-as */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\");\nfunction resolveHref(router, href, resolveAs) {\n    // we use a dummy base url for relative urls\n    let base;\n    let urlAsString = typeof href === \"string\" ? href : (0, _formaturl.formatWithValidation)(href);\n    // repeated slashes and backslashes in the URL are considered\n    // invalid and will never match a Next.js page/file\n    const urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\\/\\//);\n    const urlAsStringNoProto = urlProtoMatch ? urlAsString.slice(urlProtoMatch[0].length) : urlAsString;\n    const urlParts = urlAsStringNoProto.split(\"?\", 1);\n    if ((urlParts[0] || \"\").match(/(\\/\\/|\\\\)/)) {\n        console.error(\"Invalid href '\" + urlAsString + \"' passed to next/router in page: '\" + router.pathname + \"'. Repeated forward-slashes (//) or backslashes \\\\ are not valid in the href.\");\n        const normalizedUrl = (0, _utils.normalizeRepeatedSlashes)(urlAsStringNoProto);\n        urlAsString = (urlProtoMatch ? urlProtoMatch[0] : \"\") + normalizedUrl;\n    }\n    // Return because it cannot be routed by the Next.js router\n    if (!(0, _islocalurl.isLocalURL)(urlAsString)) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n    try {\n        base = new URL(urlAsString.startsWith(\"#\") ? router.asPath : router.pathname, \"http://n\");\n    } catch (_) {\n        // fallback to / for invalid asPath values e.g. //\n        base = new URL(\"/\", \"http://n\");\n    }\n    try {\n        const finalUrl = new URL(urlAsString, base);\n        finalUrl.pathname = (0, _normalizetrailingslash.normalizePathTrailingSlash)(finalUrl.pathname);\n        let interpolatedAs = \"\";\n        if ((0, _utils1.isDynamicRoute)(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {\n            const query = (0, _querystring.searchParamsToUrlQuery)(finalUrl.searchParams);\n            const { result, params } = (0, _interpolateas.interpolateAs)(finalUrl.pathname, finalUrl.pathname, query);\n            if (result) {\n                interpolatedAs = (0, _formaturl.formatWithValidation)({\n                    pathname: result,\n                    hash: finalUrl.hash,\n                    query: (0, _omit.omit)(query, params)\n                });\n            }\n        }\n        // if the origin didn't change, it means we received a relative href\n        const resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;\n        return resolveAs ? [\n            resolvedHref,\n            interpolatedAs || resolvedHref\n        ] : resolvedHref;\n    } catch (_) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=resolve-href.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3Jlc29sdmUtaHJlZi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsK0NBQThDO0lBQzFDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsZUFBZUMsbUJBQU9BLENBQUMsbUlBQXdDO0FBQ3JFLE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDLGlJQUF1QztBQUNsRSxNQUFNRSxRQUFRRixtQkFBT0EsQ0FBQyxxSEFBaUM7QUFDdkQsTUFBTUcsU0FBU0gsbUJBQU9BLENBQUMsNkZBQXFCO0FBQzVDLE1BQU1JLDBCQUEwQkosbUJBQU9BLENBQUMsbUhBQTRCO0FBQ3BFLE1BQU1LLGNBQWNMLG1CQUFPQSxDQUFDLHFJQUF5QztBQUNyRSxNQUFNTSxVQUFVTixtQkFBT0EsQ0FBQyxpSEFBNEI7QUFDcEQsTUFBTU8saUJBQWlCUCxtQkFBT0EsQ0FBQyx5SUFBMkM7QUFDMUUsU0FBU0YsWUFBWVUsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLFNBQVM7SUFDeEMsNENBQTRDO0lBQzVDLElBQUlDO0lBQ0osSUFBSUMsY0FBYyxPQUFPSCxTQUFTLFdBQVdBLE9BQU8sQ0FBQyxHQUFHUixXQUFXWSxvQkFBb0IsRUFBRUo7SUFDekYsNkRBQTZEO0lBQzdELG1EQUFtRDtJQUNuRCxNQUFNSyxnQkFBZ0JGLFlBQVlHLEtBQUssQ0FBQztJQUN4QyxNQUFNQyxxQkFBcUJGLGdCQUFnQkYsWUFBWUssS0FBSyxDQUFDSCxhQUFhLENBQUMsRUFBRSxDQUFDSSxNQUFNLElBQUlOO0lBQ3hGLE1BQU1PLFdBQVdILG1CQUFtQkksS0FBSyxDQUFDLEtBQUs7SUFDL0MsSUFBSSxDQUFDRCxRQUFRLENBQUMsRUFBRSxJQUFJLEVBQUMsRUFBR0osS0FBSyxDQUFDLGNBQWM7UUFDeENNLFFBQVFDLEtBQUssQ0FBQyxtQkFBbUJWLGNBQWMsdUNBQXVDSixPQUFPZSxRQUFRLEdBQUc7UUFDeEcsTUFBTUMsZ0JBQWdCLENBQUMsR0FBR3JCLE9BQU9zQix3QkFBd0IsRUFBRVQ7UUFDM0RKLGNBQWMsQ0FBQ0UsZ0JBQWdCQSxhQUFhLENBQUMsRUFBRSxHQUFHLEVBQUMsSUFBS1U7SUFDNUQ7SUFDQSwyREFBMkQ7SUFDM0QsSUFBSSxDQUFDLENBQUMsR0FBR25CLFlBQVlxQixVQUFVLEVBQUVkLGNBQWM7UUFDM0MsT0FBT0YsWUFBWTtZQUNmRTtTQUNILEdBQUdBO0lBQ1I7SUFDQSxJQUFJO1FBQ0FELE9BQU8sSUFBSWdCLElBQUlmLFlBQVlnQixVQUFVLENBQUMsT0FBT3BCLE9BQU9xQixNQUFNLEdBQUdyQixPQUFPZSxRQUFRLEVBQUU7SUFDbEYsRUFBRSxPQUFPTyxHQUFHO1FBQ1Isa0RBQWtEO1FBQ2xEbkIsT0FBTyxJQUFJZ0IsSUFBSSxLQUFLO0lBQ3hCO0lBQ0EsSUFBSTtRQUNBLE1BQU1JLFdBQVcsSUFBSUosSUFBSWYsYUFBYUQ7UUFDdENvQixTQUFTUixRQUFRLEdBQUcsQ0FBQyxHQUFHbkIsd0JBQXdCNEIsMEJBQTBCLEVBQUVELFNBQVNSLFFBQVE7UUFDN0YsSUFBSVUsaUJBQWlCO1FBQ3JCLElBQUksQ0FBQyxHQUFHM0IsUUFBUTRCLGNBQWMsRUFBRUgsU0FBU1IsUUFBUSxLQUFLUSxTQUFTSSxZQUFZLElBQUl6QixXQUFXO1lBQ3RGLE1BQU0wQixRQUFRLENBQUMsR0FBR3JDLGFBQWFzQyxzQkFBc0IsRUFBRU4sU0FBU0ksWUFBWTtZQUM1RSxNQUFNLEVBQUVHLE1BQU0sRUFBRUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxHQUFHaEMsZUFBZWlDLGFBQWEsRUFBRVQsU0FBU1IsUUFBUSxFQUFFUSxTQUFTUixRQUFRLEVBQUVhO1lBQ25HLElBQUlFLFFBQVE7Z0JBQ1JMLGlCQUFpQixDQUFDLEdBQUdoQyxXQUFXWSxvQkFBb0IsRUFBRTtvQkFDbERVLFVBQVVlO29CQUNWRyxNQUFNVixTQUFTVSxJQUFJO29CQUNuQkwsT0FBTyxDQUFDLEdBQUdsQyxNQUFNd0MsSUFBSSxFQUFFTixPQUFPRztnQkFDbEM7WUFDSjtRQUNKO1FBQ0Esb0VBQW9FO1FBQ3BFLE1BQU1JLGVBQWVaLFNBQVNhLE1BQU0sS0FBS2pDLEtBQUtpQyxNQUFNLEdBQUdiLFNBQVN0QixJQUFJLENBQUNRLEtBQUssQ0FBQ2MsU0FBU2EsTUFBTSxDQUFDMUIsTUFBTSxJQUFJYSxTQUFTdEIsSUFBSTtRQUNsSCxPQUFPQyxZQUFZO1lBQ2ZpQztZQUNBVixrQkFBa0JVO1NBQ3JCLEdBQUdBO0lBQ1IsRUFBRSxPQUFPYixHQUFHO1FBQ1IsT0FBT3BCLFlBQVk7WUFDZkU7U0FDSCxHQUFHQTtJQUNSO0FBQ0o7QUFFQSxJQUFJLENBQUMsT0FBT2xCLFFBQVFtRCxPQUFPLEtBQUssY0FBZSxPQUFPbkQsUUFBUW1ELE9BQU8sS0FBSyxZQUFZbkQsUUFBUW1ELE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT25ELFFBQVFtRCxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLdEQsT0FBT0MsY0FBYyxDQUFDQyxRQUFRbUQsT0FBTyxFQUFFLGNBQWM7UUFBRWxELE9BQU87SUFBSztJQUNuRUgsT0FBT3VELE1BQU0sQ0FBQ3JELFFBQVFtRCxPQUFPLEVBQUVuRDtJQUMvQnNELE9BQU90RCxPQUFPLEdBQUdBLFFBQVFtRCxPQUFPO0FBQ2xDLEVBRUEsd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3Jlc29sdmUtaHJlZi5qcz8yZjllIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVzb2x2ZUhyZWZcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVIcmVmO1xuICAgIH1cbn0pO1xuY29uc3QgX3F1ZXJ5c3RyaW5nID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3F1ZXJ5c3RyaW5nXCIpO1xuY29uc3QgX2Zvcm1hdHVybCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9mb3JtYXQtdXJsXCIpO1xuY29uc3QgX29taXQgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvb21pdFwiKTtcbmNvbnN0IF91dGlscyA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3V0aWxzXCIpO1xuY29uc3QgX25vcm1hbGl6ZXRyYWlsaW5nc2xhc2ggPSByZXF1aXJlKFwiLi9ub3JtYWxpemUtdHJhaWxpbmctc2xhc2hcIik7XG5jb25zdCBfaXNsb2NhbHVybCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9pcy1sb2NhbC11cmxcIik7XG5jb25zdCBfdXRpbHMxID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzXCIpO1xuY29uc3QgX2ludGVycG9sYXRlYXMgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaW50ZXJwb2xhdGUtYXNcIik7XG5mdW5jdGlvbiByZXNvbHZlSHJlZihyb3V0ZXIsIGhyZWYsIHJlc29sdmVBcykge1xuICAgIC8vIHdlIHVzZSBhIGR1bW15IGJhc2UgdXJsIGZvciByZWxhdGl2ZSB1cmxzXG4gICAgbGV0IGJhc2U7XG4gICAgbGV0IHVybEFzU3RyaW5nID0gdHlwZW9mIGhyZWYgPT09IFwic3RyaW5nXCIgPyBocmVmIDogKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKGhyZWYpO1xuICAgIC8vIHJlcGVhdGVkIHNsYXNoZXMgYW5kIGJhY2tzbGFzaGVzIGluIHRoZSBVUkwgYXJlIGNvbnNpZGVyZWRcbiAgICAvLyBpbnZhbGlkIGFuZCB3aWxsIG5ldmVyIG1hdGNoIGEgTmV4dC5qcyBwYWdlL2ZpbGVcbiAgICBjb25zdCB1cmxQcm90b01hdGNoID0gdXJsQXNTdHJpbmcubWF0Y2goL15bYS16QS1aXXsxLH06XFwvXFwvLyk7XG4gICAgY29uc3QgdXJsQXNTdHJpbmdOb1Byb3RvID0gdXJsUHJvdG9NYXRjaCA/IHVybEFzU3RyaW5nLnNsaWNlKHVybFByb3RvTWF0Y2hbMF0ubGVuZ3RoKSA6IHVybEFzU3RyaW5nO1xuICAgIGNvbnN0IHVybFBhcnRzID0gdXJsQXNTdHJpbmdOb1Byb3RvLnNwbGl0KFwiP1wiLCAxKTtcbiAgICBpZiAoKHVybFBhcnRzWzBdIHx8IFwiXCIpLm1hdGNoKC8oXFwvXFwvfFxcXFwpLykpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkludmFsaWQgaHJlZiAnXCIgKyB1cmxBc1N0cmluZyArIFwiJyBwYXNzZWQgdG8gbmV4dC9yb3V0ZXIgaW4gcGFnZTogJ1wiICsgcm91dGVyLnBhdGhuYW1lICsgXCInLiBSZXBlYXRlZCBmb3J3YXJkLXNsYXNoZXMgKC8vKSBvciBiYWNrc2xhc2hlcyBcXFxcIGFyZSBub3QgdmFsaWQgaW4gdGhlIGhyZWYuXCIpO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkVXJsID0gKDAsIF91dGlscy5ub3JtYWxpemVSZXBlYXRlZFNsYXNoZXMpKHVybEFzU3RyaW5nTm9Qcm90byk7XG4gICAgICAgIHVybEFzU3RyaW5nID0gKHVybFByb3RvTWF0Y2ggPyB1cmxQcm90b01hdGNoWzBdIDogXCJcIikgKyBub3JtYWxpemVkVXJsO1xuICAgIH1cbiAgICAvLyBSZXR1cm4gYmVjYXVzZSBpdCBjYW5ub3QgYmUgcm91dGVkIGJ5IHRoZSBOZXh0LmpzIHJvdXRlclxuICAgIGlmICghKDAsIF9pc2xvY2FsdXJsLmlzTG9jYWxVUkwpKHVybEFzU3RyaW5nKSkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZUFzID8gW1xuICAgICAgICAgICAgdXJsQXNTdHJpbmdcbiAgICAgICAgXSA6IHVybEFzU3RyaW5nO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBiYXNlID0gbmV3IFVSTCh1cmxBc1N0cmluZy5zdGFydHNXaXRoKFwiI1wiKSA/IHJvdXRlci5hc1BhdGggOiByb3V0ZXIucGF0aG5hbWUsIFwiaHR0cDovL25cIik7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgICAvLyBmYWxsYmFjayB0byAvIGZvciBpbnZhbGlkIGFzUGF0aCB2YWx1ZXMgZS5nLiAvL1xuICAgICAgICBiYXNlID0gbmV3IFVSTChcIi9cIiwgXCJodHRwOi8vblwiKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZmluYWxVcmwgPSBuZXcgVVJMKHVybEFzU3RyaW5nLCBiYXNlKTtcbiAgICAgICAgZmluYWxVcmwucGF0aG5hbWUgPSAoMCwgX25vcm1hbGl6ZXRyYWlsaW5nc2xhc2gubm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2gpKGZpbmFsVXJsLnBhdGhuYW1lKTtcbiAgICAgICAgbGV0IGludGVycG9sYXRlZEFzID0gXCJcIjtcbiAgICAgICAgaWYgKCgwLCBfdXRpbHMxLmlzRHluYW1pY1JvdXRlKShmaW5hbFVybC5wYXRobmFtZSkgJiYgZmluYWxVcmwuc2VhcmNoUGFyYW1zICYmIHJlc29sdmVBcykge1xuICAgICAgICAgICAgY29uc3QgcXVlcnkgPSAoMCwgX3F1ZXJ5c3RyaW5nLnNlYXJjaFBhcmFtc1RvVXJsUXVlcnkpKGZpbmFsVXJsLnNlYXJjaFBhcmFtcyk7XG4gICAgICAgICAgICBjb25zdCB7IHJlc3VsdCwgcGFyYW1zIH0gPSAoMCwgX2ludGVycG9sYXRlYXMuaW50ZXJwb2xhdGVBcykoZmluYWxVcmwucGF0aG5hbWUsIGZpbmFsVXJsLnBhdGhuYW1lLCBxdWVyeSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkQXMgPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikoe1xuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICBoYXNoOiBmaW5hbFVybC5oYXNoLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeTogKDAsIF9vbWl0Lm9taXQpKHF1ZXJ5LCBwYXJhbXMpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIG9yaWdpbiBkaWRuJ3QgY2hhbmdlLCBpdCBtZWFucyB3ZSByZWNlaXZlZCBhIHJlbGF0aXZlIGhyZWZcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRIcmVmID0gZmluYWxVcmwub3JpZ2luID09PSBiYXNlLm9yaWdpbiA/IGZpbmFsVXJsLmhyZWYuc2xpY2UoZmluYWxVcmwub3JpZ2luLmxlbmd0aCkgOiBmaW5hbFVybC5ocmVmO1xuICAgICAgICByZXR1cm4gcmVzb2x2ZUFzID8gW1xuICAgICAgICAgICAgcmVzb2x2ZWRIcmVmLFxuICAgICAgICAgICAgaW50ZXJwb2xhdGVkQXMgfHwgcmVzb2x2ZWRIcmVmXG4gICAgICAgIF0gOiByZXNvbHZlZEhyZWY7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZUFzID8gW1xuICAgICAgICAgICAgdXJsQXNTdHJpbmdcbiAgICAgICAgXSA6IHVybEFzU3RyaW5nO1xuICAgIH1cbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2ZS1ocmVmLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJyZXNvbHZlSHJlZiIsIl9xdWVyeXN0cmluZyIsInJlcXVpcmUiLCJfZm9ybWF0dXJsIiwiX29taXQiLCJfdXRpbHMiLCJfbm9ybWFsaXpldHJhaWxpbmdzbGFzaCIsIl9pc2xvY2FsdXJsIiwiX3V0aWxzMSIsIl9pbnRlcnBvbGF0ZWFzIiwicm91dGVyIiwiaHJlZiIsInJlc29sdmVBcyIsImJhc2UiLCJ1cmxBc1N0cmluZyIsImZvcm1hdFdpdGhWYWxpZGF0aW9uIiwidXJsUHJvdG9NYXRjaCIsIm1hdGNoIiwidXJsQXNTdHJpbmdOb1Byb3RvIiwic2xpY2UiLCJsZW5ndGgiLCJ1cmxQYXJ0cyIsInNwbGl0IiwiY29uc29sZSIsImVycm9yIiwicGF0aG5hbWUiLCJub3JtYWxpemVkVXJsIiwibm9ybWFsaXplUmVwZWF0ZWRTbGFzaGVzIiwiaXNMb2NhbFVSTCIsIlVSTCIsInN0YXJ0c1dpdGgiLCJhc1BhdGgiLCJfIiwiZmluYWxVcmwiLCJub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCIsImludGVycG9sYXRlZEFzIiwiaXNEeW5hbWljUm91dGUiLCJzZWFyY2hQYXJhbXMiLCJxdWVyeSIsInNlYXJjaFBhcmFtc1RvVXJsUXVlcnkiLCJyZXN1bHQiLCJwYXJhbXMiLCJpbnRlcnBvbGF0ZUFzIiwiaGFzaCIsIm9taXQiLCJyZXNvbHZlZEhyZWYiLCJvcmlnaW4iLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/resolve-href.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/use-intersection.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/client/use-intersection.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"useIntersection\", ({\n    enumerable: true,\n    get: function() {\n        return useIntersection;\n    }\n}));\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nconst _requestidlecallback = __webpack_require__(/*! ./request-idle-callback */ \"(app-pages-browser)/./node_modules/next/dist/client/request-idle-callback.js\");\nconst hasIntersectionObserver = typeof IntersectionObserver === \"function\";\nconst observers = new Map();\nconst idList = [];\nfunction createObserver(options) {\n    const id = {\n        root: options.root || null,\n        margin: options.rootMargin || \"\"\n    };\n    const existing = idList.find((obj)=>obj.root === id.root && obj.margin === id.margin);\n    let instance;\n    if (existing) {\n        instance = observers.get(existing);\n        if (instance) {\n            return instance;\n        }\n    }\n    const elements = new Map();\n    const observer = new IntersectionObserver((entries)=>{\n        entries.forEach((entry)=>{\n            const callback = elements.get(entry.target);\n            const isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n            if (callback && isVisible) {\n                callback(isVisible);\n            }\n        });\n    }, options);\n    instance = {\n        id,\n        observer,\n        elements\n    };\n    idList.push(id);\n    observers.set(id, instance);\n    return instance;\n}\nfunction observe(element, callback, options) {\n    const { id, observer, elements } = createObserver(options);\n    elements.set(element, callback);\n    observer.observe(element);\n    return function unobserve() {\n        elements.delete(element);\n        observer.unobserve(element);\n        // Destroy observer when there's nothing left to watch:\n        if (elements.size === 0) {\n            observer.disconnect();\n            observers.delete(id);\n            const index = idList.findIndex((obj)=>obj.root === id.root && obj.margin === id.margin);\n            if (index > -1) {\n                idList.splice(index, 1);\n            }\n        }\n    };\n}\nfunction useIntersection(param) {\n    let { rootRef, rootMargin, disabled } = param;\n    const isDisabled = disabled || !hasIntersectionObserver;\n    const [visible, setVisible] = (0, _react.useState)(false);\n    const elementRef = (0, _react.useRef)(null);\n    const setElement = (0, _react.useCallback)((element)=>{\n        elementRef.current = element;\n    }, []);\n    (0, _react.useEffect)(()=>{\n        if (hasIntersectionObserver) {\n            if (isDisabled || visible) return;\n            const element = elementRef.current;\n            if (element && element.tagName) {\n                const unobserve = observe(element, (isVisible)=>isVisible && setVisible(isVisible), {\n                    root: rootRef == null ? void 0 : rootRef.current,\n                    rootMargin\n                });\n                return unobserve;\n            }\n        } else {\n            if (!visible) {\n                const idleCallback = (0, _requestidlecallback.requestIdleCallback)(()=>setVisible(true));\n                return ()=>(0, _requestidlecallback.cancelIdleCallback)(idleCallback);\n            }\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        isDisabled,\n        rootMargin,\n        rootRef,\n        visible,\n        elementRef.current\n    ]);\n    const resetVisible = (0, _react.useCallback)(()=>{\n        setVisible(false);\n    }, []);\n    return [\n        setElement,\n        visible,\n        resetVisible\n    ];\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-intersection.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3VzZS1pbnRlcnNlY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILG1EQUFrRDtJQUM5Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLFNBQVNDLG1CQUFPQSxDQUFDLG1GQUFPO0FBQzlCLE1BQU1DLHVCQUF1QkQsbUJBQU9BLENBQUMsNkdBQXlCO0FBQzlELE1BQU1FLDBCQUEwQixPQUFPQyx5QkFBeUI7QUFDaEUsTUFBTUMsWUFBWSxJQUFJQztBQUN0QixNQUFNQyxTQUFTLEVBQUU7QUFDakIsU0FBU0MsZUFBZUMsT0FBTztJQUMzQixNQUFNQyxLQUFLO1FBQ1BDLE1BQU1GLFFBQVFFLElBQUksSUFBSTtRQUN0QkMsUUFBUUgsUUFBUUksVUFBVSxJQUFJO0lBQ2xDO0lBQ0EsTUFBTUMsV0FBV1AsT0FBT1EsSUFBSSxDQUFDLENBQUNDLE1BQU1BLElBQUlMLElBQUksS0FBS0QsR0FBR0MsSUFBSSxJQUFJSyxJQUFJSixNQUFNLEtBQUtGLEdBQUdFLE1BQU07SUFDcEYsSUFBSUs7SUFDSixJQUFJSCxVQUFVO1FBQ1ZHLFdBQVdaLFVBQVVQLEdBQUcsQ0FBQ2dCO1FBQ3pCLElBQUlHLFVBQVU7WUFDVixPQUFPQTtRQUNYO0lBQ0o7SUFDQSxNQUFNQyxXQUFXLElBQUlaO0lBQ3JCLE1BQU1hLFdBQVcsSUFBSWYscUJBQXFCLENBQUNnQjtRQUN2Q0EsUUFBUUMsT0FBTyxDQUFDLENBQUNDO1lBQ2IsTUFBTUMsV0FBV0wsU0FBU3BCLEdBQUcsQ0FBQ3dCLE1BQU1FLE1BQU07WUFDMUMsTUFBTUMsWUFBWUgsTUFBTUksY0FBYyxJQUFJSixNQUFNSyxpQkFBaUIsR0FBRztZQUNwRSxJQUFJSixZQUFZRSxXQUFXO2dCQUN2QkYsU0FBU0U7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LFFBQVE4RCxPQUFPLEVBQUU5RDtJQUMvQmlFLE9BQU9qRSxPQUFPLEdBQUdBLFFBQVE4RCxPQUFPO0FBQ2xDLEVBRUEsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3VzZS1pbnRlcnNlY3Rpb24uanM/ZmQ5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInVzZUludGVyc2VjdGlvblwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdXNlSW50ZXJzZWN0aW9uO1xuICAgIH1cbn0pO1xuY29uc3QgX3JlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xuY29uc3QgX3JlcXVlc3RpZGxlY2FsbGJhY2sgPSByZXF1aXJlKFwiLi9yZXF1ZXN0LWlkbGUtY2FsbGJhY2tcIik7XG5jb25zdCBoYXNJbnRlcnNlY3Rpb25PYnNlcnZlciA9IHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciA9PT0gXCJmdW5jdGlvblwiO1xuY29uc3Qgb2JzZXJ2ZXJzID0gbmV3IE1hcCgpO1xuY29uc3QgaWRMaXN0ID0gW107XG5mdW5jdGlvbiBjcmVhdGVPYnNlcnZlcihvcHRpb25zKSB7XG4gICAgY29uc3QgaWQgPSB7XG4gICAgICAgIHJvb3Q6IG9wdGlvbnMucm9vdCB8fCBudWxsLFxuICAgICAgICBtYXJnaW46IG9wdGlvbnMucm9vdE1hcmdpbiB8fCBcIlwiXG4gICAgfTtcbiAgICBjb25zdCBleGlzdGluZyA9IGlkTGlzdC5maW5kKChvYmopPT5vYmoucm9vdCA9PT0gaWQucm9vdCAmJiBvYmoubWFyZ2luID09PSBpZC5tYXJnaW4pO1xuICAgIGxldCBpbnN0YW5jZTtcbiAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgaW5zdGFuY2UgPSBvYnNlcnZlcnMuZ2V0KGV4aXN0aW5nKTtcbiAgICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZWxlbWVudHMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKGVudHJpZXMpPT57XG4gICAgICAgIGVudHJpZXMuZm9yRWFjaCgoZW50cnkpPT57XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IGVsZW1lbnRzLmdldChlbnRyeS50YXJnZXQpO1xuICAgICAgICAgICAgY29uc3QgaXNWaXNpYmxlID0gZW50cnkuaXNJbnRlcnNlY3RpbmcgfHwgZW50cnkuaW50ZXJzZWN0aW9uUmF0aW8gPiAwO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrICYmIGlzVmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGlzVmlzaWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sIG9wdGlvbnMpO1xuICAgIGluc3RhbmNlID0ge1xuICAgICAgICBpZCxcbiAgICAgICAgb2JzZXJ2ZXIsXG4gICAgICAgIGVsZW1lbnRzXG4gICAgfTtcbiAgICBpZExpc3QucHVzaChpZCk7XG4gICAgb2JzZXJ2ZXJzLnNldChpZCwgaW5zdGFuY2UpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIG9ic2VydmUoZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGlkLCBvYnNlcnZlciwgZWxlbWVudHMgfSA9IGNyZWF0ZU9ic2VydmVyKG9wdGlvbnMpO1xuICAgIGVsZW1lbnRzLnNldChlbGVtZW50LCBjYWxsYmFjayk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5vYnNlcnZlKCkge1xuICAgICAgICBlbGVtZW50cy5kZWxldGUoZWxlbWVudCk7XG4gICAgICAgIG9ic2VydmVyLnVub2JzZXJ2ZShlbGVtZW50KTtcbiAgICAgICAgLy8gRGVzdHJveSBvYnNlcnZlciB3aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIHdhdGNoOlxuICAgICAgICBpZiAoZWxlbWVudHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgb2JzZXJ2ZXJzLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGlkTGlzdC5maW5kSW5kZXgoKG9iaik9Pm9iai5yb290ID09PSBpZC5yb290ICYmIG9iai5tYXJnaW4gPT09IGlkLm1hcmdpbik7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIGlkTGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHVzZUludGVyc2VjdGlvbihwYXJhbSkge1xuICAgIGxldCB7IHJvb3RSZWYsIHJvb3RNYXJnaW4sIGRpc2FibGVkIH0gPSBwYXJhbTtcbiAgICBjb25zdCBpc0Rpc2FibGVkID0gZGlzYWJsZWQgfHwgIWhhc0ludGVyc2VjdGlvbk9ic2VydmVyO1xuICAgIGNvbnN0IFt2aXNpYmxlLCBzZXRWaXNpYmxlXSA9ICgwLCBfcmVhY3QudXNlU3RhdGUpKGZhbHNlKTtcbiAgICBjb25zdCBlbGVtZW50UmVmID0gKDAsIF9yZWFjdC51c2VSZWYpKG51bGwpO1xuICAgIGNvbnN0IHNldEVsZW1lbnQgPSAoMCwgX3JlYWN0LnVzZUNhbGxiYWNrKSgoZWxlbWVudCk9PntcbiAgICAgICAgZWxlbWVudFJlZi5jdXJyZW50ID0gZWxlbWVudDtcbiAgICB9LCBbXSk7XG4gICAgKDAsIF9yZWFjdC51c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIGlmIChoYXNJbnRlcnNlY3Rpb25PYnNlcnZlcikge1xuICAgICAgICAgICAgaWYgKGlzRGlzYWJsZWQgfHwgdmlzaWJsZSkgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRSZWYuY3VycmVudDtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQudGFnTmFtZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVub2JzZXJ2ZSA9IG9ic2VydmUoZWxlbWVudCwgKGlzVmlzaWJsZSk9PmlzVmlzaWJsZSAmJiBzZXRWaXNpYmxlKGlzVmlzaWJsZSksIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdDogcm9vdFJlZiA9PSBudWxsID8gdm9pZCAwIDogcm9vdFJlZi5jdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICByb290TWFyZ2luXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVub2JzZXJ2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkbGVDYWxsYmFjayA9ICgwLCBfcmVxdWVzdGlkbGVjYWxsYmFjay5yZXF1ZXN0SWRsZUNhbGxiYWNrKSgoKT0+c2V0VmlzaWJsZSh0cnVlKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpPT4oMCwgX3JlcXVlc3RpZGxlY2FsbGJhY2suY2FuY2VsSWRsZUNhbGxiYWNrKShpZGxlQ2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIH0sIFtcbiAgICAgICAgaXNEaXNhYmxlZCxcbiAgICAgICAgcm9vdE1hcmdpbixcbiAgICAgICAgcm9vdFJlZixcbiAgICAgICAgdmlzaWJsZSxcbiAgICAgICAgZWxlbWVudFJlZi5jdXJyZW50XG4gICAgXSk7XG4gICAgY29uc3QgcmVzZXRWaXNpYmxlID0gKDAsIF9yZWFjdC51c2VDYWxsYmFjaykoKCk9PntcbiAgICAgICAgc2V0VmlzaWJsZShmYWxzZSk7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBbXG4gICAgICAgIHNldEVsZW1lbnQsXG4gICAgICAgIHZpc2libGUsXG4gICAgICAgIHJlc2V0VmlzaWJsZVxuICAgIF07XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1pbnRlcnNlY3Rpb24uanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsInVzZUludGVyc2VjdGlvbiIsIl9yZWFjdCIsInJlcXVpcmUiLCJfcmVxdWVzdGlkbGVjYWxsYmFjayIsImhhc0ludGVyc2VjdGlvbk9ic2VydmVyIiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJvYnNlcnZlcnMiLCJNYXAiLCJpZExpc3QiLCJjcmVhdGVPYnNlcnZlciIsIm9wdGlvbnMiLCJpZCIsInJvb3QiLCJtYXJnaW4iLCJyb290TWFyZ2luIiwiZXhpc3RpbmciLCJmaW5kIiwib2JqIiwiaW5zdGFuY2UiLCJlbGVtZW50cyIsIm9ic2VydmVyIiwiZW50cmllcyIsImZvckVhY2giLCJlbnRyeSIsImNhbGxiYWNrIiwidGFyZ2V0IiwiaXNWaXNpYmxlIiwiaXNJbnRlcnNlY3RpbmciLCJpbnRlcnNlY3Rpb25SYXRpbyIsInB1c2giLCJzZXQiLCJvYnNlcnZlIiwiZWxlbWVudCIsInVub2JzZXJ2ZSIsImRlbGV0ZSIsInNpemUiLCJkaXNjb25uZWN0IiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJzcGxpY2UiLCJwYXJhbSIsInJvb3RSZWYiLCJkaXNhYmxlZCIsImlzRGlzYWJsZWQiLCJ2aXNpYmxlIiwic2V0VmlzaWJsZSIsInVzZVN0YXRlIiwiZWxlbWVudFJlZiIsInVzZVJlZiIsInNldEVsZW1lbnQiLCJ1c2VDYWxsYmFjayIsImN1cnJlbnQiLCJ1c2VFZmZlY3QiLCJ0YWdOYW1lIiwiaWRsZUNhbGxiYWNrIiwicmVxdWVzdElkbGVDYWxsYmFjayIsImNhbmNlbElkbGVDYWxsYmFjayIsInJlc2V0VmlzaWJsZSIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/use-intersection.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/escape-regexp.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/escape-regexp.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("// regexp is based on https://github.com/sindresorhus/escape-string-regexp\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"escapeStringRegexp\", ({\n    enumerable: true,\n    get: function() {\n        return escapeStringRegexp;\n    }\n}));\nconst reHasRegExp = /[|\\\\{}()[\\]^$+*?.-]/;\nconst reReplaceRegExp = /[|\\\\{}()[\\]^$+*?.-]/g;\nfunction escapeStringRegexp(str) {\n    // see also: https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/escapeRegExp.js#L23\n    if (reHasRegExp.test(str)) {\n        return str.replace(reReplaceRegExp, \"\\\\$&\");\n    }\n    return str;\n} //# sourceMappingURL=escape-regexp.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9lc2NhcGUtcmVnZXhwLmpzIiwibWFwcGluZ3MiOiJBQUFBLDBFQUEwRTtBQUM3RDtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsc0RBQXFEO0lBQ2pESSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsY0FBYztBQUNwQixNQUFNQyxrQkFBa0I7QUFDeEIsU0FBU0YsbUJBQW1CRyxHQUFHO0lBQzNCLCtHQUErRztJQUMvRyxJQUFJRixZQUFZRyxJQUFJLENBQUNELE1BQU07UUFDdkIsT0FBT0EsSUFBSUUsT0FBTyxDQUFDSCxpQkFBaUI7SUFDeEM7SUFDQSxPQUFPQztBQUNYLEVBRUEseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9lc2NhcGUtcmVnZXhwLmpzP2RiZmIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVnZXhwIGlzIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvZXNjYXBlLXN0cmluZy1yZWdleHBcblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZXNjYXBlU3RyaW5nUmVnZXhwXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBlc2NhcGVTdHJpbmdSZWdleHA7XG4gICAgfVxufSk7XG5jb25zdCByZUhhc1JlZ0V4cCA9IC9bfFxcXFx7fSgpW1xcXV4kKyo/Li1dLztcbmNvbnN0IHJlUmVwbGFjZVJlZ0V4cCA9IC9bfFxcXFx7fSgpW1xcXV4kKyo/Li1dL2c7XG5mdW5jdGlvbiBlc2NhcGVTdHJpbmdSZWdleHAoc3RyKSB7XG4gICAgLy8gc2VlIGFsc286IGh0dHBzOi8vZ2l0aHViLmNvbS9sb2Rhc2gvbG9kYXNoL2Jsb2IvMmRhMDI0YzNiNGY5OTQ3YTQ4NTE3NjM5ZGU3NTYwNDU3Y2Q0ZWM2Yy9lc2NhcGVSZWdFeHAuanMjTDIzXG4gICAgaWYgKHJlSGFzUmVnRXhwLnRlc3Qoc3RyKSkge1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UocmVSZXBsYWNlUmVnRXhwLCBcIlxcXFwkJlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXNjYXBlLXJlZ2V4cC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZXNjYXBlU3RyaW5nUmVnZXhwIiwicmVIYXNSZWdFeHAiLCJyZVJlcGxhY2VSZWdFeHAiLCJzdHIiLCJ0ZXN0IiwicmVwbGFjZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/escape-regexp.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/lazy-dynamic/dynamic-bailout-to-csr.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/lazy-dynamic/dynamic-bailout-to-csr.js ***!
  \**********************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"BailoutToCSR\", ({\n    enumerable: true,\n    get: function() {\n        return BailoutToCSR;\n    }\n}));\nconst _bailouttocsr = __webpack_require__(/*! ./bailout-to-csr */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js\");\nfunction BailoutToCSR(param) {\n    let { reason, children } = param;\n    if (false) {}\n    return children;\n} //# sourceMappingURL=dynamic-bailout-to-csr.js.map\n_c = BailoutToCSR;\nvar _c;\n$RefreshReg$(_c, \"BailoutToCSR\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9sYXp5LWR5bmFtaWMvZHluYW1pYy1iYWlsb3V0LXRvLWNzci5qcyIsIm1hcHBpbmdzIjoicURBRWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILGdEQUErQztJQUMzQ0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLGdCQUFnQkMsbUJBQU9BLENBQUMsZ0hBQWtCO0FBQ2hELFNBQVNGLGFBQWFHLEtBQUs7SUFDdkIsSUFBSSxFQUFFQyxNQUFNLEVBQUVDLFFBQVEsRUFBRSxHQUFHRjtJQUMzQixJQUFJLEtBQTZCLEVBQUUsRUFFbEM7SUFDRCxPQUFPRTtBQUNYLEVBRUEsa0RBQWtEO0tBUnpDTCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvbGF6eS1keW5hbWljL2R5bmFtaWMtYmFpbG91dC10by1jc3IuanM/ZjY5MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCYWlsb3V0VG9DU1JcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEJhaWxvdXRUb0NTUjtcbiAgICB9XG59KTtcbmNvbnN0IF9iYWlsb3V0dG9jc3IgPSByZXF1aXJlKFwiLi9iYWlsb3V0LXRvLWNzclwiKTtcbmZ1bmN0aW9uIEJhaWxvdXRUb0NTUihwYXJhbSkge1xuICAgIGxldCB7IHJlYXNvbiwgY2hpbGRyZW4gfSA9IHBhcmFtO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBfYmFpbG91dHRvY3NyLkJhaWxvdXRUb0NTUkVycm9yKHJlYXNvbik7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZHJlbjtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZHluYW1pYy1iYWlsb3V0LXRvLWNzci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiQmFpbG91dFRvQ1NSIiwiX2JhaWxvdXR0b2NzciIsInJlcXVpcmUiLCJwYXJhbSIsInJlYXNvbiIsImNoaWxkcmVuIiwiQmFpbG91dFRvQ1NSRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/lazy-dynamic/dynamic-bailout-to-csr.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router-context.shared-runtime.js ***!
  \****************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"RouterContext\", ({\n    enumerable: true,\n    get: function() {\n        return RouterContext;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst RouterContext = _react.default.createContext(null);\nif (true) {\n    RouterContext.displayName = \"RouterContext\";\n} //# sourceMappingURL=router-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsaURBQWdEO0lBQzVDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsMkJBQTJCQyxtQkFBT0EsQ0FBQyxnSUFBeUM7QUFDbEYsTUFBTUMsU0FBUyxXQUFXLEdBQUdGLHlCQUF5QkcsQ0FBQyxDQUFDRixtQkFBT0EsQ0FBQyxtRkFBTztBQUN2RSxNQUFNRixnQkFBZ0JHLE9BQU9FLE9BQU8sQ0FBQ0MsYUFBYSxDQUFDO0FBQ25ELElBQUlDLElBQXFDLEVBQUU7SUFDdkNQLGNBQWNRLFdBQVcsR0FBRztBQUNoQyxFQUVBLHlEQUF5RCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUuanM/OGZhMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJvdXRlckNvbnRleHRcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFJvdXRlckNvbnRleHQ7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0XCIpO1xuY29uc3QgX3JlYWN0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwicmVhY3RcIikpO1xuY29uc3QgUm91dGVyQ29udGV4dCA9IF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgUm91dGVyQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiUm91dGVyQ29udGV4dFwiO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiUm91dGVyQ29udGV4dCIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJfcmVhY3QiLCJfIiwiZGVmYXVsdCIsImNyZWF0ZUNvbnRleHQiLCJwcm9jZXNzIiwiZGlzcGxheU5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/format-url.js ***!
  \**********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("// Format function modified from nodejs\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    formatUrl: function() {\n        return formatUrl;\n    },\n    urlObjectKeys: function() {\n        return urlObjectKeys;\n    },\n    formatWithValidation: function() {\n        return formatWithValidation;\n    }\n});\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _querystring = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ./querystring */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js\"));\nconst slashedProtocols = /https?|ftp|gopher|file/;\nfunction formatUrl(urlObj) {\n    let { auth, hostname } = urlObj;\n    let protocol = urlObj.protocol || \"\";\n    let pathname = urlObj.pathname || \"\";\n    let hash = urlObj.hash || \"\";\n    let query = urlObj.query || \"\";\n    let host = false;\n    auth = auth ? encodeURIComponent(auth).replace(/%3A/i, \":\") + \"@\" : \"\";\n    if (urlObj.host) {\n        host = auth + urlObj.host;\n    } else if (hostname) {\n        host = auth + (~hostname.indexOf(\":\") ? \"[\" + hostname + \"]\" : hostname);\n        if (urlObj.port) {\n            host += \":\" + urlObj.port;\n        }\n    }\n    if (query && typeof query === \"object\") {\n        query = String(_querystring.urlQueryToSearchParams(query));\n    }\n    let search = urlObj.search || query && \"?\" + query || \"\";\n    if (protocol && !protocol.endsWith(\":\")) protocol += \":\";\n    if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {\n        host = \"//\" + (host || \"\");\n        if (pathname && pathname[0] !== \"/\") pathname = \"/\" + pathname;\n    } else if (!host) {\n        host = \"\";\n    }\n    if (hash && hash[0] !== \"#\") hash = \"#\" + hash;\n    if (search && search[0] !== \"?\") search = \"?\" + search;\n    pathname = pathname.replace(/[?#]/g, encodeURIComponent);\n    search = search.replace(\"#\", \"%23\");\n    return \"\" + protocol + host + pathname + search + hash;\n}\nconst urlObjectKeys = [\n    \"auth\",\n    \"hash\",\n    \"host\",\n    \"hostname\",\n    \"href\",\n    \"path\",\n    \"pathname\",\n    \"port\",\n    \"protocol\",\n    \"query\",\n    \"search\",\n    \"slashes\"\n];\nfunction formatWithValidation(url) {\n    if (true) {\n        if (url !== null && typeof url === \"object\") {\n            Object.keys(url).forEach((key)=>{\n                if (!urlObjectKeys.includes(key)) {\n                    console.warn(\"Unknown key passed via urlObject into url.format: \" + key);\n                }\n            });\n        }\n    }\n    return formatUrl(url);\n} //# sourceMappingURL=format-url.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZm9ybWF0LXVybC5qcyIsIm1hcHBpbmdzIjoiQUFBQSx1Q0FBdUM7QUFDdkMsc0RBQXNEO0FBQ3RELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUsZ0VBQWdFO0FBQ2hFLHNFQUFzRTtBQUN0RSxzRUFBc0U7QUFDdEUsNEVBQTRFO0FBQzVFLHFFQUFxRTtBQUNyRSx3QkFBd0I7QUFDeEIsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSx5REFBeUQ7QUFDekQsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSw2REFBNkQ7QUFDN0QsNEVBQTRFO0FBQzVFLDJFQUEyRTtBQUMzRSx3RUFBd0U7QUFDeEUsNEVBQTRFO0FBQzVFLHlDQUF5QztBQUM1QjtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUlOO0FBQ0EsU0FBU0ksUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVYsT0FBT0MsY0FBYyxDQUFDUSxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFOLFNBQVM7SUFDYkcsV0FBVztRQUNQLE9BQU9BO0lBQ1g7SUFDQUMsZUFBZTtRQUNYLE9BQU9BO0lBQ1g7SUFDQUMsc0JBQXNCO1FBQ2xCLE9BQU9BO0lBQ1g7QUFDSjtBQUNBLE1BQU1PLDRCQUE0QkMsbUJBQU9BLENBQUMsa0lBQTBDO0FBQ3BGLE1BQU1DLGVBQWUsV0FBVyxHQUFHRiwwQkFBMEJHLENBQUMsQ0FBQ0YsbUJBQU9BLENBQUMsMEdBQWU7QUFDdEYsTUFBTUcsbUJBQW1CO0FBQ3pCLFNBQVNiLFVBQVVjLE1BQU07SUFDckIsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLFFBQVEsRUFBRSxHQUFHRjtJQUN6QixJQUFJRyxXQUFXSCxPQUFPRyxRQUFRLElBQUk7SUFDbEMsSUFBSUMsV0FBV0osT0FBT0ksUUFBUSxJQUFJO0lBQ2xDLElBQUlDLE9BQU9MLE9BQU9LLElBQUksSUFBSTtJQUMxQixJQUFJQyxRQUFRTixPQUFPTSxLQUFLLElBQUk7SUFDNUIsSUFBSUMsT0FBTztJQUNYTixPQUFPQSxPQUFPTyxtQkFBbUJQLE1BQU1RLE9BQU8sQ0FBQyxRQUFRLE9BQU8sTUFBTTtJQUNwRSxJQUFJVCxPQUFPTyxJQUFJLEVBQUU7UUFDYkEsT0FBT04sT0FBT0QsT0FBT08sSUFBSTtJQUM3QixPQUFPLElBQUlMLFVBQVU7UUFDakJLLE9BQU9OLE9BQVEsRUFBQ0MsU0FBU1EsT0FBTyxDQUFDLE9BQU8sTUFBTVIsV0FBVyxNQUFNQSxRQUFPO1FBQ3RFLElBQUlGLE9BQU9XLElBQUksRUFBRTtZQUNiSixRQUFRLE1BQU1QLE9BQU9XLElBQUk7UUFDN0I7SUFDSjtJQUNBLElBQUlMLFNBQVMsT0FBT0EsVUFBVSxVQUFVO1FBQ3BDQSxRQUFRTSxPQUFPZixhQUFhZ0Isc0JBQXNCLENBQUNQO0lBQ3ZEO0lBQ0EsSUFBSVEsU0FBU2QsT0FBT2MsTUFBTSxJQUFJUixTQUFTLE1BQU1BLFNBQVM7SUFDdEQsSUFBSUgsWUFBWSxDQUFDQSxTQUFTWSxRQUFRLENBQUMsTUFBTVosWUFBWTtJQUNyRCxJQUFJSCxPQUFPZ0IsT0FBTyxJQUFJLENBQUMsQ0FBQ2IsWUFBWUosaUJBQWlCa0IsSUFBSSxDQUFDZCxTQUFRLEtBQU1JLFNBQVMsT0FBTztRQUNwRkEsT0FBTyxPQUFRQSxDQUFBQSxRQUFRLEVBQUM7UUFDeEIsSUFBSUgsWUFBWUEsUUFBUSxDQUFDLEVBQUUsS0FBSyxLQUFLQSxXQUFXLE1BQU1BO0lBQzFELE9BQU8sSUFBSSxDQUFDRyxNQUFNO1FBQ2RBLE9BQU87SUFDWDtJQUNBLElBQUlGLFFBQVFBLElBQUksQ0FBQyxFQUFFLEtBQUssS0FBS0EsT0FBTyxNQUFNQTtJQUMxQyxJQUFJUyxVQUFVQSxNQUFNLENBQUMsRUFBRSxLQUFLLEtBQUtBLFNBQVMsTUFBTUE7SUFDaERWLFdBQVdBLFNBQVNLLE9BQU8sQ0FBQyxTQUFTRDtJQUNyQ00sU0FBU0EsT0FBT0wsT0FBTyxDQUFDLEtBQUs7SUFDN0IsT0FBTyxLQUFLTixXQUFXSSxPQUFPSCxXQUFXVSxTQUFTVDtBQUN0RDtBQUNBLE1BQU1sQixnQkFBZ0I7SUFDbEI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0g7QUFDRCxTQUFTQyxxQkFBcUI4QixHQUFHO0lBQzdCLElBQUlDLElBQXNDLEVBQUU7UUFDeEMsSUFBSUQsUUFBUSxRQUFRLE9BQU9BLFFBQVEsVUFBVTtZQUN6Q3JDLE9BQU91QyxJQUFJLENBQUNGLEtBQUtHLE9BQU8sQ0FBQyxDQUFDQztnQkFDdEIsSUFBSSxDQUFDbkMsY0FBY29DLFFBQVEsQ0FBQ0QsTUFBTTtvQkFDOUJFLFFBQVFDLElBQUksQ0FBQyx1REFBdURIO2dCQUN4RTtZQUNKO1FBQ0o7SUFDSjtJQUNBLE9BQU9wQyxVQUFVZ0M7QUFDckIsRUFFQSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9mb3JtYXQtdXJsLmpzPzdiNTMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRm9ybWF0IGZ1bmN0aW9uIG1vZGlmaWVkIGZyb20gbm9kZWpzXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZm9ybWF0VXJsOiBudWxsLFxuICAgIHVybE9iamVjdEtleXM6IG51bGwsXG4gICAgZm9ybWF0V2l0aFZhbGlkYXRpb246IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgZm9ybWF0VXJsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdFVybDtcbiAgICB9LFxuICAgIHVybE9iamVjdEtleXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdXJsT2JqZWN0S2V5cztcbiAgICB9LFxuICAgIGZvcm1hdFdpdGhWYWxpZGF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdFdpdGhWYWxpZGF0aW9uO1xuICAgIH1cbn0pO1xuY29uc3QgX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkXCIpO1xuY29uc3QgX3F1ZXJ5c3RyaW5nID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLl8ocmVxdWlyZShcIi4vcXVlcnlzdHJpbmdcIikpO1xuY29uc3Qgc2xhc2hlZFByb3RvY29scyA9IC9odHRwcz98ZnRwfGdvcGhlcnxmaWxlLztcbmZ1bmN0aW9uIGZvcm1hdFVybCh1cmxPYmopIHtcbiAgICBsZXQgeyBhdXRoLCBob3N0bmFtZSB9ID0gdXJsT2JqO1xuICAgIGxldCBwcm90b2NvbCA9IHVybE9iai5wcm90b2NvbCB8fCBcIlwiO1xuICAgIGxldCBwYXRobmFtZSA9IHVybE9iai5wYXRobmFtZSB8fCBcIlwiO1xuICAgIGxldCBoYXNoID0gdXJsT2JqLmhhc2ggfHwgXCJcIjtcbiAgICBsZXQgcXVlcnkgPSB1cmxPYmoucXVlcnkgfHwgXCJcIjtcbiAgICBsZXQgaG9zdCA9IGZhbHNlO1xuICAgIGF1dGggPSBhdXRoID8gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpLnJlcGxhY2UoLyUzQS9pLCBcIjpcIikgKyBcIkBcIiA6IFwiXCI7XG4gICAgaWYgKHVybE9iai5ob3N0KSB7XG4gICAgICAgIGhvc3QgPSBhdXRoICsgdXJsT2JqLmhvc3Q7XG4gICAgfSBlbHNlIGlmIChob3N0bmFtZSkge1xuICAgICAgICBob3N0ID0gYXV0aCArICh+aG9zdG5hbWUuaW5kZXhPZihcIjpcIikgPyBcIltcIiArIGhvc3RuYW1lICsgXCJdXCIgOiBob3N0bmFtZSk7XG4gICAgICAgIGlmICh1cmxPYmoucG9ydCkge1xuICAgICAgICAgICAgaG9zdCArPSBcIjpcIiArIHVybE9iai5wb3J0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChxdWVyeSAmJiB0eXBlb2YgcXVlcnkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcXVlcnkgPSBTdHJpbmcoX3F1ZXJ5c3RyaW5nLnVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMocXVlcnkpKTtcbiAgICB9XG4gICAgbGV0IHNlYXJjaCA9IHVybE9iai5zZWFyY2ggfHwgcXVlcnkgJiYgXCI/XCIgKyBxdWVyeSB8fCBcIlwiO1xuICAgIGlmIChwcm90b2NvbCAmJiAhcHJvdG9jb2wuZW5kc1dpdGgoXCI6XCIpKSBwcm90b2NvbCArPSBcIjpcIjtcbiAgICBpZiAodXJsT2JqLnNsYXNoZXMgfHwgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xzLnRlc3QocHJvdG9jb2wpKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgICAgICBob3N0ID0gXCIvL1wiICsgKGhvc3QgfHwgXCJcIik7XG4gICAgICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZVswXSAhPT0gXCIvXCIpIHBhdGhuYW1lID0gXCIvXCIgKyBwYXRobmFtZTtcbiAgICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgICAgIGhvc3QgPSBcIlwiO1xuICAgIH1cbiAgICBpZiAoaGFzaCAmJiBoYXNoWzBdICE9PSBcIiNcIikgaGFzaCA9IFwiI1wiICsgaGFzaDtcbiAgICBpZiAoc2VhcmNoICYmIHNlYXJjaFswXSAhPT0gXCI/XCIpIHNlYXJjaCA9IFwiP1wiICsgc2VhcmNoO1xuICAgIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBlbmNvZGVVUklDb21wb25lbnQpO1xuICAgIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKFwiI1wiLCBcIiUyM1wiKTtcbiAgICByZXR1cm4gXCJcIiArIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn1cbmNvbnN0IHVybE9iamVjdEtleXMgPSBbXG4gICAgXCJhdXRoXCIsXG4gICAgXCJoYXNoXCIsXG4gICAgXCJob3N0XCIsXG4gICAgXCJob3N0bmFtZVwiLFxuICAgIFwiaHJlZlwiLFxuICAgIFwicGF0aFwiLFxuICAgIFwicGF0aG5hbWVcIixcbiAgICBcInBvcnRcIixcbiAgICBcInByb3RvY29sXCIsXG4gICAgXCJxdWVyeVwiLFxuICAgIFwic2VhcmNoXCIsXG4gICAgXCJzbGFzaGVzXCJcbl07XG5mdW5jdGlvbiBmb3JtYXRXaXRoVmFsaWRhdGlvbih1cmwpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgICBpZiAodXJsICE9PSBudWxsICYmIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHVybCkuZm9yRWFjaCgoa2V5KT0+e1xuICAgICAgICAgICAgICAgIGlmICghdXJsT2JqZWN0S2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlVua25vd24ga2V5IHBhc3NlZCB2aWEgdXJsT2JqZWN0IGludG8gdXJsLmZvcm1hdDogXCIgKyBrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmb3JtYXRVcmwodXJsKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9ybWF0LXVybC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJmb3JtYXRVcmwiLCJ1cmxPYmplY3RLZXlzIiwiZm9ybWF0V2l0aFZhbGlkYXRpb24iLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwicmVxdWlyZSIsIl9xdWVyeXN0cmluZyIsIl8iLCJzbGFzaGVkUHJvdG9jb2xzIiwidXJsT2JqIiwiYXV0aCIsImhvc3RuYW1lIiwicHJvdG9jb2wiLCJwYXRobmFtZSIsImhhc2giLCJxdWVyeSIsImhvc3QiLCJlbmNvZGVVUklDb21wb25lbnQiLCJyZXBsYWNlIiwiaW5kZXhPZiIsInBvcnQiLCJTdHJpbmciLCJ1cmxRdWVyeVRvU2VhcmNoUGFyYW1zIiwic2VhcmNoIiwiZW5kc1dpdGgiLCJzbGFzaGVzIiwidGVzdCIsInVybCIsInByb2Nlc3MiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsImluY2x1ZGVzIiwiY29uc29sZSIsIndhcm4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/index.js ***!
  \*****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getSortedRoutes: function() {\n        return _sortedroutes.getSortedRoutes;\n    },\n    isDynamicRoute: function() {\n        return _isdynamic.isDynamicRoute;\n    }\n});\nconst _sortedroutes = __webpack_require__(/*! ./sorted-routes */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/sorted-routes.js\");\nconst _isdynamic = __webpack_require__(/*! ./is-dynamic */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\"); //# sourceMappingURL=index.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0YsS0FBTUMsQ0FBQUEsQ0FHTjtBQUNBLFNBQVNHLFFBQVFDLE1BQU0sRUFBRUMsR0FBRztJQUN4QixJQUFJLElBQUlDLFFBQVFELElBQUlULE9BQU9DLGNBQWMsQ0FBQ08sUUFBUUUsTUFBTTtRQUNwREMsWUFBWTtRQUNaQyxLQUFLSCxHQUFHLENBQUNDLEtBQUs7SUFDbEI7QUFDSjtBQUNBSCxRQUFRTCxTQUFTO0lBQ2JHLGlCQUFpQjtRQUNiLE9BQU9RLGNBQWNSLGVBQWU7SUFDeEM7SUFDQUMsZ0JBQWdCO1FBQ1osT0FBT1EsV0FBV1IsY0FBYztJQUNwQztBQUNKO0FBQ0EsTUFBTU8sZ0JBQWdCRSxtQkFBT0EsQ0FBQyw4R0FBaUI7QUFDL0MsTUFBTUQsYUFBYUMsbUJBQU9BLENBQUMsd0dBQWMsR0FFekMsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaW5kZXguanM/ZjUyNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGdldFNvcnRlZFJvdXRlczogbnVsbCxcbiAgICBpc0R5bmFtaWNSb3V0ZTogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBnZXRTb3J0ZWRSb3V0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3NvcnRlZHJvdXRlcy5nZXRTb3J0ZWRSb3V0ZXM7XG4gICAgfSxcbiAgICBpc0R5bmFtaWNSb3V0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlO1xuICAgIH1cbn0pO1xuY29uc3QgX3NvcnRlZHJvdXRlcyA9IHJlcXVpcmUoXCIuL3NvcnRlZC1yb3V0ZXNcIik7XG5jb25zdCBfaXNkeW5hbWljID0gcmVxdWlyZShcIi4vaXMtZHluYW1pY1wiKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibW9kdWxlIiwiZ2V0U29ydGVkUm91dGVzIiwiaXNEeW5hbWljUm91dGUiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfc29ydGVkcm91dGVzIiwiX2lzZHluYW1pYyIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js":
/*!**************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js ***!
  \**************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"interpolateAs\", ({\n    enumerable: true,\n    get: function() {\n        return interpolateAs;\n    }\n}));\nconst _routematcher = __webpack_require__(/*! ./route-matcher */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-matcher.js\");\nconst _routeregex = __webpack_require__(/*! ./route-regex */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-regex.js\");\nfunction interpolateAs(route, asPathname, query) {\n    let interpolatedRoute = \"\";\n    const dynamicRegex = (0, _routeregex.getRouteRegex)(route);\n    const dynamicGroups = dynamicRegex.groups;\n    const dynamicMatches = (asPathname !== route ? (0, _routematcher.getRouteMatcher)(dynamicRegex)(asPathname) : \"\") || // Fall back to reading the values from the href\n    // TODO: should this take priority; also need to change in the router.\n    query;\n    interpolatedRoute = route;\n    const params = Object.keys(dynamicGroups);\n    if (!params.every((param)=>{\n        let value = dynamicMatches[param] || \"\";\n        const { repeat, optional } = dynamicGroups[param];\n        // support single-level catch-all\n        // TODO: more robust handling for user-error (passing `/`)\n        let replaced = \"[\" + (repeat ? \"...\" : \"\") + param + \"]\";\n        if (optional) {\n            replaced = (!value ? \"/\" : \"\") + \"[\" + replaced + \"]\";\n        }\n        if (repeat && !Array.isArray(value)) value = [\n            value\n        ];\n        return (optional || param in dynamicMatches) && // Interpolate group into data URL if present\n        (interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(// path delimiter escaped since they are being inserted\n        // into the URL and we expect URL encoded segments\n        // when parsing dynamic route params\n        (segment)=>encodeURIComponent(segment)).join(\"/\") : encodeURIComponent(value)) || \"/\");\n    })) {\n        interpolatedRoute = \"\" // did not satisfy all requirements\n        ;\n    // n.b. We ignore this error because we handle warning for this case in\n    // development in the `<Link>` component directly.\n    }\n    return {\n        params,\n        result: interpolatedRoute\n    };\n} //# sourceMappingURL=interpolate-as.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaW50ZXJwb2xhdGUtYXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILGlEQUFnRDtJQUM1Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLGdCQUFnQkMsbUJBQU9BLENBQUMsOEdBQWlCO0FBQy9DLE1BQU1DLGNBQWNELG1CQUFPQSxDQUFDLDBHQUFlO0FBQzNDLFNBQVNGLGNBQWNJLEtBQUssRUFBRUMsVUFBVSxFQUFFQyxLQUFLO0lBQzNDLElBQUlDLG9CQUFvQjtJQUN4QixNQUFNQyxlQUFlLENBQUMsR0FBR0wsWUFBWU0sYUFBYSxFQUFFTDtJQUNwRCxNQUFNTSxnQkFBZ0JGLGFBQWFHLE1BQU07SUFDekMsTUFBTUMsaUJBQ04sQ0FBQ1AsZUFBZUQsUUFBUSxDQUFDLEdBQUdILGNBQWNZLGVBQWUsRUFBRUwsY0FBY0gsY0FBYyxFQUFDLEtBQU0sZ0RBQWdEO0lBQzlJLHNFQUFzRTtJQUN0RUM7SUFDQUMsb0JBQW9CSDtJQUNwQixNQUFNVSxTQUFTcEIsT0FBT3FCLElBQUksQ0FBQ0w7SUFDM0IsSUFBSSxDQUFDSSxPQUFPRSxLQUFLLENBQUMsQ0FBQ0M7UUFDZixJQUFJcEIsUUFBUWUsY0FBYyxDQUFDSyxNQUFNLElBQUk7UUFDckMsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLFFBQVEsRUFBRSxHQUFHVCxhQUFhLENBQUNPLE1BQU07UUFDakQsaUNBQWlDO1FBQ2pDLDBEQUEwRDtRQUMxRCxJQUFJRyxXQUFXLE1BQU9GLENBQUFBLFNBQVMsUUFBUSxFQUFDLElBQUtELFFBQVE7UUFDckQsSUFBSUUsVUFBVTtZQUNWQyxXQUFXLENBQUMsQ0FBQ3ZCLFFBQVEsTUFBTSxFQUFDLElBQUssTUFBTXVCLFdBQVc7UUFDdEQ7UUFDQSxJQUFJRixVQUFVLENBQUNHLE1BQU1DLE9BQU8sQ0FBQ3pCLFFBQVFBLFFBQVE7WUFDekNBO1NBQ0g7UUFDRCxPQUFPLENBQUNzQixZQUFZRixTQUFTTCxjQUFhLEtBQU0sNkNBQTZDO1FBQzVGTCxDQUFBQSxvQkFBb0JBLGtCQUFrQmdCLE9BQU8sQ0FBQ0gsVUFBVUYsU0FBU3JCLE1BQU0yQixHQUFHLENBQzNFLHVEQUF1RDtRQUN2RCxrREFBa0Q7UUFDbEQsb0NBQW9DO1FBQ3BDLENBQUNDLFVBQVVDLG1CQUFtQkQsVUFBVUUsSUFBSSxDQUFDLE9BQU9ELG1CQUFtQjdCLFdBQVcsR0FBRTtJQUN4RixJQUFJO1FBQ0FVLG9CQUFvQixHQUFHLG1DQUFtQzs7SUFFOUQsdUVBQXVFO0lBQ3ZFLGtEQUFrRDtJQUNsRDtJQUNBLE9BQU87UUFDSE87UUFDQWMsUUFBUXJCO0lBQ1o7QUFDSixFQUVBLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2ludGVycG9sYXRlLWFzLmpzP2QwZTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpbnRlcnBvbGF0ZUFzXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpbnRlcnBvbGF0ZUFzO1xuICAgIH1cbn0pO1xuY29uc3QgX3JvdXRlbWF0Y2hlciA9IHJlcXVpcmUoXCIuL3JvdXRlLW1hdGNoZXJcIik7XG5jb25zdCBfcm91dGVyZWdleCA9IHJlcXVpcmUoXCIuL3JvdXRlLXJlZ2V4XCIpO1xuZnVuY3Rpb24gaW50ZXJwb2xhdGVBcyhyb3V0ZSwgYXNQYXRobmFtZSwgcXVlcnkpIHtcbiAgICBsZXQgaW50ZXJwb2xhdGVkUm91dGUgPSBcIlwiO1xuICAgIGNvbnN0IGR5bmFtaWNSZWdleCA9ICgwLCBfcm91dGVyZWdleC5nZXRSb3V0ZVJlZ2V4KShyb3V0ZSk7XG4gICAgY29uc3QgZHluYW1pY0dyb3VwcyA9IGR5bmFtaWNSZWdleC5ncm91cHM7XG4gICAgY29uc3QgZHluYW1pY01hdGNoZXMgPSAvLyBUcnkgdG8gbWF0Y2ggdGhlIGR5bmFtaWMgcm91dGUgYWdhaW5zdCB0aGUgYXNQYXRoXG4gICAgKGFzUGF0aG5hbWUgIT09IHJvdXRlID8gKDAsIF9yb3V0ZW1hdGNoZXIuZ2V0Um91dGVNYXRjaGVyKShkeW5hbWljUmVnZXgpKGFzUGF0aG5hbWUpIDogXCJcIikgfHwgLy8gRmFsbCBiYWNrIHRvIHJlYWRpbmcgdGhlIHZhbHVlcyBmcm9tIHRoZSBocmVmXG4gICAgLy8gVE9ETzogc2hvdWxkIHRoaXMgdGFrZSBwcmlvcml0eTsgYWxzbyBuZWVkIHRvIGNoYW5nZSBpbiB0aGUgcm91dGVyLlxuICAgIHF1ZXJ5O1xuICAgIGludGVycG9sYXRlZFJvdXRlID0gcm91dGU7XG4gICAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmtleXMoZHluYW1pY0dyb3Vwcyk7XG4gICAgaWYgKCFwYXJhbXMuZXZlcnkoKHBhcmFtKT0+e1xuICAgICAgICBsZXQgdmFsdWUgPSBkeW5hbWljTWF0Y2hlc1twYXJhbV0gfHwgXCJcIjtcbiAgICAgICAgY29uc3QgeyByZXBlYXQsIG9wdGlvbmFsIH0gPSBkeW5hbWljR3JvdXBzW3BhcmFtXTtcbiAgICAgICAgLy8gc3VwcG9ydCBzaW5nbGUtbGV2ZWwgY2F0Y2gtYWxsXG4gICAgICAgIC8vIFRPRE86IG1vcmUgcm9idXN0IGhhbmRsaW5nIGZvciB1c2VyLWVycm9yIChwYXNzaW5nIGAvYClcbiAgICAgICAgbGV0IHJlcGxhY2VkID0gXCJbXCIgKyAocmVwZWF0ID8gXCIuLi5cIiA6IFwiXCIpICsgcGFyYW0gKyBcIl1cIjtcbiAgICAgICAgaWYgKG9wdGlvbmFsKSB7XG4gICAgICAgICAgICByZXBsYWNlZCA9ICghdmFsdWUgPyBcIi9cIiA6IFwiXCIpICsgXCJbXCIgKyByZXBsYWNlZCArIFwiXVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXBlYXQgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB2YWx1ZSA9IFtcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiAob3B0aW9uYWwgfHwgcGFyYW0gaW4gZHluYW1pY01hdGNoZXMpICYmIC8vIEludGVycG9sYXRlIGdyb3VwIGludG8gZGF0YSBVUkwgaWYgcHJlc2VudFxuICAgICAgICAoaW50ZXJwb2xhdGVkUm91dGUgPSBpbnRlcnBvbGF0ZWRSb3V0ZS5yZXBsYWNlKHJlcGxhY2VkLCByZXBlYXQgPyB2YWx1ZS5tYXAoLy8gdGhlc2UgdmFsdWVzIHNob3VsZCBiZSBmdWxseSBlbmNvZGVkIGluc3RlYWQgb2YganVzdFxuICAgICAgICAvLyBwYXRoIGRlbGltaXRlciBlc2NhcGVkIHNpbmNlIHRoZXkgYXJlIGJlaW5nIGluc2VydGVkXG4gICAgICAgIC8vIGludG8gdGhlIFVSTCBhbmQgd2UgZXhwZWN0IFVSTCBlbmNvZGVkIHNlZ21lbnRzXG4gICAgICAgIC8vIHdoZW4gcGFyc2luZyBkeW5hbWljIHJvdXRlIHBhcmFtc1xuICAgICAgICAoc2VnbWVudCk9PmVuY29kZVVSSUNvbXBvbmVudChzZWdtZW50KSkuam9pbihcIi9cIikgOiBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKSB8fCBcIi9cIik7XG4gICAgfSkpIHtcbiAgICAgICAgaW50ZXJwb2xhdGVkUm91dGUgPSBcIlwiIC8vIGRpZCBub3Qgc2F0aXNmeSBhbGwgcmVxdWlyZW1lbnRzXG4gICAgICAgIDtcbiAgICAvLyBuLmIuIFdlIGlnbm9yZSB0aGlzIGVycm9yIGJlY2F1c2Ugd2UgaGFuZGxlIHdhcm5pbmcgZm9yIHRoaXMgY2FzZSBpblxuICAgIC8vIGRldmVsb3BtZW50IGluIHRoZSBgPExpbms+YCBjb21wb25lbnQgZGlyZWN0bHkuXG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgcmVzdWx0OiBpbnRlcnBvbGF0ZWRSb3V0ZVxuICAgIH07XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVycG9sYXRlLWFzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJpbnRlcnBvbGF0ZUFzIiwiX3JvdXRlbWF0Y2hlciIsInJlcXVpcmUiLCJfcm91dGVyZWdleCIsInJvdXRlIiwiYXNQYXRobmFtZSIsInF1ZXJ5IiwiaW50ZXJwb2xhdGVkUm91dGUiLCJkeW5hbWljUmVnZXgiLCJnZXRSb3V0ZVJlZ2V4IiwiZHluYW1pY0dyb3VwcyIsImdyb3VwcyIsImR5bmFtaWNNYXRjaGVzIiwiZ2V0Um91dGVNYXRjaGVyIiwicGFyYW1zIiwia2V5cyIsImV2ZXJ5IiwicGFyYW0iLCJyZXBlYXQiLCJvcHRpb25hbCIsInJlcGxhY2VkIiwiQXJyYXkiLCJpc0FycmF5IiwicmVwbGFjZSIsIm1hcCIsInNlZ21lbnQiLCJlbmNvZGVVUklDb21wb25lbnQiLCJqb2luIiwicmVzdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js ***!
  \**********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isDynamicRoute\", ({\n    enumerable: true,\n    get: function() {\n        return isDynamicRoute;\n    }\n}));\nconst _interceptionroutes = __webpack_require__(/*! ../../../../server/future/helpers/interception-routes */ \"(app-pages-browser)/./node_modules/next/dist/server/future/helpers/interception-routes.js\");\n// Identify /[param]/ in route string\nconst TEST_ROUTE = /\\/\\[[^/]+?\\](?=\\/|$)/;\nfunction isDynamicRoute(route) {\n    if ((0, _interceptionroutes.isInterceptionRouteAppPath)(route)) {\n        route = (0, _interceptionroutes.extractInterceptionRouteInformation)(route).interceptedRoute;\n    }\n    return TEST_ROUTE.test(route);\n} //# sourceMappingURL=is-dynamic.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtZHluYW1pYy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsa0RBQWlEO0lBQzdDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsc0JBQXNCQyxtQkFBT0EsQ0FBQyx3SkFBdUQ7QUFDM0YscUNBQXFDO0FBQ3JDLE1BQU1DLGFBQWE7QUFDbkIsU0FBU0gsZUFBZUksS0FBSztJQUN6QixJQUFJLENBQUMsR0FBR0gsb0JBQW9CSSwwQkFBMEIsRUFBRUQsUUFBUTtRQUM1REEsUUFBUSxDQUFDLEdBQUdILG9CQUFvQkssbUNBQW1DLEVBQUVGLE9BQU9HLGdCQUFnQjtJQUNoRztJQUNBLE9BQU9KLFdBQVdLLElBQUksQ0FBQ0o7QUFDM0IsRUFFQSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9pcy1keW5hbWljLmpzPzQ2ZjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0R5bmFtaWNSb3V0ZVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXNEeW5hbWljUm91dGU7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJjZXB0aW9ucm91dGVzID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL3NlcnZlci9mdXR1cmUvaGVscGVycy9pbnRlcmNlcHRpb24tcm91dGVzXCIpO1xuLy8gSWRlbnRpZnkgL1twYXJhbV0vIGluIHJvdXRlIHN0cmluZ1xuY29uc3QgVEVTVF9ST1VURSA9IC9cXC9cXFtbXi9dKz9cXF0oPz1cXC98JCkvO1xuZnVuY3Rpb24gaXNEeW5hbWljUm91dGUocm91dGUpIHtcbiAgICBpZiAoKDAsIF9pbnRlcmNlcHRpb25yb3V0ZXMuaXNJbnRlcmNlcHRpb25Sb3V0ZUFwcFBhdGgpKHJvdXRlKSkge1xuICAgICAgICByb3V0ZSA9ICgwLCBfaW50ZXJjZXB0aW9ucm91dGVzLmV4dHJhY3RJbnRlcmNlcHRpb25Sb3V0ZUluZm9ybWF0aW9uKShyb3V0ZSkuaW50ZXJjZXB0ZWRSb3V0ZTtcbiAgICB9XG4gICAgcmV0dXJuIFRFU1RfUk9VVEUudGVzdChyb3V0ZSk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLWR5bmFtaWMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsImlzRHluYW1pY1JvdXRlIiwiX2ludGVyY2VwdGlvbnJvdXRlcyIsInJlcXVpcmUiLCJURVNUX1JPVVRFIiwicm91dGUiLCJpc0ludGVyY2VwdGlvblJvdXRlQXBwUGF0aCIsImV4dHJhY3RJbnRlcmNlcHRpb25Sb3V0ZUluZm9ybWF0aW9uIiwiaW50ZXJjZXB0ZWRSb3V0ZSIsInRlc3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/is-local-url.js ***!
  \************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isLocalURL\", ({\n    enumerable: true,\n    get: function() {\n        return isLocalURL;\n    }\n}));\nconst _utils = __webpack_require__(/*! ../../utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nconst _hasbasepath = __webpack_require__(/*! ../../../../client/has-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/has-base-path.js\");\nfunction isLocalURL(url) {\n    // prevent a hydration mismatch on href for url with anchor refs\n    if (!(0, _utils.isAbsoluteUrl)(url)) return true;\n    try {\n        // absolute urls can be local if they are on the same origin\n        const locationOrigin = (0, _utils.getLocationOrigin)();\n        const resolved = new URL(url, locationOrigin);\n        return resolved.origin === locationOrigin && (0, _hasbasepath.hasBasePath)(resolved.pathname);\n    } catch (_) {\n        return false;\n    }\n} //# sourceMappingURL=is-local-url.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtbG9jYWwtdXJsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCw4Q0FBNkM7SUFDekNJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQyxTQUFTQyxtQkFBT0EsQ0FBQyxxRkFBYTtBQUNwQyxNQUFNQyxlQUFlRCxtQkFBT0EsQ0FBQyw4R0FBa0M7QUFDL0QsU0FBU0YsV0FBV0ksR0FBRztJQUNuQixnRUFBZ0U7SUFDaEUsSUFBSSxDQUFDLENBQUMsR0FBR0gsT0FBT0ksYUFBYSxFQUFFRCxNQUFNLE9BQU87SUFDNUMsSUFBSTtRQUNBLDREQUE0RDtRQUM1RCxNQUFNRSxpQkFBaUIsQ0FBQyxHQUFHTCxPQUFPTSxpQkFBaUI7UUFDbkQsTUFBTUMsV0FBVyxJQUFJQyxJQUFJTCxLQUFLRTtRQUM5QixPQUFPRSxTQUFTRSxNQUFNLEtBQUtKLGtCQUFrQixDQUFDLEdBQUdILGFBQWFRLFdBQVcsRUFBRUgsU0FBU0ksUUFBUTtJQUNoRyxFQUFFLE9BQU9DLEdBQUc7UUFDUixPQUFPO0lBQ1g7QUFDSixFQUVBLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2lzLWxvY2FsLXVybC5qcz81ZDI4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNMb2NhbFVSTFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXNMb2NhbFVSTDtcbiAgICB9XG59KTtcbmNvbnN0IF91dGlscyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbmNvbnN0IF9oYXNiYXNlcGF0aCA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9jbGllbnQvaGFzLWJhc2UtcGF0aFwiKTtcbmZ1bmN0aW9uIGlzTG9jYWxVUkwodXJsKSB7XG4gICAgLy8gcHJldmVudCBhIGh5ZHJhdGlvbiBtaXNtYXRjaCBvbiBocmVmIGZvciB1cmwgd2l0aCBhbmNob3IgcmVmc1xuICAgIGlmICghKDAsIF91dGlscy5pc0Fic29sdXRlVXJsKSh1cmwpKSByZXR1cm4gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICAvLyBhYnNvbHV0ZSB1cmxzIGNhbiBiZSBsb2NhbCBpZiB0aGV5IGFyZSBvbiB0aGUgc2FtZSBvcmlnaW5cbiAgICAgICAgY29uc3QgbG9jYXRpb25PcmlnaW4gPSAoMCwgX3V0aWxzLmdldExvY2F0aW9uT3JpZ2luKSgpO1xuICAgICAgICBjb25zdCByZXNvbHZlZCA9IG5ldyBVUkwodXJsLCBsb2NhdGlvbk9yaWdpbik7XG4gICAgICAgIHJldHVybiByZXNvbHZlZC5vcmlnaW4gPT09IGxvY2F0aW9uT3JpZ2luICYmICgwLCBfaGFzYmFzZXBhdGguaGFzQmFzZVBhdGgpKHJlc29sdmVkLnBhdGhuYW1lKTtcbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLWxvY2FsLXVybC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiaXNMb2NhbFVSTCIsIl91dGlscyIsInJlcXVpcmUiLCJfaGFzYmFzZXBhdGgiLCJ1cmwiLCJpc0Fic29sdXRlVXJsIiwibG9jYXRpb25PcmlnaW4iLCJnZXRMb2NhdGlvbk9yaWdpbiIsInJlc29sdmVkIiwiVVJMIiwib3JpZ2luIiwiaGFzQmFzZVBhdGgiLCJwYXRobmFtZSIsIl8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/omit.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/omit.js ***!
  \****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"omit\", ({\n    enumerable: true,\n    get: function() {\n        return omit;\n    }\n}));\nfunction omit(object, keys) {\n    const omitted = {};\n    Object.keys(object).forEach((key)=>{\n        if (!keys.includes(key)) {\n            omitted[key] = object[key];\n        }\n    });\n    return omitted;\n} //# sourceMappingURL=omit.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvb21pdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsd0NBQXVDO0lBQ25DSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsU0FBU0EsS0FBS0MsTUFBTSxFQUFFQyxJQUFJO0lBQ3RCLE1BQU1DLFVBQVUsQ0FBQztJQUNqQlQsT0FBT1EsSUFBSSxDQUFDRCxRQUFRRyxPQUFPLENBQUMsQ0FBQ0M7UUFDekIsSUFBSSxDQUFDSCxLQUFLSSxRQUFRLENBQUNELE1BQU07WUFDckJGLE9BQU8sQ0FBQ0UsSUFBSSxHQUFHSixNQUFNLENBQUNJLElBQUk7UUFDOUI7SUFDSjtJQUNBLE9BQU9GO0FBQ1gsRUFFQSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9vbWl0LmpzP2ZiNzgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJvbWl0XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBvbWl0O1xuICAgIH1cbn0pO1xuZnVuY3Rpb24gb21pdChvYmplY3QsIGtleXMpIHtcbiAgICBjb25zdCBvbWl0dGVkID0ge307XG4gICAgT2JqZWN0LmtleXMob2JqZWN0KS5mb3JFYWNoKChrZXkpPT57XG4gICAgICAgIGlmICgha2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICBvbWl0dGVkW2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvbWl0dGVkO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1vbWl0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJvbWl0Iiwib2JqZWN0Iiwia2V5cyIsIm9taXR0ZWQiLCJmb3JFYWNoIiwia2V5IiwiaW5jbHVkZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/omit.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/querystring.js ***!
  \***********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    searchParamsToUrlQuery: function() {\n        return searchParamsToUrlQuery;\n    },\n    urlQueryToSearchParams: function() {\n        return urlQueryToSearchParams;\n    },\n    assign: function() {\n        return assign;\n    }\n});\nfunction searchParamsToUrlQuery(searchParams) {\n    const query = {};\n    searchParams.forEach((value, key)=>{\n        if (typeof query[key] === \"undefined\") {\n            query[key] = value;\n        } else if (Array.isArray(query[key])) {\n            query[key].push(value);\n        } else {\n            query[key] = [\n                query[key],\n                value\n            ];\n        }\n    });\n    return query;\n}\nfunction stringifyUrlQueryParam(param) {\n    if (typeof param === \"string\" || typeof param === \"number\" && !isNaN(param) || typeof param === \"boolean\") {\n        return String(param);\n    } else {\n        return \"\";\n    }\n}\nfunction urlQueryToSearchParams(urlQuery) {\n    const result = new URLSearchParams();\n    Object.entries(urlQuery).forEach((param)=>{\n        let [key, value] = param;\n        if (Array.isArray(value)) {\n            value.forEach((item)=>result.append(key, stringifyUrlQueryParam(item)));\n        } else {\n            result.set(key, stringifyUrlQueryParam(value));\n        }\n    });\n    return result;\n}\nfunction assign(target) {\n    for(var _len = arguments.length, searchParamsList = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        searchParamsList[_key - 1] = arguments[_key];\n    }\n    searchParamsList.forEach((searchParams)=>{\n        Array.from(searchParams.keys()).forEach((key)=>target.delete(key));\n        searchParams.forEach((value, key)=>target.append(key, value));\n    });\n    return target;\n} //# sourceMappingURL=querystring.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcXVlcnlzdHJpbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0YsS0FBTUMsQ0FBQUEsQ0FJTjtBQUNBLFNBQVNJLFFBQVFDLE1BQU0sRUFBRUMsR0FBRztJQUN4QixJQUFJLElBQUlDLFFBQVFELElBQUlWLE9BQU9DLGNBQWMsQ0FBQ1EsUUFBUUUsTUFBTTtRQUNwREMsWUFBWTtRQUNaQyxLQUFLSCxHQUFHLENBQUNDLEtBQUs7SUFDbEI7QUFDSjtBQUNBSCxRQUFRTixTQUFTO0lBQ2JHLHdCQUF3QjtRQUNwQixPQUFPQTtJQUNYO0lBQ0FDLHdCQUF3QjtRQUNwQixPQUFPQTtJQUNYO0lBQ0FDLFFBQVE7UUFDSixPQUFPQTtJQUNYO0FBQ0o7QUFDQSxTQUFTRix1QkFBdUJTLFlBQVk7SUFDeEMsTUFBTUMsUUFBUSxDQUFDO0lBQ2ZELGFBQWFFLE9BQU8sQ0FBQyxDQUFDYixPQUFPYztRQUN6QixJQUFJLE9BQU9GLEtBQUssQ0FBQ0UsSUFBSSxLQUFLLGFBQWE7WUFDbkNGLEtBQUssQ0FBQ0UsSUFBSSxHQUFHZDtRQUNqQixPQUFPLElBQUllLE1BQU1DLE9BQU8sQ0FBQ0osS0FBSyxDQUFDRSxJQUFJLEdBQUc7WUFDbENGLEtBQUssQ0FBQ0UsSUFBSSxDQUFDRyxJQUFJLENBQUNqQjtRQUNwQixPQUFPO1lBQ0hZLEtBQUssQ0FBQ0UsSUFBSSxHQUFHO2dCQUNURixLQUFLLENBQUNFLElBQUk7Z0JBQ1ZkO2FBQ0g7UUFDTDtJQUNKO0lBQ0EsT0FBT1k7QUFDWDtBQUNBLFNBQVNNLHVCQUF1QkMsS0FBSztJQUNqQyxJQUFJLE9BQU9BLFVBQVUsWUFBWSxPQUFPQSxVQUFVLFlBQVksQ0FBQ0MsTUFBTUQsVUFBVSxPQUFPQSxVQUFVLFdBQVc7UUFDdkcsT0FBT0UsT0FBT0Y7SUFDbEIsT0FBTztRQUNILE9BQU87SUFDWDtBQUNKO0FBQ0EsU0FBU2hCLHVCQUF1Qm1CLFFBQVE7SUFDcEMsTUFBTUMsU0FBUyxJQUFJQztJQUNuQjNCLE9BQU80QixPQUFPLENBQUNILFVBQVVULE9BQU8sQ0FBQyxDQUFDTTtRQUM5QixJQUFJLENBQUNMLEtBQUtkLE1BQU0sR0FBR21CO1FBQ25CLElBQUlKLE1BQU1DLE9BQU8sQ0FBQ2hCLFFBQVE7WUFDdEJBLE1BQU1hLE9BQU8sQ0FBQyxDQUFDYSxPQUFPSCxPQUFPSSxNQUFNLENBQUNiLEtBQUtJLHVCQUF1QlE7UUFDcEUsT0FBTztZQUNISCxPQUFPSyxHQUFHLENBQUNkLEtBQUtJLHVCQUF1QmxCO1FBQzNDO0lBQ0o7SUFDQSxPQUFPdUI7QUFDWDtBQUNBLFNBQVNuQixPQUFPRSxNQUFNO0lBQ2xCLElBQUksSUFBSXVCLE9BQU9DLFVBQVVDLE1BQU0sRUFBRUMsbUJBQW1CLElBQUlqQixNQUFNYyxPQUFPLElBQUlBLE9BQU8sSUFBSSxJQUFJSSxPQUFPLEdBQUdBLE9BQU9KLE1BQU1JLE9BQU87UUFDbEhELGdCQUFnQixDQUFDQyxPQUFPLEVBQUUsR0FBR0gsU0FBUyxDQUFDRyxLQUFLO0lBQ2hEO0lBQ0FELGlCQUFpQm5CLE9BQU8sQ0FBQyxDQUFDRjtRQUN0QkksTUFBTW1CLElBQUksQ0FBQ3ZCLGFBQWF3QixJQUFJLElBQUl0QixPQUFPLENBQUMsQ0FBQ0MsTUFBTVIsT0FBTzhCLE1BQU0sQ0FBQ3RCO1FBQzdESCxhQUFhRSxPQUFPLENBQUMsQ0FBQ2IsT0FBT2MsTUFBTVIsT0FBT3FCLE1BQU0sQ0FBQ2IsS0FBS2Q7SUFDMUQ7SUFDQSxPQUFPTTtBQUNYLEVBRUEsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcXVlcnlzdHJpbmcuanM/MDE0OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIHNlYXJjaFBhcmFtc1RvVXJsUXVlcnk6IG51bGwsXG4gICAgdXJsUXVlcnlUb1NlYXJjaFBhcmFtczogbnVsbCxcbiAgICBhc3NpZ246IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgc2VhcmNoUGFyYW1zVG9VcmxRdWVyeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5O1xuICAgIH0sXG4gICAgdXJsUXVlcnlUb1NlYXJjaFBhcmFtczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB1cmxRdWVyeVRvU2VhcmNoUGFyYW1zO1xuICAgIH0sXG4gICAgYXNzaWduOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGFzc2lnbjtcbiAgICB9XG59KTtcbmZ1bmN0aW9uIHNlYXJjaFBhcmFtc1RvVXJsUXVlcnkoc2VhcmNoUGFyYW1zKSB7XG4gICAgY29uc3QgcXVlcnkgPSB7fTtcbiAgICBzZWFyY2hQYXJhbXMuZm9yRWFjaCgodmFsdWUsIGtleSk9PntcbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyeVtrZXldID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBxdWVyeVtrZXldID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShxdWVyeVtrZXldKSkge1xuICAgICAgICAgICAgcXVlcnlba2V5XS5wdXNoKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHF1ZXJ5W2tleV0gPSBbXG4gICAgICAgICAgICAgICAgcXVlcnlba2V5XSxcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBxdWVyeTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0ocGFyYW0pIHtcbiAgICBpZiAodHlwZW9mIHBhcmFtID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBwYXJhbSA9PT0gXCJudW1iZXJcIiAmJiAhaXNOYU4ocGFyYW0pIHx8IHR5cGVvZiBwYXJhbSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhwYXJhbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxufVxuZnVuY3Rpb24gdXJsUXVlcnlUb1NlYXJjaFBhcmFtcyh1cmxRdWVyeSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICBPYmplY3QuZW50cmllcyh1cmxRdWVyeSkuZm9yRWFjaCgocGFyYW0pPT57XG4gICAgICAgIGxldCBba2V5LCB2YWx1ZV0gPSBwYXJhbTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKChpdGVtKT0+cmVzdWx0LmFwcGVuZChrZXksIHN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0oaXRlbSkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5zZXQoa2V5LCBzdHJpbmdpZnlVcmxRdWVyeVBhcmFtKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gYXNzaWduKHRhcmdldCkge1xuICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHNlYXJjaFBhcmFtc0xpc3QgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgIHNlYXJjaFBhcmFtc0xpc3RbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBzZWFyY2hQYXJhbXNMaXN0LmZvckVhY2goKHNlYXJjaFBhcmFtcyk9PntcbiAgICAgICAgQXJyYXkuZnJvbShzZWFyY2hQYXJhbXMua2V5cygpKS5mb3JFYWNoKChrZXkpPT50YXJnZXQuZGVsZXRlKGtleSkpO1xuICAgICAgICBzZWFyY2hQYXJhbXMuZm9yRWFjaCgodmFsdWUsIGtleSk9PnRhcmdldC5hcHBlbmQoa2V5LCB2YWx1ZSkpO1xuICAgIH0pO1xuICAgIHJldHVybiB0YXJnZXQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5c3RyaW5nLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsInNlYXJjaFBhcmFtc1RvVXJsUXVlcnkiLCJ1cmxRdWVyeVRvU2VhcmNoUGFyYW1zIiwiYXNzaWduIiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0Iiwic2VhcmNoUGFyYW1zIiwicXVlcnkiLCJmb3JFYWNoIiwia2V5IiwiQXJyYXkiLCJpc0FycmF5IiwicHVzaCIsInN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0iLCJwYXJhbSIsImlzTmFOIiwiU3RyaW5nIiwidXJsUXVlcnkiLCJyZXN1bHQiLCJVUkxTZWFyY2hQYXJhbXMiLCJlbnRyaWVzIiwiaXRlbSIsImFwcGVuZCIsInNldCIsIl9sZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzZWFyY2hQYXJhbXNMaXN0IiwiX2tleSIsImZyb20iLCJrZXlzIiwiZGVsZXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-matcher.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/route-matcher.js ***!
  \*************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getRouteMatcher\", ({\n    enumerable: true,\n    get: function() {\n        return getRouteMatcher;\n    }\n}));\nconst _utils = __webpack_require__(/*! ../../utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nfunction getRouteMatcher(param) {\n    let { re, groups } = param;\n    return (pathname)=>{\n        const routeMatch = re.exec(pathname);\n        if (!routeMatch) {\n            return false;\n        }\n        const decode = (param)=>{\n            try {\n                return decodeURIComponent(param);\n            } catch (_) {\n                throw new _utils.DecodeError(\"failed to decode param\");\n            }\n        };\n        const params = {};\n        Object.keys(groups).forEach((slugName)=>{\n            const g = groups[slugName];\n            const m = routeMatch[g.pos];\n            if (m !== undefined) {\n                params[slugName] = ~m.indexOf(\"/\") ? m.split(\"/\").map((entry)=>decode(entry)) : g.repeat ? [\n                    decode(m)\n                ] : decode(m);\n            }\n        });\n        return params;\n    };\n} //# sourceMappingURL=route-matcher.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtbWF0Y2hlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsbURBQWtEO0lBQzlDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsU0FBU0MsbUJBQU9BLENBQUMscUZBQWE7QUFDcEMsU0FBU0YsZ0JBQWdCRyxLQUFLO0lBQzFCLElBQUksRUFBRUMsRUFBRSxFQUFFQyxNQUFNLEVBQUUsR0FBR0Y7SUFDckIsT0FBTyxDQUFDRztRQUNKLE1BQU1DLGFBQWFILEdBQUdJLElBQUksQ0FBQ0Y7UUFDM0IsSUFBSSxDQUFDQyxZQUFZO1lBQ2IsT0FBTztRQUNYO1FBQ0EsTUFBTUUsU0FBUyxDQUFDTjtZQUNaLElBQUk7Z0JBQ0EsT0FBT08sbUJBQW1CUDtZQUM5QixFQUFFLE9BQU9RLEdBQUc7Z0JBQ1IsTUFBTSxJQUFJVixPQUFPVyxXQUFXLENBQUM7WUFDakM7UUFDSjtRQUNBLE1BQU1DLFNBQVMsQ0FBQztRQUNoQm5CLE9BQU9vQixJQUFJLENBQUNULFFBQVFVLE9BQU8sQ0FBQyxDQUFDQztZQUN6QixNQUFNQyxJQUFJWixNQUFNLENBQUNXLFNBQVM7WUFDMUIsTUFBTUUsSUFBSVgsVUFBVSxDQUFDVSxFQUFFRSxHQUFHLENBQUM7WUFDM0IsSUFBSUQsTUFBTUUsV0FBVztnQkFDakJQLE1BQU0sQ0FBQ0csU0FBUyxHQUFHLENBQUNFLEVBQUVHLE9BQU8sQ0FBQyxPQUFPSCxFQUFFSSxLQUFLLENBQUMsS0FBS0MsR0FBRyxDQUFDLENBQUNDLFFBQVFmLE9BQU9lLFVBQVVQLEVBQUVRLE1BQU0sR0FBRztvQkFDdkZoQixPQUFPUztpQkFDVixHQUFHVCxPQUFPUztZQUNmO1FBQ0o7UUFDQSxPQUFPTDtJQUNYO0FBQ0osRUFFQSx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9yb3V0ZS1tYXRjaGVyLmpzP2M4NmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRSb3V0ZU1hdGNoZXJcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGdldFJvdXRlTWF0Y2hlcjtcbiAgICB9XG59KTtcbmNvbnN0IF91dGlscyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbmZ1bmN0aW9uIGdldFJvdXRlTWF0Y2hlcihwYXJhbSkge1xuICAgIGxldCB7IHJlLCBncm91cHMgfSA9IHBhcmFtO1xuICAgIHJldHVybiAocGF0aG5hbWUpPT57XG4gICAgICAgIGNvbnN0IHJvdXRlTWF0Y2ggPSByZS5leGVjKHBhdGhuYW1lKTtcbiAgICAgICAgaWYgKCFyb3V0ZU1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVjb2RlID0gKHBhcmFtKT0+e1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHBhcmFtKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgX3V0aWxzLkRlY29kZUVycm9yKFwiZmFpbGVkIHRvIGRlY29kZSBwYXJhbVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKGdyb3VwcykuZm9yRWFjaCgoc2x1Z05hbWUpPT57XG4gICAgICAgICAgICBjb25zdCBnID0gZ3JvdXBzW3NsdWdOYW1lXTtcbiAgICAgICAgICAgIGNvbnN0IG0gPSByb3V0ZU1hdGNoW2cucG9zXTtcbiAgICAgICAgICAgIGlmIChtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNbc2x1Z05hbWVdID0gfm0uaW5kZXhPZihcIi9cIikgPyBtLnNwbGl0KFwiL1wiKS5tYXAoKGVudHJ5KT0+ZGVjb2RlKGVudHJ5KSkgOiBnLnJlcGVhdCA/IFtcbiAgICAgICAgICAgICAgICAgICAgZGVjb2RlKG0pXG4gICAgICAgICAgICAgICAgXSA6IGRlY29kZShtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGUtbWF0Y2hlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZ2V0Um91dGVNYXRjaGVyIiwiX3V0aWxzIiwicmVxdWlyZSIsInBhcmFtIiwicmUiLCJncm91cHMiLCJwYXRobmFtZSIsInJvdXRlTWF0Y2giLCJleGVjIiwiZGVjb2RlIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiXyIsIkRlY29kZUVycm9yIiwicGFyYW1zIiwia2V5cyIsImZvckVhY2giLCJzbHVnTmFtZSIsImciLCJtIiwicG9zIiwidW5kZWZpbmVkIiwiaW5kZXhPZiIsInNwbGl0IiwibWFwIiwiZW50cnkiLCJyZXBlYXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-matcher.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-regex.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/route-regex.js ***!
  \***********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getRouteRegex: function() {\n        return getRouteRegex;\n    },\n    getNamedRouteRegex: function() {\n        return getNamedRouteRegex;\n    },\n    getNamedMiddlewareRegex: function() {\n        return getNamedMiddlewareRegex;\n    }\n});\nconst _interceptionroutes = __webpack_require__(/*! ../../../../server/future/helpers/interception-routes */ \"(app-pages-browser)/./node_modules/next/dist/server/future/helpers/interception-routes.js\");\nconst _escaperegexp = __webpack_require__(/*! ../../escape-regexp */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/escape-regexp.js\");\nconst _removetrailingslash = __webpack_require__(/*! ./remove-trailing-slash */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\nconst NEXT_QUERY_PARAM_PREFIX = \"nxtP\";\nconst NEXT_INTERCEPTION_MARKER_PREFIX = \"nxtI\";\n/**\n * Parses a given parameter from a route to a data structure that can be used\n * to generate the parametrized route. Examples:\n *   - `[...slug]` -> `{ key: 'slug', repeat: true, optional: true }`\n *   - `...slug` -> `{ key: 'slug', repeat: true, optional: false }`\n *   - `[foo]` -> `{ key: 'foo', repeat: false, optional: true }`\n *   - `bar` -> `{ key: 'bar', repeat: false, optional: false }`\n */ function parseParameter(param) {\n    const optional = param.startsWith(\"[\") && param.endsWith(\"]\");\n    if (optional) {\n        param = param.slice(1, -1);\n    }\n    const repeat = param.startsWith(\"...\");\n    if (repeat) {\n        param = param.slice(3);\n    }\n    return {\n        key: param,\n        repeat,\n        optional\n    };\n}\nfunction getParametrizedRoute(route) {\n    const segments = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split(\"/\");\n    const groups = {};\n    let groupIndex = 1;\n    return {\n        parameterizedRoute: segments.map((segment)=>{\n            const markerMatch = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.find((m)=>segment.startsWith(m));\n            const paramMatches = segment.match(/\\[((?:\\[.*\\])|.+)\\]/) // Check for parameters\n            ;\n            if (markerMatch && paramMatches) {\n                const { key, optional, repeat } = parseParameter(paramMatches[1]);\n                groups[key] = {\n                    pos: groupIndex++,\n                    repeat,\n                    optional\n                };\n                return \"/\" + (0, _escaperegexp.escapeStringRegexp)(markerMatch) + \"([^/]+?)\";\n            } else if (paramMatches) {\n                const { key, repeat, optional } = parseParameter(paramMatches[1]);\n                groups[key] = {\n                    pos: groupIndex++,\n                    repeat,\n                    optional\n                };\n                return repeat ? optional ? \"(?:/(.+?))?\" : \"/(.+?)\" : \"/([^/]+?)\";\n            } else {\n                return \"/\" + (0, _escaperegexp.escapeStringRegexp)(segment);\n            }\n        }).join(\"\"),\n        groups\n    };\n}\nfunction getRouteRegex(normalizedRoute) {\n    const { parameterizedRoute, groups } = getParametrizedRoute(normalizedRoute);\n    return {\n        re: new RegExp(\"^\" + parameterizedRoute + \"(?:/)?$\"),\n        groups: groups\n    };\n}\n/**\n * Builds a function to generate a minimal routeKey using only a-z and minimal\n * number of characters.\n */ function buildGetSafeRouteKey() {\n    let i = 0;\n    return ()=>{\n        let routeKey = \"\";\n        let j = ++i;\n        while(j > 0){\n            routeKey += String.fromCharCode(97 + (j - 1) % 26);\n            j = Math.floor((j - 1) / 26);\n        }\n        return routeKey;\n    };\n}\nfunction getSafeKeyFromSegment(param) {\n    let { interceptionMarker, getSafeRouteKey, segment, routeKeys, keyPrefix } = param;\n    const { key, optional, repeat } = parseParameter(segment);\n    // replace any non-word characters since they can break\n    // the named regex\n    let cleanedKey = key.replace(/\\W/g, \"\");\n    if (keyPrefix) {\n        cleanedKey = \"\" + keyPrefix + cleanedKey;\n    }\n    let invalidKey = false;\n    // check if the key is still invalid and fallback to using a known\n    // safe key\n    if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n        invalidKey = true;\n    }\n    if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {\n        invalidKey = true;\n    }\n    if (invalidKey) {\n        cleanedKey = getSafeRouteKey();\n    }\n    if (keyPrefix) {\n        routeKeys[cleanedKey] = \"\" + keyPrefix + key;\n    } else {\n        routeKeys[cleanedKey] = key;\n    }\n    // if the segment has an interception marker, make sure that's part of the regex pattern\n    // this is to ensure that the route with the interception marker doesn't incorrectly match\n    // the non-intercepted route (ie /app/(.)[username] should not match /app/[username])\n    const interceptionPrefix = interceptionMarker ? (0, _escaperegexp.escapeStringRegexp)(interceptionMarker) : \"\";\n    return repeat ? optional ? \"(?:/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">.+?))?\" : \"/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">.+?)\" : \"/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">[^/]+?)\";\n}\nfunction getNamedParametrizedRoute(route, prefixRouteKeys) {\n    const segments = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split(\"/\");\n    const getSafeRouteKey = buildGetSafeRouteKey();\n    const routeKeys = {};\n    return {\n        namedParameterizedRoute: segments.map((segment)=>{\n            const hasInterceptionMarker = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some((m)=>segment.startsWith(m));\n            const paramMatches = segment.match(/\\[((?:\\[.*\\])|.+)\\]/) // Check for parameters\n            ;\n            if (hasInterceptionMarker && paramMatches) {\n                const [usedMarker] = segment.split(paramMatches[0]);\n                return getSafeKeyFromSegment({\n                    getSafeRouteKey,\n                    interceptionMarker: usedMarker,\n                    segment: paramMatches[1],\n                    routeKeys,\n                    keyPrefix: prefixRouteKeys ? NEXT_INTERCEPTION_MARKER_PREFIX : undefined\n                });\n            } else if (paramMatches) {\n                return getSafeKeyFromSegment({\n                    getSafeRouteKey,\n                    segment: paramMatches[1],\n                    routeKeys,\n                    keyPrefix: prefixRouteKeys ? NEXT_QUERY_PARAM_PREFIX : undefined\n                });\n            } else {\n                return \"/\" + (0, _escaperegexp.escapeStringRegexp)(segment);\n            }\n        }).join(\"\"),\n        routeKeys\n    };\n}\nfunction getNamedRouteRegex(normalizedRoute, prefixRouteKey) {\n    const result = getNamedParametrizedRoute(normalizedRoute, prefixRouteKey);\n    return {\n        ...getRouteRegex(normalizedRoute),\n        namedRegex: \"^\" + result.namedParameterizedRoute + \"(?:/)?$\",\n        routeKeys: result.routeKeys\n    };\n}\nfunction getNamedMiddlewareRegex(normalizedRoute, options) {\n    const { parameterizedRoute } = getParametrizedRoute(normalizedRoute);\n    const { catchAll = true } = options;\n    if (parameterizedRoute === \"/\") {\n        let catchAllRegex = catchAll ? \".*\" : \"\";\n        return {\n            namedRegex: \"^/\" + catchAllRegex + \"$\"\n        };\n    }\n    const { namedParameterizedRoute } = getNamedParametrizedRoute(normalizedRoute, false);\n    let catchAllGroupedRegex = catchAll ? \"(?:(/.*)?)\" : \"\";\n    return {\n        namedRegex: \"^\" + namedParameterizedRoute + catchAllGroupedRegex + \"$\"\n    };\n} //# sourceMappingURL=route-regex.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtcmVnZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0YsS0FBTUMsQ0FBQUEsQ0FJTjtBQUNBLFNBQVNJLFFBQVFDLE1BQU0sRUFBRUMsR0FBRztJQUN4QixJQUFJLElBQUlDLFFBQVFELElBQUlWLE9BQU9DLGNBQWMsQ0FBQ1EsUUFBUUUsTUFBTTtRQUNwREMsWUFBWTtRQUNaQyxLQUFLSCxHQUFHLENBQUNDLEtBQUs7SUFDbEI7QUFDSjtBQUNBSCxRQUFRTixTQUFTO0lBQ2JHLGVBQWU7UUFDWCxPQUFPQTtJQUNYO0lBQ0FDLG9CQUFvQjtRQUNoQixPQUFPQTtJQUNYO0lBQ0FDLHlCQUF5QjtRQUNyQixPQUFPQTtJQUNYO0FBQ0o7QUFDQSxNQUFNTyxzQkFBc0JDLG1CQUFPQSxDQUFDLHdKQUF1RDtBQUMzRixNQUFNQyxnQkFBZ0JELG1CQUFPQSxDQUFDLHFHQUFxQjtBQUNuRCxNQUFNRSx1QkFBdUJGLG1CQUFPQSxDQUFDLDhIQUF5QjtBQUM5RCxNQUFNRywwQkFBMEI7QUFDaEMsTUFBTUMsa0NBQWtDO0FBQ3hDOzs7Ozs7O0NBT0MsR0FBRyxTQUFTQyxlQUFlQyxLQUFLO0lBQzdCLE1BQU1DLFdBQVdELE1BQU1FLFVBQVUsQ0FBQyxRQUFRRixNQUFNRyxRQUFRLENBQUM7SUFDekQsSUFBSUYsVUFBVTtRQUNWRCxRQUFRQSxNQUFNSSxLQUFLLENBQUMsR0FBRyxDQUFDO0lBQzVCO0lBQ0EsTUFBTUMsU0FBU0wsTUFBTUUsVUFBVSxDQUFDO0lBQ2hDLElBQUlHLFFBQVE7UUFDUkwsUUFBUUEsTUFBTUksS0FBSyxDQUFDO0lBQ3hCO0lBQ0EsT0FBTztRQUNIRSxLQUFLTjtRQUNMSztRQUNBSjtJQUNKO0FBQ0o7QUFDQSxTQUFTTSxxQkFBcUJDLEtBQUs7SUFD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LE9BQU87Z0JBQ0gsT0FBTyxNQUFNLENBQUMsR0FBRzVELGNBQWM2QixrQkFBa0IsRUFBRVI7WUFDdkQ7UUFDSixHQUFHUyxJQUFJLENBQUM7UUFDUmU7SUFDSjtBQUNKO0FBQ0EsU0FBU3ZELG1CQUFtQnlDLGVBQWUsRUFBRThCLGNBQWM7SUFDdkQsTUFBTUMsU0FBU1IsMEJBQTBCdkIsaUJBQWlCOEI7SUFDMUQsT0FBTztRQUNILEdBQUd4RSxjQUFjMEMsZ0JBQWdCO1FBQ2pDZ0MsWUFBWSxNQUFNRCxPQUFPTix1QkFBdUIsR0FBRztRQUNuRFgsV0FBV2lCLE9BQU9qQixTQUFTO0lBQy9CO0FBQ0o7QUFDQSxTQUFTdEQsd0JBQXdCd0MsZUFBZSxFQUFFaUMsT0FBTztJQUNyRCxNQUFNLEVBQUU3QyxrQkFBa0IsRUFBRSxHQUFHUCxxQkFBcUJtQjtJQUNwRCxNQUFNLEVBQUVrQyxXQUFXLElBQUksRUFBRSxHQUFHRDtJQUM1QixJQUFJN0MsdUJBQXVCLEtBQUs7UUFDNUIsSUFBSStDLGdCQUFnQkQsV0FBVyxPQUFPO1FBQ3RDLE9BQU87WUFDSEYsWUFBWSxPQUFPRyxnQkFBZ0I7UUFDdkM7SUFDSjtJQUNBLE1BQU0sRUFBRVYsdUJBQXVCLEVBQUUsR0FBR0YsMEJBQTBCdkIsaUJBQWlCO0lBQy9FLElBQUlvQyx1QkFBdUJGLFdBQVcsZUFBZTtJQUNyRCxPQUFPO1FBQ0hGLFlBQVksTUFBTVAsMEJBQTBCVyx1QkFBdUI7SUFDdkU7QUFDSixFQUVBLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3JvdXRlLXJlZ2V4LmpzP2VhYzIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBnZXRSb3V0ZVJlZ2V4OiBudWxsLFxuICAgIGdldE5hbWVkUm91dGVSZWdleDogbnVsbCxcbiAgICBnZXROYW1lZE1pZGRsZXdhcmVSZWdleDogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBnZXRSb3V0ZVJlZ2V4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGdldFJvdXRlUmVnZXg7XG4gICAgfSxcbiAgICBnZXROYW1lZFJvdXRlUmVnZXg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0TmFtZWRSb3V0ZVJlZ2V4O1xuICAgIH0sXG4gICAgZ2V0TmFtZWRNaWRkbGV3YXJlUmVnZXg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0TmFtZWRNaWRkbGV3YXJlUmVnZXg7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJjZXB0aW9ucm91dGVzID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL3NlcnZlci9mdXR1cmUvaGVscGVycy9pbnRlcmNlcHRpb24tcm91dGVzXCIpO1xuY29uc3QgX2VzY2FwZXJlZ2V4cCA9IHJlcXVpcmUoXCIuLi8uLi9lc2NhcGUtcmVnZXhwXCIpO1xuY29uc3QgX3JlbW92ZXRyYWlsaW5nc2xhc2ggPSByZXF1aXJlKFwiLi9yZW1vdmUtdHJhaWxpbmctc2xhc2hcIik7XG5jb25zdCBORVhUX1FVRVJZX1BBUkFNX1BSRUZJWCA9IFwibnh0UFwiO1xuY29uc3QgTkVYVF9JTlRFUkNFUFRJT05fTUFSS0VSX1BSRUZJWCA9IFwibnh0SVwiO1xuLyoqXG4gKiBQYXJzZXMgYSBnaXZlbiBwYXJhbWV0ZXIgZnJvbSBhIHJvdXRlIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgdGhhdCBjYW4gYmUgdXNlZFxuICogdG8gZ2VuZXJhdGUgdGhlIHBhcmFtZXRyaXplZCByb3V0ZS4gRXhhbXBsZXM6XG4gKiAgIC0gYFsuLi5zbHVnXWAgLT4gYHsga2V5OiAnc2x1ZycsIHJlcGVhdDogdHJ1ZSwgb3B0aW9uYWw6IHRydWUgfWBcbiAqICAgLSBgLi4uc2x1Z2AgLT4gYHsga2V5OiAnc2x1ZycsIHJlcGVhdDogdHJ1ZSwgb3B0aW9uYWw6IGZhbHNlIH1gXG4gKiAgIC0gYFtmb29dYCAtPiBgeyBrZXk6ICdmb28nLCByZXBlYXQ6IGZhbHNlLCBvcHRpb25hbDogdHJ1ZSB9YFxuICogICAtIGBiYXJgIC0+IGB7IGtleTogJ2JhcicsIHJlcGVhdDogZmFsc2UsIG9wdGlvbmFsOiBmYWxzZSB9YFxuICovIGZ1bmN0aW9uIHBhcnNlUGFyYW1ldGVyKHBhcmFtKSB7XG4gICAgY29uc3Qgb3B0aW9uYWwgPSBwYXJhbS5zdGFydHNXaXRoKFwiW1wiKSAmJiBwYXJhbS5lbmRzV2l0aChcIl1cIik7XG4gICAgaWYgKG9wdGlvbmFsKSB7XG4gICAgICAgIHBhcmFtID0gcGFyYW0uc2xpY2UoMSwgLTEpO1xuICAgIH1cbiAgICBjb25zdCByZXBlYXQgPSBwYXJhbS5zdGFydHNXaXRoKFwiLi4uXCIpO1xuICAgIGlmIChyZXBlYXQpIHtcbiAgICAgICAgcGFyYW0gPSBwYXJhbS5zbGljZSgzKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2V5OiBwYXJhbSxcbiAgICAgICAgcmVwZWF0LFxuICAgICAgICBvcHRpb25hbFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRQYXJhbWV0cml6ZWRSb3V0ZShyb3V0ZSkge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKHJvdXRlKS5zbGljZSgxKS5zcGxpdChcIi9cIik7XG4gICAgY29uc3QgZ3JvdXBzID0ge307XG4gICAgbGV0IGdyb3VwSW5kZXggPSAxO1xuICAgIHJldHVybiB7XG4gICAgICAgIHBhcmFtZXRlcml6ZWRSb3V0ZTogc2VnbWVudHMubWFwKChzZWdtZW50KT0+e1xuICAgICAgICAgICAgY29uc3QgbWFya2VyTWF0Y2ggPSBfaW50ZXJjZXB0aW9ucm91dGVzLklOVEVSQ0VQVElPTl9ST1VURV9NQVJLRVJTLmZpbmQoKG0pPT5zZWdtZW50LnN0YXJ0c1dpdGgobSkpO1xuICAgICAgICAgICAgY29uc3QgcGFyYW1NYXRjaGVzID0gc2VnbWVudC5tYXRjaCgvXFxbKCg/OlxcWy4qXFxdKXwuKylcXF0vKSAvLyBDaGVjayBmb3IgcGFyYW1ldGVyc1xuICAgICAgICAgICAgO1xuICAgICAgICAgICAgaWYgKG1hcmtlck1hdGNoICYmIHBhcmFtTWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsga2V5LCBvcHRpb25hbCwgcmVwZWF0IH0gPSBwYXJzZVBhcmFtZXRlcihwYXJhbU1hdGNoZXNbMV0pO1xuICAgICAgICAgICAgICAgIGdyb3Vwc1trZXldID0ge1xuICAgICAgICAgICAgICAgICAgICBwb3M6IGdyb3VwSW5kZXgrKyxcbiAgICAgICAgICAgICAgICAgICAgcmVwZWF0LFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25hbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiL1wiICsgKDAsIF9lc2NhcGVyZWdleHAuZXNjYXBlU3RyaW5nUmVnZXhwKShtYXJrZXJNYXRjaCkgKyBcIihbXi9dKz8pXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtTWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsga2V5LCByZXBlYXQsIG9wdGlvbmFsIH0gPSBwYXJzZVBhcmFtZXRlcihwYXJhbU1hdGNoZXNbMV0pO1xuICAgICAgICAgICAgICAgIGdyb3Vwc1trZXldID0ge1xuICAgICAgICAgICAgICAgICAgICBwb3M6IGdyb3VwSW5kZXgrKyxcbiAgICAgICAgICAgICAgICAgICAgcmVwZWF0LFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25hbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcGVhdCA/IG9wdGlvbmFsID8gXCIoPzovKC4rPykpP1wiIDogXCIvKC4rPylcIiA6IFwiLyhbXi9dKz8pXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIi9cIiArICgwLCBfZXNjYXBlcmVnZXhwLmVzY2FwZVN0cmluZ1JlZ2V4cCkoc2VnbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmpvaW4oXCJcIiksXG4gICAgICAgIGdyb3Vwc1xuICAgIH07XG59XG5mdW5jdGlvbiBnZXRSb3V0ZVJlZ2V4KG5vcm1hbGl6ZWRSb3V0ZSkge1xuICAgIGNvbnN0IHsgcGFyYW1ldGVyaXplZFJvdXRlLCBncm91cHMgfSA9IGdldFBhcmFtZXRyaXplZFJvdXRlKG5vcm1hbGl6ZWRSb3V0ZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmU6IG5ldyBSZWdFeHAoXCJeXCIgKyBwYXJhbWV0ZXJpemVkUm91dGUgKyBcIig/Oi8pPyRcIiksXG4gICAgICAgIGdyb3VwczogZ3JvdXBzXG4gICAgfTtcbn1cbi8qKlxuICogQnVpbGRzIGEgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgYSBtaW5pbWFsIHJvdXRlS2V5IHVzaW5nIG9ubHkgYS16IGFuZCBtaW5pbWFsXG4gKiBudW1iZXIgb2YgY2hhcmFjdGVycy5cbiAqLyBmdW5jdGlvbiBidWlsZEdldFNhZmVSb3V0ZUtleSgpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgcmV0dXJuICgpPT57XG4gICAgICAgIGxldCByb3V0ZUtleSA9IFwiXCI7XG4gICAgICAgIGxldCBqID0gKytpO1xuICAgICAgICB3aGlsZShqID4gMCl7XG4gICAgICAgICAgICByb3V0ZUtleSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDk3ICsgKGogLSAxKSAlIDI2KTtcbiAgICAgICAgICAgIGogPSBNYXRoLmZsb29yKChqIC0gMSkgLyAyNik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvdXRlS2V5O1xuICAgIH07XG59XG5mdW5jdGlvbiBnZXRTYWZlS2V5RnJvbVNlZ21lbnQocGFyYW0pIHtcbiAgICBsZXQgeyBpbnRlcmNlcHRpb25NYXJrZXIsIGdldFNhZmVSb3V0ZUtleSwgc2VnbWVudCwgcm91dGVLZXlzLCBrZXlQcmVmaXggfSA9IHBhcmFtO1xuICAgIGNvbnN0IHsga2V5LCBvcHRpb25hbCwgcmVwZWF0IH0gPSBwYXJzZVBhcmFtZXRlcihzZWdtZW50KTtcbiAgICAvLyByZXBsYWNlIGFueSBub24td29yZCBjaGFyYWN0ZXJzIHNpbmNlIHRoZXkgY2FuIGJyZWFrXG4gICAgLy8gdGhlIG5hbWVkIHJlZ2V4XG4gICAgbGV0IGNsZWFuZWRLZXkgPSBrZXkucmVwbGFjZSgvXFxXL2csIFwiXCIpO1xuICAgIGlmIChrZXlQcmVmaXgpIHtcbiAgICAgICAgY2xlYW5lZEtleSA9IFwiXCIgKyBrZXlQcmVmaXggKyBjbGVhbmVkS2V5O1xuICAgIH1cbiAgICBsZXQgaW52YWxpZEtleSA9IGZhbHNlO1xuICAgIC8vIGNoZWNrIGlmIHRoZSBrZXkgaXMgc3RpbGwgaW52YWxpZCBhbmQgZmFsbGJhY2sgdG8gdXNpbmcgYSBrbm93blxuICAgIC8vIHNhZmUga2V5XG4gICAgaWYgKGNsZWFuZWRLZXkubGVuZ3RoID09PSAwIHx8IGNsZWFuZWRLZXkubGVuZ3RoID4gMzApIHtcbiAgICAgICAgaW52YWxpZEtleSA9IHRydWU7XG4gICAgfVxuICAgIGlmICghaXNOYU4ocGFyc2VJbnQoY2xlYW5lZEtleS5zbGljZSgwLCAxKSkpKSB7XG4gICAgICAgIGludmFsaWRLZXkgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaW52YWxpZEtleSkge1xuICAgICAgICBjbGVhbmVkS2V5ID0gZ2V0U2FmZVJvdXRlS2V5KCk7XG4gICAgfVxuICAgIGlmIChrZXlQcmVmaXgpIHtcbiAgICAgICAgcm91dGVLZXlzW2NsZWFuZWRLZXldID0gXCJcIiArIGtleVByZWZpeCArIGtleTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb3V0ZUtleXNbY2xlYW5lZEtleV0gPSBrZXk7XG4gICAgfVxuICAgIC8vIGlmIHRoZSBzZWdtZW50IGhhcyBhbiBpbnRlcmNlcHRpb24gbWFya2VyLCBtYWtlIHN1cmUgdGhhdCdzIHBhcnQgb2YgdGhlIHJlZ2V4IHBhdHRlcm5cbiAgICAvLyB0aGlzIGlzIHRvIGVuc3VyZSB0aGF0IHRoZSByb3V0ZSB3aXRoIHRoZSBpbnRlcmNlcHRpb24gbWFya2VyIGRvZXNuJ3QgaW5jb3JyZWN0bHkgbWF0Y2hcbiAgICAvLyB0aGUgbm9uLWludGVyY2VwdGVkIHJvdXRlIChpZSAvYXBwLyguKVt1c2VybmFtZV0gc2hvdWxkIG5vdCBtYXRjaCAvYXBwL1t1c2VybmFtZV0pXG4gICAgY29uc3QgaW50ZXJjZXB0aW9uUHJlZml4ID0gaW50ZXJjZXB0aW9uTWFya2VyID8gKDAsIF9lc2NhcGVyZWdleHAuZXNjYXBlU3RyaW5nUmVnZXhwKShpbnRlcmNlcHRpb25NYXJrZXIpIDogXCJcIjtcbiAgICByZXR1cm4gcmVwZWF0ID8gb3B0aW9uYWwgPyBcIig/Oi9cIiArIGludGVyY2VwdGlvblByZWZpeCArIFwiKD88XCIgKyBjbGVhbmVkS2V5ICsgXCI+Lis/KSk/XCIgOiBcIi9cIiArIGludGVyY2VwdGlvblByZWZpeCArIFwiKD88XCIgKyBjbGVhbmVkS2V5ICsgXCI+Lis/KVwiIDogXCIvXCIgKyBpbnRlcmNlcHRpb25QcmVmaXggKyBcIig/PFwiICsgY2xlYW5lZEtleSArIFwiPlteL10rPylcIjtcbn1cbmZ1bmN0aW9uIGdldE5hbWVkUGFyYW1ldHJpemVkUm91dGUocm91dGUsIHByZWZpeFJvdXRlS2V5cykge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKHJvdXRlKS5zbGljZSgxKS5zcGxpdChcIi9cIik7XG4gICAgY29uc3QgZ2V0U2FmZVJvdXRlS2V5ID0gYnVpbGRHZXRTYWZlUm91dGVLZXkoKTtcbiAgICBjb25zdCByb3V0ZUtleXMgPSB7fTtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZTogc2VnbWVudHMubWFwKChzZWdtZW50KT0+e1xuICAgICAgICAgICAgY29uc3QgaGFzSW50ZXJjZXB0aW9uTWFya2VyID0gX2ludGVyY2VwdGlvbnJvdXRlcy5JTlRFUkNFUFRJT05fUk9VVEVfTUFSS0VSUy5zb21lKChtKT0+c2VnbWVudC5zdGFydHNXaXRoKG0pKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtTWF0Y2hlcyA9IHNlZ21lbnQubWF0Y2goL1xcWygoPzpcXFsuKlxcXSl8LispXFxdLykgLy8gQ2hlY2sgZm9yIHBhcmFtZXRlcnNcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIGlmIChoYXNJbnRlcmNlcHRpb25NYXJrZXIgJiYgcGFyYW1NYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3VzZWRNYXJrZXJdID0gc2VnbWVudC5zcGxpdChwYXJhbU1hdGNoZXNbMF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRTYWZlS2V5RnJvbVNlZ21lbnQoe1xuICAgICAgICAgICAgICAgICAgICBnZXRTYWZlUm91dGVLZXksXG4gICAgICAgICAgICAgICAgICAgIGludGVyY2VwdGlvbk1hcmtlcjogdXNlZE1hcmtlcixcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudDogcGFyYW1NYXRjaGVzWzFdLFxuICAgICAgICAgICAgICAgICAgICByb3V0ZUtleXMsXG4gICAgICAgICAgICAgICAgICAgIGtleVByZWZpeDogcHJlZml4Um91dGVLZXlzID8gTkVYVF9JTlRFUkNFUFRJT05fTUFSS0VSX1BSRUZJWCA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbU1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0U2FmZUtleUZyb21TZWdtZW50KHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0U2FmZVJvdXRlS2V5LFxuICAgICAgICAgICAgICAgICAgICBzZWdtZW50OiBwYXJhbU1hdGNoZXNbMV0sXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlS2V5cyxcbiAgICAgICAgICAgICAgICAgICAga2V5UHJlZml4OiBwcmVmaXhSb3V0ZUtleXMgPyBORVhUX1FVRVJZX1BBUkFNX1BSRUZJWCA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCIvXCIgKyAoMCwgX2VzY2FwZXJlZ2V4cC5lc2NhcGVTdHJpbmdSZWdleHApKHNlZ21lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS5qb2luKFwiXCIpLFxuICAgICAgICByb3V0ZUtleXNcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0TmFtZWRSb3V0ZVJlZ2V4KG5vcm1hbGl6ZWRSb3V0ZSwgcHJlZml4Um91dGVLZXkpIHtcbiAgICBjb25zdCByZXN1bHQgPSBnZXROYW1lZFBhcmFtZXRyaXplZFJvdXRlKG5vcm1hbGl6ZWRSb3V0ZSwgcHJlZml4Um91dGVLZXkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmdldFJvdXRlUmVnZXgobm9ybWFsaXplZFJvdXRlKSxcbiAgICAgICAgbmFtZWRSZWdleDogXCJeXCIgKyByZXN1bHQubmFtZWRQYXJhbWV0ZXJpemVkUm91dGUgKyBcIig/Oi8pPyRcIixcbiAgICAgICAgcm91dGVLZXlzOiByZXN1bHQucm91dGVLZXlzXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldE5hbWVkTWlkZGxld2FyZVJlZ2V4KG5vcm1hbGl6ZWRSb3V0ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgcGFyYW1ldGVyaXplZFJvdXRlIH0gPSBnZXRQYXJhbWV0cml6ZWRSb3V0ZShub3JtYWxpemVkUm91dGUpO1xuICAgIGNvbnN0IHsgY2F0Y2hBbGwgPSB0cnVlIH0gPSBvcHRpb25zO1xuICAgIGlmIChwYXJhbWV0ZXJpemVkUm91dGUgPT09IFwiL1wiKSB7XG4gICAgICAgIGxldCBjYXRjaEFsbFJlZ2V4ID0gY2F0Y2hBbGwgPyBcIi4qXCIgOiBcIlwiO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZWRSZWdleDogXCJeL1wiICsgY2F0Y2hBbGxSZWdleCArIFwiJFwiXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHsgbmFtZWRQYXJhbWV0ZXJpemVkUm91dGUgfSA9IGdldE5hbWVkUGFyYW1ldHJpemVkUm91dGUobm9ybWFsaXplZFJvdXRlLCBmYWxzZSk7XG4gICAgbGV0IGNhdGNoQWxsR3JvdXBlZFJlZ2V4ID0gY2F0Y2hBbGwgPyBcIig/OigvLiopPylcIiA6IFwiXCI7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZWRSZWdleDogXCJeXCIgKyBuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZSArIGNhdGNoQWxsR3JvdXBlZFJlZ2V4ICsgXCIkXCJcbiAgICB9O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZS1yZWdleC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJnZXRSb3V0ZVJlZ2V4IiwiZ2V0TmFtZWRSb3V0ZVJlZ2V4IiwiZ2V0TmFtZWRNaWRkbGV3YXJlUmVnZXgiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfaW50ZXJjZXB0aW9ucm91dGVzIiwicmVxdWlyZSIsIl9lc2NhcGVyZWdleHAiLCJfcmVtb3ZldHJhaWxpbmdzbGFzaCIsIk5FWFRfUVVFUllfUEFSQU1fUFJFRklYIiwiTkVYVF9JTlRFUkNFUFRJT05fTUFSS0VSX1BSRUZJWCIsInBhcnNlUGFyYW1ldGVyIiwicGFyYW0iLCJvcHRpb25hbCIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsInNsaWNlIiwicmVwZWF0Iiwia2V5IiwiZ2V0UGFyYW1ldHJpemVkUm91dGUiLCJyb3V0ZSIsInNlZ21lbnRzIiwicmVtb3ZlVHJhaWxpbmdTbGFzaCIsInNwbGl0IiwiZ3JvdXBzIiwiZ3JvdXBJbmRleCIsInBhcmFtZXRlcml6ZWRSb3V0ZSIsIm1hcCIsInNlZ21lbnQiLCJtYXJrZXJNYXRjaCIsIklOVEVSQ0VQVElPTl9ST1VURV9NQVJLRVJTIiwiZmluZCIsIm0iLCJwYXJhbU1hdGNoZXMiLCJtYXRjaCIsInBvcyIsImVzY2FwZVN0cmluZ1JlZ2V4cCIsImpvaW4iLCJub3JtYWxpemVkUm91dGUiLCJyZSIsIlJlZ0V4cCIsImJ1aWxkR2V0U2FmZVJvdXRlS2V5IiwiaSIsInJvdXRlS2V5IiwiaiIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIk1hdGgiLCJmbG9vciIsImdldFNhZmVLZXlGcm9tU2VnbWVudCIsImludGVyY2VwdGlvbk1hcmtlciIsImdldFNhZmVSb3V0ZUtleSIsInJvdXRlS2V5cyIsImtleVByZWZpeCIsImNsZWFuZWRLZXkiLCJyZXBsYWNlIiwiaW52YWxpZEtleSIsImxlbmd0aCIsImlzTmFOIiwicGFyc2VJbnQiLCJpbnRlcmNlcHRpb25QcmVmaXgiLCJnZXROYW1lZFBhcmFtZXRyaXplZFJvdXRlIiwicHJlZml4Um91dGVLZXlzIiwibmFtZWRQYXJhbWV0ZXJpemVkUm91dGUiLCJoYXNJbnRlcmNlcHRpb25NYXJrZXIiLCJzb21lIiwidXNlZE1hcmtlciIsInVuZGVmaW5lZCIsInByZWZpeFJvdXRlS2V5IiwicmVzdWx0IiwibmFtZWRSZWdleCIsIm9wdGlvbnMiLCJjYXRjaEFsbCIsImNhdGNoQWxsUmVnZXgiLCJjYXRjaEFsbEdyb3VwZWRSZWdleCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-regex.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/sorted-routes.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/sorted-routes.js ***!
  \*************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getSortedRoutes\", ({\n    enumerable: true,\n    get: function() {\n        return getSortedRoutes;\n    }\n}));\nclass UrlNode {\n    insert(urlPath) {\n        this._insert(urlPath.split(\"/\").filter(Boolean), [], false);\n    }\n    smoosh() {\n        return this._smoosh();\n    }\n    _smoosh(prefix) {\n        if (prefix === void 0) prefix = \"/\";\n        const childrenPaths = [\n            ...this.children.keys()\n        ].sort();\n        if (this.slugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf(\"[]\"), 1);\n        }\n        if (this.restSlugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf(\"[...]\"), 1);\n        }\n        if (this.optionalRestSlugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf(\"[[...]]\"), 1);\n        }\n        const routes = childrenPaths.map((c)=>this.children.get(c)._smoosh(\"\" + prefix + c + \"/\")).reduce((prev, curr)=>[\n                ...prev,\n                ...curr\n            ], []);\n        if (this.slugName !== null) {\n            routes.push(...this.children.get(\"[]\")._smoosh(prefix + \"[\" + this.slugName + \"]/\"));\n        }\n        if (!this.placeholder) {\n            const r = prefix === \"/\" ? \"/\" : prefix.slice(0, -1);\n            if (this.optionalRestSlugName != null) {\n                throw new Error('You cannot define a route with the same specificity as a optional catch-all route (\"' + r + '\" and \"' + r + \"[[...\" + this.optionalRestSlugName + ']]\").');\n            }\n            routes.unshift(r);\n        }\n        if (this.restSlugName !== null) {\n            routes.push(...this.children.get(\"[...]\")._smoosh(prefix + \"[...\" + this.restSlugName + \"]/\"));\n        }\n        if (this.optionalRestSlugName !== null) {\n            routes.push(...this.children.get(\"[[...]]\")._smoosh(prefix + \"[[...\" + this.optionalRestSlugName + \"]]/\"));\n        }\n        return routes;\n    }\n    _insert(urlPaths, slugNames, isCatchAll) {\n        if (urlPaths.length === 0) {\n            this.placeholder = false;\n            return;\n        }\n        if (isCatchAll) {\n            throw new Error(\"Catch-all must be the last part of the URL.\");\n        }\n        // The next segment in the urlPaths list\n        let nextSegment = urlPaths[0];\n        // Check if the segment matches `[something]`\n        if (nextSegment.startsWith(\"[\") && nextSegment.endsWith(\"]\")) {\n            // Strip `[` and `]`, leaving only `something`\n            let segmentName = nextSegment.slice(1, -1);\n            let isOptional = false;\n            if (segmentName.startsWith(\"[\") && segmentName.endsWith(\"]\")) {\n                // Strip optional `[` and `]`, leaving only `something`\n                segmentName = segmentName.slice(1, -1);\n                isOptional = true;\n            }\n            if (segmentName.startsWith(\"...\")) {\n                // Strip `...`, leaving only `something`\n                segmentName = segmentName.substring(3);\n                isCatchAll = true;\n            }\n            if (segmentName.startsWith(\"[\") || segmentName.endsWith(\"]\")) {\n                throw new Error(\"Segment names may not start or end with extra brackets ('\" + segmentName + \"').\");\n            }\n            if (segmentName.startsWith(\".\")) {\n                throw new Error(\"Segment names may not start with erroneous periods ('\" + segmentName + \"').\");\n            }\n            function handleSlug(previousSlug, nextSlug) {\n                if (previousSlug !== null) {\n                    // If the specific segment already has a slug but the slug is not `something`\n                    // This prevents collisions like:\n                    // pages/[post]/index.js\n                    // pages/[id]/index.js\n                    // Because currently multiple dynamic params on the same segment level are not supported\n                    if (previousSlug !== nextSlug) {\n                        // TODO: This error seems to be confusing for users, needs an error link, the description can be based on above comment.\n                        throw new Error(\"You cannot use different slug names for the same dynamic path ('\" + previousSlug + \"' !== '\" + nextSlug + \"').\");\n                    }\n                }\n                slugNames.forEach((slug)=>{\n                    if (slug === nextSlug) {\n                        throw new Error('You cannot have the same slug name \"' + nextSlug + '\" repeat within a single dynamic path');\n                    }\n                    if (slug.replace(/\\W/g, \"\") === nextSegment.replace(/\\W/g, \"\")) {\n                        throw new Error('You cannot have the slug names \"' + slug + '\" and \"' + nextSlug + '\" differ only by non-word symbols within a single dynamic path');\n                    }\n                });\n                slugNames.push(nextSlug);\n            }\n            if (isCatchAll) {\n                if (isOptional) {\n                    if (this.restSlugName != null) {\n                        throw new Error('You cannot use both an required and optional catch-all route at the same level (\"[...' + this.restSlugName + ']\" and \"' + urlPaths[0] + '\" ).');\n                    }\n                    handleSlug(this.optionalRestSlugName, segmentName);\n                    // slugName is kept as it can only be one particular slugName\n                    this.optionalRestSlugName = segmentName;\n                    // nextSegment is overwritten to [[...]] so that it can later be sorted specifically\n                    nextSegment = \"[[...]]\";\n                } else {\n                    if (this.optionalRestSlugName != null) {\n                        throw new Error('You cannot use both an optional and required catch-all route at the same level (\"[[...' + this.optionalRestSlugName + ']]\" and \"' + urlPaths[0] + '\").');\n                    }\n                    handleSlug(this.restSlugName, segmentName);\n                    // slugName is kept as it can only be one particular slugName\n                    this.restSlugName = segmentName;\n                    // nextSegment is overwritten to [...] so that it can later be sorted specifically\n                    nextSegment = \"[...]\";\n                }\n            } else {\n                if (isOptional) {\n                    throw new Error('Optional route parameters are not yet supported (\"' + urlPaths[0] + '\").');\n                }\n                handleSlug(this.slugName, segmentName);\n                // slugName is kept as it can only be one particular slugName\n                this.slugName = segmentName;\n                // nextSegment is overwritten to [] so that it can later be sorted specifically\n                nextSegment = \"[]\";\n            }\n        }\n        // If this UrlNode doesn't have the nextSegment yet we create a new child UrlNode\n        if (!this.children.has(nextSegment)) {\n            this.children.set(nextSegment, new UrlNode());\n        }\n        this.children.get(nextSegment)._insert(urlPaths.slice(1), slugNames, isCatchAll);\n    }\n    constructor(){\n        this.placeholder = true;\n        this.children = new Map();\n        this.slugName = null;\n        this.restSlugName = null;\n        this.optionalRestSlugName = null;\n    }\n}\nfunction getSortedRoutes(normalizedPages) {\n    // First the UrlNode is created, and every UrlNode can have only 1 dynamic segment\n    // Eg you can't have pages/[post]/abc.js and pages/[hello]/something-else.js\n    // Only 1 dynamic segment per nesting level\n    // So in the case that is test/integration/dynamic-routing it'll be this:\n    // pages/[post]/comments.js\n    // pages/blog/[post]/comment/[id].js\n    // Both are fine because `pages/[post]` and `pages/blog` are on the same level\n    // So in this case `UrlNode` created here has `this.slugName === 'post'`\n    // And since your PR passed through `slugName` as an array basically it'd including it in too many possibilities\n    // Instead what has to be passed through is the upwards path's dynamic names\n    const root = new UrlNode();\n    // Here the `root` gets injected multiple paths, and insert will break them up into sublevels\n    normalizedPages.forEach((pagePath)=>root.insert(pagePath));\n    // Smoosh will then sort those sublevels up to the point where you get the correct route definition priority\n    return root.smoosh();\n} //# sourceMappingURL=sorted-routes.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvc29ydGVkLXJvdXRlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsbURBQWtEO0lBQzlDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUM7SUFDRkMsT0FBT0MsT0FBTyxFQUFFO1FBQ1osSUFBSSxDQUFDQyxPQUFPLENBQUNELFFBQVFFLEtBQUssQ0FBQyxLQUFLQyxNQUFNLENBQUNDLFVBQVUsRUFBRSxFQUFFO0lBQ3pEO0lBQ0FDLFNBQVM7UUFDTCxPQUFPLElBQUksQ0FBQ0MsT0FBTztJQUN2QjtJQUNBQSxRQUFRQyxNQUFNLEVBQUU7UUFDWixJQUFJQSxXQUFXLEtBQUssR0FBR0EsU0FBUztRQUNoQyxNQUFNQyxnQkFBZ0I7ZUFDZixJQUFJLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSTtTQUN4QixDQUFDQyxJQUFJO1FBQ04sSUFBSSxJQUFJLENBQUNDLFFBQVEsS0FBSyxNQUFNO1lBQ3hCSixjQUFjSyxNQUFNLENBQUNMLGNBQWNNLE9BQU8sQ0FBQyxPQUFPO1FBQ3REO1FBQ0EsSUFBSSxJQUFJLENBQUNDLFlBQVksS0FBSyxNQUFNO1lBQzVCUCxjQUFjSyxNQUFNLENBQUNMLGNBQWNNLE9BQU8sQ0FBQyxVQUFVO1FBQ3pEO1FBQ0EsSUFBSSxJQUFJLENBQUNFLG9CQUFvQixLQUFLLE1BQU07WUFDcENSLGNBQWNLLE1BQU0sQ0FBQ0wsY0FBY00sT0FBTyxDQUFDLFlBQVk7UUFDM0Q7UUFDQSxNQUFNRyxTQUFTVCxjQUFjVSxHQUFHLENBQUMsQ0FBQ0MsSUFBSSxJQUFJLENBQUNWLFFBQVEsQ0FBQ2IsR0FBRyxDQUFDdUIsR0FBR2IsT0FBTyxDQUFDLEtBQUtDLFNBQVNZLElBQUksTUFBTUMsTUFBTSxDQUFDLENBQUNDLE1BQU1DLE9BQU87bUJBQ3JHRDttQkFDQUM7YUFDTixFQUFFLEVBQUU7UUFDVCxJQUFJLElBQUksQ0FBQ1YsUUFBUSxLQUFLLE1BQU07WUFDeEJLLE9BQU9NLElBQUksSUFBSSxJQUFJLENBQUNkLFFBQVEsQ0FBQ2IsR0FBRyxDQUFDLE1BQU1VLE9BQU8sQ0FBQ0MsU0FBUyxNQUFNLElBQUksQ0FBQ0ssUUFBUSxHQUFHO1FBQ2xGO1FBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQ1ksV0FBVyxFQUFFO1lBQ25CLE1BQU1DLElBQUlsQixXQUFXLE1BQU0sTUFBTUEsT0FBT21CLEtBQUssQ0FBQyxHQUFHLENBQUM7WUFDbEQsSUFBSSxJQUFJLENBQUNWLG9CQUFvQixJQUFJLE1BQU07Z0JBQ25DLE1BQU0sSUFBSVcsTUFBTSx5RkFBeUZGLElBQUksWUFBWUEsSUFBSSxVQUFVLElBQUksQ0FBQ1Qsb0JBQW9CLEdBQUc7WUFDdks7WUFDQUMsT0FBT1csT0FBTyxDQUFDSDtRQUNuQjtRQUNBLElBQUksSUFBSSxDQUFDVixZQUFZLEtBQUssTUFBTTtZQUM1QkUsT0FBT00sSUFBSSxJQUFJLElBQUksQ0FBQ2QsUUFBUSxDQUFDYixHQUFHLENBQUMsU0FBU1UsT0FBTyxDQUFDQyxTQUFTLFNBQVMsSUFBSSxDQUFDUSxZQUFZLEdBQUc7UUFDNUY7UUFDQSxJQUFJLElBQUksQ0FBQ0Msb0JBQW9CLEtBQUssTUFBTTtZQUNwQ0MsT0FBT00sSUFBSSxJQUFJLElBQUksQ0FBQ2QsUUFBUSxDQUFDYixHQUFHLENBQUMsV0FBV1UsT0FBTyxDQUFDQyxTQUFTLFVBQVUsSUFBSSxDQUFDUyxvQkFBb0IsR0FBRztRQUN2RztRQUNBLE9BQU9DO0lBQ1g7SUFDQWhCLFFBQVE0QixRQUFRLEVBQUVDLFNBQVMsRUFBRUMsVUFBVSxFQUFFO1FBQ3JDLElBQUlGLFNBQVNHLE1BQU0sS0FBSyxHQUFHO1lBQ3ZCLElBQUksQ0FBQ1IsV0FBVyxHQUFHO1lBQ25CO1FBQ0o7UUFDQSxJQUFJTyxZQUFZO1lBQ1osTUFBTSxJQUFJSixNQUFNO1FBQ3BCO1FBQ0Esd0NBQXdDO1FBQ3hDLElBQUlNLGNBQWNKLFFBQVEsQ0FBQyxFQUFFO1FBQzdCLDZDQUE2QztRQUM3QyxJQUFJSSxZQUFZQyxVQUFVLENBQUMsUUFBUUQsWUFBWUUsUUFBUSxDQUFDLE1BQU07WUFDMUQsOENBQThDO1lBQzlDLElBQUlDLGNBQWNILFlBQVlQLEtBQUssQ0FBQyxHQUFHLENBQUM7WUFDeEMsSUFBSVcsYUFBYTtZQUNqQixJQUFJRCxZQUFZRixVQUFVLENBQUMsUUFBUUUsWUFBWUQsUUFBUSxDQUFDLE1BQU07Z0JBQzFELHVEQUF1RDtnQkFDdkRDLGNBQWNBLFlBQVlWLEtBQUssQ0FBQyxHQUFHLENBQUM7Z0JBQ3BDVyxhQUFhO1lBQ2pCO1lBQ0EsSUFBSUQsWUFBWUYsVUFBVSxDQUFDLFFBQVE7Z0JBQy9CLHdDQUF3QztnQkFDeENFLGNBQWNBLFlBQVlFLFNBQVMsQ0FBQztnQkFDcENQLGFBQWE7WUFDakI7WUFDQSxJQUFJSyxZQUFZRixVQUFVLENBQUMsUUFBUUUsWUFBWUQsUUFBUSxDQUFDLE1BQU07Z0JBQzFELE1BQU0sSUFBSVIsTUFBTSw4REFBOERTLGNBQWM7WUFDaEc7WUFDQSxJQUFJQSxZQUFZRixVQUFVLENBQUMsTUFBTTtnQkFDN0IsTUFBTSxJQUFJUCxNQUFNLDBEQUEwRFMsY0FBYztZQUM1RjtZQUNBLFNBQVNHLFdBQVdDLFlBQVksRUFBRUMsUUFBUTtnQkFDdEMsSUFBSUQsaUJBQWlCLE1BQU07b0JBQ3ZCLDZFQUE2RTtvQkFDN0UsaUNBQWlDO29CQUNqQyx3QkFBd0I7b0JBQ3hCLHNCQUFzQjtvQkFDdEIsd0ZBQXdGO29CQUN4RixJQUFJQSxpQkFBaUJDLFVBQVU7d0JBQzNCLHdIQUF3SDt3QkFDeEgsTUFBTSxJQUFJZCxNQUFNLHFFQUFxRWEsZUFBZSxZQUFZQyxXQUFXO29CQUMvSDtnQkFDSjtnQkFDQVgsVUFBVVksT0FBTyxDQUFDLENBQUNDO29CQUNmLElBQUlBLFNBQVNGLFVBQVU7d0JBQ25CLE1BQU0sSUFBSWQsTUFBTSx5Q0FBeUNjLFdBQVc7b0JBQ3hFO29CQUNBLElBQUlFLEtBQUtDLE9BQU8sQ0FBQyxPQUFPLFFBQVFYLFlBQVlXLE9BQU8sQ0FBQyxPQUFPLEtBQUs7d0JBQzVELE1BQU0sSUFBSWpCLE1BQU0scUNBQXFDZ0IsT0FBTyxZQUFZRixXQUFXO29CQUN2RjtnQkFDSjtnQkFDQVgsVUFBVVAsSUFBSSxDQUFDa0I7WUFDbkI7WUFDQSxJQUFJVixZQUFZO2dCQUNaLElBQUlNLFlBQVk7b0JBQ1osSUFBSSxJQUFJLENBQUN0QixZQUFZLElBQUksTUFBTTt3QkFDM0IsTUFBTSxJQUFJWSxNQUFNLDBGQUEwRixJQUFJLENBQUNaLFlBQVksR0FBRyxhQUFhYyxRQUFRLENBQUMsRUFBRSxHQUFHO29CQUM3SjtvQkFDQVUsV0FBVyxJQUFJLENBQUN2QixvQkFBb0IsRUFBRW9CO29CQUN0Qyw2REFBNkQ7b0JBQzdELElBQUksQ0FBQ3BCLG9CQUFvQixHQUFHb0I7b0JBQzVCLG9GQUFvRjtvQkFDcEZILGNBQWM7Z0JBQ2xCLE9BQU87b0JBQ0gsSUFBSSxJQUFJLENBQUNqQixvQkFBb0IsSUFBSSxNQUFNO3dCQUNuQyxNQUFNLElBQUlXLE1BQU0sMkZBQTJGLElBQUksQ0FBQ1gsb0JBQW9CLEdBQUcsY0FBY2EsUUFBUSxDQUFDLEVBQUUsR0FBRztvQkFDdks7b0JBQ0FVLFdBQVcsSUFBSSxDQUFDeEIsWUFBWSxFQUFFcUI7b0JBQzlCLDZEQUE2RDtvQkFDN0QsSUFBSSxDQUFDckIsWUFBWSxHQUFHcUI7b0JBQ3BCLGtGQUFrRjtvQkFDbEZILGNBQWM7Z0JBQ2xCO1lBQ0osT0FBTztnQkFDSCxJQUFJSSxZQUFZO29CQUNaLE1BQU0sSUFBSVYsTUFBTSx1REFBdURFLFFBQVEsQ0FBQyxFQUFFLEdBQUc7Z0JBQ3pGO2dCQUNBVSxXQUFXLElBQUksQ0FBQzNCLFFBQVEsRUFBRXdCO2dCQUMxQiw2REFBNkQ7Z0JBQzdELElBQUksQ0FBQ3hCLFFBQVEsR0FBR3dCO2dCQUNoQiwrRUFBK0U7Z0JBQy9FSCxjQUFjO1lBQ2xCO1FBQ0o7UUFDQSxpRkFBaUY7UUFDakYsSUFBSSxDQUFDLElBQUksQ0FBQ3hCLFFBQVEsQ0FBQ29DLEdBQUcsQ0FBQ1osY0FBYztZQUNqQyxJQUFJLENBQUN4QixRQUFRLENBQUNxQyxHQUFHLENBQUNiLGFBQWEsSUFBSW5DO1FBQ3ZDO1FBQ0EsSUFBSSxDQUFDVyxRQUFRLENBQUNiLEdBQUcsQ0FBQ3FDLGFBQWFoQyxPQUFPLENBQUM0QixTQUFTSCxLQUFLLENBQUMsSUFBSUksV0FBV0M7SUFDekU7SUFDQWdCLGFBQWE7UUFDVCxJQUFJLENBQUN2QixXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDZixRQUFRLEdBQUcsSUFBSXVDO1FBQ3BCLElBQUksQ0FBQ3BDLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNHLFlBQVksR0FBRztRQUNwQixJQUFJLENBQUNDLG9CQUFvQixHQUFHO0lBQ2hDO0FBQ0o7QUFDQSxTQUFTbkIsZ0JBQWdCb0QsZUFBZTtJQUNwQyxrRkFBa0Y7SUFDbEYsNEVBQTRFO0lBQzVFLDJDQUEyQztJQUMzQyx5RUFBeUU7SUFDekUsMkJBQTJCO0lBQzNCLG9DQUFvQztJQUNwQyw4RUFBOEU7SUFDOUUsd0VBQXdFO0lBQ3hFLGdIQUFnSDtJQUNoSCw0RUFBNEU7SUFDNUUsTUFBTUMsT0FBTyxJQUFJcEQ7SUFDakIsNkZBQTZGO0lBQzdGbUQsZ0JBQWdCUCxPQUFPLENBQUMsQ0FBQ1MsV0FBV0QsS0FBS25ELE1BQU0sQ0FBQ29EO0lBQ2hELDRHQUE0RztJQUM1RyxPQUFPRCxLQUFLN0MsTUFBTTtBQUN0QixFQUVBLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3NvcnRlZC1yb3V0ZXMuanM/MmY3OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldFNvcnRlZFJvdXRlc1wiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0U29ydGVkUm91dGVzO1xuICAgIH1cbn0pO1xuY2xhc3MgVXJsTm9kZSB7XG4gICAgaW5zZXJ0KHVybFBhdGgpIHtcbiAgICAgICAgdGhpcy5faW5zZXJ0KHVybFBhdGguc3BsaXQoXCIvXCIpLmZpbHRlcihCb29sZWFuKSwgW10sIGZhbHNlKTtcbiAgICB9XG4gICAgc21vb3NoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc21vb3NoKCk7XG4gICAgfVxuICAgIF9zbW9vc2gocHJlZml4KSB7XG4gICAgICAgIGlmIChwcmVmaXggPT09IHZvaWQgMCkgcHJlZml4ID0gXCIvXCI7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuUGF0aHMgPSBbXG4gICAgICAgICAgICAuLi50aGlzLmNoaWxkcmVuLmtleXMoKVxuICAgICAgICBdLnNvcnQoKTtcbiAgICAgICAgaWYgKHRoaXMuc2x1Z05hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuUGF0aHMuc3BsaWNlKGNoaWxkcmVuUGF0aHMuaW5kZXhPZihcIltdXCIpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXN0U2x1Z05hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuUGF0aHMuc3BsaWNlKGNoaWxkcmVuUGF0aHMuaW5kZXhPZihcIlsuLi5dXCIpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25hbFJlc3RTbHVnTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2hpbGRyZW5QYXRocy5zcGxpY2UoY2hpbGRyZW5QYXRocy5pbmRleE9mKFwiW1suLi5dXVwiKSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm91dGVzID0gY2hpbGRyZW5QYXRocy5tYXAoKGMpPT50aGlzLmNoaWxkcmVuLmdldChjKS5fc21vb3NoKFwiXCIgKyBwcmVmaXggKyBjICsgXCIvXCIpKS5yZWR1Y2UoKHByZXYsIGN1cnIpPT5bXG4gICAgICAgICAgICAgICAgLi4ucHJldixcbiAgICAgICAgICAgICAgICAuLi5jdXJyXG4gICAgICAgICAgICBdLCBbXSk7XG4gICAgICAgIGlmICh0aGlzLnNsdWdOYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgICByb3V0ZXMucHVzaCguLi50aGlzLmNoaWxkcmVuLmdldChcIltdXCIpLl9zbW9vc2gocHJlZml4ICsgXCJbXCIgKyB0aGlzLnNsdWdOYW1lICsgXCJdL1wiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICBjb25zdCByID0gcHJlZml4ID09PSBcIi9cIiA/IFwiL1wiIDogcHJlZml4LnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsUmVzdFNsdWdOYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW5ub3QgZGVmaW5lIGEgcm91dGUgd2l0aCB0aGUgc2FtZSBzcGVjaWZpY2l0eSBhcyBhIG9wdGlvbmFsIGNhdGNoLWFsbCByb3V0ZSAoXCInICsgciArICdcIiBhbmQgXCInICsgciArIFwiW1suLi5cIiArIHRoaXMub3B0aW9uYWxSZXN0U2x1Z05hbWUgKyAnXV1cIikuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3V0ZXMudW5zaGlmdChyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXN0U2x1Z05hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJvdXRlcy5wdXNoKC4uLnRoaXMuY2hpbGRyZW4uZ2V0KFwiWy4uLl1cIikuX3Ntb29zaChwcmVmaXggKyBcIlsuLi5cIiArIHRoaXMucmVzdFNsdWdOYW1lICsgXCJdL1wiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxSZXN0U2x1Z05hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJvdXRlcy5wdXNoKC4uLnRoaXMuY2hpbGRyZW4uZ2V0KFwiW1suLi5dXVwiKS5fc21vb3NoKHByZWZpeCArIFwiW1suLi5cIiArIHRoaXMub3B0aW9uYWxSZXN0U2x1Z05hbWUgKyBcIl1dL1wiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvdXRlcztcbiAgICB9XG4gICAgX2luc2VydCh1cmxQYXRocywgc2x1Z05hbWVzLCBpc0NhdGNoQWxsKSB7XG4gICAgICAgIGlmICh1cmxQYXRocy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDYXRjaEFsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2F0Y2gtYWxsIG11c3QgYmUgdGhlIGxhc3QgcGFydCBvZiB0aGUgVVJMLlwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgbmV4dCBzZWdtZW50IGluIHRoZSB1cmxQYXRocyBsaXN0XG4gICAgICAgIGxldCBuZXh0U2VnbWVudCA9IHVybFBhdGhzWzBdO1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgc2VnbWVudCBtYXRjaGVzIGBbc29tZXRoaW5nXWBcbiAgICAgICAgaWYgKG5leHRTZWdtZW50LnN0YXJ0c1dpdGgoXCJbXCIpICYmIG5leHRTZWdtZW50LmVuZHNXaXRoKFwiXVwiKSkge1xuICAgICAgICAgICAgLy8gU3RyaXAgYFtgIGFuZCBgXWAsIGxlYXZpbmcgb25seSBgc29tZXRoaW5nYFxuICAgICAgICAgICAgbGV0IHNlZ21lbnROYW1lID0gbmV4dFNlZ21lbnQuc2xpY2UoMSwgLTEpO1xuICAgICAgICAgICAgbGV0IGlzT3B0aW9uYWwgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzZWdtZW50TmFtZS5zdGFydHNXaXRoKFwiW1wiKSAmJiBzZWdtZW50TmFtZS5lbmRzV2l0aChcIl1cIikpIHtcbiAgICAgICAgICAgICAgICAvLyBTdHJpcCBvcHRpb25hbCBgW2AgYW5kIGBdYCwgbGVhdmluZyBvbmx5IGBzb21ldGhpbmdgXG4gICAgICAgICAgICAgICAgc2VnbWVudE5hbWUgPSBzZWdtZW50TmFtZS5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICAgICAgaXNPcHRpb25hbCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VnbWVudE5hbWUuc3RhcnRzV2l0aChcIi4uLlwiKSkge1xuICAgICAgICAgICAgICAgIC8vIFN0cmlwIGAuLi5gLCBsZWF2aW5nIG9ubHkgYHNvbWV0aGluZ2BcbiAgICAgICAgICAgICAgICBzZWdtZW50TmFtZSA9IHNlZ21lbnROYW1lLnN1YnN0cmluZygzKTtcbiAgICAgICAgICAgICAgICBpc0NhdGNoQWxsID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWdtZW50TmFtZS5zdGFydHNXaXRoKFwiW1wiKSB8fCBzZWdtZW50TmFtZS5lbmRzV2l0aChcIl1cIikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZWdtZW50IG5hbWVzIG1heSBub3Qgc3RhcnQgb3IgZW5kIHdpdGggZXh0cmEgYnJhY2tldHMgKCdcIiArIHNlZ21lbnROYW1lICsgXCInKS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VnbWVudE5hbWUuc3RhcnRzV2l0aChcIi5cIikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZWdtZW50IG5hbWVzIG1heSBub3Qgc3RhcnQgd2l0aCBlcnJvbmVvdXMgcGVyaW9kcyAoJ1wiICsgc2VnbWVudE5hbWUgKyBcIicpLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGhhbmRsZVNsdWcocHJldmlvdXNTbHVnLCBuZXh0U2x1Zykge1xuICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c1NsdWcgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHNwZWNpZmljIHNlZ21lbnQgYWxyZWFkeSBoYXMgYSBzbHVnIGJ1dCB0aGUgc2x1ZyBpcyBub3QgYHNvbWV0aGluZ2BcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBwcmV2ZW50cyBjb2xsaXNpb25zIGxpa2U6XG4gICAgICAgICAgICAgICAgICAgIC8vIHBhZ2VzL1twb3N0XS9pbmRleC5qc1xuICAgICAgICAgICAgICAgICAgICAvLyBwYWdlcy9baWRdL2luZGV4LmpzXG4gICAgICAgICAgICAgICAgICAgIC8vIEJlY2F1c2UgY3VycmVudGx5IG11bHRpcGxlIGR5bmFtaWMgcGFyYW1zIG9uIHRoZSBzYW1lIHNlZ21lbnQgbGV2ZWwgYXJlIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzU2x1ZyAhPT0gbmV4dFNsdWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFRoaXMgZXJyb3Igc2VlbXMgdG8gYmUgY29uZnVzaW5nIGZvciB1c2VycywgbmVlZHMgYW4gZXJyb3IgbGluaywgdGhlIGRlc2NyaXB0aW9uIGNhbiBiZSBiYXNlZCBvbiBhYm92ZSBjb21tZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbm5vdCB1c2UgZGlmZmVyZW50IHNsdWcgbmFtZXMgZm9yIHRoZSBzYW1lIGR5bmFtaWMgcGF0aCAoJ1wiICsgcHJldmlvdXNTbHVnICsgXCInICE9PSAnXCIgKyBuZXh0U2x1ZyArIFwiJykuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNsdWdOYW1lcy5mb3JFYWNoKChzbHVnKT0+e1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2x1ZyA9PT0gbmV4dFNsdWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGNhbm5vdCBoYXZlIHRoZSBzYW1lIHNsdWcgbmFtZSBcIicgKyBuZXh0U2x1ZyArICdcIiByZXBlYXQgd2l0aGluIGEgc2luZ2xlIGR5bmFtaWMgcGF0aCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzbHVnLnJlcGxhY2UoL1xcVy9nLCBcIlwiKSA9PT0gbmV4dFNlZ21lbnQucmVwbGFjZSgvXFxXL2csIFwiXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW5ub3QgaGF2ZSB0aGUgc2x1ZyBuYW1lcyBcIicgKyBzbHVnICsgJ1wiIGFuZCBcIicgKyBuZXh0U2x1ZyArICdcIiBkaWZmZXIgb25seSBieSBub24td29yZCBzeW1ib2xzIHdpdGhpbiBhIHNpbmdsZSBkeW5hbWljIHBhdGgnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNsdWdOYW1lcy5wdXNoKG5leHRTbHVnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0NhdGNoQWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzT3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVzdFNsdWdOYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGNhbm5vdCB1c2UgYm90aCBhbiByZXF1aXJlZCBhbmQgb3B0aW9uYWwgY2F0Y2gtYWxsIHJvdXRlIGF0IHRoZSBzYW1lIGxldmVsIChcIlsuLi4nICsgdGhpcy5yZXN0U2x1Z05hbWUgKyAnXVwiIGFuZCBcIicgKyB1cmxQYXRoc1swXSArICdcIiApLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZVNsdWcodGhpcy5vcHRpb25hbFJlc3RTbHVnTmFtZSwgc2VnbWVudE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBzbHVnTmFtZSBpcyBrZXB0IGFzIGl0IGNhbiBvbmx5IGJlIG9uZSBwYXJ0aWN1bGFyIHNsdWdOYW1lXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uYWxSZXN0U2x1Z05hbWUgPSBzZWdtZW50TmFtZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gbmV4dFNlZ21lbnQgaXMgb3ZlcndyaXR0ZW4gdG8gW1suLi5dXSBzbyB0aGF0IGl0IGNhbiBsYXRlciBiZSBzb3J0ZWQgc3BlY2lmaWNhbGx5XG4gICAgICAgICAgICAgICAgICAgIG5leHRTZWdtZW50ID0gXCJbWy4uLl1dXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxSZXN0U2x1Z05hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgY2Fubm90IHVzZSBib3RoIGFuIG9wdGlvbmFsIGFuZCByZXF1aXJlZCBjYXRjaC1hbGwgcm91dGUgYXQgdGhlIHNhbWUgbGV2ZWwgKFwiW1suLi4nICsgdGhpcy5vcHRpb25hbFJlc3RTbHVnTmFtZSArICddXVwiIGFuZCBcIicgKyB1cmxQYXRoc1swXSArICdcIikuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlU2x1Zyh0aGlzLnJlc3RTbHVnTmFtZSwgc2VnbWVudE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBzbHVnTmFtZSBpcyBrZXB0IGFzIGl0IGNhbiBvbmx5IGJlIG9uZSBwYXJ0aWN1bGFyIHNsdWdOYW1lXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdFNsdWdOYW1lID0gc2VnbWVudE5hbWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5leHRTZWdtZW50IGlzIG92ZXJ3cml0dGVuIHRvIFsuLi5dIHNvIHRoYXQgaXQgY2FuIGxhdGVyIGJlIHNvcnRlZCBzcGVjaWZpY2FsbHlcbiAgICAgICAgICAgICAgICAgICAgbmV4dFNlZ21lbnQgPSBcIlsuLi5dXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNPcHRpb25hbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbmFsIHJvdXRlIHBhcmFtZXRlcnMgYXJlIG5vdCB5ZXQgc3VwcG9ydGVkIChcIicgKyB1cmxQYXRoc1swXSArICdcIikuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhhbmRsZVNsdWcodGhpcy5zbHVnTmFtZSwgc2VnbWVudE5hbWUpO1xuICAgICAgICAgICAgICAgIC8vIHNsdWdOYW1lIGlzIGtlcHQgYXMgaXQgY2FuIG9ubHkgYmUgb25lIHBhcnRpY3VsYXIgc2x1Z05hbWVcbiAgICAgICAgICAgICAgICB0aGlzLnNsdWdOYW1lID0gc2VnbWVudE5hbWU7XG4gICAgICAgICAgICAgICAgLy8gbmV4dFNlZ21lbnQgaXMgb3ZlcndyaXR0ZW4gdG8gW10gc28gdGhhdCBpdCBjYW4gbGF0ZXIgYmUgc29ydGVkIHNwZWNpZmljYWxseVxuICAgICAgICAgICAgICAgIG5leHRTZWdtZW50ID0gXCJbXVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoaXMgVXJsTm9kZSBkb2Vzbid0IGhhdmUgdGhlIG5leHRTZWdtZW50IHlldCB3ZSBjcmVhdGUgYSBuZXcgY2hpbGQgVXJsTm9kZVxuICAgICAgICBpZiAoIXRoaXMuY2hpbGRyZW4uaGFzKG5leHRTZWdtZW50KSkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5zZXQobmV4dFNlZ21lbnQsIG5ldyBVcmxOb2RlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZ2V0KG5leHRTZWdtZW50KS5faW5zZXJ0KHVybFBhdGhzLnNsaWNlKDEpLCBzbHVnTmFtZXMsIGlzQ2F0Y2hBbGwpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zbHVnTmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMucmVzdFNsdWdOYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5vcHRpb25hbFJlc3RTbHVnTmFtZSA9IG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0U29ydGVkUm91dGVzKG5vcm1hbGl6ZWRQYWdlcykge1xuICAgIC8vIEZpcnN0IHRoZSBVcmxOb2RlIGlzIGNyZWF0ZWQsIGFuZCBldmVyeSBVcmxOb2RlIGNhbiBoYXZlIG9ubHkgMSBkeW5hbWljIHNlZ21lbnRcbiAgICAvLyBFZyB5b3UgY2FuJ3QgaGF2ZSBwYWdlcy9bcG9zdF0vYWJjLmpzIGFuZCBwYWdlcy9baGVsbG9dL3NvbWV0aGluZy1lbHNlLmpzXG4gICAgLy8gT25seSAxIGR5bmFtaWMgc2VnbWVudCBwZXIgbmVzdGluZyBsZXZlbFxuICAgIC8vIFNvIGluIHRoZSBjYXNlIHRoYXQgaXMgdGVzdC9pbnRlZ3JhdGlvbi9keW5hbWljLXJvdXRpbmcgaXQnbGwgYmUgdGhpczpcbiAgICAvLyBwYWdlcy9bcG9zdF0vY29tbWVudHMuanNcbiAgICAvLyBwYWdlcy9ibG9nL1twb3N0XS9jb21tZW50L1tpZF0uanNcbiAgICAvLyBCb3RoIGFyZSBmaW5lIGJlY2F1c2UgYHBhZ2VzL1twb3N0XWAgYW5kIGBwYWdlcy9ibG9nYCBhcmUgb24gdGhlIHNhbWUgbGV2ZWxcbiAgICAvLyBTbyBpbiB0aGlzIGNhc2UgYFVybE5vZGVgIGNyZWF0ZWQgaGVyZSBoYXMgYHRoaXMuc2x1Z05hbWUgPT09ICdwb3N0J2BcbiAgICAvLyBBbmQgc2luY2UgeW91ciBQUiBwYXNzZWQgdGhyb3VnaCBgc2x1Z05hbWVgIGFzIGFuIGFycmF5IGJhc2ljYWxseSBpdCdkIGluY2x1ZGluZyBpdCBpbiB0b28gbWFueSBwb3NzaWJpbGl0aWVzXG4gICAgLy8gSW5zdGVhZCB3aGF0IGhhcyB0byBiZSBwYXNzZWQgdGhyb3VnaCBpcyB0aGUgdXB3YXJkcyBwYXRoJ3MgZHluYW1pYyBuYW1lc1xuICAgIGNvbnN0IHJvb3QgPSBuZXcgVXJsTm9kZSgpO1xuICAgIC8vIEhlcmUgdGhlIGByb290YCBnZXRzIGluamVjdGVkIG11bHRpcGxlIHBhdGhzLCBhbmQgaW5zZXJ0IHdpbGwgYnJlYWsgdGhlbSB1cCBpbnRvIHN1YmxldmVsc1xuICAgIG5vcm1hbGl6ZWRQYWdlcy5mb3JFYWNoKChwYWdlUGF0aCk9PnJvb3QuaW5zZXJ0KHBhZ2VQYXRoKSk7XG4gICAgLy8gU21vb3NoIHdpbGwgdGhlbiBzb3J0IHRob3NlIHN1YmxldmVscyB1cCB0byB0aGUgcG9pbnQgd2hlcmUgeW91IGdldCB0aGUgY29ycmVjdCByb3V0ZSBkZWZpbml0aW9uIHByaW9yaXR5XG4gICAgcmV0dXJuIHJvb3Quc21vb3NoKCk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNvcnRlZC1yb3V0ZXMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsImdldFNvcnRlZFJvdXRlcyIsIlVybE5vZGUiLCJpbnNlcnQiLCJ1cmxQYXRoIiwiX2luc2VydCIsInNwbGl0IiwiZmlsdGVyIiwiQm9vbGVhbiIsInNtb29zaCIsIl9zbW9vc2giLCJwcmVmaXgiLCJjaGlsZHJlblBhdGhzIiwiY2hpbGRyZW4iLCJrZXlzIiwic29ydCIsInNsdWdOYW1lIiwic3BsaWNlIiwiaW5kZXhPZiIsInJlc3RTbHVnTmFtZSIsIm9wdGlvbmFsUmVzdFNsdWdOYW1lIiwicm91dGVzIiwibWFwIiwiYyIsInJlZHVjZSIsInByZXYiLCJjdXJyIiwicHVzaCIsInBsYWNlaG9sZGVyIiwiciIsInNsaWNlIiwiRXJyb3IiLCJ1bnNoaWZ0IiwidXJsUGF0aHMiLCJzbHVnTmFtZXMiLCJpc0NhdGNoQWxsIiwibGVuZ3RoIiwibmV4dFNlZ21lbnQiLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJzZWdtZW50TmFtZSIsImlzT3B0aW9uYWwiLCJzdWJzdHJpbmciLCJoYW5kbGVTbHVnIiwicHJldmlvdXNTbHVnIiwibmV4dFNsdWciLCJmb3JFYWNoIiwic2x1ZyIsInJlcGxhY2UiLCJoYXMiLCJzZXQiLCJjb25zdHJ1Y3RvciIsIk1hcCIsIm5vcm1hbGl6ZWRQYWdlcyIsInJvb3QiLCJwYWdlUGF0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/sorted-routes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js":
/*!****************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/utils.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    WEB_VITALS: function() {\n        return WEB_VITALS;\n    },\n    execOnce: function() {\n        return execOnce;\n    },\n    isAbsoluteUrl: function() {\n        return isAbsoluteUrl;\n    },\n    getLocationOrigin: function() {\n        return getLocationOrigin;\n    },\n    getURL: function() {\n        return getURL;\n    },\n    getDisplayName: function() {\n        return getDisplayName;\n    },\n    isResSent: function() {\n        return isResSent;\n    },\n    normalizeRepeatedSlashes: function() {\n        return normalizeRepeatedSlashes;\n    },\n    loadGetInitialProps: function() {\n        return loadGetInitialProps;\n    },\n    SP: function() {\n        return SP;\n    },\n    ST: function() {\n        return ST;\n    },\n    DecodeError: function() {\n        return DecodeError;\n    },\n    NormalizeError: function() {\n        return NormalizeError;\n    },\n    PageNotFoundError: function() {\n        return PageNotFoundError;\n    },\n    MissingStaticPage: function() {\n        return MissingStaticPage;\n    },\n    MiddlewareNotFoundError: function() {\n        return MiddlewareNotFoundError;\n    },\n    stringifyError: function() {\n        return stringifyError;\n    }\n});\nconst WEB_VITALS = [\n    \"CLS\",\n    \"FCP\",\n    \"FID\",\n    \"INP\",\n    \"LCP\",\n    \"TTFB\"\n];\nfunction execOnce(fn) {\n    let used = false;\n    let result;\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (!used) {\n            used = true;\n            result = fn(...args);\n        }\n        return result;\n    };\n}\n// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1\n// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\nconst ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/;\nconst isAbsoluteUrl = (url)=>ABSOLUTE_URL_REGEX.test(url);\nfunction getLocationOrigin() {\n    const { protocol, hostname, port } = window.location;\n    return protocol + \"//\" + hostname + (port ? \":\" + port : \"\");\n}\nfunction getURL() {\n    const { href } = window.location;\n    const origin = getLocationOrigin();\n    return href.substring(origin.length);\n}\nfunction getDisplayName(Component) {\n    return typeof Component === \"string\" ? Component : Component.displayName || Component.name || \"Unknown\";\n}\nfunction isResSent(res) {\n    return res.finished || res.headersSent;\n}\nfunction normalizeRepeatedSlashes(url) {\n    const urlParts = url.split(\"?\");\n    const urlNoQuery = urlParts[0];\n    return urlNoQuery // first we replace any non-encoded backslashes with forward\n    // then normalize repeated forward slashes\n    .replace(/\\\\/g, \"/\").replace(/\\/\\/+/g, \"/\") + (urlParts[1] ? \"?\" + urlParts.slice(1).join(\"?\") : \"\");\n}\nasync function loadGetInitialProps(App, ctx) {\n    if (true) {\n        var _App_prototype;\n        if ((_App_prototype = App.prototype) == null ? void 0 : _App_prototype.getInitialProps) {\n            const message = '\"' + getDisplayName(App) + '.getInitialProps()\" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.';\n            throw new Error(message);\n        }\n    }\n    // when called from _app `ctx` is nested in `ctx`\n    const res = ctx.res || ctx.ctx && ctx.ctx.res;\n    if (!App.getInitialProps) {\n        if (ctx.ctx && ctx.Component) {\n            // @ts-ignore pageProps default\n            return {\n                pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx)\n            };\n        }\n        return {};\n    }\n    const props = await App.getInitialProps(ctx);\n    if (res && isResSent(res)) {\n        return props;\n    }\n    if (!props) {\n        const message = '\"' + getDisplayName(App) + '.getInitialProps()\" should resolve to an object. But found \"' + props + '\" instead.';\n        throw new Error(message);\n    }\n    if (true) {\n        if (Object.keys(props).length === 0 && !ctx.ctx) {\n            console.warn(\"\" + getDisplayName(App) + \" returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps\");\n        }\n    }\n    return props;\n}\nconst SP = typeof performance !== \"undefined\";\nconst ST = SP && [\n    \"mark\",\n    \"measure\",\n    \"getEntriesByName\"\n].every((method)=>typeof performance[method] === \"function\");\nclass DecodeError extends Error {\n}\nclass NormalizeError extends Error {\n}\nclass PageNotFoundError extends Error {\n    constructor(page){\n        super();\n        this.code = \"ENOENT\";\n        this.name = \"PageNotFoundError\";\n        this.message = \"Cannot find module for page: \" + page;\n    }\n}\nclass MissingStaticPage extends Error {\n    constructor(page, message){\n        super();\n        this.message = \"Failed to load static file for page: \" + page + \" \" + message;\n    }\n}\nclass MiddlewareNotFoundError extends Error {\n    constructor(){\n        super();\n        this.code = \"ENOENT\";\n        this.message = \"Cannot find the middleware module\";\n    }\n}\nfunction stringifyError(error) {\n    return JSON.stringify({\n        message: error.message,\n        stack: error.stack\n    });\n} //# sourceMappingURL=utils.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQWtCTjtBQUNBLFNBQVNrQixRQUFRQyxNQUFNLEVBQUVDLEdBQUc7SUFDeEIsSUFBSSxJQUFJQyxRQUFRRCxJQUFJeEIsT0FBT0MsY0FBYyxDQUFDc0IsUUFBUUUsTUFBTTtRQUNwREMsWUFBWTtRQUNaQyxLQUFLSCxHQUFHLENBQUNDLEtBQUs7SUFDbEI7QUFDSjtBQUNBSCxRQUFRcEIsU0FBUztJQUNiRyxZQUFZO1FBQ1IsT0FBT0E7SUFDWDtJQUNBQyxVQUFVO1FBQ04sT0FBT0E7SUFDWDtJQUNBQyxlQUFlO1FBQ1gsT0FBT0E7SUFDWDtJQUNBQyxtQkFBbUI7UUFDZixPQUFPQTtJQUNYO0lBQ0FDLFFBQVE7UUFDSixPQUFPQTtJQUNYO0lBQ0FDLGdCQUFnQjtRQUNaLE9BQU9BO0lBQ1g7SUFDQUMsV0FBVztRQUNQLE9BQU9BO0lBQ1g7SUFDQUMsMEJBQTBCO1FBQ3RCLE9BQU9BO0lBQ1g7SUFDQUMscUJBQXFCO1FBQ2pCLE9BQU9BO0lBQ1g7SUFDQUMsSUFBSTtRQUNBLE9BQU9BO0lBQ1g7SUFDQUMsSUFBSTtRQUNBLE9BQU9BO0lBQ1g7SUFDQUMsYUFBYTtRQUNULE9BQU9BO0lBQ1g7SUFDQUMsZ0JBQWdCO1FBQ1osT0FBT0E7SUFDWDtJQUNBQyxtQkFBbUI7UUFDZixPQUFPQTtJQUNYO0lBQ0FDLG1CQUFtQjtRQUNmLE9BQU9BO0lBQ1g7SUFDQUMseUJBQXlCO1FBQ3JCLE9BQU9BO0lBQ1g7SUFDQUMsZ0JBQWdCO1FBQ1osT0FBT0E7SUFDWDtBQUNKO0FBQ0EsTUFBTWhCLGFBQWE7SUFDZjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDSDtBQUNELFNBQVNDLFNBQVNzQixFQUFFO0lBQ2hCLElBQUlD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QUFFO1lBQzdDVSxRQUFRQyxJQUFJLENBQUMsS0FBSzdELGVBQWVpRCxPQUFPO1FBQzVDO0lBQ0o7SUFDQSxPQUFPUztBQUNYO0FBQ0EsTUFBTXRELEtBQUssT0FBTzBELGdCQUFnQjtBQUNsQyxNQUFNekQsS0FBS0QsTUFBTTtJQUNiO0lBQ0E7SUFDQTtDQUNILENBQUMyRCxLQUFLLENBQUMsQ0FBQ0MsU0FBUyxPQUFPRixXQUFXLENBQUNFLE9BQU8sS0FBSztBQUNqRCxNQUFNMUQsb0JBQW9Ca0Q7QUFDMUI7QUFDQSxNQUFNakQsdUJBQXVCaUQ7QUFDN0I7QUFDQSxNQUFNaEQsMEJBQTBCZ0Q7SUFDNUJTLFlBQVlDLElBQUksQ0FBQztRQUNiLEtBQUs7UUFDTCxJQUFJLENBQUNDLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ3BELElBQUksR0FBRztRQUNaLElBQUksQ0FBQ3dDLE9BQU8sR0FBRyxrQ0FBa0NXO0lBQ3JEO0FBQ0o7QUFDQSxNQUFNekQsMEJBQTBCK0M7SUFDNUJTLFlBQVlDLElBQUksRUFBRVgsT0FBTyxDQUFDO1FBQ3RCLEtBQUs7UUFDTCxJQUFJLENBQUNBLE9BQU8sR0FBRywwQ0FBMENXLE9BQU8sTUFBTVg7SUFDMUU7QUFDSjtBQUNBLE1BQU03QyxnQ0FBZ0M4QztJQUNsQ1MsYUFBYTtRQUNULEtBQUs7UUFDTCxJQUFJLENBQUNFLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ1osT0FBTyxHQUFHO0lBQ25CO0FBQ0o7QUFDQSxTQUFTNUMsZUFBZXlELEtBQUs7SUFDekIsT0FBT0MsS0FBS0MsU0FBUyxDQUFDO1FBQ2xCZixTQUFTYSxNQUFNYixPQUFPO1FBQ3RCZ0IsT0FBT0gsTUFBTUcsS0FBSztJQUN0QjtBQUNKLEVBRUEsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi91dGlscy5qcz9lN2ZmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgV0VCX1ZJVEFMUzogbnVsbCxcbiAgICBleGVjT25jZTogbnVsbCxcbiAgICBpc0Fic29sdXRlVXJsOiBudWxsLFxuICAgIGdldExvY2F0aW9uT3JpZ2luOiBudWxsLFxuICAgIGdldFVSTDogbnVsbCxcbiAgICBnZXREaXNwbGF5TmFtZTogbnVsbCxcbiAgICBpc1Jlc1NlbnQ6IG51bGwsXG4gICAgbm9ybWFsaXplUmVwZWF0ZWRTbGFzaGVzOiBudWxsLFxuICAgIGxvYWRHZXRJbml0aWFsUHJvcHM6IG51bGwsXG4gICAgU1A6IG51bGwsXG4gICAgU1Q6IG51bGwsXG4gICAgRGVjb2RlRXJyb3I6IG51bGwsXG4gICAgTm9ybWFsaXplRXJyb3I6IG51bGwsXG4gICAgUGFnZU5vdEZvdW5kRXJyb3I6IG51bGwsXG4gICAgTWlzc2luZ1N0YXRpY1BhZ2U6IG51bGwsXG4gICAgTWlkZGxld2FyZU5vdEZvdW5kRXJyb3I6IG51bGwsXG4gICAgc3RyaW5naWZ5RXJyb3I6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgV0VCX1ZJVEFMUzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBXRUJfVklUQUxTO1xuICAgIH0sXG4gICAgZXhlY09uY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZXhlY09uY2U7XG4gICAgfSxcbiAgICBpc0Fic29sdXRlVXJsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGlzQWJzb2x1dGVVcmw7XG4gICAgfSxcbiAgICBnZXRMb2NhdGlvbk9yaWdpbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRMb2NhdGlvbk9yaWdpbjtcbiAgICB9LFxuICAgIGdldFVSTDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRVUkw7XG4gICAgfSxcbiAgICBnZXREaXNwbGF5TmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXREaXNwbGF5TmFtZTtcbiAgICB9LFxuICAgIGlzUmVzU2VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpc1Jlc1NlbnQ7XG4gICAgfSxcbiAgICBub3JtYWxpemVSZXBlYXRlZFNsYXNoZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplUmVwZWF0ZWRTbGFzaGVzO1xuICAgIH0sXG4gICAgbG9hZEdldEluaXRpYWxQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBsb2FkR2V0SW5pdGlhbFByb3BzO1xuICAgIH0sXG4gICAgU1A6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gU1A7XG4gICAgfSxcbiAgICBTVDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBTVDtcbiAgICB9LFxuICAgIERlY29kZUVycm9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIERlY29kZUVycm9yO1xuICAgIH0sXG4gICAgTm9ybWFsaXplRXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTm9ybWFsaXplRXJyb3I7XG4gICAgfSxcbiAgICBQYWdlTm90Rm91bmRFcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBQYWdlTm90Rm91bmRFcnJvcjtcbiAgICB9LFxuICAgIE1pc3NpbmdTdGF0aWNQYWdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE1pc3NpbmdTdGF0aWNQYWdlO1xuICAgIH0sXG4gICAgTWlkZGxld2FyZU5vdEZvdW5kRXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTWlkZGxld2FyZU5vdEZvdW5kRXJyb3I7XG4gICAgfSxcbiAgICBzdHJpbmdpZnlFcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlFcnJvcjtcbiAgICB9XG59KTtcbmNvbnN0IFdFQl9WSVRBTFMgPSBbXG4gICAgXCJDTFNcIixcbiAgICBcIkZDUFwiLFxuICAgIFwiRklEXCIsXG4gICAgXCJJTlBcIixcbiAgICBcIkxDUFwiLFxuICAgIFwiVFRGQlwiXG5dO1xuZnVuY3Rpb24gZXhlY09uY2UoZm4pIHtcbiAgICBsZXQgdXNlZCA9IGZhbHNlO1xuICAgIGxldCByZXN1bHQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdXNlZCkge1xuICAgICAgICAgICAgdXNlZCA9IHRydWU7XG4gICAgICAgICAgICByZXN1bHQgPSBmbiguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59XG4vLyBTY2hlbWU6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tMy4xXG4vLyBBYnNvbHV0ZSBVUkw6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tNC4zXG5jb25zdCBBQlNPTFVURV9VUkxfUkVHRVggPSAvXlthLXpBLVpdW2EtekEtWlxcZCtcXC0uXSo/Oi87XG5jb25zdCBpc0Fic29sdXRlVXJsID0gKHVybCk9PkFCU09MVVRFX1VSTF9SRUdFWC50ZXN0KHVybCk7XG5mdW5jdGlvbiBnZXRMb2NhdGlvbk9yaWdpbigpIHtcbiAgICBjb25zdCB7IHByb3RvY29sLCBob3N0bmFtZSwgcG9ydCB9ID0gd2luZG93LmxvY2F0aW9uO1xuICAgIHJldHVybiBwcm90b2NvbCArIFwiLy9cIiArIGhvc3RuYW1lICsgKHBvcnQgPyBcIjpcIiArIHBvcnQgOiBcIlwiKTtcbn1cbmZ1bmN0aW9uIGdldFVSTCgpIHtcbiAgICBjb25zdCB7IGhyZWYgfSA9IHdpbmRvdy5sb2NhdGlvbjtcbiAgICBjb25zdCBvcmlnaW4gPSBnZXRMb2NhdGlvbk9yaWdpbigpO1xuICAgIHJldHVybiBocmVmLnN1YnN0cmluZyhvcmlnaW4ubGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIGdldERpc3BsYXlOYW1lKENvbXBvbmVudCkge1xuICAgIHJldHVybiB0eXBlb2YgQ29tcG9uZW50ID09PSBcInN0cmluZ1wiID8gQ29tcG9uZW50IDogQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8IFwiVW5rbm93blwiO1xufVxuZnVuY3Rpb24gaXNSZXNTZW50KHJlcykge1xuICAgIHJldHVybiByZXMuZmluaXNoZWQgfHwgcmVzLmhlYWRlcnNTZW50O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUmVwZWF0ZWRTbGFzaGVzKHVybCkge1xuICAgIGNvbnN0IHVybFBhcnRzID0gdXJsLnNwbGl0KFwiP1wiKTtcbiAgICBjb25zdCB1cmxOb1F1ZXJ5ID0gdXJsUGFydHNbMF07XG4gICAgcmV0dXJuIHVybE5vUXVlcnkvLyBmaXJzdCB3ZSByZXBsYWNlIGFueSBub24tZW5jb2RlZCBiYWNrc2xhc2hlcyB3aXRoIGZvcndhcmRcbiAgICAvLyB0aGVuIG5vcm1hbGl6ZSByZXBlYXRlZCBmb3J3YXJkIHNsYXNoZXNcbiAgICAucmVwbGFjZSgvXFxcXC9nLCBcIi9cIikucmVwbGFjZSgvXFwvXFwvKy9nLCBcIi9cIikgKyAodXJsUGFydHNbMV0gPyBcIj9cIiArIHVybFBhcnRzLnNsaWNlKDEpLmpvaW4oXCI/XCIpIDogXCJcIik7XG59XG5hc3luYyBmdW5jdGlvbiBsb2FkR2V0SW5pdGlhbFByb3BzKEFwcCwgY3R4KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICB2YXIgX0FwcF9wcm90b3R5cGU7XG4gICAgICAgIGlmICgoX0FwcF9wcm90b3R5cGUgPSBBcHAucHJvdG90eXBlKSA9PSBudWxsID8gdm9pZCAwIDogX0FwcF9wcm90b3R5cGUuZ2V0SW5pdGlhbFByb3BzKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gJ1wiJyArIGdldERpc3BsYXlOYW1lKEFwcCkgKyAnLmdldEluaXRpYWxQcm9wcygpXCIgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgLSB2aXNpdCBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9nZXQtaW5pdGlhbC1wcm9wcy1hcy1hbi1pbnN0YW5jZS1tZXRob2QgZm9yIG1vcmUgaW5mb3JtYXRpb24uJztcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyB3aGVuIGNhbGxlZCBmcm9tIF9hcHAgYGN0eGAgaXMgbmVzdGVkIGluIGBjdHhgXG4gICAgY29uc3QgcmVzID0gY3R4LnJlcyB8fCBjdHguY3R4ICYmIGN0eC5jdHgucmVzO1xuICAgIGlmICghQXBwLmdldEluaXRpYWxQcm9wcykge1xuICAgICAgICBpZiAoY3R4LmN0eCAmJiBjdHguQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIHBhZ2VQcm9wcyBkZWZhdWx0XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBhZ2VQcm9wczogYXdhaXQgbG9hZEdldEluaXRpYWxQcm9wcyhjdHguQ29tcG9uZW50LCBjdHguY3R4KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IHByb3BzID0gYXdhaXQgQXBwLmdldEluaXRpYWxQcm9wcyhjdHgpO1xuICAgIGlmIChyZXMgJiYgaXNSZXNTZW50KHJlcykpIHtcbiAgICAgICAgcmV0dXJuIHByb3BzO1xuICAgIH1cbiAgICBpZiAoIXByb3BzKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnXCInICsgZ2V0RGlzcGxheU5hbWUoQXBwKSArICcuZ2V0SW5pdGlhbFByb3BzKClcIiBzaG91bGQgcmVzb2x2ZSB0byBhbiBvYmplY3QuIEJ1dCBmb3VuZCBcIicgKyBwcm9wcyArICdcIiBpbnN0ZWFkLic7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMocHJvcHMpLmxlbmd0aCA9PT0gMCAmJiAhY3R4LmN0eCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiXCIgKyBnZXREaXNwbGF5TmFtZShBcHApICsgXCIgcmV0dXJuZWQgYW4gZW1wdHkgb2JqZWN0IGZyb20gYGdldEluaXRpYWxQcm9wc2AuIFRoaXMgZGUtb3B0aW1pemVzIGFuZCBwcmV2ZW50cyBhdXRvbWF0aWMgc3RhdGljIG9wdGltaXphdGlvbi4gaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvZW1wdHktb2JqZWN0LWdldEluaXRpYWxQcm9wc1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcHM7XG59XG5jb25zdCBTUCA9IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gXCJ1bmRlZmluZWRcIjtcbmNvbnN0IFNUID0gU1AgJiYgW1xuICAgIFwibWFya1wiLFxuICAgIFwibWVhc3VyZVwiLFxuICAgIFwiZ2V0RW50cmllc0J5TmFtZVwiXG5dLmV2ZXJ5KChtZXRob2QpPT50eXBlb2YgcGVyZm9ybWFuY2VbbWV0aG9kXSA9PT0gXCJmdW5jdGlvblwiKTtcbmNsYXNzIERlY29kZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xufVxuY2xhc3MgTm9ybWFsaXplRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG59XG5jbGFzcyBQYWdlTm90Rm91bmRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihwYWdlKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb2RlID0gXCJFTk9FTlRcIjtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJQYWdlTm90Rm91bmRFcnJvclwiO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBcIkNhbm5vdCBmaW5kIG1vZHVsZSBmb3IgcGFnZTogXCIgKyBwYWdlO1xuICAgIH1cbn1cbmNsYXNzIE1pc3NpbmdTdGF0aWNQYWdlIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHBhZ2UsIG1lc3NhZ2Upe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBcIkZhaWxlZCB0byBsb2FkIHN0YXRpYyBmaWxlIGZvciBwYWdlOiBcIiArIHBhZ2UgKyBcIiBcIiArIG1lc3NhZ2U7XG4gICAgfVxufVxuY2xhc3MgTWlkZGxld2FyZU5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb2RlID0gXCJFTk9FTlRcIjtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gXCJDYW5ub3QgZmluZCB0aGUgbWlkZGxld2FyZSBtb2R1bGVcIjtcbiAgICB9XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgIHN0YWNrOiBlcnJvci5zdGFja1xuICAgIH0pO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJXRUJfVklUQUxTIiwiZXhlY09uY2UiLCJpc0Fic29sdXRlVXJsIiwiZ2V0TG9jYXRpb25PcmlnaW4iLCJnZXRVUkwiLCJnZXREaXNwbGF5TmFtZSIsImlzUmVzU2VudCIsIm5vcm1hbGl6ZVJlcGVhdGVkU2xhc2hlcyIsImxvYWRHZXRJbml0aWFsUHJvcHMiLCJTUCIsIlNUIiwiRGVjb2RlRXJyb3IiLCJOb3JtYWxpemVFcnJvciIsIlBhZ2VOb3RGb3VuZEVycm9yIiwiTWlzc2luZ1N0YXRpY1BhZ2UiLCJNaWRkbGV3YXJlTm90Rm91bmRFcnJvciIsInN0cmluZ2lmeUVycm9yIiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZm4iLCJ1c2VkIiwicmVzdWx0IiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJBQlNPTFVURV9VUkxfUkVHRVgiLCJ1cmwiLCJ0ZXN0IiwicHJvdG9jb2wiLCJob3N0bmFtZSIsInBvcnQiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsImhyZWYiLCJvcmlnaW4iLCJzdWJzdHJpbmciLCJDb21wb25lbnQiLCJkaXNwbGF5TmFtZSIsInJlcyIsImZpbmlzaGVkIiwiaGVhZGVyc1NlbnQiLCJ1cmxQYXJ0cyIsInNwbGl0IiwidXJsTm9RdWVyeSIsInJlcGxhY2UiLCJzbGljZSIsImpvaW4iLCJBcHAiLCJjdHgiLCJwcm9jZXNzIiwiX0FwcF9wcm90b3R5cGUiLCJwcm90b3R5cGUiLCJnZXRJbml0aWFsUHJvcHMiLCJtZXNzYWdlIiwiRXJyb3IiLCJwYWdlUHJvcHMiLCJwcm9wcyIsImtleXMiLCJjb25zb2xlIiwid2FybiIsInBlcmZvcm1hbmNlIiwiZXZlcnkiLCJtZXRob2QiLCJjb25zdHJ1Y3RvciIsInBhZ2UiLCJjb2RlIiwiZXJyb3IiLCJKU09OIiwic3RyaW5naWZ5Iiwic3RhY2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./utils/linkActiveChecker.js":
/*!************************************!*\
  !*** ./utils/linkActiveChecker.js ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isActiveLink: function() { return /* binding */ isActiveLink; },\n/* harmony export */   isActiveParent: function() { return /* binding */ isActiveParent; },\n/* harmony export */   isActiveParentChaild: function() { return /* binding */ isActiveParentChaild; }\n/* harmony export */ });\n// is active parent check\nconst isActiveParent = function() {\n    let data = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], path = arguments.length > 1 ? arguments[1] : void 0;\n    if ((data === null || data === void 0 ? void 0 : data.length) !== 0) {\n        return data === null || data === void 0 ? void 0 : data.some((param)=>{\n            let { items } = param;\n            return items === null || items === void 0 ? void 0 : items.some((menu)=>menu.routePath.replace(/\\/\\d+/, \"\") === path.replace(/\\/\\d+/, \"\"));\n        });\n    }\n};\n// is active parent childe check\nconst isActiveParentChaild = function() {\n    let data = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], path = arguments.length > 1 ? arguments[1] : void 0;\n    if ((data === null || data === void 0 ? void 0 : data.length) !== 0) {\n        return data === null || data === void 0 ? void 0 : data.some((menu)=>menu.routePath.replace(/\\/\\d+/, \"\") === path.replace(/\\/\\d+/, \"\"));\n    }\n};\n// is active link check\nconst isActiveLink = (menuPath, routePath)=>{\n    if (menuPath && routePath) {\n        return menuPath.replace(/\\/\\d+/, \"\") === routePath.replace(/\\/\\d+/, \"\");\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3V0aWxzL2xpbmtBY3RpdmVDaGVja2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLHlCQUF5QjtBQUNsQixNQUFNQSxpQkFBaUI7UUFBQ0Msd0VBQU8sRUFBRSxFQUFFQztJQUN4QyxJQUFJRCxDQUFBQSxpQkFBQUEsMkJBQUFBLEtBQU1FLE1BQU0sTUFBSyxHQUFHO1FBQ3RCLE9BQU9GLGlCQUFBQSwyQkFBQUEsS0FBTUcsSUFBSSxDQUFDO2dCQUFDLEVBQUVDLEtBQUssRUFBRTttQkFDMUJBLGtCQUFBQSw0QkFBQUEsTUFBT0QsSUFBSSxDQUNULENBQUNFLE9BQ0NBLEtBQUtDLFNBQVMsQ0FBQ0MsT0FBTyxDQUFDLFNBQVMsUUFBUU4sS0FBS00sT0FBTyxDQUFDLFNBQVM7O0lBR3RFO0FBQ0YsRUFBRTtBQUVGLGdDQUFnQztBQUN6QixNQUFNQyx1QkFBdUI7UUFBQ1Isd0VBQU8sRUFBRSxFQUFFQztJQUM5QyxJQUFJRCxDQUFBQSxpQkFBQUEsMkJBQUFBLEtBQU1FLE1BQU0sTUFBSyxHQUFHO1FBQ3RCLE9BQU9GLGlCQUFBQSwyQkFBQUEsS0FBTUcsSUFBSSxDQUNmLENBQUNFLE9BQ0NBLEtBQUtDLFNBQVMsQ0FBQ0MsT0FBTyxDQUFDLFNBQVMsUUFBUU4sS0FBS00sT0FBTyxDQUFDLFNBQVM7SUFFcEU7QUFDRixFQUFFO0FBRUYsdUJBQXVCO0FBQ2hCLE1BQU1FLGVBQWUsQ0FBQ0MsVUFBVUo7SUFDckMsSUFBSUksWUFBWUosV0FBVztRQUN6QixPQUFPSSxTQUFTSCxPQUFPLENBQUMsU0FBUyxRQUFRRCxVQUFVQyxPQUFPLENBQUMsU0FBUztJQUN0RTtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vdXRpbHMvbGlua0FjdGl2ZUNoZWNrZXIuanM/NjYxNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBpcyBhY3RpdmUgcGFyZW50IGNoZWNrXG5leHBvcnQgY29uc3QgaXNBY3RpdmVQYXJlbnQgPSAoZGF0YSA9IFtdLCBwYXRoKSA9PiB7XG4gIGlmIChkYXRhPy5sZW5ndGggIT09IDApIHtcbiAgICByZXR1cm4gZGF0YT8uc29tZSgoeyBpdGVtcyB9KSA9PlxuICAgICAgaXRlbXM/LnNvbWUoXG4gICAgICAgIChtZW51KSA9PlxuICAgICAgICAgIG1lbnUucm91dGVQYXRoLnJlcGxhY2UoL1xcL1xcZCsvLCBcIlwiKSA9PT0gcGF0aC5yZXBsYWNlKC9cXC9cXGQrLywgXCJcIilcbiAgICAgIClcbiAgICApO1xuICB9XG59O1xuXG4vLyBpcyBhY3RpdmUgcGFyZW50IGNoaWxkZSBjaGVja1xuZXhwb3J0IGNvbnN0IGlzQWN0aXZlUGFyZW50Q2hhaWxkID0gKGRhdGEgPSBbXSwgcGF0aCkgPT4ge1xuICBpZiAoZGF0YT8ubGVuZ3RoICE9PSAwKSB7XG4gICAgcmV0dXJuIGRhdGE/LnNvbWUoXG4gICAgICAobWVudSkgPT5cbiAgICAgICAgbWVudS5yb3V0ZVBhdGgucmVwbGFjZSgvXFwvXFxkKy8sIFwiXCIpID09PSBwYXRoLnJlcGxhY2UoL1xcL1xcZCsvLCBcIlwiKVxuICAgICk7XG4gIH1cbn07XG5cbi8vIGlzIGFjdGl2ZSBsaW5rIGNoZWNrXG5leHBvcnQgY29uc3QgaXNBY3RpdmVMaW5rID0gKG1lbnVQYXRoLCByb3V0ZVBhdGgpID0+IHtcbiAgaWYgKG1lbnVQYXRoICYmIHJvdXRlUGF0aCkge1xuICAgIHJldHVybiBtZW51UGF0aC5yZXBsYWNlKC9cXC9cXGQrLywgXCJcIikgPT09IHJvdXRlUGF0aC5yZXBsYWNlKC9cXC9cXGQrLywgXCJcIik7XG4gIH1cbn07XG4iXSwibmFtZXMiOlsiaXNBY3RpdmVQYXJlbnQiLCJkYXRhIiwicGF0aCIsImxlbmd0aCIsInNvbWUiLCJpdGVtcyIsIm1lbnUiLCJyb3V0ZVBhdGgiLCJyZXBsYWNlIiwiaXNBY3RpdmVQYXJlbnRDaGFpbGQiLCJpc0FjdGl2ZUxpbmsiLCJtZW51UGF0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./utils/linkActiveChecker.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/defineProperty.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/defineProperty.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _defineProperty; }\n/* harmony export */ });\n/* harmony import */ var _toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toPropertyKey.js */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js\");\n\nfunction _defineProperty(obj, key, value) {\n    key = (0,_toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUErQztBQUNoQyxTQUFTQyxnQkFBZ0JDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxLQUFLO0lBQ3JERCxNQUFNSCw2REFBYUEsQ0FBQ0c7SUFDcEIsSUFBSUEsT0FBT0QsS0FBSztRQUNkRyxPQUFPQyxjQUFjLENBQUNKLEtBQUtDLEtBQUs7WUFDOUJDLE9BQU9BO1lBQ1BHLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1FBQ1o7SUFDRixPQUFPO1FBQ0xQLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHQztJQUNiO0lBQ0EsT0FBT0Y7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHkuanM/NDJiNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdG9Qcm9wZXJ0eUtleSBmcm9tIFwiLi90b1Byb3BlcnR5S2V5LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGtleSA9IHRvUHJvcGVydHlLZXkoa2V5KTtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn0iXSwibmFtZXMiOlsidG9Qcm9wZXJ0eUtleSIsIl9kZWZpbmVQcm9wZXJ0eSIsIm9iaiIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/defineProperty.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/objectSpread2.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/objectSpread2.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _objectSpread2; }\n/* harmony export */ });\n/* harmony import */ var _defineProperty_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defineProperty.js */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/defineProperty.js\");\n\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread2(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            (0,_defineProperty_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RTcHJlYWQyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWlEO0FBQ2pELFNBQVNDLFFBQVFDLENBQUMsRUFBRUMsQ0FBQztJQUNuQixJQUFJQyxJQUFJQyxPQUFPQyxJQUFJLENBQUNKO0lBQ3BCLElBQUlHLE9BQU9FLHFCQUFxQixFQUFFO1FBQ2hDLElBQUlDLElBQUlILE9BQU9FLHFCQUFxQixDQUFDTDtRQUNyQ0MsS0FBTUssQ0FBQUEsSUFBSUEsRUFBRUMsTUFBTSxDQUFDLFNBQVVOLENBQUM7WUFDNUIsT0FBT0UsT0FBT0ssd0JBQXdCLENBQUNSLEdBQUdDLEdBQUdRLFVBQVU7UUFDekQsRUFBQyxHQUFJUCxFQUFFUSxJQUFJLENBQUNDLEtBQUssQ0FBQ1QsR0FBR0k7SUFDdkI7SUFDQSxPQUFPSjtBQUNUO0FBQ2UsU0FBU1UsZUFBZVosQ0FBQztJQUN0QyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSVksVUFBVUMsTUFBTSxFQUFFYixJQUFLO1FBQ3pDLElBQUlDLElBQUksUUFBUVcsU0FBUyxDQUFDWixFQUFFLEdBQUdZLFNBQVMsQ0FBQ1osRUFBRSxHQUFHLENBQUM7UUFDL0NBLElBQUksSUFBSUYsUUFBUUksT0FBT0QsSUFBSSxDQUFDLEdBQUdhLE9BQU8sQ0FBQyxTQUFVZCxDQUFDO1lBQ2hESCw4REFBY0EsQ0FBQ0UsR0FBR0MsR0FBR0MsQ0FBQyxDQUFDRCxFQUFFO1FBQzNCLEtBQUtFLE9BQU9hLHlCQUF5QixHQUFHYixPQUFPYyxnQkFBZ0IsQ0FBQ2pCLEdBQUdHLE9BQU9hLHlCQUF5QixDQUFDZCxNQUFNSCxRQUFRSSxPQUFPRCxJQUFJYSxPQUFPLENBQUMsU0FBVWQsQ0FBQztZQUM5SUUsT0FBT0wsY0FBYyxDQUFDRSxHQUFHQyxHQUFHRSxPQUFPSyx3QkFBd0IsQ0FBQ04sR0FBR0Q7UUFDakU7SUFDRjtJQUNBLE9BQU9EO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFNwcmVhZDIuanM/M2IxNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZGVmaW5lUHJvcGVydHkgZnJvbSBcIi4vZGVmaW5lUHJvcGVydHkuanNcIjtcbmZ1bmN0aW9uIG93bktleXMoZSwgcikge1xuICB2YXIgdCA9IE9iamVjdC5rZXlzKGUpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtcbiAgICByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7XG4gICAgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkMihlKSB7XG4gIGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7XG4gICAgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9O1xuICAgIHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgICBkZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTtcbiAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZTtcbn0iXSwibmFtZXMiOlsiZGVmaW5lUHJvcGVydHkiLCJvd25LZXlzIiwiZSIsInIiLCJ0IiwiT2JqZWN0Iiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsIm8iLCJmaWx0ZXIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwicHVzaCIsImFwcGx5IiwiX29iamVjdFNwcmVhZDIiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJmb3JFYWNoIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/objectSpread2.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/toPrimitive.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/toPrimitive.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ toPrimitive; }\n/* harmony export */ });\n/* harmony import */ var _typeof_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typeof.js */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/typeof.js\");\n\nfunction toPrimitive(t, r) {\n    if (\"object\" != (0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != (0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b1ByaW1pdGl2ZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFrQztBQUNuQixTQUFTQyxZQUFZQyxDQUFDLEVBQUVDLENBQUM7SUFDdEMsSUFBSSxZQUFZSCxzREFBT0EsQ0FBQ0UsTUFBTSxDQUFDQSxHQUFHLE9BQU9BO0lBQ3pDLElBQUlFLElBQUlGLENBQUMsQ0FBQ0csT0FBT0osV0FBVyxDQUFDO0lBQzdCLElBQUksS0FBSyxNQUFNRyxHQUFHO1FBQ2hCLElBQUlFLElBQUlGLEVBQUVHLElBQUksQ0FBQ0wsR0FBR0MsS0FBSztRQUN2QixJQUFJLFlBQVlILHNEQUFPQSxDQUFDTSxJQUFJLE9BQU9BO1FBQ25DLE1BQU0sSUFBSUUsVUFBVTtJQUN0QjtJQUNBLE9BQU8sQ0FBQyxhQUFhTCxJQUFJTSxTQUFTQyxNQUFLLEVBQUdSO0FBQzVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b1ByaW1pdGl2ZS5qcz8zZTYxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfdHlwZW9mIGZyb20gXCIuL3R5cGVvZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdG9QcmltaXRpdmUodCwgcikge1xuICBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDtcbiAgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmICh2b2lkIDAgIT09IGUpIHtcbiAgICB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTtcbn0iXSwibmFtZXMiOlsiX3R5cGVvZiIsInRvUHJpbWl0aXZlIiwidCIsInIiLCJlIiwiU3ltYm9sIiwiaSIsImNhbGwiLCJUeXBlRXJyb3IiLCJTdHJpbmciLCJOdW1iZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/toPrimitive.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ toPropertyKey; }\n/* harmony export */ });\n/* harmony import */ var _typeof_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typeof.js */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/typeof.js\");\n/* harmony import */ var _toPrimitive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./toPrimitive.js */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/toPrimitive.js\");\n\n\nfunction toPropertyKey(t) {\n    var i = (0,_toPrimitive_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(t, \"string\");\n    return \"symbol\" == (0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(i) ? i : String(i);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b1Byb3BlcnR5S2V5LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFrQztBQUNTO0FBQzVCLFNBQVNFLGNBQWNDLENBQUM7SUFDckMsSUFBSUMsSUFBSUgsMkRBQVdBLENBQUNFLEdBQUc7SUFDdkIsT0FBTyxZQUFZSCxzREFBT0EsQ0FBQ0ksS0FBS0EsSUFBSUMsT0FBT0Q7QUFDN0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvUHJvcGVydHlLZXkuanM/MWNiZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX3R5cGVvZiBmcm9tIFwiLi90eXBlb2YuanNcIjtcbmltcG9ydCB0b1ByaW1pdGl2ZSBmcm9tIFwiLi90b1ByaW1pdGl2ZS5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdG9Qcm9wZXJ0eUtleSh0KSB7XG4gIHZhciBpID0gdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7XG4gIHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogU3RyaW5nKGkpO1xufSJdLCJuYW1lcyI6WyJfdHlwZW9mIiwidG9QcmltaXRpdmUiLCJ0b1Byb3BlcnR5S2V5IiwidCIsImkiLCJTdHJpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/typeof.js":
/*!***********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/typeof.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _typeof; }\n/* harmony export */ });\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90eXBlb2YuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFlLFNBQVNBLFFBQVFDLENBQUM7SUFDL0I7SUFFQSxPQUFPRCxVQUFVLGNBQWMsT0FBT0UsVUFBVSxZQUFZLE9BQU9BLE9BQU9DLFFBQVEsR0FBRyxTQUFVRixDQUFDO1FBQzlGLE9BQU8sT0FBT0E7SUFDaEIsSUFBSSxTQUFVQSxDQUFDO1FBQ2IsT0FBT0EsS0FBSyxjQUFjLE9BQU9DLFVBQVVELEVBQUVHLFdBQVcsS0FBS0YsVUFBVUQsTUFBTUMsT0FBT0csU0FBUyxHQUFHLFdBQVcsT0FBT0o7SUFDcEgsR0FBR0QsUUFBUUM7QUFDYiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdHlwZW9mLmpzP2IwZmEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3R5cGVvZihvKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvO1xuICB9IDogZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbztcbiAgfSwgX3R5cGVvZihvKTtcbn0iXSwibmFtZXMiOlsiX3R5cGVvZiIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/typeof.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/immer/dist/immer.esm.mjs":
/*!***********************************************!*\
  !*** ./node_modules/immer/dist/immer.esm.mjs ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Immer: function() { return /* binding */ un; },\n/* harmony export */   applyPatches: function() { return /* binding */ pn; },\n/* harmony export */   castDraft: function() { return /* binding */ K; },\n/* harmony export */   castImmutable: function() { return /* binding */ $; },\n/* harmony export */   createDraft: function() { return /* binding */ ln; },\n/* harmony export */   current: function() { return /* binding */ R; },\n/* harmony export */   enableAllPlugins: function() { return /* binding */ J; },\n/* harmony export */   enableES5: function() { return /* binding */ F; },\n/* harmony export */   enableMapSet: function() { return /* binding */ C; },\n/* harmony export */   enablePatches: function() { return /* binding */ T; },\n/* harmony export */   finishDraft: function() { return /* binding */ dn; },\n/* harmony export */   freeze: function() { return /* binding */ d; },\n/* harmony export */   immerable: function() { return /* binding */ L; },\n/* harmony export */   isDraft: function() { return /* binding */ r; },\n/* harmony export */   isDraftable: function() { return /* binding */ t; },\n/* harmony export */   nothing: function() { return /* binding */ H; },\n/* harmony export */   original: function() { return /* binding */ e; },\n/* harmony export */   produce: function() { return /* binding */ fn; },\n/* harmony export */   produceWithPatches: function() { return /* binding */ cn; },\n/* harmony export */   setAutoFreeze: function() { return /* binding */ sn; },\n/* harmony export */   setUseProxies: function() { return /* binding */ vn; }\n/* harmony export */ });\nfunction n(n) {\n    for(var r = arguments.length, t = Array(r > 1 ? r - 1 : 0), e = 1; e < r; e++)t[e - 1] = arguments[e];\n    if (true) {\n        var i = Y[n], o = i ? \"function\" == typeof i ? i.apply(null, t) : i : \"unknown error nr: \" + n;\n        throw Error(\"[Immer] \" + o);\n    }\n    throw Error(\"[Immer] minified error nr: \" + n + (t.length ? \" \" + t.map(function(n) {\n        return \"'\" + n + \"'\";\n    }).join(\",\") : \"\") + \". Find the full error at: https://bit.ly/3cXEKWf\");\n}\nfunction r(n) {\n    return !!n && !!n[Q];\n}\nfunction t(n) {\n    var r;\n    return !!n && (function(n) {\n        if (!n || \"object\" != typeof n) return !1;\n        var r = Object.getPrototypeOf(n);\n        if (null === r) return !0;\n        var t = Object.hasOwnProperty.call(r, \"constructor\") && r.constructor;\n        return t === Object || \"function\" == typeof t && Function.toString.call(t) === Z;\n    }(n) || Array.isArray(n) || !!n[L] || !!(null === (r = n.constructor) || void 0 === r ? void 0 : r[L]) || s(n) || v(n));\n}\nfunction e(t) {\n    return r(t) || n(23, t), t[Q].t;\n}\nfunction i(n, r, t) {\n    void 0 === t && (t = !1), 0 === o(n) ? (t ? Object.keys : nn)(n).forEach(function(e) {\n        t && \"symbol\" == typeof e || r(e, n[e], n);\n    }) : n.forEach(function(t, e) {\n        return r(e, t, n);\n    });\n}\nfunction o(n) {\n    var r = n[Q];\n    return r ? r.i > 3 ? r.i - 4 : r.i : Array.isArray(n) ? 1 : s(n) ? 2 : v(n) ? 3 : 0;\n}\nfunction u(n, r) {\n    return 2 === o(n) ? n.has(r) : Object.prototype.hasOwnProperty.call(n, r);\n}\nfunction a(n, r) {\n    return 2 === o(n) ? n.get(r) : n[r];\n}\nfunction f(n, r, t) {\n    var e = o(n);\n    2 === e ? n.set(r, t) : 3 === e ? n.add(t) : n[r] = t;\n}\nfunction c(n, r) {\n    return n === r ? 0 !== n || 1 / n == 1 / r : n != n && r != r;\n}\nfunction s(n) {\n    return X && n instanceof Map;\n}\nfunction v(n) {\n    return q && n instanceof Set;\n}\nfunction p(n) {\n    return n.o || n.t;\n}\nfunction l(n) {\n    if (Array.isArray(n)) return Array.prototype.slice.call(n);\n    var r = rn(n);\n    delete r[Q];\n    for(var t = nn(r), e = 0; e < t.length; e++){\n        var i = t[e], o = r[i];\n        !1 === o.writable && (o.writable = !0, o.configurable = !0), (o.get || o.set) && (r[i] = {\n            configurable: !0,\n            writable: !0,\n            enumerable: o.enumerable,\n            value: n[i]\n        });\n    }\n    return Object.create(Object.getPrototypeOf(n), r);\n}\nfunction d(n, e) {\n    return void 0 === e && (e = !1), y(n) || r(n) || !t(n) || (o(n) > 1 && (n.set = n.add = n.clear = n.delete = h), Object.freeze(n), e && i(n, function(n, r) {\n        return d(r, !0);\n    }, !0)), n;\n}\nfunction h() {\n    n(2);\n}\nfunction y(n) {\n    return null == n || \"object\" != typeof n || Object.isFrozen(n);\n}\nfunction b(r) {\n    var t = tn[r];\n    return t || n(18, r), t;\n}\nfunction m(n, r) {\n    tn[n] || (tn[n] = r);\n}\nfunction _() {\n    return  false || U || n(0), U;\n}\nfunction j(n, r) {\n    r && (b(\"Patches\"), n.u = [], n.s = [], n.v = r);\n}\nfunction g(n) {\n    O(n), n.p.forEach(S), n.p = null;\n}\nfunction O(n) {\n    n === U && (U = n.l);\n}\n_c = O;\nfunction w(n) {\n    return U = {\n        p: [],\n        l: U,\n        h: n,\n        m: !0,\n        _: 0\n    };\n}\nfunction S(n) {\n    var r = n[Q];\n    0 === r.i || 1 === r.i ? r.j() : r.g = !0;\n}\n_c1 = S;\nfunction P(r, e) {\n    e._ = e.p.length;\n    var i = e.p[0], o = void 0 !== r && r !== i;\n    return e.h.O || b(\"ES5\").S(e, r, o), o ? (i[Q].P && (g(e), n(4)), t(r) && (r = M(e, r), e.l || x(e, r)), e.u && b(\"Patches\").M(i[Q].t, r, e.u, e.s)) : r = M(e, i, []), g(e), e.u && e.v(e.u, e.s), r !== H ? r : void 0;\n}\n_c2 = P;\nfunction M(n, r, t) {\n    if (y(r)) return r;\n    var e = r[Q];\n    if (!e) return i(r, function(i, o) {\n        return A(n, e, r, i, o, t);\n    }, !0), r;\n    if (e.A !== n) return r;\n    if (!e.P) return x(n, e.t, !0), e.t;\n    if (!e.I) {\n        e.I = !0, e.A._--;\n        var o = 4 === e.i || 5 === e.i ? e.o = l(e.k) : e.o, u = o, a = !1;\n        3 === e.i && (u = new Set(o), o.clear(), a = !0), i(u, function(r, i) {\n            return A(n, e, o, r, i, t, a);\n        }), x(n, o, !1), t && n.u && b(\"Patches\").N(e, t, n.u, n.s);\n    }\n    return e.o;\n}\n_c3 = M;\nfunction A(e, i, o, a, c, s, v) {\n    if ( true && c === o && n(5), r(c)) {\n        var p = M(e, c, s && i && 3 !== i.i && !u(i.R, a) ? s.concat(a) : void 0);\n        if (f(o, a, p), !r(p)) return;\n        e.m = !1;\n    } else v && o.add(c);\n    if (t(c) && !y(c)) {\n        if (!e.h.D && e._ < 1) return;\n        M(e, c), i && i.A.l || x(e, c);\n    }\n}\n_c4 = A;\nfunction x(n, r, t) {\n    void 0 === t && (t = !1), !n.l && n.h.D && n.m && d(r, t);\n}\nfunction z(n, r) {\n    var t = n[Q];\n    return (t ? p(t) : n)[r];\n}\nfunction I(n, r) {\n    if (r in n) for(var t = Object.getPrototypeOf(n); t;){\n        var e = Object.getOwnPropertyDescriptor(t, r);\n        if (e) return e;\n        t = Object.getPrototypeOf(t);\n    }\n}\n_c5 = I;\nfunction k(n) {\n    n.P || (n.P = !0, n.l && k(n.l));\n}\nfunction E(n) {\n    n.o || (n.o = l(n.t));\n}\n_c6 = E;\nfunction N(n, r, t) {\n    var e = s(r) ? b(\"MapSet\").F(r, t) : v(r) ? b(\"MapSet\").T(r, t) : n.O ? function(n, r) {\n        var t = Array.isArray(n), e = {\n            i: t ? 1 : 0,\n            A: r ? r.A : _(),\n            P: !1,\n            I: !1,\n            R: {},\n            l: r,\n            t: n,\n            k: null,\n            o: null,\n            j: null,\n            C: !1\n        }, i = e, o = en;\n        t && (i = [\n            e\n        ], o = on);\n        var u = Proxy.revocable(i, o), a = u.revoke, f = u.proxy;\n        return e.k = f, e.j = a, f;\n    }(r, t) : b(\"ES5\").J(r, t);\n    return (t ? t.A : _()).p.push(e), e;\n}\n_c7 = N;\nfunction R(e) {\n    return r(e) || n(22, e), function n(r) {\n        if (!t(r)) return r;\n        var e, u = r[Q], c = o(r);\n        if (u) {\n            if (!u.P && (u.i < 4 || !b(\"ES5\").K(u))) return u.t;\n            u.I = !0, e = D(r, c), u.I = !1;\n        } else e = D(r, c);\n        return i(e, function(r, t) {\n            u && a(u.t, r) === t || f(e, r, n(t));\n        }), 3 === c ? new Set(e) : e;\n    }(e);\n}\n_c8 = R;\nfunction D(n, r) {\n    switch(r){\n        case 2:\n            return new Map(n);\n        case 3:\n            return Array.from(n);\n    }\n    return l(n);\n}\n_c9 = D;\nfunction F() {\n    function t(n, r) {\n        var t = s[n];\n        return t ? t.enumerable = r : s[n] = t = {\n            configurable: !0,\n            enumerable: r,\n            get: function() {\n                var r = this[Q];\n                return  true && f(r), en.get(r, n);\n            },\n            set: function(r) {\n                var t = this[Q];\n                 true && f(t), en.set(t, n, r);\n            }\n        }, t;\n    }\n    function e(n) {\n        for(var r = n.length - 1; r >= 0; r--){\n            var t = n[r][Q];\n            if (!t.P) switch(t.i){\n                case 5:\n                    a(t) && k(t);\n                    break;\n                case 4:\n                    o(t) && k(t);\n            }\n        }\n    }\n    function o(n) {\n        for(var r = n.t, t = n.k, e = nn(t), i = e.length - 1; i >= 0; i--){\n            var o = e[i];\n            if (o !== Q) {\n                var a = r[o];\n                if (void 0 === a && !u(r, o)) return !0;\n                var f = t[o], s = f && f[Q];\n                if (s ? s.t !== a : !c(f, a)) return !0;\n            }\n        }\n        var v = !!r[Q];\n        return e.length !== nn(r).length + (v ? 0 : 1);\n    }\n    function a(n) {\n        var r = n.k;\n        if (r.length !== n.t.length) return !0;\n        var t = Object.getOwnPropertyDescriptor(r, r.length - 1);\n        if (t && !t.get) return !0;\n        for(var e = 0; e < r.length; e++)if (!r.hasOwnProperty(e)) return !0;\n        return !1;\n    }\n    function f(r) {\n        r.g && n(3, JSON.stringify(p(r)));\n    }\n    var s = {};\n    m(\"ES5\", {\n        J: function(n, r) {\n            var e = Array.isArray(n), i = function(n, r) {\n                if (n) {\n                    for(var e = Array(r.length), i = 0; i < r.length; i++)Object.defineProperty(e, \"\" + i, t(i, !0));\n                    return e;\n                }\n                var o = rn(r);\n                delete o[Q];\n                for(var u = nn(o), a = 0; a < u.length; a++){\n                    var f = u[a];\n                    o[f] = t(f, n || !!o[f].enumerable);\n                }\n                return Object.create(Object.getPrototypeOf(r), o);\n            }(e, n), o = {\n                i: e ? 5 : 4,\n                A: r ? r.A : _(),\n                P: !1,\n                I: !1,\n                R: {},\n                l: r,\n                t: n,\n                k: i,\n                o: null,\n                g: !1,\n                C: !1\n            };\n            return Object.defineProperty(i, Q, {\n                value: o,\n                writable: !0\n            }), i;\n        },\n        S: function(n, t, o) {\n            o ? r(t) && t[Q].A === n && e(n.p) : (n.u && function n(r) {\n                if (r && \"object\" == typeof r) {\n                    var t = r[Q];\n                    if (t) {\n                        var e = t.t, o = t.k, f = t.R, c = t.i;\n                        if (4 === c) i(o, function(r) {\n                            r !== Q && (void 0 !== e[r] || u(e, r) ? f[r] || n(o[r]) : (f[r] = !0, k(t)));\n                        }), i(e, function(n) {\n                            void 0 !== o[n] || u(o, n) || (f[n] = !1, k(t));\n                        });\n                        else if (5 === c) {\n                            if (a(t) && (k(t), f.length = !0), o.length < e.length) for(var s = o.length; s < e.length; s++)f[s] = !1;\n                            else for(var v = e.length; v < o.length; v++)f[v] = !0;\n                            for(var p = Math.min(o.length, e.length), l = 0; l < p; l++)o.hasOwnProperty(l) || (f[l] = !0), void 0 === f[l] && n(o[l]);\n                        }\n                    }\n                }\n            }(n.p[0]), e(n.p));\n        },\n        K: function(n) {\n            return 4 === n.i ? o(n) : a(n);\n        }\n    });\n}\n_c10 = F;\nfunction T() {\n    function e(n) {\n        if (!t(n)) return n;\n        if (Array.isArray(n)) return n.map(e);\n        if (s(n)) return new Map(Array.from(n.entries()).map(function(n) {\n            return [\n                n[0],\n                e(n[1])\n            ];\n        }));\n        if (v(n)) return new Set(Array.from(n).map(e));\n        var r = Object.create(Object.getPrototypeOf(n));\n        for(var i in n)r[i] = e(n[i]);\n        return u(n, L) && (r[L] = n[L]), r;\n    }\n    function f(n) {\n        return r(n) ? e(n) : n;\n    }\n    var c = \"add\";\n    m(\"Patches\", {\n        $: function(r, t) {\n            return t.forEach(function(t) {\n                for(var i = t.path, u = t.op, f = r, s = 0; s < i.length - 1; s++){\n                    var v = o(f), p = i[s];\n                    \"string\" != typeof p && \"number\" != typeof p && (p = \"\" + p), 0 !== v && 1 !== v || \"__proto__\" !== p && \"constructor\" !== p || n(24), \"function\" == typeof f && \"prototype\" === p && n(24), \"object\" != typeof (f = a(f, p)) && n(15, i.join(\"/\"));\n                }\n                var l = o(f), d = e(t.value), h = i[i.length - 1];\n                switch(u){\n                    case \"replace\":\n                        switch(l){\n                            case 2:\n                                return f.set(h, d);\n                            case 3:\n                                n(16);\n                            default:\n                                return f[h] = d;\n                        }\n                    case c:\n                        switch(l){\n                            case 1:\n                                return \"-\" === h ? f.push(d) : f.splice(h, 0, d);\n                            case 2:\n                                return f.set(h, d);\n                            case 3:\n                                return f.add(d);\n                            default:\n                                return f[h] = d;\n                        }\n                    case \"remove\":\n                        switch(l){\n                            case 1:\n                                return f.splice(h, 1);\n                            case 2:\n                                return f.delete(h);\n                            case 3:\n                                return f.delete(t.value);\n                            default:\n                                return delete f[h];\n                        }\n                    default:\n                        n(17, u);\n                }\n            }), r;\n        },\n        N: function(n, r, t, e) {\n            switch(n.i){\n                case 0:\n                case 4:\n                case 2:\n                    return function(n, r, t, e) {\n                        var o = n.t, s = n.o;\n                        i(n.R, function(n, i) {\n                            var v = a(o, n), p = a(s, n), l = i ? u(o, n) ? \"replace\" : c : \"remove\";\n                            if (v !== p || \"replace\" !== l) {\n                                var d = r.concat(n);\n                                t.push(\"remove\" === l ? {\n                                    op: l,\n                                    path: d\n                                } : {\n                                    op: l,\n                                    path: d,\n                                    value: p\n                                }), e.push(l === c ? {\n                                    op: \"remove\",\n                                    path: d\n                                } : \"remove\" === l ? {\n                                    op: c,\n                                    path: d,\n                                    value: f(v)\n                                } : {\n                                    op: \"replace\",\n                                    path: d,\n                                    value: f(v)\n                                });\n                            }\n                        });\n                    }(n, r, t, e);\n                case 5:\n                case 1:\n                    return function(n, r, t, e) {\n                        var i = n.t, o = n.R, u = n.o;\n                        if (u.length < i.length) {\n                            var a = [\n                                u,\n                                i\n                            ];\n                            i = a[0], u = a[1];\n                            var s = [\n                                e,\n                                t\n                            ];\n                            t = s[0], e = s[1];\n                        }\n                        for(var v = 0; v < i.length; v++)if (o[v] && u[v] !== i[v]) {\n                            var p = r.concat([\n                                v\n                            ]);\n                            t.push({\n                                op: \"replace\",\n                                path: p,\n                                value: f(u[v])\n                            }), e.push({\n                                op: \"replace\",\n                                path: p,\n                                value: f(i[v])\n                            });\n                        }\n                        for(var l = i.length; l < u.length; l++){\n                            var d = r.concat([\n                                l\n                            ]);\n                            t.push({\n                                op: c,\n                                path: d,\n                                value: f(u[l])\n                            });\n                        }\n                        i.length < u.length && e.push({\n                            op: \"replace\",\n                            path: r.concat([\n                                \"length\"\n                            ]),\n                            value: i.length\n                        });\n                    }(n, r, t, e);\n                case 3:\n                    return function(n, r, t, e) {\n                        var i = n.t, o = n.o, u = 0;\n                        i.forEach(function(n) {\n                            if (!o.has(n)) {\n                                var i = r.concat([\n                                    u\n                                ]);\n                                t.push({\n                                    op: \"remove\",\n                                    path: i,\n                                    value: n\n                                }), e.unshift({\n                                    op: c,\n                                    path: i,\n                                    value: n\n                                });\n                            }\n                            u++;\n                        }), u = 0, o.forEach(function(n) {\n                            if (!i.has(n)) {\n                                var o = r.concat([\n                                    u\n                                ]);\n                                t.push({\n                                    op: c,\n                                    path: o,\n                                    value: n\n                                }), e.unshift({\n                                    op: \"remove\",\n                                    path: o,\n                                    value: n\n                                });\n                            }\n                            u++;\n                        });\n                    }(n, r, t, e);\n            }\n        },\n        M: function(n, r, t, e) {\n            t.push({\n                op: \"replace\",\n                path: [],\n                value: r === H ? void 0 : r\n            }), e.push({\n                op: \"replace\",\n                path: [],\n                value: n\n            });\n        }\n    });\n}\n_c11 = T;\nfunction C() {\n    function r(n, r) {\n        function t() {\n            this.constructor = n;\n        }\n        a(n, r), n.prototype = (t.prototype = r.prototype, new t);\n    }\n    function e(n) {\n        n.o || (n.R = new Map, n.o = new Map(n.t));\n    }\n    function o(n) {\n        n.o || (n.o = new Set, n.t.forEach(function(r) {\n            if (t(r)) {\n                var e = N(n.A.h, r, n);\n                n.p.set(r, e), n.o.add(e);\n            } else n.o.add(r);\n        }));\n    }\n    function u(r) {\n        r.g && n(3, JSON.stringify(p(r)));\n    }\n    var a = function(n, r) {\n        return (a = Object.setPrototypeOf || ({\n            __proto__: []\n        }) instanceof Array && function(n, r) {\n            n.__proto__ = r;\n        } || function(n, r) {\n            for(var t in r)r.hasOwnProperty(t) && (n[t] = r[t]);\n        })(n, r);\n    }, f = function() {\n        function n(n, r) {\n            return this[Q] = {\n                i: 2,\n                l: r,\n                A: r ? r.A : _(),\n                P: !1,\n                I: !1,\n                o: void 0,\n                R: void 0,\n                t: n,\n                k: this,\n                C: !1,\n                g: !1\n            }, this;\n        }\n        r(n, Map);\n        var o = n.prototype;\n        return Object.defineProperty(o, \"size\", {\n            get: function() {\n                return p(this[Q]).size;\n            }\n        }), o.has = function(n) {\n            return p(this[Q]).has(n);\n        }, o.set = function(n, r) {\n            var t = this[Q];\n            return u(t), p(t).has(n) && p(t).get(n) === r || (e(t), k(t), t.R.set(n, !0), t.o.set(n, r), t.R.set(n, !0)), this;\n        }, o.delete = function(n) {\n            if (!this.has(n)) return !1;\n            var r = this[Q];\n            return u(r), e(r), k(r), r.t.has(n) ? r.R.set(n, !1) : r.R.delete(n), r.o.delete(n), !0;\n        }, o.clear = function() {\n            var n = this[Q];\n            u(n), p(n).size && (e(n), k(n), n.R = new Map, i(n.t, function(r) {\n                n.R.set(r, !1);\n            }), n.o.clear());\n        }, o.forEach = function(n, r) {\n            var t = this;\n            p(this[Q]).forEach(function(e, i) {\n                n.call(r, t.get(i), i, t);\n            });\n        }, o.get = function(n) {\n            var r = this[Q];\n            u(r);\n            var i = p(r).get(n);\n            if (r.I || !t(i)) return i;\n            if (i !== r.t.get(n)) return i;\n            var o = N(r.A.h, i, r);\n            return e(r), r.o.set(n, o), o;\n        }, o.keys = function() {\n            return p(this[Q]).keys();\n        }, o.values = function() {\n            var n, r = this, t = this.keys();\n            return (n = {})[V] = function() {\n                return r.values();\n            }, n.next = function() {\n                var n = t.next();\n                return n.done ? n : {\n                    done: !1,\n                    value: r.get(n.value)\n                };\n            }, n;\n        }, o.entries = function() {\n            var n, r = this, t = this.keys();\n            return (n = {})[V] = function() {\n                return r.entries();\n            }, n.next = function() {\n                var n = t.next();\n                if (n.done) return n;\n                var e = r.get(n.value);\n                return {\n                    done: !1,\n                    value: [\n                        n.value,\n                        e\n                    ]\n                };\n            }, n;\n        }, o[V] = function() {\n            return this.entries();\n        }, n;\n    }(), c = function() {\n        function n(n, r) {\n            return this[Q] = {\n                i: 3,\n                l: r,\n                A: r ? r.A : _(),\n                P: !1,\n                I: !1,\n                o: void 0,\n                t: n,\n                k: this,\n                p: new Map,\n                g: !1,\n                C: !1\n            }, this;\n        }\n        r(n, Set);\n        var t = n.prototype;\n        return Object.defineProperty(t, \"size\", {\n            get: function() {\n                return p(this[Q]).size;\n            }\n        }), t.has = function(n) {\n            var r = this[Q];\n            return u(r), r.o ? !!r.o.has(n) || !(!r.p.has(n) || !r.o.has(r.p.get(n))) : r.t.has(n);\n        }, t.add = function(n) {\n            var r = this[Q];\n            return u(r), this.has(n) || (o(r), k(r), r.o.add(n)), this;\n        }, t.delete = function(n) {\n            if (!this.has(n)) return !1;\n            var r = this[Q];\n            return u(r), o(r), k(r), r.o.delete(n) || !!r.p.has(n) && r.o.delete(r.p.get(n));\n        }, t.clear = function() {\n            var n = this[Q];\n            u(n), p(n).size && (o(n), k(n), n.o.clear());\n        }, t.values = function() {\n            var n = this[Q];\n            return u(n), o(n), n.o.values();\n        }, t.entries = function() {\n            var n = this[Q];\n            return u(n), o(n), n.o.entries();\n        }, t.keys = function() {\n            return this.values();\n        }, t[V] = function() {\n            return this.values();\n        }, t.forEach = function(n, r) {\n            for(var t = this.values(), e = t.next(); !e.done;)n.call(r, e.value, e.value, this), e = t.next();\n        }, n;\n    }();\n    m(\"MapSet\", {\n        F: function(n, r) {\n            return new f(n, r);\n        },\n        T: function(n, r) {\n            return new c(n, r);\n        }\n    });\n}\n_c12 = C;\nfunction J() {\n    F(), C(), T();\n}\n_c13 = J;\nfunction K(n) {\n    return n;\n}\n_c14 = K;\nfunction $(n) {\n    return n;\n}\nvar G, U, W = \"undefined\" != typeof Symbol && \"symbol\" == typeof Symbol(\"x\"), X = \"undefined\" != typeof Map, q = \"undefined\" != typeof Set, B = \"undefined\" != typeof Proxy && void 0 !== Proxy.revocable && \"undefined\" != typeof Reflect, H = W ? Symbol.for(\"immer-nothing\") : ((G = {})[\"immer-nothing\"] = !0, G), L = W ? Symbol.for(\"immer-draftable\") : \"__$immer_draftable\", Q = W ? Symbol.for(\"immer-state\") : \"__$immer_state\", V = \"undefined\" != typeof Symbol && Symbol.iterator || \"@@iterator\", Y = {\n    0: \"Illegal state\",\n    1: \"Immer drafts cannot have computed properties\",\n    2: \"This object has been frozen and should not be mutated\",\n    3: function(n) {\n        return \"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + n;\n    },\n    4: \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n    5: \"Immer forbids circular references\",\n    6: \"The first or second argument to `produce` must be a function\",\n    7: \"The third argument to `produce` must be a function or undefined\",\n    8: \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n    9: \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n    10: \"The given draft is already finalized\",\n    11: \"Object.defineProperty() cannot be used on an Immer draft\",\n    12: \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n    13: \"Immer only supports deleting array indices\",\n    14: \"Immer only supports setting array indices and the 'length' property\",\n    15: function(n) {\n        return \"Cannot apply patch, path doesn't resolve: \" + n;\n    },\n    16: 'Sets cannot have \"replace\" patches.',\n    17: function(n) {\n        return \"Unsupported patch operation: \" + n;\n    },\n    18: function(n) {\n        return \"The plugin for '\" + n + \"' has not been loaded into Immer. To enable the plugin, import and call `enable\" + n + \"()` when initializing your application.\";\n    },\n    20: \"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\",\n    21: function(n) {\n        return \"produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '\" + n + \"'\";\n    },\n    22: function(n) {\n        return \"'current' expects a draft, got: \" + n;\n    },\n    23: function(n) {\n        return \"'original' expects a draft, got: \" + n;\n    },\n    24: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n}, Z = \"\" + Object.prototype.constructor, nn = \"undefined\" != typeof Reflect && Reflect.ownKeys ? Reflect.ownKeys : void 0 !== Object.getOwnPropertySymbols ? function(n) {\n    return Object.getOwnPropertyNames(n).concat(Object.getOwnPropertySymbols(n));\n} : Object.getOwnPropertyNames, rn = Object.getOwnPropertyDescriptors || function(n) {\n    var r = {};\n    return nn(n).forEach(function(t) {\n        r[t] = Object.getOwnPropertyDescriptor(n, t);\n    }), r;\n}, tn = {}, en = {\n    get: function(n, r) {\n        if (r === Q) return n;\n        var e = p(n);\n        if (!u(e, r)) return function(n, r, t) {\n            var e, i = I(r, t);\n            return i ? \"value\" in i ? i.value : null === (e = i.get) || void 0 === e ? void 0 : e.call(n.k) : void 0;\n        }(n, e, r);\n        var i = e[r];\n        return n.I || !t(i) ? i : i === z(n.t, r) ? (E(n), n.o[r] = N(n.A.h, i, n)) : i;\n    },\n    has: function(n, r) {\n        return r in p(n);\n    },\n    ownKeys: function(n) {\n        return Reflect.ownKeys(p(n));\n    },\n    set: function(n, r, t) {\n        var e = I(p(n), r);\n        if (null == e ? void 0 : e.set) return e.set.call(n.k, t), !0;\n        if (!n.P) {\n            var i = z(p(n), r), o = null == i ? void 0 : i[Q];\n            if (o && o.t === t) return n.o[r] = t, n.R[r] = !1, !0;\n            if (c(t, i) && (void 0 !== t || u(n.t, r))) return !0;\n            E(n), k(n);\n        }\n        return n.o[r] === t && (void 0 !== t || r in n.o) || Number.isNaN(t) && Number.isNaN(n.o[r]) || (n.o[r] = t, n.R[r] = !0), !0;\n    },\n    deleteProperty: function(n, r) {\n        return void 0 !== z(n.t, r) || r in n.t ? (n.R[r] = !1, E(n), k(n)) : delete n.R[r], n.o && delete n.o[r], !0;\n    },\n    getOwnPropertyDescriptor: function(n, r) {\n        var t = p(n), e = Reflect.getOwnPropertyDescriptor(t, r);\n        return e ? {\n            writable: !0,\n            configurable: 1 !== n.i || \"length\" !== r,\n            enumerable: e.enumerable,\n            value: t[r]\n        } : e;\n    },\n    defineProperty: function() {\n        n(11);\n    },\n    getPrototypeOf: function(n) {\n        return Object.getPrototypeOf(n.t);\n    },\n    setPrototypeOf: function() {\n        n(12);\n    }\n}, on = {};\ni(en, function(n, r) {\n    on[n] = function() {\n        return arguments[0] = arguments[0][0], r.apply(this, arguments);\n    };\n}), on.deleteProperty = function(r, t) {\n    return  true && isNaN(parseInt(t)) && n(13), on.set.call(this, r, t, void 0);\n}, on.set = function(r, t, e) {\n    return  true && \"length\" !== t && isNaN(parseInt(t)) && n(14), en.set.call(this, r[0], t, e, r[0]);\n};\nvar un = function() {\n    function e(r) {\n        var e = this;\n        this.O = B, this.D = !0, this.produce = function(r, i, o) {\n            if (\"function\" == typeof r && \"function\" != typeof i) {\n                var u = i;\n                i = r;\n                var a = e;\n                return function(n) {\n                    var r = this;\n                    void 0 === n && (n = u);\n                    for(var t = arguments.length, e = Array(t > 1 ? t - 1 : 0), o = 1; o < t; o++)e[o - 1] = arguments[o];\n                    return a.produce(n, function(n) {\n                        var t;\n                        return (t = i).call.apply(t, [\n                            r,\n                            n\n                        ].concat(e));\n                    });\n                };\n            }\n            var f;\n            if (\"function\" != typeof i && n(6), void 0 !== o && \"function\" != typeof o && n(7), t(r)) {\n                var c = w(e), s = N(e, r, void 0), v = !0;\n                try {\n                    f = i(s), v = !1;\n                } finally{\n                    v ? g(c) : O(c);\n                }\n                return \"undefined\" != typeof Promise && f instanceof Promise ? f.then(function(n) {\n                    return j(c, o), P(n, c);\n                }, function(n) {\n                    throw g(c), n;\n                }) : (j(c, o), P(f, c));\n            }\n            if (!r || \"object\" != typeof r) {\n                if (void 0 === (f = i(r)) && (f = r), f === H && (f = void 0), e.D && d(f, !0), o) {\n                    var p = [], l = [];\n                    b(\"Patches\").M(r, f, p, l), o(p, l);\n                }\n                return f;\n            }\n            n(21, r);\n        }, this.produceWithPatches = function(n, r) {\n            if (\"function\" == typeof n) return function(r) {\n                for(var t = arguments.length, i = Array(t > 1 ? t - 1 : 0), o = 1; o < t; o++)i[o - 1] = arguments[o];\n                return e.produceWithPatches(r, function(r) {\n                    return n.apply(void 0, [\n                        r\n                    ].concat(i));\n                });\n            };\n            var t, i, o = e.produce(n, r, function(n, r) {\n                t = n, i = r;\n            });\n            return \"undefined\" != typeof Promise && o instanceof Promise ? o.then(function(n) {\n                return [\n                    n,\n                    t,\n                    i\n                ];\n            }) : [\n                o,\n                t,\n                i\n            ];\n        }, \"boolean\" == typeof (null == r ? void 0 : r.useProxies) && this.setUseProxies(r.useProxies), \"boolean\" == typeof (null == r ? void 0 : r.autoFreeze) && this.setAutoFreeze(r.autoFreeze);\n    }\n    var i = e.prototype;\n    return i.createDraft = function(e) {\n        t(e) || n(8), r(e) && (e = R(e));\n        var i = w(this), o = N(this, e, void 0);\n        return o[Q].C = !0, O(i), o;\n    }, i.finishDraft = function(r, t) {\n        var e = r && r[Q];\n         true && (e && e.C || n(9), e.I && n(10));\n        var i = e.A;\n        return j(i, t), P(void 0, i);\n    }, i.setAutoFreeze = function(n) {\n        this.D = n;\n    }, i.setUseProxies = function(r) {\n        r && !B && n(20), this.O = r;\n    }, i.applyPatches = function(n, t) {\n        var e;\n        for(e = t.length - 1; e >= 0; e--){\n            var i = t[e];\n            if (0 === i.path.length && \"replace\" === i.op) {\n                n = i.value;\n                break;\n            }\n        }\n        e > -1 && (t = t.slice(e + 1));\n        var o = b(\"Patches\").$;\n        return r(n) ? o(n, t) : this.produce(n, function(n) {\n            return o(n, t);\n        });\n    }, e;\n}(), an = new un, fn = an.produce, cn = an.produceWithPatches.bind(an), sn = an.setAutoFreeze.bind(an), vn = an.setUseProxies.bind(an), pn = an.applyPatches.bind(an), ln = an.createDraft.bind(an), dn = an.finishDraft.bind(an);\n/* harmony default export */ __webpack_exports__[\"default\"] = (fn);\n //# sourceMappingURL=immer.esm.js.map\nvar _c, _c1, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9, _c10, _c11, _c12, _c13, _c14;\n$RefreshReg$(_c, \"O\");\n$RefreshReg$(_c1, \"S\");\n$RefreshReg$(_c2, \"P\");\n$RefreshReg$(_c3, \"M\");\n$RefreshReg$(_c4, \"A\");\n$RefreshReg$(_c5, \"I\");\n$RefreshReg$(_c6, \"E\");\n$RefreshReg$(_c7, \"N\");\n$RefreshReg$(_c8, \"R\");\n$RefreshReg$(_c9, \"D\");\n$RefreshReg$(_c10, \"F\");\n$RefreshReg$(_c11, \"T\");\n$RefreshReg$(_c12, \"C\");\n$RefreshReg$(_c13, \"J\");\n$RefreshReg$(_c14, \"K\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9pbW1lci9kaXN0L2ltbWVyLmVzbS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsU0FBU0EsRUFBRUEsQ0FBQztJQUFFLElBQUksSUFBSUMsSUFBRUMsVUFBVUMsTUFBTSxFQUFDQyxJQUFFQyxNQUFNSixJQUFFLElBQUVBLElBQUUsSUFBRSxJQUFHSyxJQUFFLEdBQUVBLElBQUVMLEdBQUVLLElBQUlGLENBQUMsQ0FBQ0UsSUFBRSxFQUFFLEdBQUNKLFNBQVMsQ0FBQ0ksRUFBRTtJQUFDLElBQUcsSUFBL0YsRUFBbUk7UUFBQyxJQUFJQyxJQUFFQyxDQUFDLENBQUNSLEVBQUUsRUFBQ1MsSUFBRUYsSUFBRSxjQUFZLE9BQU9BLElBQUVBLEVBQUVHLEtBQUssQ0FBQyxNQUFLTixLQUFHRyxJQUFFLHVCQUFxQlA7UUFBRSxNQUFNVyxNQUFNLGFBQVdGO0lBQUU7SUFBQyxNQUFNRSxNQUFNLGdDQUE4QlgsSUFBR0ksQ0FBQUEsRUFBRUQsTUFBTSxHQUFDLE1BQUlDLEVBQUVRLEdBQUcsQ0FBRSxTQUFTWixDQUFDO1FBQUUsT0FBTSxNQUFJQSxJQUFFO0lBQUcsR0FBSWEsSUFBSSxDQUFDLE9BQUssRUFBQyxJQUFHO0FBQW1EO0FBQUMsU0FBU1osRUFBRUQsQ0FBQztJQUFFLE9BQU0sQ0FBQyxDQUFDQSxLQUFHLENBQUMsQ0FBQ0EsQ0FBQyxDQUFDYyxFQUFFO0FBQUE7QUFBQyxTQUFTVixFQUFFSixDQUFDO0lBQUUsSUFBSUM7SUFBRSxPQUFNLENBQUMsQ0FBQ0QsS0FBSSxVQUFTQSxDQUFDO1FBQUUsSUFBRyxDQUFDQSxLQUFHLFlBQVUsT0FBT0EsR0FBRSxPQUFNLENBQUM7UUFBRSxJQUFJQyxJQUFFYyxPQUFPQyxjQUFjLENBQUNoQjtRQUFHLElBQUcsU0FBT0MsR0FBRSxPQUFNLENBQUM7UUFBRSxJQUFJRyxJQUFFVyxPQUFPRSxjQUFjLENBQUNDLElBQUksQ0FB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a0QsRUFBRSxXQUFXMkMsQ0FBQztRQUFDLE9BQU9yRyxFQUFFRCxLQUFHUyxFQUFFVCxHQUFFSSxLQUFHLElBQUksQ0FBQzhILE9BQU8sQ0FBQ2xJLEdBQUcsU0FBU0EsQ0FBQztZQUFFLE9BQU9TLEVBQUVULEdBQUVJO1FBQUU7SUFBRyxHQUFFRTtBQUFDLEtBQUl1SSxLQUFHLElBQUlaLElBQUdhLEtBQUdELEdBQUdYLE9BQU8sRUFBQ2EsS0FBR0YsR0FBR1Isa0JBQWtCLENBQUNXLElBQUksQ0FBQ0gsS0FBSUksS0FBR0osR0FBR0osYUFBYSxDQUFDTyxJQUFJLENBQUNILEtBQUlLLEtBQUdMLEdBQUdOLGFBQWEsQ0FBQ1MsSUFBSSxDQUFDSCxLQUFJTSxLQUFHTixHQUFHRCxZQUFZLENBQUNJLElBQUksQ0FBQ0gsS0FBSU8sS0FBR1AsR0FBR0gsV0FBVyxDQUFDTSxJQUFJLENBQUNILEtBQUlRLEtBQUdSLEdBQUdGLFdBQVcsQ0FBQ0ssSUFBSSxDQUFDSDtBQUFJLCtEQUFlQyxFQUFFQSxFQUFDO0FBQXVXLENBQ2o5akIscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9pbW1lci9kaXN0L2ltbWVyLmVzbS5tanM/MTBiZiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBuKG4pe2Zvcih2YXIgcj1hcmd1bWVudHMubGVuZ3RoLHQ9QXJyYXkocj4xP3ItMTowKSxlPTE7ZTxyO2UrKyl0W2UtMV09YXJndW1lbnRzW2VdO2lmKFwicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlYpe3ZhciBpPVlbbl0sbz1pP1wiZnVuY3Rpb25cIj09dHlwZW9mIGk/aS5hcHBseShudWxsLHQpOmk6XCJ1bmtub3duIGVycm9yIG5yOiBcIituO3Rocm93IEVycm9yKFwiW0ltbWVyXSBcIitvKX10aHJvdyBFcnJvcihcIltJbW1lcl0gbWluaWZpZWQgZXJyb3IgbnI6IFwiK24rKHQubGVuZ3RoP1wiIFwiK3QubWFwKChmdW5jdGlvbihuKXtyZXR1cm5cIidcIituK1wiJ1wifSkpLmpvaW4oXCIsXCIpOlwiXCIpK1wiLiBGaW5kIHRoZSBmdWxsIGVycm9yIGF0OiBodHRwczovL2JpdC5seS8zY1hFS1dmXCIpfWZ1bmN0aW9uIHIobil7cmV0dXJuISFuJiYhIW5bUV19ZnVuY3Rpb24gdChuKXt2YXIgcjtyZXR1cm4hIW4mJihmdW5jdGlvbihuKXtpZighbnx8XCJvYmplY3RcIiE9dHlwZW9mIG4pcmV0dXJuITE7dmFyIHI9T2JqZWN0LmdldFByb3RvdHlwZU9mKG4pO2lmKG51bGw9PT1yKXJldHVybiEwO3ZhciB0PU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsXCJjb25zdHJ1Y3RvclwiKSYmci5jb25zdHJ1Y3RvcjtyZXR1cm4gdD09PU9iamVjdHx8XCJmdW5jdGlvblwiPT10eXBlb2YgdCYmRnVuY3Rpb24udG9TdHJpbmcuY2FsbCh0KT09PVp9KG4pfHxBcnJheS5pc0FycmF5KG4pfHwhIW5bTF18fCEhKG51bGw9PT0ocj1uLmNvbnN0cnVjdG9yKXx8dm9pZCAwPT09cj92b2lkIDA6cltMXSl8fHMobil8fHYobikpfWZ1bmN0aW9uIGUodCl7cmV0dXJuIHIodCl8fG4oMjMsdCksdFtRXS50fWZ1bmN0aW9uIGkobixyLHQpe3ZvaWQgMD09PXQmJih0PSExKSwwPT09byhuKT8odD9PYmplY3Qua2V5czpubikobikuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dCYmXCJzeW1ib2xcIj09dHlwZW9mIGV8fHIoZSxuW2VdLG4pfSkpOm4uZm9yRWFjaCgoZnVuY3Rpb24odCxlKXtyZXR1cm4gcihlLHQsbil9KSl9ZnVuY3Rpb24gbyhuKXt2YXIgcj1uW1FdO3JldHVybiByP3IuaT4zP3IuaS00OnIuaTpBcnJheS5pc0FycmF5KG4pPzE6cyhuKT8yOnYobik/MzowfWZ1bmN0aW9uIHUobixyKXtyZXR1cm4gMj09PW8obik/bi5oYXMocik6T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4scil9ZnVuY3Rpb24gYShuLHIpe3JldHVybiAyPT09byhuKT9uLmdldChyKTpuW3JdfWZ1bmN0aW9uIGYobixyLHQpe3ZhciBlPW8obik7Mj09PWU/bi5zZXQocix0KTozPT09ZT9uLmFkZCh0KTpuW3JdPXR9ZnVuY3Rpb24gYyhuLHIpe3JldHVybiBuPT09cj8wIT09bnx8MS9uPT0xL3I6biE9biYmciE9cn1mdW5jdGlvbiBzKG4pe3JldHVybiBYJiZuIGluc3RhbmNlb2YgTWFwfWZ1bmN0aW9uIHYobil7cmV0dXJuIHEmJm4gaW5zdGFuY2VvZiBTZXR9ZnVuY3Rpb24gcChuKXtyZXR1cm4gbi5vfHxuLnR9ZnVuY3Rpb24gbChuKXtpZihBcnJheS5pc0FycmF5KG4pKXJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChuKTt2YXIgcj1ybihuKTtkZWxldGUgcltRXTtmb3IodmFyIHQ9bm4ociksZT0wO2U8dC5sZW5ndGg7ZSsrKXt2YXIgaT10W2VdLG89cltpXTshMT09PW8ud3JpdGFibGUmJihvLndyaXRhYmxlPSEwLG8uY29uZmlndXJhYmxlPSEwKSwoby5nZXR8fG8uc2V0KSYmKHJbaV09e2NvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCxlbnVtZXJhYmxlOm8uZW51bWVyYWJsZSx2YWx1ZTpuW2ldfSl9cmV0dXJuIE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKG4pLHIpfWZ1bmN0aW9uIGQobixlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9ITEpLHkobil8fHIobil8fCF0KG4pfHwobyhuKT4xJiYobi5zZXQ9bi5hZGQ9bi5jbGVhcj1uLmRlbGV0ZT1oKSxPYmplY3QuZnJlZXplKG4pLGUmJmkobiwoZnVuY3Rpb24obixyKXtyZXR1cm4gZChyLCEwKX0pLCEwKSksbn1mdW5jdGlvbiBoKCl7bigyKX1mdW5jdGlvbiB5KG4pe3JldHVybiBudWxsPT1ufHxcIm9iamVjdFwiIT10eXBlb2Ygbnx8T2JqZWN0LmlzRnJvemVuKG4pfWZ1bmN0aW9uIGIocil7dmFyIHQ9dG5bcl07cmV0dXJuIHR8fG4oMTgsciksdH1mdW5jdGlvbiBtKG4scil7dG5bbl18fCh0bltuXT1yKX1mdW5jdGlvbiBfKCl7cmV0dXJuXCJwcm9kdWN0aW9uXCI9PT1wcm9jZXNzLmVudi5OT0RFX0VOVnx8VXx8bigwKSxVfWZ1bmN0aW9uIGoobixyKXtyJiYoYihcIlBhdGNoZXNcIiksbi51PVtdLG4ucz1bXSxuLnY9cil9ZnVuY3Rpb24gZyhuKXtPKG4pLG4ucC5mb3JFYWNoKFMpLG4ucD1udWxsfWZ1bmN0aW9uIE8obil7bj09PVUmJihVPW4ubCl9ZnVuY3Rpb24gdyhuKXtyZXR1cm4gVT17cDpbXSxsOlUsaDpuLG06ITAsXzowfX1mdW5jdGlvbiBTKG4pe3ZhciByPW5bUV07MD09PXIuaXx8MT09PXIuaT9yLmooKTpyLmc9ITB9ZnVuY3Rpb24gUChyLGUpe2UuXz1lLnAubGVuZ3RoO3ZhciBpPWUucFswXSxvPXZvaWQgMCE9PXImJnIhPT1pO3JldHVybiBlLmguT3x8YihcIkVTNVwiKS5TKGUscixvKSxvPyhpW1FdLlAmJihnKGUpLG4oNCkpLHQocikmJihyPU0oZSxyKSxlLmx8fHgoZSxyKSksZS51JiZiKFwiUGF0Y2hlc1wiKS5NKGlbUV0udCxyLGUudSxlLnMpKTpyPU0oZSxpLFtdKSxnKGUpLGUudSYmZS52KGUudSxlLnMpLHIhPT1IP3I6dm9pZCAwfWZ1bmN0aW9uIE0obixyLHQpe2lmKHkocikpcmV0dXJuIHI7dmFyIGU9cltRXTtpZighZSlyZXR1cm4gaShyLChmdW5jdGlvbihpLG8pe3JldHVybiBBKG4sZSxyLGksbyx0KX0pLCEwKSxyO2lmKGUuQSE9PW4pcmV0dXJuIHI7aWYoIWUuUClyZXR1cm4geChuLGUudCwhMCksZS50O2lmKCFlLkkpe2UuST0hMCxlLkEuXy0tO3ZhciBvPTQ9PT1lLml8fDU9PT1lLmk/ZS5vPWwoZS5rKTplLm8sdT1vLGE9ITE7Mz09PWUuaSYmKHU9bmV3IFNldChvKSxvLmNsZWFyKCksYT0hMCksaSh1LChmdW5jdGlvbihyLGkpe3JldHVybiBBKG4sZSxvLHIsaSx0LGEpfSkpLHgobixvLCExKSx0JiZuLnUmJmIoXCJQYXRjaGVzXCIpLk4oZSx0LG4udSxuLnMpfXJldHVybiBlLm99ZnVuY3Rpb24gQShlLGksbyxhLGMscyx2KXtpZihcInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WJiZjPT09byYmbig1KSxyKGMpKXt2YXIgcD1NKGUsYyxzJiZpJiYzIT09aS5pJiYhdShpLlIsYSk/cy5jb25jYXQoYSk6dm9pZCAwKTtpZihmKG8sYSxwKSwhcihwKSlyZXR1cm47ZS5tPSExfWVsc2UgdiYmby5hZGQoYyk7aWYodChjKSYmIXkoYykpe2lmKCFlLmguRCYmZS5fPDEpcmV0dXJuO00oZSxjKSxpJiZpLkEubHx8eChlLGMpfX1mdW5jdGlvbiB4KG4scix0KXt2b2lkIDA9PT10JiYodD0hMSksIW4ubCYmbi5oLkQmJm4ubSYmZChyLHQpfWZ1bmN0aW9uIHoobixyKXt2YXIgdD1uW1FdO3JldHVybih0P3AodCk6bilbcl19ZnVuY3Rpb24gSShuLHIpe2lmKHIgaW4gbilmb3IodmFyIHQ9T2JqZWN0LmdldFByb3RvdHlwZU9mKG4pO3Q7KXt2YXIgZT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQscik7aWYoZSlyZXR1cm4gZTt0PU9iamVjdC5nZXRQcm90b3R5cGVPZih0KX19ZnVuY3Rpb24gayhuKXtuLlB8fChuLlA9ITAsbi5sJiZrKG4ubCkpfWZ1bmN0aW9uIEUobil7bi5vfHwobi5vPWwobi50KSl9ZnVuY3Rpb24gTihuLHIsdCl7dmFyIGU9cyhyKT9iKFwiTWFwU2V0XCIpLkYocix0KTp2KHIpP2IoXCJNYXBTZXRcIikuVChyLHQpOm4uTz9mdW5jdGlvbihuLHIpe3ZhciB0PUFycmF5LmlzQXJyYXkobiksZT17aTp0PzE6MCxBOnI/ci5BOl8oKSxQOiExLEk6ITEsUjp7fSxsOnIsdDpuLGs6bnVsbCxvOm51bGwsajpudWxsLEM6ITF9LGk9ZSxvPWVuO3QmJihpPVtlXSxvPW9uKTt2YXIgdT1Qcm94eS5yZXZvY2FibGUoaSxvKSxhPXUucmV2b2tlLGY9dS5wcm94eTtyZXR1cm4gZS5rPWYsZS5qPWEsZn0ocix0KTpiKFwiRVM1XCIpLkoocix0KTtyZXR1cm4odD90LkE6XygpKS5wLnB1c2goZSksZX1mdW5jdGlvbiBSKGUpe3JldHVybiByKGUpfHxuKDIyLGUpLGZ1bmN0aW9uIG4ocil7aWYoIXQocikpcmV0dXJuIHI7dmFyIGUsdT1yW1FdLGM9byhyKTtpZih1KXtpZighdS5QJiYodS5pPDR8fCFiKFwiRVM1XCIpLksodSkpKXJldHVybiB1LnQ7dS5JPSEwLGU9RChyLGMpLHUuST0hMX1lbHNlIGU9RChyLGMpO3JldHVybiBpKGUsKGZ1bmN0aW9uKHIsdCl7dSYmYSh1LnQscik9PT10fHxmKGUscixuKHQpKX0pKSwzPT09Yz9uZXcgU2V0KGUpOmV9KGUpfWZ1bmN0aW9uIEQobixyKXtzd2l0Y2gocil7Y2FzZSAyOnJldHVybiBuZXcgTWFwKG4pO2Nhc2UgMzpyZXR1cm4gQXJyYXkuZnJvbShuKX1yZXR1cm4gbChuKX1mdW5jdGlvbiBGKCl7ZnVuY3Rpb24gdChuLHIpe3ZhciB0PXNbbl07cmV0dXJuIHQ/dC5lbnVtZXJhYmxlPXI6c1tuXT10PXtjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTpyLGdldDpmdW5jdGlvbigpe3ZhciByPXRoaXNbUV07cmV0dXJuXCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOViYmZihyKSxlbi5nZXQocixuKX0sc2V0OmZ1bmN0aW9uKHIpe3ZhciB0PXRoaXNbUV07XCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOViYmZih0KSxlbi5zZXQodCxuLHIpfX0sdH1mdW5jdGlvbiBlKG4pe2Zvcih2YXIgcj1uLmxlbmd0aC0xO3I+PTA7ci0tKXt2YXIgdD1uW3JdW1FdO2lmKCF0LlApc3dpdGNoKHQuaSl7Y2FzZSA1OmEodCkmJmsodCk7YnJlYWs7Y2FzZSA0Om8odCkmJmsodCl9fX1mdW5jdGlvbiBvKG4pe2Zvcih2YXIgcj1uLnQsdD1uLmssZT1ubih0KSxpPWUubGVuZ3RoLTE7aT49MDtpLS0pe3ZhciBvPWVbaV07aWYobyE9PVEpe3ZhciBhPXJbb107aWYodm9pZCAwPT09YSYmIXUocixvKSlyZXR1cm4hMDt2YXIgZj10W29dLHM9ZiYmZltRXTtpZihzP3MudCE9PWE6IWMoZixhKSlyZXR1cm4hMH19dmFyIHY9ISFyW1FdO3JldHVybiBlLmxlbmd0aCE9PW5uKHIpLmxlbmd0aCsodj8wOjEpfWZ1bmN0aW9uIGEobil7dmFyIHI9bi5rO2lmKHIubGVuZ3RoIT09bi50Lmxlbmd0aClyZXR1cm4hMDt2YXIgdD1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHIsci5sZW5ndGgtMSk7aWYodCYmIXQuZ2V0KXJldHVybiEwO2Zvcih2YXIgZT0wO2U8ci5sZW5ndGg7ZSsrKWlmKCFyLmhhc093blByb3BlcnR5KGUpKXJldHVybiEwO3JldHVybiExfWZ1bmN0aW9uIGYocil7ci5nJiZuKDMsSlNPTi5zdHJpbmdpZnkocChyKSkpfXZhciBzPXt9O20oXCJFUzVcIix7SjpmdW5jdGlvbihuLHIpe3ZhciBlPUFycmF5LmlzQXJyYXkobiksaT1mdW5jdGlvbihuLHIpe2lmKG4pe2Zvcih2YXIgZT1BcnJheShyLmxlbmd0aCksaT0wO2k8ci5sZW5ndGg7aSsrKU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiXCIraSx0KGksITApKTtyZXR1cm4gZX12YXIgbz1ybihyKTtkZWxldGUgb1tRXTtmb3IodmFyIHU9bm4obyksYT0wO2E8dS5sZW5ndGg7YSsrKXt2YXIgZj11W2FdO29bZl09dChmLG58fCEhb1tmXS5lbnVtZXJhYmxlKX1yZXR1cm4gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2Yociksbyl9KGUsbiksbz17aTplPzU6NCxBOnI/ci5BOl8oKSxQOiExLEk6ITEsUjp7fSxsOnIsdDpuLGs6aSxvOm51bGwsZzohMSxDOiExfTtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGksUSx7dmFsdWU6byx3cml0YWJsZTohMH0pLGl9LFM6ZnVuY3Rpb24obix0LG8pe28/cih0KSYmdFtRXS5BPT09biYmZShuLnApOihuLnUmJmZ1bmN0aW9uIG4ocil7aWYociYmXCJvYmplY3RcIj09dHlwZW9mIHIpe3ZhciB0PXJbUV07aWYodCl7dmFyIGU9dC50LG89dC5rLGY9dC5SLGM9dC5pO2lmKDQ9PT1jKWkobywoZnVuY3Rpb24ocil7ciE9PVEmJih2b2lkIDAhPT1lW3JdfHx1KGUscik/ZltyXXx8bihvW3JdKTooZltyXT0hMCxrKHQpKSl9KSksaShlLChmdW5jdGlvbihuKXt2b2lkIDAhPT1vW25dfHx1KG8sbil8fChmW25dPSExLGsodCkpfSkpO2Vsc2UgaWYoNT09PWMpe2lmKGEodCkmJihrKHQpLGYubGVuZ3RoPSEwKSxvLmxlbmd0aDxlLmxlbmd0aClmb3IodmFyIHM9by5sZW5ndGg7czxlLmxlbmd0aDtzKyspZltzXT0hMTtlbHNlIGZvcih2YXIgdj1lLmxlbmd0aDt2PG8ubGVuZ3RoO3YrKylmW3ZdPSEwO2Zvcih2YXIgcD1NYXRoLm1pbihvLmxlbmd0aCxlLmxlbmd0aCksbD0wO2w8cDtsKyspby5oYXNPd25Qcm9wZXJ0eShsKXx8KGZbbF09ITApLHZvaWQgMD09PWZbbF0mJm4ob1tsXSl9fX19KG4ucFswXSksZShuLnApKX0sSzpmdW5jdGlvbihuKXtyZXR1cm4gND09PW4uaT9vKG4pOmEobil9fSl9ZnVuY3Rpb24gVCgpe2Z1bmN0aW9uIGUobil7aWYoIXQobikpcmV0dXJuIG47aWYoQXJyYXkuaXNBcnJheShuKSlyZXR1cm4gbi5tYXAoZSk7aWYocyhuKSlyZXR1cm4gbmV3IE1hcChBcnJheS5mcm9tKG4uZW50cmllcygpKS5tYXAoKGZ1bmN0aW9uKG4pe3JldHVybltuWzBdLGUoblsxXSldfSkpKTtpZih2KG4pKXJldHVybiBuZXcgU2V0KEFycmF5LmZyb20obikubWFwKGUpKTt2YXIgcj1PYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihuKSk7Zm9yKHZhciBpIGluIG4pcltpXT1lKG5baV0pO3JldHVybiB1KG4sTCkmJihyW0xdPW5bTF0pLHJ9ZnVuY3Rpb24gZihuKXtyZXR1cm4gcihuKT9lKG4pOm59dmFyIGM9XCJhZGRcIjttKFwiUGF0Y2hlc1wiLHskOmZ1bmN0aW9uKHIsdCl7cmV0dXJuIHQuZm9yRWFjaCgoZnVuY3Rpb24odCl7Zm9yKHZhciBpPXQucGF0aCx1PXQub3AsZj1yLHM9MDtzPGkubGVuZ3RoLTE7cysrKXt2YXIgdj1vKGYpLHA9aVtzXTtcInN0cmluZ1wiIT10eXBlb2YgcCYmXCJudW1iZXJcIiE9dHlwZW9mIHAmJihwPVwiXCIrcCksMCE9PXYmJjEhPT12fHxcIl9fcHJvdG9fX1wiIT09cCYmXCJjb25zdHJ1Y3RvclwiIT09cHx8bigyNCksXCJmdW5jdGlvblwiPT10eXBlb2YgZiYmXCJwcm90b3R5cGVcIj09PXAmJm4oMjQpLFwib2JqZWN0XCIhPXR5cGVvZihmPWEoZixwKSkmJm4oMTUsaS5qb2luKFwiL1wiKSl9dmFyIGw9byhmKSxkPWUodC52YWx1ZSksaD1pW2kubGVuZ3RoLTFdO3N3aXRjaCh1KXtjYXNlXCJyZXBsYWNlXCI6c3dpdGNoKGwpe2Nhc2UgMjpyZXR1cm4gZi5zZXQoaCxkKTtjYXNlIDM6bigxNik7ZGVmYXVsdDpyZXR1cm4gZltoXT1kfWNhc2UgYzpzd2l0Y2gobCl7Y2FzZSAxOnJldHVyblwiLVwiPT09aD9mLnB1c2goZCk6Zi5zcGxpY2UoaCwwLGQpO2Nhc2UgMjpyZXR1cm4gZi5zZXQoaCxkKTtjYXNlIDM6cmV0dXJuIGYuYWRkKGQpO2RlZmF1bHQ6cmV0dXJuIGZbaF09ZH1jYXNlXCJyZW1vdmVcIjpzd2l0Y2gobCl7Y2FzZSAxOnJldHVybiBmLnNwbGljZShoLDEpO2Nhc2UgMjpyZXR1cm4gZi5kZWxldGUoaCk7Y2FzZSAzOnJldHVybiBmLmRlbGV0ZSh0LnZhbHVlKTtkZWZhdWx0OnJldHVybiBkZWxldGUgZltoXX1kZWZhdWx0Om4oMTcsdSl9fSkpLHJ9LE46ZnVuY3Rpb24obixyLHQsZSl7c3dpdGNoKG4uaSl7Y2FzZSAwOmNhc2UgNDpjYXNlIDI6cmV0dXJuIGZ1bmN0aW9uKG4scix0LGUpe3ZhciBvPW4udCxzPW4ubztpKG4uUiwoZnVuY3Rpb24obixpKXt2YXIgdj1hKG8sbikscD1hKHMsbiksbD1pP3UobyxuKT9cInJlcGxhY2VcIjpjOlwicmVtb3ZlXCI7aWYodiE9PXB8fFwicmVwbGFjZVwiIT09bCl7dmFyIGQ9ci5jb25jYXQobik7dC5wdXNoKFwicmVtb3ZlXCI9PT1sP3tvcDpsLHBhdGg6ZH06e29wOmwscGF0aDpkLHZhbHVlOnB9KSxlLnB1c2gobD09PWM/e29wOlwicmVtb3ZlXCIscGF0aDpkfTpcInJlbW92ZVwiPT09bD97b3A6YyxwYXRoOmQsdmFsdWU6Zih2KX06e29wOlwicmVwbGFjZVwiLHBhdGg6ZCx2YWx1ZTpmKHYpfSl9fSkpfShuLHIsdCxlKTtjYXNlIDU6Y2FzZSAxOnJldHVybiBmdW5jdGlvbihuLHIsdCxlKXt2YXIgaT1uLnQsbz1uLlIsdT1uLm87aWYodS5sZW5ndGg8aS5sZW5ndGgpe3ZhciBhPVt1LGldO2k9YVswXSx1PWFbMV07dmFyIHM9W2UsdF07dD1zWzBdLGU9c1sxXX1mb3IodmFyIHY9MDt2PGkubGVuZ3RoO3YrKylpZihvW3ZdJiZ1W3ZdIT09aVt2XSl7dmFyIHA9ci5jb25jYXQoW3ZdKTt0LnB1c2goe29wOlwicmVwbGFjZVwiLHBhdGg6cCx2YWx1ZTpmKHVbdl0pfSksZS5wdXNoKHtvcDpcInJlcGxhY2VcIixwYXRoOnAsdmFsdWU6ZihpW3ZdKX0pfWZvcih2YXIgbD1pLmxlbmd0aDtsPHUubGVuZ3RoO2wrKyl7dmFyIGQ9ci5jb25jYXQoW2xdKTt0LnB1c2goe29wOmMscGF0aDpkLHZhbHVlOmYodVtsXSl9KX1pLmxlbmd0aDx1Lmxlbmd0aCYmZS5wdXNoKHtvcDpcInJlcGxhY2VcIixwYXRoOnIuY29uY2F0KFtcImxlbmd0aFwiXSksdmFsdWU6aS5sZW5ndGh9KX0obixyLHQsZSk7Y2FzZSAzOnJldHVybiBmdW5jdGlvbihuLHIsdCxlKXt2YXIgaT1uLnQsbz1uLm8sdT0wO2kuZm9yRWFjaCgoZnVuY3Rpb24obil7aWYoIW8uaGFzKG4pKXt2YXIgaT1yLmNvbmNhdChbdV0pO3QucHVzaCh7b3A6XCJyZW1vdmVcIixwYXRoOmksdmFsdWU6bn0pLGUudW5zaGlmdCh7b3A6YyxwYXRoOmksdmFsdWU6bn0pfXUrK30pKSx1PTAsby5mb3JFYWNoKChmdW5jdGlvbihuKXtpZighaS5oYXMobikpe3ZhciBvPXIuY29uY2F0KFt1XSk7dC5wdXNoKHtvcDpjLHBhdGg6byx2YWx1ZTpufSksZS51bnNoaWZ0KHtvcDpcInJlbW92ZVwiLHBhdGg6byx2YWx1ZTpufSl9dSsrfSkpfShuLHIsdCxlKX19LE06ZnVuY3Rpb24obixyLHQsZSl7dC5wdXNoKHtvcDpcInJlcGxhY2VcIixwYXRoOltdLHZhbHVlOnI9PT1IP3ZvaWQgMDpyfSksZS5wdXNoKHtvcDpcInJlcGxhY2VcIixwYXRoOltdLHZhbHVlOm59KX19KX1mdW5jdGlvbiBDKCl7ZnVuY3Rpb24gcihuLHIpe2Z1bmN0aW9uIHQoKXt0aGlzLmNvbnN0cnVjdG9yPW59YShuLHIpLG4ucHJvdG90eXBlPSh0LnByb3RvdHlwZT1yLnByb3RvdHlwZSxuZXcgdCl9ZnVuY3Rpb24gZShuKXtuLm98fChuLlI9bmV3IE1hcCxuLm89bmV3IE1hcChuLnQpKX1mdW5jdGlvbiBvKG4pe24ub3x8KG4ubz1uZXcgU2V0LG4udC5mb3JFYWNoKChmdW5jdGlvbihyKXtpZih0KHIpKXt2YXIgZT1OKG4uQS5oLHIsbik7bi5wLnNldChyLGUpLG4uby5hZGQoZSl9ZWxzZSBuLm8uYWRkKHIpfSkpKX1mdW5jdGlvbiB1KHIpe3IuZyYmbigzLEpTT04uc3RyaW5naWZ5KHAocikpKX12YXIgYT1mdW5jdGlvbihuLHIpe3JldHVybihhPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbihuLHIpe24uX19wcm90b19fPXJ9fHxmdW5jdGlvbihuLHIpe2Zvcih2YXIgdCBpbiByKXIuaGFzT3duUHJvcGVydHkodCkmJihuW3RdPXJbdF0pfSkobixyKX0sZj1mdW5jdGlvbigpe2Z1bmN0aW9uIG4obixyKXtyZXR1cm4gdGhpc1tRXT17aToyLGw6cixBOnI/ci5BOl8oKSxQOiExLEk6ITEsbzp2b2lkIDAsUjp2b2lkIDAsdDpuLGs6dGhpcyxDOiExLGc6ITF9LHRoaXN9cihuLE1hcCk7dmFyIG89bi5wcm90b3R5cGU7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLFwic2l6ZVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcCh0aGlzW1FdKS5zaXplfX0pLG8uaGFzPWZ1bmN0aW9uKG4pe3JldHVybiBwKHRoaXNbUV0pLmhhcyhuKX0sby5zZXQ9ZnVuY3Rpb24obixyKXt2YXIgdD10aGlzW1FdO3JldHVybiB1KHQpLHAodCkuaGFzKG4pJiZwKHQpLmdldChuKT09PXJ8fChlKHQpLGsodCksdC5SLnNldChuLCEwKSx0Lm8uc2V0KG4sciksdC5SLnNldChuLCEwKSksdGhpc30sby5kZWxldGU9ZnVuY3Rpb24obil7aWYoIXRoaXMuaGFzKG4pKXJldHVybiExO3ZhciByPXRoaXNbUV07cmV0dXJuIHUociksZShyKSxrKHIpLHIudC5oYXMobik/ci5SLnNldChuLCExKTpyLlIuZGVsZXRlKG4pLHIuby5kZWxldGUobiksITB9LG8uY2xlYXI9ZnVuY3Rpb24oKXt2YXIgbj10aGlzW1FdO3UobikscChuKS5zaXplJiYoZShuKSxrKG4pLG4uUj1uZXcgTWFwLGkobi50LChmdW5jdGlvbihyKXtuLlIuc2V0KHIsITEpfSkpLG4uby5jbGVhcigpKX0sby5mb3JFYWNoPWZ1bmN0aW9uKG4scil7dmFyIHQ9dGhpcztwKHRoaXNbUV0pLmZvckVhY2goKGZ1bmN0aW9uKGUsaSl7bi5jYWxsKHIsdC5nZXQoaSksaSx0KX0pKX0sby5nZXQ9ZnVuY3Rpb24obil7dmFyIHI9dGhpc1tRXTt1KHIpO3ZhciBpPXAocikuZ2V0KG4pO2lmKHIuSXx8IXQoaSkpcmV0dXJuIGk7aWYoaSE9PXIudC5nZXQobikpcmV0dXJuIGk7dmFyIG89TihyLkEuaCxpLHIpO3JldHVybiBlKHIpLHIuby5zZXQobixvKSxvfSxvLmtleXM9ZnVuY3Rpb24oKXtyZXR1cm4gcCh0aGlzW1FdKS5rZXlzKCl9LG8udmFsdWVzPWZ1bmN0aW9uKCl7dmFyIG4scj10aGlzLHQ9dGhpcy5rZXlzKCk7cmV0dXJuKG49e30pW1ZdPWZ1bmN0aW9uKCl7cmV0dXJuIHIudmFsdWVzKCl9LG4ubmV4dD1mdW5jdGlvbigpe3ZhciBuPXQubmV4dCgpO3JldHVybiBuLmRvbmU/bjp7ZG9uZTohMSx2YWx1ZTpyLmdldChuLnZhbHVlKX19LG59LG8uZW50cmllcz1mdW5jdGlvbigpe3ZhciBuLHI9dGhpcyx0PXRoaXMua2V5cygpO3JldHVybihuPXt9KVtWXT1mdW5jdGlvbigpe3JldHVybiByLmVudHJpZXMoKX0sbi5uZXh0PWZ1bmN0aW9uKCl7dmFyIG49dC5uZXh0KCk7aWYobi5kb25lKXJldHVybiBuO3ZhciBlPXIuZ2V0KG4udmFsdWUpO3JldHVybntkb25lOiExLHZhbHVlOltuLnZhbHVlLGVdfX0sbn0sb1tWXT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVudHJpZXMoKX0sbn0oKSxjPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihuLHIpe3JldHVybiB0aGlzW1FdPXtpOjMsbDpyLEE6cj9yLkE6XygpLFA6ITEsSTohMSxvOnZvaWQgMCx0Om4sazp0aGlzLHA6bmV3IE1hcCxnOiExLEM6ITF9LHRoaXN9cihuLFNldCk7dmFyIHQ9bi5wcm90b3R5cGU7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwic2l6ZVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcCh0aGlzW1FdKS5zaXplfX0pLHQuaGFzPWZ1bmN0aW9uKG4pe3ZhciByPXRoaXNbUV07cmV0dXJuIHUociksci5vPyEhci5vLmhhcyhuKXx8ISghci5wLmhhcyhuKXx8IXIuby5oYXMoci5wLmdldChuKSkpOnIudC5oYXMobil9LHQuYWRkPWZ1bmN0aW9uKG4pe3ZhciByPXRoaXNbUV07cmV0dXJuIHUociksdGhpcy5oYXMobil8fChvKHIpLGsociksci5vLmFkZChuKSksdGhpc30sdC5kZWxldGU9ZnVuY3Rpb24obil7aWYoIXRoaXMuaGFzKG4pKXJldHVybiExO3ZhciByPXRoaXNbUV07cmV0dXJuIHUociksbyhyKSxrKHIpLHIuby5kZWxldGUobil8fCEhci5wLmhhcyhuKSYmci5vLmRlbGV0ZShyLnAuZ2V0KG4pKX0sdC5jbGVhcj1mdW5jdGlvbigpe3ZhciBuPXRoaXNbUV07dShuKSxwKG4pLnNpemUmJihvKG4pLGsobiksbi5vLmNsZWFyKCkpfSx0LnZhbHVlcz1mdW5jdGlvbigpe3ZhciBuPXRoaXNbUV07cmV0dXJuIHUobiksbyhuKSxuLm8udmFsdWVzKCl9LHQuZW50cmllcz1mdW5jdGlvbigpe3ZhciBuPXRoaXNbUV07cmV0dXJuIHUobiksbyhuKSxuLm8uZW50cmllcygpfSx0LmtleXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWx1ZXMoKX0sdFtWXT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbHVlcygpfSx0LmZvckVhY2g9ZnVuY3Rpb24obixyKXtmb3IodmFyIHQ9dGhpcy52YWx1ZXMoKSxlPXQubmV4dCgpOyFlLmRvbmU7KW4uY2FsbChyLGUudmFsdWUsZS52YWx1ZSx0aGlzKSxlPXQubmV4dCgpfSxufSgpO20oXCJNYXBTZXRcIix7RjpmdW5jdGlvbihuLHIpe3JldHVybiBuZXcgZihuLHIpfSxUOmZ1bmN0aW9uKG4scil7cmV0dXJuIG5ldyBjKG4scil9fSl9ZnVuY3Rpb24gSigpe0YoKSxDKCksVCgpfWZ1bmN0aW9uIEsobil7cmV0dXJuIG59ZnVuY3Rpb24gJChuKXtyZXR1cm4gbn12YXIgRyxVLFc9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbChcInhcIiksWD1cInVuZGVmaW5lZFwiIT10eXBlb2YgTWFwLHE9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFNldCxCPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBQcm94eSYmdm9pZCAwIT09UHJveHkucmV2b2NhYmxlJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgUmVmbGVjdCxIPVc/U3ltYm9sLmZvcihcImltbWVyLW5vdGhpbmdcIik6KChHPXt9KVtcImltbWVyLW5vdGhpbmdcIl09ITAsRyksTD1XP1N5bWJvbC5mb3IoXCJpbW1lci1kcmFmdGFibGVcIik6XCJfXyRpbW1lcl9kcmFmdGFibGVcIixRPVc/U3ltYm9sLmZvcihcImltbWVyLXN0YXRlXCIpOlwiX18kaW1tZXJfc3RhdGVcIixWPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5pdGVyYXRvcnx8XCJAQGl0ZXJhdG9yXCIsWT17MDpcIklsbGVnYWwgc3RhdGVcIiwxOlwiSW1tZXIgZHJhZnRzIGNhbm5vdCBoYXZlIGNvbXB1dGVkIHByb3BlcnRpZXNcIiwyOlwiVGhpcyBvYmplY3QgaGFzIGJlZW4gZnJvemVuIGFuZCBzaG91bGQgbm90IGJlIG11dGF0ZWRcIiwzOmZ1bmN0aW9uKG4pe3JldHVyblwiQ2Fubm90IHVzZSBhIHByb3h5IHRoYXQgaGFzIGJlZW4gcmV2b2tlZC4gRGlkIHlvdSBwYXNzIGFuIG9iamVjdCBmcm9tIGluc2lkZSBhbiBpbW1lciBmdW5jdGlvbiB0byBhbiBhc3luYyBwcm9jZXNzPyBcIitufSw0OlwiQW4gaW1tZXIgcHJvZHVjZXIgcmV0dXJuZWQgYSBuZXcgdmFsdWUgKmFuZCogbW9kaWZpZWQgaXRzIGRyYWZ0LiBFaXRoZXIgcmV0dXJuIGEgbmV3IHZhbHVlICpvciogbW9kaWZ5IHRoZSBkcmFmdC5cIiw1OlwiSW1tZXIgZm9yYmlkcyBjaXJjdWxhciByZWZlcmVuY2VzXCIsNjpcIlRoZSBmaXJzdCBvciBzZWNvbmQgYXJndW1lbnQgdG8gYHByb2R1Y2VgIG11c3QgYmUgYSBmdW5jdGlvblwiLDc6XCJUaGUgdGhpcmQgYXJndW1lbnQgdG8gYHByb2R1Y2VgIG11c3QgYmUgYSBmdW5jdGlvbiBvciB1bmRlZmluZWRcIiw4OlwiRmlyc3QgYXJndW1lbnQgdG8gYGNyZWF0ZURyYWZ0YCBtdXN0IGJlIGEgcGxhaW4gb2JqZWN0LCBhbiBhcnJheSwgb3IgYW4gaW1tZXJhYmxlIG9iamVjdFwiLDk6XCJGaXJzdCBhcmd1bWVudCB0byBgZmluaXNoRHJhZnRgIG11c3QgYmUgYSBkcmFmdCByZXR1cm5lZCBieSBgY3JlYXRlRHJhZnRgXCIsMTA6XCJUaGUgZ2l2ZW4gZHJhZnQgaXMgYWxyZWFkeSBmaW5hbGl6ZWRcIiwxMTpcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eSgpIGNhbm5vdCBiZSB1c2VkIG9uIGFuIEltbWVyIGRyYWZ0XCIsMTI6XCJPYmplY3Quc2V0UHJvdG90eXBlT2YoKSBjYW5ub3QgYmUgdXNlZCBvbiBhbiBJbW1lciBkcmFmdFwiLDEzOlwiSW1tZXIgb25seSBzdXBwb3J0cyBkZWxldGluZyBhcnJheSBpbmRpY2VzXCIsMTQ6XCJJbW1lciBvbmx5IHN1cHBvcnRzIHNldHRpbmcgYXJyYXkgaW5kaWNlcyBhbmQgdGhlICdsZW5ndGgnIHByb3BlcnR5XCIsMTU6ZnVuY3Rpb24obil7cmV0dXJuXCJDYW5ub3QgYXBwbHkgcGF0Y2gsIHBhdGggZG9lc24ndCByZXNvbHZlOiBcIitufSwxNjonU2V0cyBjYW5ub3QgaGF2ZSBcInJlcGxhY2VcIiBwYXRjaGVzLicsMTc6ZnVuY3Rpb24obil7cmV0dXJuXCJVbnN1cHBvcnRlZCBwYXRjaCBvcGVyYXRpb246IFwiK259LDE4OmZ1bmN0aW9uKG4pe3JldHVyblwiVGhlIHBsdWdpbiBmb3IgJ1wiK24rXCInIGhhcyBub3QgYmVlbiBsb2FkZWQgaW50byBJbW1lci4gVG8gZW5hYmxlIHRoZSBwbHVnaW4sIGltcG9ydCBhbmQgY2FsbCBgZW5hYmxlXCIrbitcIigpYCB3aGVuIGluaXRpYWxpemluZyB5b3VyIGFwcGxpY2F0aW9uLlwifSwyMDpcIkNhbm5vdCB1c2UgcHJveGllcyBpZiBQcm94eSwgUHJveHkucmV2b2NhYmxlIG9yIFJlZmxlY3QgYXJlIG5vdCBhdmFpbGFibGVcIiwyMTpmdW5jdGlvbihuKXtyZXR1cm5cInByb2R1Y2UgY2FuIG9ubHkgYmUgY2FsbGVkIG9uIHRoaW5ncyB0aGF0IGFyZSBkcmFmdGFibGU6IHBsYWluIG9iamVjdHMsIGFycmF5cywgTWFwLCBTZXQgb3IgY2xhc3NlcyB0aGF0IGFyZSBtYXJrZWQgd2l0aCAnW2ltbWVyYWJsZV06IHRydWUnLiBHb3QgJ1wiK24rXCInXCJ9LDIyOmZ1bmN0aW9uKG4pe3JldHVyblwiJ2N1cnJlbnQnIGV4cGVjdHMgYSBkcmFmdCwgZ290OiBcIitufSwyMzpmdW5jdGlvbihuKXtyZXR1cm5cIidvcmlnaW5hbCcgZXhwZWN0cyBhIGRyYWZ0LCBnb3Q6IFwiK259LDI0OlwiUGF0Y2hpbmcgcmVzZXJ2ZWQgYXR0cmlidXRlcyBsaWtlIF9fcHJvdG9fXywgcHJvdG90eXBlIGFuZCBjb25zdHJ1Y3RvciBpcyBub3QgYWxsb3dlZFwifSxaPVwiXCIrT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcixubj1cInVuZGVmaW5lZFwiIT10eXBlb2YgUmVmbGVjdCYmUmVmbGVjdC5vd25LZXlzP1JlZmxlY3Qub3duS2V5czp2b2lkIDAhPT1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzP2Z1bmN0aW9uKG4pe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhuKS5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhuKSl9Ok9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzLHJuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzfHxmdW5jdGlvbihuKXt2YXIgcj17fTtyZXR1cm4gbm4obikuZm9yRWFjaCgoZnVuY3Rpb24odCl7clt0XT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sdCl9KSkscn0sdG49e30sZW49e2dldDpmdW5jdGlvbihuLHIpe2lmKHI9PT1RKXJldHVybiBuO3ZhciBlPXAobik7aWYoIXUoZSxyKSlyZXR1cm4gZnVuY3Rpb24obixyLHQpe3ZhciBlLGk9SShyLHQpO3JldHVybiBpP1widmFsdWVcImluIGk/aS52YWx1ZTpudWxsPT09KGU9aS5nZXQpfHx2b2lkIDA9PT1lP3ZvaWQgMDplLmNhbGwobi5rKTp2b2lkIDB9KG4sZSxyKTt2YXIgaT1lW3JdO3JldHVybiBuLkl8fCF0KGkpP2k6aT09PXoobi50LHIpPyhFKG4pLG4ub1tyXT1OKG4uQS5oLGksbikpOml9LGhhczpmdW5jdGlvbihuLHIpe3JldHVybiByIGluIHAobil9LG93bktleXM6ZnVuY3Rpb24obil7cmV0dXJuIFJlZmxlY3Qub3duS2V5cyhwKG4pKX0sc2V0OmZ1bmN0aW9uKG4scix0KXt2YXIgZT1JKHAobikscik7aWYobnVsbD09ZT92b2lkIDA6ZS5zZXQpcmV0dXJuIGUuc2V0LmNhbGwobi5rLHQpLCEwO2lmKCFuLlApe3ZhciBpPXoocChuKSxyKSxvPW51bGw9PWk/dm9pZCAwOmlbUV07aWYobyYmby50PT09dClyZXR1cm4gbi5vW3JdPXQsbi5SW3JdPSExLCEwO2lmKGModCxpKSYmKHZvaWQgMCE9PXR8fHUobi50LHIpKSlyZXR1cm4hMDtFKG4pLGsobil9cmV0dXJuIG4ub1tyXT09PXQmJih2b2lkIDAhPT10fHxyIGluIG4ubyl8fE51bWJlci5pc05hTih0KSYmTnVtYmVyLmlzTmFOKG4ub1tyXSl8fChuLm9bcl09dCxuLlJbcl09ITApLCEwfSxkZWxldGVQcm9wZXJ0eTpmdW5jdGlvbihuLHIpe3JldHVybiB2b2lkIDAhPT16KG4udCxyKXx8ciBpbiBuLnQ/KG4uUltyXT0hMSxFKG4pLGsobikpOmRlbGV0ZSBuLlJbcl0sbi5vJiZkZWxldGUgbi5vW3JdLCEwfSxnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ZnVuY3Rpb24obixyKXt2YXIgdD1wKG4pLGU9UmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxyKTtyZXR1cm4gZT97d3JpdGFibGU6ITAsY29uZmlndXJhYmxlOjEhPT1uLml8fFwibGVuZ3RoXCIhPT1yLGVudW1lcmFibGU6ZS5lbnVtZXJhYmxlLHZhbHVlOnRbcl19OmV9LGRlZmluZVByb3BlcnR5OmZ1bmN0aW9uKCl7bigxMSl9LGdldFByb3RvdHlwZU9mOmZ1bmN0aW9uKG4pe3JldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobi50KX0sc2V0UHJvdG90eXBlT2Y6ZnVuY3Rpb24oKXtuKDEyKX19LG9uPXt9O2koZW4sKGZ1bmN0aW9uKG4scil7b25bbl09ZnVuY3Rpb24oKXtyZXR1cm4gYXJndW1lbnRzWzBdPWFyZ3VtZW50c1swXVswXSxyLmFwcGx5KHRoaXMsYXJndW1lbnRzKX19KSksb24uZGVsZXRlUHJvcGVydHk9ZnVuY3Rpb24ocix0KXtyZXR1cm5cInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WJiZpc05hTihwYXJzZUludCh0KSkmJm4oMTMpLG9uLnNldC5jYWxsKHRoaXMscix0LHZvaWQgMCl9LG9uLnNldD1mdW5jdGlvbihyLHQsZSl7cmV0dXJuXCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOViYmXCJsZW5ndGhcIiE9PXQmJmlzTmFOKHBhcnNlSW50KHQpKSYmbigxNCksZW4uc2V0LmNhbGwodGhpcyxyWzBdLHQsZSxyWzBdKX07dmFyIHVuPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShyKXt2YXIgZT10aGlzO3RoaXMuTz1CLHRoaXMuRD0hMCx0aGlzLnByb2R1Y2U9ZnVuY3Rpb24ocixpLG8pe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHImJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGkpe3ZhciB1PWk7aT1yO3ZhciBhPWU7cmV0dXJuIGZ1bmN0aW9uKG4pe3ZhciByPXRoaXM7dm9pZCAwPT09biYmKG49dSk7Zm9yKHZhciB0PWFyZ3VtZW50cy5sZW5ndGgsZT1BcnJheSh0PjE/dC0xOjApLG89MTtvPHQ7bysrKWVbby0xXT1hcmd1bWVudHNbb107cmV0dXJuIGEucHJvZHVjZShuLChmdW5jdGlvbihuKXt2YXIgdDtyZXR1cm4odD1pKS5jYWxsLmFwcGx5KHQsW3Isbl0uY29uY2F0KGUpKX0pKX19dmFyIGY7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgaSYmbig2KSx2b2lkIDAhPT1vJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBvJiZuKDcpLHQocikpe3ZhciBjPXcoZSkscz1OKGUscix2b2lkIDApLHY9ITA7dHJ5e2Y9aShzKSx2PSExfWZpbmFsbHl7dj9nKGMpOk8oYyl9cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFByb21pc2UmJmYgaW5zdGFuY2VvZiBQcm9taXNlP2YudGhlbigoZnVuY3Rpb24obil7cmV0dXJuIGooYyxvKSxQKG4sYyl9KSwoZnVuY3Rpb24obil7dGhyb3cgZyhjKSxufSkpOihqKGMsbyksUChmLGMpKX1pZighcnx8XCJvYmplY3RcIiE9dHlwZW9mIHIpe2lmKHZvaWQgMD09PShmPWkocikpJiYoZj1yKSxmPT09SCYmKGY9dm9pZCAwKSxlLkQmJmQoZiwhMCksbyl7dmFyIHA9W10sbD1bXTtiKFwiUGF0Y2hlc1wiKS5NKHIsZixwLGwpLG8ocCxsKX1yZXR1cm4gZn1uKDIxLHIpfSx0aGlzLnByb2R1Y2VXaXRoUGF0Y2hlcz1mdW5jdGlvbihuLHIpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIG4pcmV0dXJuIGZ1bmN0aW9uKHIpe2Zvcih2YXIgdD1hcmd1bWVudHMubGVuZ3RoLGk9QXJyYXkodD4xP3QtMTowKSxvPTE7bzx0O28rKylpW28tMV09YXJndW1lbnRzW29dO3JldHVybiBlLnByb2R1Y2VXaXRoUGF0Y2hlcyhyLChmdW5jdGlvbihyKXtyZXR1cm4gbi5hcHBseSh2b2lkIDAsW3JdLmNvbmNhdChpKSl9KSl9O3ZhciB0LGksbz1lLnByb2R1Y2UobixyLChmdW5jdGlvbihuLHIpe3Q9bixpPXJ9KSk7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFByb21pc2UmJm8gaW5zdGFuY2VvZiBQcm9taXNlP28udGhlbigoZnVuY3Rpb24obil7cmV0dXJuW24sdCxpXX0pKTpbbyx0LGldfSxcImJvb2xlYW5cIj09dHlwZW9mKG51bGw9PXI/dm9pZCAwOnIudXNlUHJveGllcykmJnRoaXMuc2V0VXNlUHJveGllcyhyLnVzZVByb3hpZXMpLFwiYm9vbGVhblwiPT10eXBlb2YobnVsbD09cj92b2lkIDA6ci5hdXRvRnJlZXplKSYmdGhpcy5zZXRBdXRvRnJlZXplKHIuYXV0b0ZyZWV6ZSl9dmFyIGk9ZS5wcm90b3R5cGU7cmV0dXJuIGkuY3JlYXRlRHJhZnQ9ZnVuY3Rpb24oZSl7dChlKXx8big4KSxyKGUpJiYoZT1SKGUpKTt2YXIgaT13KHRoaXMpLG89Tih0aGlzLGUsdm9pZCAwKTtyZXR1cm4gb1tRXS5DPSEwLE8oaSksb30saS5maW5pc2hEcmFmdD1mdW5jdGlvbihyLHQpe3ZhciBlPXImJnJbUV07XCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOViYmKGUmJmUuQ3x8big5KSxlLkkmJm4oMTApKTt2YXIgaT1lLkE7cmV0dXJuIGooaSx0KSxQKHZvaWQgMCxpKX0saS5zZXRBdXRvRnJlZXplPWZ1bmN0aW9uKG4pe3RoaXMuRD1ufSxpLnNldFVzZVByb3hpZXM9ZnVuY3Rpb24ocil7ciYmIUImJm4oMjApLHRoaXMuTz1yfSxpLmFwcGx5UGF0Y2hlcz1mdW5jdGlvbihuLHQpe3ZhciBlO2ZvcihlPXQubGVuZ3RoLTE7ZT49MDtlLS0pe3ZhciBpPXRbZV07aWYoMD09PWkucGF0aC5sZW5ndGgmJlwicmVwbGFjZVwiPT09aS5vcCl7bj1pLnZhbHVlO2JyZWFrfX1lPi0xJiYodD10LnNsaWNlKGUrMSkpO3ZhciBvPWIoXCJQYXRjaGVzXCIpLiQ7cmV0dXJuIHIobik/byhuLHQpOnRoaXMucHJvZHVjZShuLChmdW5jdGlvbihuKXtyZXR1cm4gbyhuLHQpfSkpfSxlfSgpLGFuPW5ldyB1bixmbj1hbi5wcm9kdWNlLGNuPWFuLnByb2R1Y2VXaXRoUGF0Y2hlcy5iaW5kKGFuKSxzbj1hbi5zZXRBdXRvRnJlZXplLmJpbmQoYW4pLHZuPWFuLnNldFVzZVByb3hpZXMuYmluZChhbikscG49YW4uYXBwbHlQYXRjaGVzLmJpbmQoYW4pLGxuPWFuLmNyZWF0ZURyYWZ0LmJpbmQoYW4pLGRuPWFuLmZpbmlzaERyYWZ0LmJpbmQoYW4pO2V4cG9ydCBkZWZhdWx0IGZuO2V4cG9ydHt1biBhcyBJbW1lcixwbiBhcyBhcHBseVBhdGNoZXMsSyBhcyBjYXN0RHJhZnQsJCBhcyBjYXN0SW1tdXRhYmxlLGxuIGFzIGNyZWF0ZURyYWZ0LFIgYXMgY3VycmVudCxKIGFzIGVuYWJsZUFsbFBsdWdpbnMsRiBhcyBlbmFibGVFUzUsQyBhcyBlbmFibGVNYXBTZXQsVCBhcyBlbmFibGVQYXRjaGVzLGRuIGFzIGZpbmlzaERyYWZ0LGQgYXMgZnJlZXplLEwgYXMgaW1tZXJhYmxlLHIgYXMgaXNEcmFmdCx0IGFzIGlzRHJhZnRhYmxlLEggYXMgbm90aGluZyxlIGFzIG9yaWdpbmFsLGZuIGFzIHByb2R1Y2UsY24gYXMgcHJvZHVjZVdpdGhQYXRjaGVzLHNuIGFzIHNldEF1dG9GcmVlemUsdm4gYXMgc2V0VXNlUHJveGllc307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbW1lci5lc20uanMubWFwXG4iXSwibmFtZXMiOlsibiIsInIiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJ0IiwiQXJyYXkiLCJlIiwiaSIsIlkiLCJvIiwiYXBwbHkiLCJFcnJvciIsIm1hcCIsImpvaW4iLCJRIiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJjb25zdHJ1Y3RvciIsIkZ1bmN0aW9uIiwidG9TdHJpbmciLCJaIiwiaXNBcnJheSIsIkwiLCJzIiwidiIsImtleXMiLCJubiIsImZvckVhY2giLCJ1IiwiaGFzIiwicHJvdG90eXBlIiwiYSIsImdldCIsImYiLCJzZXQiLCJhZGQiLCJjIiwiWCIsIk1hcCIsInEiLCJTZXQiLCJwIiwibCIsInNsaWNlIiwicm4iLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ2YWx1ZSIsImNyZWF0ZSIsImQiLCJ5IiwiY2xlYXIiLCJkZWxldGUiLCJoIiwiZnJlZXplIiwiaXNGcm96ZW4iLCJiIiwidG4iLCJtIiwiXyIsIlUiLCJqIiwiZyIsIk8iLCJTIiwidyIsIlAiLCJNIiwieCIsIkgiLCJBIiwiSSIsImsiLCJOIiwiUiIsImNvbmNhdCIsIkQiLCJ6IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiRSIsIkYiLCJUIiwiQyIsImVuIiwib24iLCJQcm94eSIsInJldm9jYWJsZSIsInJldm9rZSIsInByb3h5IiwiSiIsInB1c2giLCJLIiwiZnJvbSIsIkpTT04iLCJzdHJpbmdpZnkiLCJkZWZpbmVQcm9wZXJ0eSIsIk1hdGgiLCJtaW4iLCJlbnRyaWVzIiwiJCIsInBhdGgiLCJvcCIsInNwbGljZSIsInVuc2hpZnQiLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsInNpemUiLCJ2YWx1ZXMiLCJWIiwibmV4dCIsImRvbmUiLCJHIiwiVyIsIlN5bWJvbCIsIkIiLCJSZWZsZWN0IiwiZm9yIiwiaXRlcmF0b3IiLCJvd25LZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJOdW1iZXIiLCJpc05hTiIsImRlbGV0ZVByb3BlcnR5IiwicGFyc2VJbnQiLCJ1biIsInByb2R1Y2UiLCJQcm9taXNlIiwidGhlbiIsInByb2R1Y2VXaXRoUGF0Y2hlcyIsInVzZVByb3hpZXMiLCJzZXRVc2VQcm94aWVzIiwiYXV0b0ZyZWV6ZSIsInNldEF1dG9GcmVlemUiLCJjcmVhdGVEcmFmdCIsImZpbmlzaERyYWZ0IiwiYXBwbHlQYXRjaGVzIiwiYW4iLCJmbiIsImNuIiwiYmluZCIsInNuIiwidm4iLCJwbiIsImxuIiwiZG4iLCJJbW1lciIsImNhc3REcmFmdCIsImNhc3RJbW11dGFibGUiLCJjdXJyZW50IiwiZW5hYmxlQWxsUGx1Z2lucyIsImVuYWJsZUVTNSIsImVuYWJsZU1hcFNldCIsImVuYWJsZVBhdGNoZXMiLCJpbW1lcmFibGUiLCJpc0RyYWZ0IiwiaXNEcmFmdGFibGUiLCJub3RoaW5nIiwib3JpZ2luYWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/immer/dist/immer.esm.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/js-cookie/dist/js.cookie.mjs":
/*!***************************************************!*\
  !*** ./node_modules/js-cookie/dist/js.cookie.mjs ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ api; }\n/* harmony export */ });\n/*! js-cookie v3.0.5 | MIT */ /* eslint-disable no-var */ function assign(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i];\n        for(var key in source){\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\n/* eslint-enable no-var */ /* eslint-disable no-var */ var defaultConverter = {\n    read: function(value) {\n        if (value[0] === '\"') {\n            value = value.slice(1, -1);\n        }\n        return value.replace(/(%[\\dA-F]{2})+/gi, decodeURIComponent);\n    },\n    write: function(value) {\n        return encodeURIComponent(value).replace(/%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g, decodeURIComponent);\n    }\n};\n/* eslint-enable no-var */ /* eslint-disable no-var */ function init(converter, defaultAttributes) {\n    function set(name, value, attributes) {\n        if (typeof document === \"undefined\") {\n            return;\n        }\n        attributes = assign({}, defaultAttributes, attributes);\n        if (typeof attributes.expires === \"number\") {\n            attributes.expires = new Date(Date.now() + attributes.expires * 864e5);\n        }\n        if (attributes.expires) {\n            attributes.expires = attributes.expires.toUTCString();\n        }\n        name = encodeURIComponent(name).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);\n        var stringifiedAttributes = \"\";\n        for(var attributeName in attributes){\n            if (!attributes[attributeName]) {\n                continue;\n            }\n            stringifiedAttributes += \"; \" + attributeName;\n            if (attributes[attributeName] === true) {\n                continue;\n            }\n            // Considers RFC 6265 section 5.2:\n            // ...\n            // 3.  If the remaining unparsed-attributes contains a %x3B (\";\")\n            //     character:\n            // Consume the characters of the unparsed-attributes up to,\n            // not including, the first %x3B (\";\") character.\n            // ...\n            stringifiedAttributes += \"=\" + attributes[attributeName].split(\";\")[0];\n        }\n        return document.cookie = name + \"=\" + converter.write(value, name) + stringifiedAttributes;\n    }\n    function get(name) {\n        if (typeof document === \"undefined\" || arguments.length && !name) {\n            return;\n        }\n        // To prevent the for loop in the first place assign an empty array\n        // in case there are no cookies at all.\n        var cookies = document.cookie ? document.cookie.split(\"; \") : [];\n        var jar = {};\n        for(var i = 0; i < cookies.length; i++){\n            var parts = cookies[i].split(\"=\");\n            var value = parts.slice(1).join(\"=\");\n            try {\n                var found = decodeURIComponent(parts[0]);\n                jar[found] = converter.read(value, found);\n                if (name === found) {\n                    break;\n                }\n            } catch (e) {}\n        }\n        return name ? jar[name] : jar;\n    }\n    return Object.create({\n        set,\n        get,\n        remove: function(name, attributes) {\n            set(name, \"\", assign({}, attributes, {\n                expires: -1\n            }));\n        },\n        withAttributes: function(attributes) {\n            return init(this.converter, assign({}, this.attributes, attributes));\n        },\n        withConverter: function(converter) {\n            return init(assign({}, this.converter, converter), this.attributes);\n        }\n    }, {\n        attributes: {\n            value: Object.freeze(defaultAttributes)\n        },\n        converter: {\n            value: Object.freeze(converter)\n        }\n    });\n}\nvar api = init(defaultConverter, {\n    path: \"/\"\n});\n/* eslint-enable no-var */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qcy1jb29raWUvZGlzdC9qcy5jb29raWUubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSwyQkFBMkIsR0FDM0IseUJBQXlCLEdBQ3pCLFNBQVNBLE9BQVFDLE1BQU07SUFDckIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlDLFVBQVVDLE1BQU0sRUFBRUYsSUFBSztRQUN6QyxJQUFJRyxTQUFTRixTQUFTLENBQUNELEVBQUU7UUFDekIsSUFBSyxJQUFJSSxPQUFPRCxPQUFRO1lBQ3RCSixNQUFNLENBQUNLLElBQUksR0FBR0QsTUFBTSxDQUFDQyxJQUFJO1FBQzNCO0lBQ0Y7SUFDQSxPQUFPTDtBQUNUO0FBQ0Esd0JBQXdCLEdBRXhCLHlCQUF5QixHQUN6QixJQUFJTSxtQkFBbUI7SUFDckJDLE1BQU0sU0FBVUMsS0FBSztRQUNuQixJQUFJQSxLQUFLLENBQUMsRUFBRSxLQUFLLEtBQUs7WUFDcEJBLFFBQVFBLE1BQU1DLEtBQUssQ0FBQyxHQUFHLENBQUM7UUFDMUI7UUFDQSxPQUFPRCxNQUFNRSxPQUFPLENBQUMsb0JBQW9CQztJQUMzQztJQUNBQyxPQUFPLFNBQVVKLEtBQUs7UUFDcEIsT0FBT0ssbUJBQW1CTCxPQUFPRSxPQUFPLENBQ3RDLDRDQUNBQztJQUVKO0FBQ0Y7QUFDQSx3QkFBd0IsR0FFeEIseUJBQXlCLEdBRXpCLFNBQVNHLEtBQU1DLFNBQVMsRUFBRUMsaUJBQWlCO0lBQ3pDLFNBQVNDLElBQUtDLElBQUksRUFBRVYsS0FBSyxFQUFFVyxVQUFVO1FBQ25DLElBQUksT0FBT0MsYUFBYSxhQUFhO1lBQ25DO1FBQ0Y7UUFFQUQsYUFBYXBCLE9BQU8sQ0FBQyxHQUFHaUIsbUJBQW1CRztRQUUzQyxJQUFJLE9BQU9BLFdBQVdFLE9BQU8sS0FBSyxVQUFVO1lBQzFDRixXQUFXRSxPQUFPLEdBQUcsSUFBSUMsS0FBS0EsS0FBS0MsR0FBRyxLQUFLSixXQUFXRSxPQUFPLEdBQUc7UUFDbEU7UUFDQSxJQUFJRixXQUFXRSxPQUFPLEVBQUU7WUFDdEJGLFdBQVdFLE9BQU8sR0FBR0YsV0FBV0UsT0FBTyxDQUFDRyxXQUFXO1FBQ3JEO1FBRUFOLE9BQU9MLG1CQUFtQkssTUFDdkJSLE9BQU8sQ0FBQyx3QkFBd0JDLG9CQUNoQ0QsT0FBTyxDQUFDLFNBQVNlO1FBRXBCLElBQUlDLHdCQUF3QjtRQUM1QixJQUFLLElBQUlDLGlCQUFpQlIsV0FBWTtZQUNwQyxJQUFJLENBQUNBLFVBQVUsQ0FBQ1EsY0FBYyxFQUFFO2dCQUM5QjtZQUNGO1lBRUFELHlCQUF5QixPQUFPQztZQUVoQyxJQUFJUixVQUFVLENBQUNRLGNBQWMsS0FBSyxNQUFNO2dCQUN0QztZQUNGO1lBRUEsa0NBQWtDO1lBQ2xDLE1BQU07WUFDTixpRUFBaUU7WUFDakUsaUJBQWlCO1lBQ2pCLDJEQUEyRDtZQUMzRCxpREFBaUQ7WUFDakQsTUFBTTtZQUNORCx5QkFBeUIsTUFBTVAsVUFBVSxDQUFDUSxjQUFjLENBQUNDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTtRQUN4RTtRQUVBLE9BQVFSLFNBQVNTLE1BQU0sR0FDckJYLE9BQU8sTUFBTUgsVUFBVUgsS0FBSyxDQUFDSixPQUFPVSxRQUFRUTtJQUNoRDtJQUVBLFNBQVNJLElBQUtaLElBQUk7UUFDaEIsSUFBSSxPQUFPRSxhQUFhLGVBQWdCbEIsVUFBVUMsTUFBTSxJQUFJLENBQUNlLE1BQU87WUFDbEU7UUFDRjtRQUVBLG1FQUFtRTtRQUNuRSx1Q0FBdUM7UUFDdkMsSUFBSWEsVUFBVVgsU0FBU1MsTUFBTSxHQUFHVCxTQUFTUyxNQUFNLENBQUNELEtBQUssQ0FBQyxRQUFRLEVBQUU7UUFDaEUsSUFBSUksTUFBTSxDQUFDO1FBQ1gsSUFBSyxJQUFJL0IsSUFBSSxHQUFHQSxJQUFJOEIsUUFBUTVCLE1BQU0sRUFBRUYsSUFBSztZQUN2QyxJQUFJZ0MsUUFBUUYsT0FBTyxDQUFDOUIsRUFBRSxDQUFDMkIsS0FBSyxDQUFDO1lBQzdCLElBQUlwQixRQUFReUIsTUFBTXhCLEtBQUssQ0FBQyxHQUFHeUIsSUFBSSxDQUFDO1lBRWhDLElBQUk7Z0JBQ0YsSUFBSUMsUUFBUXhCLG1CQUFtQnNCLEtBQUssQ0FBQyxFQUFFO2dCQUN2Q0QsR0FBRyxDQUFDRyxNQUFNLEdBQUdwQixVQUFVUixJQUFJLENBQUNDLE9BQU8yQjtnQkFFbkMsSUFBSWpCLFNBQVNpQixPQUFPO29CQUNsQjtnQkFDRjtZQUNGLEVBQUUsT0FBT0MsR0FBRyxDQUFDO1FBQ2Y7UUFFQSxPQUFPbEIsT0FBT2MsR0FBRyxDQUFDZCxLQUFLLEdBQUdjO0lBQzVCO0lBRUEsT0FBT0ssT0FBT0MsTUFBTSxDQUNsQjtRQUNFckI7UUFDQWE7UUFDQVMsUUFBUSxTQUFVckIsSUFBSSxFQUFFQyxVQUFVO1lBQ2hDRixJQUNFQyxNQUNBLElBQ0FuQixPQUFPLENBQUMsR0FBR29CLFlBQVk7Z0JBQ3JCRSxTQUFTLENBQUM7WUFDWjtRQUVKO1FBQ0FtQixnQkFBZ0IsU0FBVXJCLFVBQVU7WUFDbEMsT0FBT0wsS0FBSyxJQUFJLENBQUNDLFNBQVMsRUFBRWhCLE9BQU8sQ0FBQyxHQUFHLElBQUksQ0FBQ29CLFVBQVUsRUFBRUE7UUFDMUQ7UUFDQXNCLGVBQWUsU0FBVTFCLFNBQVM7WUFDaEMsT0FBT0QsS0FBS2YsT0FBTyxDQUFDLEdBQUcsSUFBSSxDQUFDZ0IsU0FBUyxFQUFFQSxZQUFZLElBQUksQ0FBQ0ksVUFBVTtRQUNwRTtJQUNGLEdBQ0E7UUFDRUEsWUFBWTtZQUFFWCxPQUFPNkIsT0FBT0ssTUFBTSxDQUFDMUI7UUFBbUI7UUFDdERELFdBQVc7WUFBRVAsT0FBTzZCLE9BQU9LLE1BQU0sQ0FBQzNCO1FBQVc7SUFDL0M7QUFFSjtBQUVBLElBQUk0QixNQUFNN0IsS0FBS1Isa0JBQWtCO0lBQUVzQyxNQUFNO0FBQUk7QUFDN0Msd0JBQXdCLEdBRUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2pzLWNvb2tpZS9kaXN0L2pzLmNvb2tpZS5tanM/YTc5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEganMtY29va2llIHYzLjAuNSB8IE1JVCAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tdmFyICovXG5mdW5jdGlvbiBhc3NpZ24gKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldFxufVxuLyogZXNsaW50LWVuYWJsZSBuby12YXIgKi9cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdmFyICovXG52YXIgZGVmYXVsdENvbnZlcnRlciA9IHtcbiAgcmVhZDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlWzBdID09PSAnXCInKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEsIC0xKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoLyglW1xcZEEtRl17Mn0pKy9naSwgZGVjb2RlVVJJQ29tcG9uZW50KVxuICB9LFxuICB3cml0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkucmVwbGFjZShcbiAgICAgIC8lKDJbMzQ2QkZdfDNbQUMtRl18NDB8NVtCREVdfDYwfDdbQkNEXSkvZyxcbiAgICAgIGRlY29kZVVSSUNvbXBvbmVudFxuICAgIClcbiAgfVxufTtcbi8qIGVzbGludC1lbmFibGUgbm8tdmFyICovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXZhciAqL1xuXG5mdW5jdGlvbiBpbml0IChjb252ZXJ0ZXIsIGRlZmF1bHRBdHRyaWJ1dGVzKSB7XG4gIGZ1bmN0aW9uIHNldCAobmFtZSwgdmFsdWUsIGF0dHJpYnV0ZXMpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgYXR0cmlidXRlcyA9IGFzc2lnbih7fSwgZGVmYXVsdEF0dHJpYnV0ZXMsIGF0dHJpYnV0ZXMpO1xuXG4gICAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzLmV4cGlyZXMgPT09ICdudW1iZXInKSB7XG4gICAgICBhdHRyaWJ1dGVzLmV4cGlyZXMgPSBuZXcgRGF0ZShEYXRlLm5vdygpICsgYXR0cmlidXRlcy5leHBpcmVzICogODY0ZTUpO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlcy5leHBpcmVzKSB7XG4gICAgICBhdHRyaWJ1dGVzLmV4cGlyZXMgPSBhdHRyaWJ1dGVzLmV4cGlyZXMudG9VVENTdHJpbmcoKTtcbiAgICB9XG5cbiAgICBuYW1lID0gZW5jb2RlVVJJQ29tcG9uZW50KG5hbWUpXG4gICAgICAucmVwbGFjZSgvJSgyWzM0NkJdfDVFfDYwfDdDKS9nLCBkZWNvZGVVUklDb21wb25lbnQpXG4gICAgICAucmVwbGFjZSgvWygpXS9nLCBlc2NhcGUpO1xuXG4gICAgdmFyIHN0cmluZ2lmaWVkQXR0cmlidXRlcyA9ICcnO1xuICAgIGZvciAodmFyIGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgaWYgKCFhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIHN0cmluZ2lmaWVkQXR0cmlidXRlcyArPSAnOyAnICsgYXR0cmlidXRlTmFtZTtcblxuICAgICAgaWYgKGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0gPT09IHRydWUpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gQ29uc2lkZXJzIFJGQyA2MjY1IHNlY3Rpb24gNS4yOlxuICAgICAgLy8gLi4uXG4gICAgICAvLyAzLiAgSWYgdGhlIHJlbWFpbmluZyB1bnBhcnNlZC1hdHRyaWJ1dGVzIGNvbnRhaW5zIGEgJXgzQiAoXCI7XCIpXG4gICAgICAvLyAgICAgY2hhcmFjdGVyOlxuICAgICAgLy8gQ29uc3VtZSB0aGUgY2hhcmFjdGVycyBvZiB0aGUgdW5wYXJzZWQtYXR0cmlidXRlcyB1cCB0byxcbiAgICAgIC8vIG5vdCBpbmNsdWRpbmcsIHRoZSBmaXJzdCAleDNCIChcIjtcIikgY2hhcmFjdGVyLlxuICAgICAgLy8gLi4uXG4gICAgICBzdHJpbmdpZmllZEF0dHJpYnV0ZXMgKz0gJz0nICsgYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXS5zcGxpdCgnOycpWzBdO1xuICAgIH1cblxuICAgIHJldHVybiAoZG9jdW1lbnQuY29va2llID1cbiAgICAgIG5hbWUgKyAnPScgKyBjb252ZXJ0ZXIud3JpdGUodmFsdWUsIG5hbWUpICsgc3RyaW5naWZpZWRBdHRyaWJ1dGVzKVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0IChuYW1lKSB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgKGFyZ3VtZW50cy5sZW5ndGggJiYgIW5hbWUpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBUbyBwcmV2ZW50IHRoZSBmb3IgbG9vcCBpbiB0aGUgZmlyc3QgcGxhY2UgYXNzaWduIGFuIGVtcHR5IGFycmF5XG4gICAgLy8gaW4gY2FzZSB0aGVyZSBhcmUgbm8gY29va2llcyBhdCBhbGwuXG4gICAgdmFyIGNvb2tpZXMgPSBkb2N1bWVudC5jb29raWUgPyBkb2N1bWVudC5jb29raWUuc3BsaXQoJzsgJykgOiBbXTtcbiAgICB2YXIgamFyID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29raWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcGFydHMgPSBjb29raWVzW2ldLnNwbGl0KCc9Jyk7XG4gICAgICB2YXIgdmFsdWUgPSBwYXJ0cy5zbGljZSgxKS5qb2luKCc9Jyk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBmb3VuZCA9IGRlY29kZVVSSUNvbXBvbmVudChwYXJ0c1swXSk7XG4gICAgICAgIGphcltmb3VuZF0gPSBjb252ZXJ0ZXIucmVhZCh2YWx1ZSwgZm91bmQpO1xuXG4gICAgICAgIGlmIChuYW1lID09PSBmb3VuZCkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hbWUgPyBqYXJbbmFtZV0gOiBqYXJcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuY3JlYXRlKFxuICAgIHtcbiAgICAgIHNldCxcbiAgICAgIGdldCxcbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gKG5hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgc2V0KFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgJycsXG4gICAgICAgICAgYXNzaWduKHt9LCBhdHRyaWJ1dGVzLCB7XG4gICAgICAgICAgICBleHBpcmVzOiAtMVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgd2l0aEF0dHJpYnV0ZXM6IGZ1bmN0aW9uIChhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHJldHVybiBpbml0KHRoaXMuY29udmVydGVyLCBhc3NpZ24oe30sIHRoaXMuYXR0cmlidXRlcywgYXR0cmlidXRlcykpXG4gICAgICB9LFxuICAgICAgd2l0aENvbnZlcnRlcjogZnVuY3Rpb24gKGNvbnZlcnRlcikge1xuICAgICAgICByZXR1cm4gaW5pdChhc3NpZ24oe30sIHRoaXMuY29udmVydGVyLCBjb252ZXJ0ZXIpLCB0aGlzLmF0dHJpYnV0ZXMpXG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBhdHRyaWJ1dGVzOiB7IHZhbHVlOiBPYmplY3QuZnJlZXplKGRlZmF1bHRBdHRyaWJ1dGVzKSB9LFxuICAgICAgY29udmVydGVyOiB7IHZhbHVlOiBPYmplY3QuZnJlZXplKGNvbnZlcnRlcikgfVxuICAgIH1cbiAgKVxufVxuXG52YXIgYXBpID0gaW5pdChkZWZhdWx0Q29udmVydGVyLCB7IHBhdGg6ICcvJyB9KTtcbi8qIGVzbGludC1lbmFibGUgbm8tdmFyICovXG5cbmV4cG9ydCB7IGFwaSBhcyBkZWZhdWx0IH07XG4iXSwibmFtZXMiOlsiYXNzaWduIiwidGFyZ2V0IiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImtleSIsImRlZmF1bHRDb252ZXJ0ZXIiLCJyZWFkIiwidmFsdWUiLCJzbGljZSIsInJlcGxhY2UiLCJkZWNvZGVVUklDb21wb25lbnQiLCJ3cml0ZSIsImVuY29kZVVSSUNvbXBvbmVudCIsImluaXQiLCJjb252ZXJ0ZXIiLCJkZWZhdWx0QXR0cmlidXRlcyIsInNldCIsIm5hbWUiLCJhdHRyaWJ1dGVzIiwiZG9jdW1lbnQiLCJleHBpcmVzIiwiRGF0ZSIsIm5vdyIsInRvVVRDU3RyaW5nIiwiZXNjYXBlIiwic3RyaW5naWZpZWRBdHRyaWJ1dGVzIiwiYXR0cmlidXRlTmFtZSIsInNwbGl0IiwiY29va2llIiwiZ2V0IiwiY29va2llcyIsImphciIsInBhcnRzIiwiam9pbiIsImZvdW5kIiwiZSIsIk9iamVjdCIsImNyZWF0ZSIsInJlbW92ZSIsIndpdGhBdHRyaWJ1dGVzIiwid2l0aENvbnZlcnRlciIsImZyZWV6ZSIsImFwaSIsInBhdGgiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/js-cookie/dist/js.cookie.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-redux/dist/react-redux.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/react-redux/dist/react-redux.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Provider: function() { return /* binding */ Provider_default; },\n/* harmony export */   ReactReduxContext: function() { return /* binding */ ReactReduxContext; },\n/* harmony export */   batch: function() { return /* binding */ batch; },\n/* harmony export */   connect: function() { return /* binding */ connect_default; },\n/* harmony export */   createDispatchHook: function() { return /* binding */ createDispatchHook; },\n/* harmony export */   createSelectorHook: function() { return /* binding */ createSelectorHook; },\n/* harmony export */   createStoreHook: function() { return /* binding */ createStoreHook; },\n/* harmony export */   shallowEqual: function() { return /* binding */ shallowEqual; },\n/* harmony export */   useDispatch: function() { return /* binding */ useDispatch; },\n/* harmony export */   useSelector: function() { return /* binding */ useSelector; },\n/* harmony export */   useStore: function() { return /* binding */ useStore; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var use_sync_external_store_with_selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! use-sync-external-store/with-selector.js */ \"(app-pages-browser)/./node_modules/use-sync-external-store/with-selector.js\");\n// src/utils/react.ts\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n// src/utils/react-is.ts\nvar IS_REACT_19 = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.version.startsWith(\"19\");\nvar REACT_ELEMENT_TYPE = /* @__PURE__ */ Symbol.for(IS_REACT_19 ? \"react.transitional.element\" : \"react.element\");\nvar REACT_PORTAL_TYPE = /* @__PURE__ */ Symbol.for(\"react.portal\");\nvar REACT_FRAGMENT_TYPE = /* @__PURE__ */ Symbol.for(\"react.fragment\");\nvar REACT_STRICT_MODE_TYPE = /* @__PURE__ */ Symbol.for(\"react.strict_mode\");\nvar REACT_PROFILER_TYPE = /* @__PURE__ */ Symbol.for(\"react.profiler\");\nvar REACT_CONSUMER_TYPE = /* @__PURE__ */ Symbol.for(\"react.consumer\");\nvar REACT_CONTEXT_TYPE = /* @__PURE__ */ Symbol.for(\"react.context\");\nvar REACT_FORWARD_REF_TYPE = /* @__PURE__ */ Symbol.for(\"react.forward_ref\");\nvar REACT_SUSPENSE_TYPE = /* @__PURE__ */ Symbol.for(\"react.suspense\");\nvar REACT_SUSPENSE_LIST_TYPE = /* @__PURE__ */ Symbol.for(\"react.suspense_list\");\nvar REACT_MEMO_TYPE = /* @__PURE__ */ Symbol.for(\"react.memo\");\nvar REACT_LAZY_TYPE = /* @__PURE__ */ Symbol.for(\"react.lazy\");\nvar REACT_OFFSCREEN_TYPE = /* @__PURE__ */ Symbol.for(\"react.offscreen\");\nvar REACT_CLIENT_REFERENCE = /* @__PURE__ */ Symbol.for(\"react.client.reference\");\nvar ForwardRef = REACT_FORWARD_REF_TYPE;\nvar Memo = REACT_MEMO_TYPE;\nfunction isValidElementType(type) {\n    return typeof type === \"string\" || typeof type === \"function\" || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE || typeof type === \"object\" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || type.getModuleId !== void 0) ? true : false;\n}\nfunction typeOf(object) {\n    if (typeof object === \"object\" && object !== null) {\n        const { $$typeof } = object;\n        switch($$typeof){\n            case REACT_ELEMENT_TYPE:\n                switch(object = object.type, object){\n                    case REACT_FRAGMENT_TYPE:\n                    case REACT_PROFILER_TYPE:\n                    case REACT_STRICT_MODE_TYPE:\n                    case REACT_SUSPENSE_TYPE:\n                    case REACT_SUSPENSE_LIST_TYPE:\n                        return object;\n                    default:\n                        switch(object = object && object.$$typeof, object){\n                            case REACT_CONTEXT_TYPE:\n                            case REACT_FORWARD_REF_TYPE:\n                            case REACT_LAZY_TYPE:\n                            case REACT_MEMO_TYPE:\n                                return object;\n                            case REACT_CONSUMER_TYPE:\n                                return object;\n                            default:\n                                return $$typeof;\n                        }\n                }\n            case REACT_PORTAL_TYPE:\n                return $$typeof;\n        }\n    }\n}\nfunction isContextConsumer(object) {\n    return IS_REACT_19 ? typeOf(object) === REACT_CONSUMER_TYPE : typeOf(object) === REACT_CONTEXT_TYPE;\n}\nfunction isMemo(object) {\n    return typeOf(object) === REACT_MEMO_TYPE;\n}\n// src/utils/warning.ts\nfunction warning(message) {\n    if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n        console.error(message);\n    }\n    try {\n        throw new Error(message);\n    } catch (e) {}\n}\n// src/connect/verifySubselectors.ts\nfunction verify(selector, methodName) {\n    if (!selector) {\n        throw new Error(\"Unexpected value for \".concat(methodName, \" in connect.\"));\n    } else if (methodName === \"mapStateToProps\" || methodName === \"mapDispatchToProps\") {\n        if (!Object.prototype.hasOwnProperty.call(selector, \"dependsOnOwnProps\")) {\n            warning(\"The selector for \".concat(methodName, \" of connect did not specify a value for dependsOnOwnProps.\"));\n        }\n    }\n}\nfunction verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps) {\n    verify(mapStateToProps, \"mapStateToProps\");\n    verify(mapDispatchToProps, \"mapDispatchToProps\");\n    verify(mergeProps, \"mergeProps\");\n}\n// src/connect/selectorFactory.ts\nfunction pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, param) {\n    let { areStatesEqual, areOwnPropsEqual, areStatePropsEqual } = param;\n    let hasRunAtLeastOnce = false;\n    let state;\n    let ownProps;\n    let stateProps;\n    let dispatchProps;\n    let mergedProps;\n    function handleFirstCall(firstState, firstOwnProps) {\n        state = firstState;\n        ownProps = firstOwnProps;\n        stateProps = mapStateToProps(state, ownProps);\n        dispatchProps = mapDispatchToProps(dispatch, ownProps);\n        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n        hasRunAtLeastOnce = true;\n        return mergedProps;\n    }\n    function handleNewPropsAndNewState() {\n        stateProps = mapStateToProps(state, ownProps);\n        if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);\n        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n        return mergedProps;\n    }\n    function handleNewProps() {\n        if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);\n        if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);\n        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n        return mergedProps;\n    }\n    function handleNewState() {\n        const nextStateProps = mapStateToProps(state, ownProps);\n        const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);\n        stateProps = nextStateProps;\n        if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n        return mergedProps;\n    }\n    function handleSubsequentCalls(nextState, nextOwnProps) {\n        const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);\n        const stateChanged = !areStatesEqual(nextState, state, nextOwnProps, ownProps);\n        state = nextState;\n        ownProps = nextOwnProps;\n        if (propsChanged && stateChanged) return handleNewPropsAndNewState();\n        if (propsChanged) return handleNewProps();\n        if (stateChanged) return handleNewState();\n        return mergedProps;\n    }\n    return function pureFinalPropsSelector(nextState, nextOwnProps) {\n        return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);\n    };\n}\nfunction finalPropsSelectorFactory(dispatch, param) {\n    let { initMapStateToProps, initMapDispatchToProps, initMergeProps, ...options } = param;\n    const mapStateToProps = initMapStateToProps(dispatch, options);\n    const mapDispatchToProps = initMapDispatchToProps(dispatch, options);\n    const mergeProps = initMergeProps(dispatch, options);\n    if (true) {\n        verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps);\n    }\n    return pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);\n}\n// src/utils/bindActionCreators.ts\nfunction bindActionCreators(actionCreators, dispatch) {\n    const boundActionCreators = {};\n    for(const key in actionCreators){\n        const actionCreator = actionCreators[key];\n        if (typeof actionCreator === \"function\") {\n            boundActionCreators[key] = function() {\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                return dispatch(actionCreator(...args));\n            };\n        }\n    }\n    return boundActionCreators;\n}\n// src/utils/isPlainObject.ts\nfunction isPlainObject(obj) {\n    if (typeof obj !== \"object\" || obj === null) return false;\n    const proto = Object.getPrototypeOf(obj);\n    if (proto === null) return true;\n    let baseProto = proto;\n    while(Object.getPrototypeOf(baseProto) !== null){\n        baseProto = Object.getPrototypeOf(baseProto);\n    }\n    return proto === baseProto;\n}\n// src/utils/verifyPlainObject.ts\nfunction verifyPlainObject(value, displayName, methodName) {\n    if (!isPlainObject(value)) {\n        warning(\"\".concat(methodName, \"() in \").concat(displayName, \" must return a plain object. Instead received \").concat(value, \".\"));\n    }\n}\n// src/connect/wrapMapToProps.ts\nfunction wrapMapToPropsConstant(getConstant) {\n    return function initConstantSelector(dispatch) {\n        const constant = getConstant(dispatch);\n        function constantSelector() {\n            return constant;\n        }\n        constantSelector.dependsOnOwnProps = false;\n        return constantSelector;\n    };\n}\nfunction getDependsOnOwnProps(mapToProps) {\n    return mapToProps.dependsOnOwnProps ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;\n}\nfunction wrapMapToPropsFunc(mapToProps, methodName) {\n    return function initProxySelector(dispatch, param) {\n        let { displayName } = param;\n        const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {\n            return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch, void 0);\n        };\n        proxy.dependsOnOwnProps = true;\n        proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {\n            proxy.mapToProps = mapToProps;\n            proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);\n            let props = proxy(stateOrDispatch, ownProps);\n            if (typeof props === \"function\") {\n                proxy.mapToProps = props;\n                proxy.dependsOnOwnProps = getDependsOnOwnProps(props);\n                props = proxy(stateOrDispatch, ownProps);\n            }\n            if (true) verifyPlainObject(props, displayName, methodName);\n            return props;\n        };\n        return proxy;\n    };\n}\n// src/connect/invalidArgFactory.ts\nfunction createInvalidArgFactory(arg, name) {\n    return (dispatch, options)=>{\n        throw new Error(\"Invalid value of type \".concat(typeof arg, \" for \").concat(name, \" argument when connecting component \").concat(options.wrappedComponentName, \".\"));\n    };\n}\n// src/connect/mapDispatchToProps.ts\nfunction mapDispatchToPropsFactory(mapDispatchToProps) {\n    return mapDispatchToProps && typeof mapDispatchToProps === \"object\" ? wrapMapToPropsConstant((dispatch)=>// @ts-ignore\n        bindActionCreators(mapDispatchToProps, dispatch)) : !mapDispatchToProps ? wrapMapToPropsConstant((dispatch)=>({\n            dispatch\n        })) : typeof mapDispatchToProps === \"function\" ? // @ts-ignore\n    wrapMapToPropsFunc(mapDispatchToProps, \"mapDispatchToProps\") : createInvalidArgFactory(mapDispatchToProps, \"mapDispatchToProps\");\n}\n// src/connect/mapStateToProps.ts\nfunction mapStateToPropsFactory(mapStateToProps) {\n    return !mapStateToProps ? wrapMapToPropsConstant(()=>({})) : typeof mapStateToProps === \"function\" ? // @ts-ignore\n    wrapMapToPropsFunc(mapStateToProps, \"mapStateToProps\") : createInvalidArgFactory(mapStateToProps, \"mapStateToProps\");\n}\n// src/connect/mergeProps.ts\nfunction defaultMergeProps(stateProps, dispatchProps, ownProps) {\n    return {\n        ...ownProps,\n        ...stateProps,\n        ...dispatchProps\n    };\n}\nfunction wrapMergePropsFunc(mergeProps) {\n    return function initMergePropsProxy(dispatch, param) {\n        let { displayName, areMergedPropsEqual } = param;\n        let hasRunOnce = false;\n        let mergedProps;\n        return function mergePropsProxy(stateProps, dispatchProps, ownProps) {\n            const nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n            if (hasRunOnce) {\n                if (!areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;\n            } else {\n                hasRunOnce = true;\n                mergedProps = nextMergedProps;\n                if (true) verifyPlainObject(mergedProps, displayName, \"mergeProps\");\n            }\n            return mergedProps;\n        };\n    };\n}\nfunction mergePropsFactory(mergeProps) {\n    return !mergeProps ? ()=>defaultMergeProps : typeof mergeProps === \"function\" ? wrapMergePropsFunc(mergeProps) : createInvalidArgFactory(mergeProps, \"mergeProps\");\n}\n// src/utils/batch.ts\nfunction defaultNoopBatch(callback) {\n    callback();\n}\n// src/utils/Subscription.ts\nfunction createListenerCollection() {\n    let first = null;\n    let last = null;\n    return {\n        clear () {\n            first = null;\n            last = null;\n        },\n        notify () {\n            defaultNoopBatch(()=>{\n                let listener = first;\n                while(listener){\n                    listener.callback();\n                    listener = listener.next;\n                }\n            });\n        },\n        get () {\n            const listeners = [];\n            let listener = first;\n            while(listener){\n                listeners.push(listener);\n                listener = listener.next;\n            }\n            return listeners;\n        },\n        subscribe (callback) {\n            let isSubscribed = true;\n            const listener = last = {\n                callback,\n                next: null,\n                prev: last\n            };\n            if (listener.prev) {\n                listener.prev.next = listener;\n            } else {\n                first = listener;\n            }\n            return function unsubscribe() {\n                if (!isSubscribed || first === null) return;\n                isSubscribed = false;\n                if (listener.next) {\n                    listener.next.prev = listener.prev;\n                } else {\n                    last = listener.prev;\n                }\n                if (listener.prev) {\n                    listener.prev.next = listener.next;\n                } else {\n                    first = listener.next;\n                }\n            };\n        }\n    };\n}\nvar nullListeners = {\n    notify () {},\n    get: ()=>[]\n};\nfunction createSubscription(store, parentSub) {\n    let unsubscribe;\n    let listeners = nullListeners;\n    let subscriptionsAmount = 0;\n    let selfSubscribed = false;\n    function addNestedSub(listener) {\n        trySubscribe();\n        const cleanupListener = listeners.subscribe(listener);\n        let removed = false;\n        return ()=>{\n            if (!removed) {\n                removed = true;\n                cleanupListener();\n                tryUnsubscribe();\n            }\n        };\n    }\n    function notifyNestedSubs() {\n        listeners.notify();\n    }\n    function handleChangeWrapper() {\n        if (subscription.onStateChange) {\n            subscription.onStateChange();\n        }\n    }\n    function isSubscribed() {\n        return selfSubscribed;\n    }\n    function trySubscribe() {\n        subscriptionsAmount++;\n        if (!unsubscribe) {\n            unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);\n            listeners = createListenerCollection();\n        }\n    }\n    function tryUnsubscribe() {\n        subscriptionsAmount--;\n        if (unsubscribe && subscriptionsAmount === 0) {\n            unsubscribe();\n            unsubscribe = void 0;\n            listeners.clear();\n            listeners = nullListeners;\n        }\n    }\n    function trySubscribeSelf() {\n        if (!selfSubscribed) {\n            selfSubscribed = true;\n            trySubscribe();\n        }\n    }\n    function tryUnsubscribeSelf() {\n        if (selfSubscribed) {\n            selfSubscribed = false;\n            tryUnsubscribe();\n        }\n    }\n    const subscription = {\n        addNestedSub,\n        notifyNestedSubs,\n        handleChangeWrapper,\n        isSubscribed,\n        trySubscribe: trySubscribeSelf,\n        tryUnsubscribe: tryUnsubscribeSelf,\n        getListeners: ()=>listeners\n    };\n    return subscription;\n}\n// src/utils/useIsomorphicLayoutEffect.ts\nvar canUseDOM = ()=>!!( true && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\");\nvar isDOM = /* @__PURE__ */ canUseDOM();\nvar isRunningInReactNative = ()=>typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\";\nvar isReactNative = /* @__PURE__ */ isRunningInReactNative();\nvar getUseIsomorphicLayoutEffect = ()=>isDOM || isReactNative ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nvar useIsomorphicLayoutEffect = /* @__PURE__ */ getUseIsomorphicLayoutEffect();\n// src/utils/shallowEqual.ts\nfunction is(x, y) {\n    if (x === y) {\n        return x !== 0 || y !== 0 || 1 / x === 1 / y;\n    } else {\n        return x !== x && y !== y;\n    }\n}\nfunction shallowEqual(objA, objB) {\n    if (is(objA, objB)) return true;\n    if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n        return false;\n    }\n    const keysA = Object.keys(objA);\n    const keysB = Object.keys(objB);\n    if (keysA.length !== keysB.length) return false;\n    for(let i = 0; i < keysA.length; i++){\n        if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n            return false;\n        }\n    }\n    return true;\n}\n// src/utils/hoistStatics.ts\nvar REACT_STATICS = {\n    childContextTypes: true,\n    contextType: true,\n    contextTypes: true,\n    defaultProps: true,\n    displayName: true,\n    getDefaultProps: true,\n    getDerivedStateFromError: true,\n    getDerivedStateFromProps: true,\n    mixins: true,\n    propTypes: true,\n    type: true\n};\nvar KNOWN_STATICS = {\n    name: true,\n    length: true,\n    prototype: true,\n    caller: true,\n    callee: true,\n    arguments: true,\n    arity: true\n};\nvar FORWARD_REF_STATICS = {\n    $$typeof: true,\n    render: true,\n    defaultProps: true,\n    displayName: true,\n    propTypes: true\n};\nvar MEMO_STATICS = {\n    $$typeof: true,\n    compare: true,\n    defaultProps: true,\n    displayName: true,\n    propTypes: true,\n    type: true\n};\nvar TYPE_STATICS = {\n    [ForwardRef]: FORWARD_REF_STATICS,\n    [Memo]: MEMO_STATICS\n};\nfunction getStatics(component) {\n    if (isMemo(component)) {\n        return MEMO_STATICS;\n    }\n    return TYPE_STATICS[component[\"$$typeof\"]] || REACT_STATICS;\n}\nvar defineProperty = Object.defineProperty;\nvar getOwnPropertyNames = Object.getOwnPropertyNames;\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar getPrototypeOf = Object.getPrototypeOf;\nvar objectPrototype = Object.prototype;\nfunction hoistNonReactStatics(targetComponent, sourceComponent) {\n    if (typeof sourceComponent !== \"string\") {\n        if (objectPrototype) {\n            const inheritedComponent = getPrototypeOf(sourceComponent);\n            if (inheritedComponent && inheritedComponent !== objectPrototype) {\n                hoistNonReactStatics(targetComponent, inheritedComponent);\n            }\n        }\n        let keys = getOwnPropertyNames(sourceComponent);\n        if (getOwnPropertySymbols) {\n            keys = keys.concat(getOwnPropertySymbols(sourceComponent));\n        }\n        const targetStatics = getStatics(targetComponent);\n        const sourceStatics = getStatics(sourceComponent);\n        for(let i = 0; i < keys.length; ++i){\n            const key = keys[i];\n            if (!KNOWN_STATICS[key] && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {\n                const descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n                try {\n                    defineProperty(targetComponent, key, descriptor);\n                } catch (e) {}\n            }\n        }\n    }\n    return targetComponent;\n}\n// src/components/Context.ts\nvar ContextKey = /* @__PURE__ */ Symbol.for(\"react-redux-context\");\nvar gT = typeof globalThis !== \"undefined\" ? globalThis : /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */ {};\nfunction getContext() {\n    var _gT, _ContextKey;\n    if (!react__WEBPACK_IMPORTED_MODULE_0__.createContext) return {};\n    var _;\n    const contextMap = (_ = (_gT = gT)[_ContextKey = ContextKey]) !== null && _ !== void 0 ? _ : _gT[_ContextKey] = /* @__PURE__ */ new Map();\n    let realContext = contextMap.get(react__WEBPACK_IMPORTED_MODULE_0__.createContext);\n    if (!realContext) {\n        realContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n        if (true) {\n            realContext.displayName = \"ReactRedux\";\n        }\n        contextMap.set(react__WEBPACK_IMPORTED_MODULE_0__.createContext, realContext);\n    }\n    return realContext;\n}\nvar ReactReduxContext = /* @__PURE__ */ getContext();\n// src/components/connect.tsx\nvar NO_SUBSCRIPTION_ARRAY = [\n    null,\n    null\n];\nvar stringifyComponent = (Comp)=>{\n    try {\n        return JSON.stringify(Comp);\n    } catch (err) {\n        return String(Comp);\n    }\n};\nfunction useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {\n    _s();\n    useIsomorphicLayoutEffect(()=>effectFunc(...effectArgs), dependencies);\n}\n_s(useIsomorphicLayoutEffectWithArgs, \"Vd+jpwighRca2oU8HoLqd+zm4Bo=\", false, function() {\n    return [\n        useIsomorphicLayoutEffect\n    ];\n});\nfunction captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, childPropsFromStoreUpdate, notifyNestedSubs) {\n    lastWrapperProps.current = wrapperProps;\n    renderIsScheduled.current = false;\n    if (childPropsFromStoreUpdate.current) {\n        childPropsFromStoreUpdate.current = null;\n        notifyNestedSubs();\n    }\n}\nfunction subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, additionalSubscribeListener) {\n    if (!shouldHandleStateChanges) return ()=>{};\n    let didUnsubscribe = false;\n    let lastThrownError = null;\n    const checkForUpdates = ()=>{\n        if (didUnsubscribe || !isMounted.current) {\n            return;\n        }\n        const latestStoreState = store.getState();\n        let newChildProps, error;\n        try {\n            newChildProps = childPropsSelector(latestStoreState, lastWrapperProps.current);\n        } catch (e) {\n            error = e;\n            lastThrownError = e;\n        }\n        if (!error) {\n            lastThrownError = null;\n        }\n        if (newChildProps === lastChildProps.current) {\n            if (!renderIsScheduled.current) {\n                notifyNestedSubs();\n            }\n        } else {\n            lastChildProps.current = newChildProps;\n            childPropsFromStoreUpdate.current = newChildProps;\n            renderIsScheduled.current = true;\n            additionalSubscribeListener();\n        }\n    };\n    subscription.onStateChange = checkForUpdates;\n    subscription.trySubscribe();\n    checkForUpdates();\n    const unsubscribeWrapper = ()=>{\n        didUnsubscribe = true;\n        subscription.tryUnsubscribe();\n        subscription.onStateChange = null;\n        if (lastThrownError) {\n            throw lastThrownError;\n        }\n    };\n    return unsubscribeWrapper;\n}\nfunction strictEqual(a, b) {\n    return a === b;\n}\nvar hasWarnedAboutDeprecatedPureOption = false;\nfunction connect(mapStateToProps, mapDispatchToProps, mergeProps) {\n    let { // The `pure` option has been removed, so TS doesn't like us destructuring this to check its existence.\n    // @ts-ignore\n    pure, areStatesEqual = strictEqual, areOwnPropsEqual = shallowEqual, areStatePropsEqual = shallowEqual, areMergedPropsEqual = shallowEqual, // use React's forwardRef to expose a ref of the wrapped component\n    forwardRef = false, // the context consumer to use\n    context = ReactReduxContext } = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n    if (true) {\n        if (pure !== void 0 && !hasWarnedAboutDeprecatedPureOption) {\n            hasWarnedAboutDeprecatedPureOption = true;\n            warning('The `pure` option has been removed. `connect` is now always a \"pure/memoized\" component');\n        }\n    }\n    const Context = context;\n    const initMapStateToProps = mapStateToPropsFactory(mapStateToProps);\n    const initMapDispatchToProps = mapDispatchToPropsFactory(mapDispatchToProps);\n    const initMergeProps = mergePropsFactory(mergeProps);\n    const shouldHandleStateChanges = Boolean(mapStateToProps);\n    const wrapWithConnect = (WrappedComponent)=>{\n        var _s = $RefreshSig$();\n        if (true) {\n            const isValid = /* @__PURE__ */ isValidElementType(WrappedComponent);\n            if (!isValid) throw new Error(\"You must pass a component to the function returned by connect. Instead received \".concat(stringifyComponent(WrappedComponent)));\n        }\n        const wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || \"Component\";\n        const displayName = \"Connect(\".concat(wrappedComponentName, \")\");\n        const selectorFactoryOptions = {\n            shouldHandleStateChanges,\n            displayName,\n            wrappedComponentName,\n            WrappedComponent,\n            // @ts-ignore\n            initMapStateToProps,\n            initMapDispatchToProps,\n            initMergeProps,\n            areStatesEqual,\n            areStatePropsEqual,\n            areOwnPropsEqual,\n            areMergedPropsEqual\n        };\n        function ConnectFunction(props) {\n            _s();\n            const [propsContext, reactReduxForwardedRef, wrapperProps] = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n                const { reactReduxForwardedRef: reactReduxForwardedRef2, ...wrapperProps2 } = props;\n                return [\n                    props.context,\n                    reactReduxForwardedRef2,\n                    wrapperProps2\n                ];\n            }, [\n                props\n            ]);\n            const ContextToUse = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n                let ResultContext = Context;\n                if (propsContext === null || propsContext === void 0 ? void 0 : propsContext.Consumer) {\n                    if (true) {\n                        const isValid = /* @__PURE__ */ isContextConsumer(// @ts-ignore\n                        /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(propsContext.Consumer, null));\n                        if (!isValid) {\n                            throw new Error(\"You must pass a valid React context consumer as `props.context`\");\n                        }\n                        ResultContext = propsContext;\n                    }\n                }\n                return ResultContext;\n            }, [\n                propsContext,\n                Context\n            ]);\n            const contextValue = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ContextToUse);\n            const didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);\n            const didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);\n            if ( true && !didStoreComeFromProps && !didStoreComeFromContext) {\n                throw new Error('Could not find \"store\" in the context of \"'.concat(displayName, '\". Either wrap the root component in a <Provider>, or pass a custom React context provider to <Provider> and the corresponding React context consumer to ').concat(displayName, \" in connect options.\"));\n            }\n            const store = didStoreComeFromProps ? props.store : contextValue.store;\n            const getServerState = didStoreComeFromContext ? contextValue.getServerState : store.getState;\n            const childPropsSelector = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n                return finalPropsSelectorFactory(store.dispatch, selectorFactoryOptions);\n            }, [\n                store\n            ]);\n            const [subscription, notifyNestedSubs] = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n                if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY;\n                const subscription2 = createSubscription(store, didStoreComeFromProps ? void 0 : contextValue.subscription);\n                const notifyNestedSubs2 = subscription2.notifyNestedSubs.bind(subscription2);\n                return [\n                    subscription2,\n                    notifyNestedSubs2\n                ];\n            }, [\n                store,\n                didStoreComeFromProps,\n                contextValue\n            ]);\n            const overriddenContextValue = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n                if (didStoreComeFromProps) {\n                    return contextValue;\n                }\n                return {\n                    ...contextValue,\n                    subscription\n                };\n            }, [\n                didStoreComeFromProps,\n                contextValue,\n                subscription\n            ]);\n            const lastChildProps = react__WEBPACK_IMPORTED_MODULE_0__.useRef(void 0);\n            const lastWrapperProps = react__WEBPACK_IMPORTED_MODULE_0__.useRef(wrapperProps);\n            const childPropsFromStoreUpdate = react__WEBPACK_IMPORTED_MODULE_0__.useRef(void 0);\n            const renderIsScheduled = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n            const isMounted = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n            const latestSubscriptionCallbackError = react__WEBPACK_IMPORTED_MODULE_0__.useRef(void 0);\n            useIsomorphicLayoutEffect(()=>{\n                isMounted.current = true;\n                return ()=>{\n                    isMounted.current = false;\n                };\n            }, []);\n            const actualChildPropsSelector = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n                const selector = ()=>{\n                    if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {\n                        return childPropsFromStoreUpdate.current;\n                    }\n                    return childPropsSelector(store.getState(), wrapperProps);\n                };\n                return selector;\n            }, [\n                store,\n                wrapperProps\n            ]);\n            const subscribeForReact = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n                const subscribe = (reactListener)=>{\n                    if (!subscription) {\n                        return ()=>{};\n                    }\n                    return subscribeUpdates(shouldHandleStateChanges, store, subscription, // @ts-ignore\n                    childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, reactListener);\n                };\n                return subscribe;\n            }, [\n                subscription\n            ]);\n            useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [\n                lastWrapperProps,\n                lastChildProps,\n                renderIsScheduled,\n                wrapperProps,\n                childPropsFromStoreUpdate,\n                notifyNestedSubs\n            ]);\n            let actualChildProps;\n            try {\n                actualChildProps = react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore(// TODO We're passing through a big wrapper that does a bunch of extra side effects besides subscribing\n                subscribeForReact, // TODO This is incredibly hacky. We've already processed the store update and calculated new child props,\n                // TODO and we're just passing that through so it triggers a re-render for us rather than relying on `uSES`.\n                actualChildPropsSelector, getServerState ? ()=>childPropsSelector(getServerState(), wrapperProps) : actualChildPropsSelector);\n            } catch (err) {\n                if (latestSubscriptionCallbackError.current) {\n                    ;\n                    err.message += \"\\nThe error may be correlated with this previous error:\\n\".concat(latestSubscriptionCallbackError.current.stack, \"\\n\\n\");\n                }\n                throw err;\n            }\n            useIsomorphicLayoutEffect(()=>{\n                latestSubscriptionCallbackError.current = void 0;\n                childPropsFromStoreUpdate.current = void 0;\n                lastChildProps.current = actualChildProps;\n            });\n            const renderedWrappedComponent = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n                return(// @ts-ignore\n                /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(WrappedComponent, {\n                    ...actualChildProps,\n                    ref: reactReduxForwardedRef\n                }));\n            }, [\n                reactReduxForwardedRef,\n                WrappedComponent,\n                actualChildProps\n            ]);\n            const renderedChild = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n                if (shouldHandleStateChanges) {\n                    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ContextToUse.Provider, {\n                        value: overriddenContextValue\n                    }, renderedWrappedComponent);\n                }\n                return renderedWrappedComponent;\n            }, [\n                ContextToUse,\n                renderedWrappedComponent,\n                overriddenContextValue\n            ]);\n            return renderedChild;\n        }\n        _s(ConnectFunction, \"4g4IudS3UsRQGRunuW1/5Qci71c=\", false, function() {\n            return [\n                useIsomorphicLayoutEffect,\n                useIsomorphicLayoutEffectWithArgs,\n                useIsomorphicLayoutEffect\n            ];\n        });\n        const _Connect = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.memo(ConnectFunction);\n        const Connect = _Connect;\n        Connect.WrappedComponent = WrappedComponent;\n        Connect.displayName = ConnectFunction.displayName = displayName;\n        if (forwardRef) {\n            const _forwarded = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function forwardConnectRef(props, ref) {\n                return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Connect, {\n                    ...props,\n                    reactReduxForwardedRef: ref\n                });\n            });\n            const forwarded = _forwarded;\n            forwarded.displayName = displayName;\n            forwarded.WrappedComponent = WrappedComponent;\n            return /* @__PURE__ */ hoistNonReactStatics(forwarded, WrappedComponent);\n        }\n        return /* @__PURE__ */ hoistNonReactStatics(Connect, WrappedComponent);\n    };\n    return wrapWithConnect;\n}\nvar connect_default = connect;\n// src/components/Provider.tsx\nfunction Provider(providerProps) {\n    _s1();\n    const { children, context, serverState, store } = providerProps;\n    const contextValue = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        const subscription = createSubscription(store);\n        const baseContextValue = {\n            store,\n            subscription,\n            getServerState: serverState ? ()=>serverState : void 0\n        };\n        if (false) {} else {\n            const { identityFunctionCheck = \"once\", stabilityCheck = \"once\" } = providerProps;\n            return /* @__PURE__ */ Object.assign(baseContextValue, {\n                stabilityCheck,\n                identityFunctionCheck\n            });\n        }\n    }, [\n        store,\n        serverState\n    ]);\n    const previousState = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>store.getState(), [\n        store\n    ]);\n    useIsomorphicLayoutEffect(()=>{\n        const { subscription } = contextValue;\n        subscription.onStateChange = subscription.notifyNestedSubs;\n        subscription.trySubscribe();\n        if (previousState !== store.getState()) {\n            subscription.notifyNestedSubs();\n        }\n        return ()=>{\n            subscription.tryUnsubscribe();\n            subscription.onStateChange = void 0;\n        };\n    }, [\n        contextValue,\n        previousState\n    ]);\n    const Context = context || ReactReduxContext;\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Context.Provider, {\n        value: contextValue\n    }, children);\n}\n_s1(Provider, \"UYZUOdaFWZnoeXRb2Yd5sJGEKkk=\", false, function() {\n    return [\n        useIsomorphicLayoutEffect\n    ];\n});\n_c = Provider;\nvar Provider_default = Provider;\n// src/hooks/useReduxContext.ts\nfunction createReduxContextHook() {\n    let context = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ReactReduxContext;\n    var _s = $RefreshSig$();\n    return _s(function useReduxContext2() {\n        _s();\n        const contextValue = react__WEBPACK_IMPORTED_MODULE_0__.useContext(context);\n        if ( true && !contextValue) {\n            throw new Error(\"could not find react-redux context value; please ensure the component is wrapped in a <Provider>\");\n        }\n        return contextValue;\n    }, \"LIxFXvZbUdXE/TWxKLLXMjM3Mig=\");\n}\nvar useReduxContext = /* @__PURE__ */ createReduxContextHook();\n// src/hooks/useStore.ts\nfunction createStoreHook() {\n    let context = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ReactReduxContext;\n    var _s = $RefreshSig$();\n    const useReduxContext2 = context === ReactReduxContext ? useReduxContext : // @ts-ignore\n    createReduxContextHook(context);\n    const useStore2 = ()=>{\n        _s();\n        const { store } = useReduxContext2();\n        return store;\n    };\n    _s(useStore2, \"2zRszP8U73u9PkAgpGu7+pashzU=\", false, function() {\n        return [\n            useReduxContext2\n        ];\n    });\n    Object.assign(useStore2, {\n        withTypes: ()=>useStore2\n    });\n    return useStore2;\n}\nvar useStore = /* @__PURE__ */ createStoreHook();\n// src/hooks/useDispatch.ts\nfunction createDispatchHook() {\n    let context = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ReactReduxContext;\n    var _s = $RefreshSig$();\n    const useStore2 = context === ReactReduxContext ? useStore : createStoreHook(context);\n    const useDispatch2 = ()=>{\n        _s();\n        const store = useStore2();\n        return store.dispatch;\n    };\n    _s(useDispatch2, \"R3RnulSyf8rj5wf0vNt7XNoJlHg=\", false, function() {\n        return [\n            useStore2\n        ];\n    });\n    Object.assign(useDispatch2, {\n        withTypes: ()=>useDispatch2\n    });\n    return useDispatch2;\n}\nvar useDispatch = /* @__PURE__ */ createDispatchHook();\n// src/hooks/useSelector.ts\n\nvar refEquality = (a, b)=>a === b;\nfunction createSelectorHook() {\n    let context = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ReactReduxContext;\n    var _s = $RefreshSig$();\n    const useReduxContext2 = context === ReactReduxContext ? useReduxContext : createReduxContextHook(context);\n    const useSelector2 = function(selector) {\n        let equalityFnOrOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        _s();\n        const { equalityFn = refEquality } = typeof equalityFnOrOptions === \"function\" ? {\n            equalityFn: equalityFnOrOptions\n        } : equalityFnOrOptions;\n        if (true) {\n            if (!selector) {\n                throw new Error(\"You must pass a selector to useSelector\");\n            }\n            if (typeof selector !== \"function\") {\n                throw new Error(\"You must pass a function as a selector to useSelector\");\n            }\n            if (typeof equalityFn !== \"function\") {\n                throw new Error(\"You must pass a function as an equality function to useSelector\");\n            }\n        }\n        const reduxContext = useReduxContext2();\n        const { store, subscription, getServerState } = reduxContext;\n        const firstRun = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\n        const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback({\n            [selector.name] (state) {\n                const selected = selector(state);\n                if (true) {\n                    const { devModeChecks = {} } = typeof equalityFnOrOptions === \"function\" ? {} : equalityFnOrOptions;\n                    const { identityFunctionCheck, stabilityCheck } = reduxContext;\n                    const { identityFunctionCheck: finalIdentityFunctionCheck, stabilityCheck: finalStabilityCheck } = {\n                        stabilityCheck,\n                        identityFunctionCheck,\n                        ...devModeChecks\n                    };\n                    if (finalStabilityCheck === \"always\" || finalStabilityCheck === \"once\" && firstRun.current) {\n                        const toCompare = selector(state);\n                        if (!equalityFn(selected, toCompare)) {\n                            let stack = void 0;\n                            try {\n                                throw new Error();\n                            } catch (e) {\n                                ;\n                                ({ stack } = e);\n                            }\n                            console.warn(\"Selector \" + (selector.name || \"unknown\") + \" returned a different result when called with the same parameters. This can lead to unnecessary rerenders.\\nSelectors that return a new reference (such as an object or an array) should be memoized: https://redux.js.org/usage/deriving-data-selectors#optimizing-selectors-with-memoization\", {\n                                state,\n                                selected,\n                                selected2: toCompare,\n                                stack\n                            });\n                        }\n                    }\n                    if (finalIdentityFunctionCheck === \"always\" || finalIdentityFunctionCheck === \"once\" && firstRun.current) {\n                        if (selected === state) {\n                            let stack = void 0;\n                            try {\n                                throw new Error();\n                            } catch (e) {\n                                ;\n                                ({ stack } = e);\n                            }\n                            console.warn(\"Selector \" + (selector.name || \"unknown\") + \" returned the root state when called. This can lead to unnecessary rerenders.\\nSelectors that return the entire state are almost certainly a mistake, as they will cause a rerender whenever *anything* in state changes.\", {\n                                stack\n                            });\n                        }\n                    }\n                    if (firstRun.current) firstRun.current = false;\n                }\n                return selected;\n            }\n        }[selector.name], [\n            selector\n        ]);\n        const selectedState = (0,use_sync_external_store_with_selector_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStoreWithSelector)(subscription.addNestedSub, store.getState, getServerState || store.getState, wrappedSelector, equalityFn);\n        react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue(selectedState);\n        return selectedState;\n    };\n    _s(useSelector2, \"pswO8bVX5C2PVhO6bFfzT1FnZQs=\", false, function() {\n        return [\n            useReduxContext2,\n            use_sync_external_store_with_selector_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStoreWithSelector\n        ];\n    });\n    Object.assign(useSelector2, {\n        withTypes: ()=>useSelector2\n    });\n    return useSelector2;\n}\nvar useSelector = /* @__PURE__ */ createSelectorHook();\n// src/exports.ts\nvar batch = defaultNoopBatch;\n //# sourceMappingURL=react-redux.mjs.map\nvar _c;\n$RefreshReg$(_c, \"Provider\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9kaXN0L3JlYWN0LXJlZHV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUEscUJBQXFCOztBQUNVO0FBRS9CLHdCQUF3QjtBQUN4QixJQUFJQyxjQUFjLGFBQWEsR0FBR0QsMENBQWEsQ0FBQ0csVUFBVSxDQUFDO0FBQzNELElBQUlDLHFCQUFxQixhQUFhLEdBQUdDLE9BQU9DLEdBQUcsQ0FDakRMLGNBQWMsK0JBQStCO0FBRS9DLElBQUlNLG9CQUFvQixhQUFhLEdBQUdGLE9BQU9DLEdBQUcsQ0FBQztBQUNuRCxJQUFJRSxzQkFBc0IsYUFBYSxHQUFHSCxPQUFPQyxHQUFHLENBQUM7QUFDckQsSUFBSUcseUJBQXlCLGFBQWEsR0FBR0osT0FBT0MsR0FBRyxDQUFDO0FBQ3hELElBQUlJLHNCQUFzQixhQUFhLEdBQUdMLE9BQU9DLEdBQUcsQ0FBQztBQUNyRCxJQUFJSyxzQkFBc0IsYUFBYSxHQUFHTixPQUFPQyxHQUFHLENBQUM7QUFDckQsSUFBSU0scUJBQXFCLGFBQWEsR0FBR1AsT0FBT0MsR0FBRyxDQUFDO0FBQ3BELElBQUlPLHlCQUF5QixhQUFhLEdBQUdSLE9BQU9DLEdBQUcsQ0FBQztBQUN4RCxJQUFJUSxzQkFBc0IsYUFBYSxHQUFHVCxPQUFPQyxHQUFHLENBQUM7QUFDckQsSUFBSVMsMkJBQTJCLGFBQWEsR0FBR1YsT0FBT0MsR0FBRyxDQUN2RDtBQUVGLElBQUlVLGtCQUFrQixhQUFhLEdBQUdYLE9BQU9DLEdBQUcsQ0FBQztBQUNqRCxJQUFJVyxrQkFBa0IsYUFBYSxHQUFHWixPQUFPQyxHQUFHLENBQUM7QUFDakQsSUFBSVksdUJBQXVCLGFBQWEsR0FBR2IsT0FBT0MsR0FBRyxDQUFDO0FBQ3RELElBQUlhLHlCQUF5QixhQUFhLEdBQUdkLE9BQU9DLEdBQUcsQ0FDckQ7QUFFRixJQUFJYyxhQUFhUDtBQUNqQixJQUFJUSxPQUFPTDtBQUNYLFNB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QVEsSUFBSyxrU0FDN0M7Z0NBQ0UxRDtnQ0FDQXlSO2dDQUNBTSxXQUFXRjtnQ0FDWDdDOzRCQUNGO3dCQUVKO29CQUNGO29CQUNBLElBQUkyQywrQkFBK0IsWUFBWUEsK0JBQStCLFVBQVVMLFNBQVN6RixPQUFPLEVBQUU7d0JBQ3hHLElBQUk0RixhQUFhelIsT0FBTzs0QkFDdEIsSUFBSWdQLFFBQVEsS0FBSzs0QkFDakIsSUFBSTtnQ0FDRixNQUFNLElBQUluUTs0QkFDWixFQUFFLE9BQU9DLEdBQUc7O2dDQUVULEdBQUVrUSxLQUFLLEVBQUUsR0FBR2xRLENBQUFBOzRCQUNmOzRCQUNBSCxRQUFRbVQsSUFBSSxDQUNWLGNBQWU5UyxDQUFBQSxTQUFTMEUsSUFBSSxJQUFJLFNBQVEsSUFBSyw2TkFDN0M7Z0NBQUVzTDs0QkFBTTt3QkFFWjtvQkFDRjtvQkFDQSxJQUFJc0MsU0FBU3pGLE9BQU8sRUFBRXlGLFNBQVN6RixPQUFPLEdBQUc7Z0JBQzNDO2dCQUNBLE9BQU80RjtZQUNUO1FBQ0YsQ0FBQyxDQUFDelMsU0FBUzBFLElBQUksQ0FBQyxFQUNoQjtZQUFDMUU7U0FBUztRQUVaLE1BQU1nVCxnQkFBZ0JqQiwwR0FBZ0NBLENBQ3BENUssYUFBYVAsWUFBWSxFQUN6QkosTUFBTStHLFFBQVEsRUFDZDZCLGtCQUFrQjVJLE1BQU0rRyxRQUFRLEVBQ2hDZ0YsaUJBQ0FIO1FBRUZ6VSxnREFBbUIsQ0FBQ3FWO1FBQ3BCLE9BQU9BO0lBQ1Q7T0FyRk1kOztZQWVpQlo7WUE2RENTLHNHQUFnQ0E7OztJQVV4RDdSLE9BQU9nUixNQUFNLENBQUNnQixjQUFjO1FBQzFCUixXQUFXLElBQU1RO0lBQ25CO0lBQ0EsT0FBT0E7QUFDVDtBQUNBLElBQUlnQixjQUFjLGFBQWEsR0FBR2pCO0FBRWxDLGlCQUFpQjtBQUNqQixJQUFJa0IsUUFBUTdOO0FBYVYsQ0FDRix3Q0FBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2Rpc3QvcmVhY3QtcmVkdXgubWpzPzA0MjIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3V0aWxzL3JlYWN0LnRzXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL3V0aWxzL3JlYWN0LWlzLnRzXG52YXIgSVNfUkVBQ1RfMTkgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QudmVyc2lvbi5zdGFydHNXaXRoKFwiMTlcIik7XG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXG4gIElTX1JFQUNUXzE5ID8gXCJyZWFjdC50cmFuc2l0aW9uYWwuZWxlbWVudFwiIDogXCJyZWFjdC5lbGVtZW50XCJcbik7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKTtcbnZhciBSRUFDVF9DT05TVU1FUl9UWVBFID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJyZWFjdC5jb25zdW1lclwiKTtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIik7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIik7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIik7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXG4gIFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiXG4pO1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKTtcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIik7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcInJlYWN0Lm9mZnNjcmVlblwiKTtcbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXG4gIFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiXG4pO1xudmFyIEZvcndhcmRSZWYgPSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xudmFyIE1lbW8gPSBSRUFDVF9NRU1PX1RZUEU7XG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHR5cGUgPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9PRkZTQ1JFRU5fVFlQRSB8fCB0eXBlb2YgdHlwZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlICE9PSBudWxsICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05TVU1FUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB2b2lkIDApID8gdHJ1ZSA6IGZhbHNlO1xufVxuZnVuY3Rpb24gdHlwZU9mKG9iamVjdCkge1xuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gXCJvYmplY3RcIiAmJiBvYmplY3QgIT09IG51bGwpIHtcbiAgICBjb25zdCB7ICQkdHlwZW9mIH0gPSBvYmplY3Q7XG4gICAgc3dpdGNoICgkJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgIHN3aXRjaCAob2JqZWN0ID0gb2JqZWN0LnR5cGUsIG9iamVjdCkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHN3aXRjaCAob2JqZWN0ID0gb2JqZWN0ICYmIG9iamVjdC4kJHR5cGVvZiwgb2JqZWN0KSB7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlNVTUVSX1RZUEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGlzQ29udGV4dENvbnN1bWVyKG9iamVjdCkge1xuICByZXR1cm4gSVNfUkVBQ1RfMTkgPyB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OU1VNRVJfVFlQRSA6IHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05URVhUX1RZUEU7XG59XG5mdW5jdGlvbiBpc01lbW8ob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTUVNT19UWVBFO1xufVxuXG4vLyBzcmMvdXRpbHMvd2FybmluZy50c1xuZnVuY3Rpb24gd2FybmluZyhtZXNzYWdlKSB7XG4gIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgfVxuICB0cnkge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfSBjYXRjaCAoZSkge1xuICB9XG59XG5cbi8vIHNyYy9jb25uZWN0L3ZlcmlmeVN1YnNlbGVjdG9ycy50c1xuZnVuY3Rpb24gdmVyaWZ5KHNlbGVjdG9yLCBtZXRob2ROYW1lKSB7XG4gIGlmICghc2VsZWN0b3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgdmFsdWUgZm9yICR7bWV0aG9kTmFtZX0gaW4gY29ubmVjdC5gKTtcbiAgfSBlbHNlIGlmIChtZXRob2ROYW1lID09PSBcIm1hcFN0YXRlVG9Qcm9wc1wiIHx8IG1ldGhvZE5hbWUgPT09IFwibWFwRGlzcGF0Y2hUb1Byb3BzXCIpIHtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZWxlY3RvciwgXCJkZXBlbmRzT25Pd25Qcm9wc1wiKSkge1xuICAgICAgd2FybmluZyhcbiAgICAgICAgYFRoZSBzZWxlY3RvciBmb3IgJHttZXRob2ROYW1lfSBvZiBjb25uZWN0IGRpZCBub3Qgc3BlY2lmeSBhIHZhbHVlIGZvciBkZXBlbmRzT25Pd25Qcm9wcy5gXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdmVyaWZ5U3Vic2VsZWN0b3JzKG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzKSB7XG4gIHZlcmlmeShtYXBTdGF0ZVRvUHJvcHMsIFwibWFwU3RhdGVUb1Byb3BzXCIpO1xuICB2ZXJpZnkobWFwRGlzcGF0Y2hUb1Byb3BzLCBcIm1hcERpc3BhdGNoVG9Qcm9wc1wiKTtcbiAgdmVyaWZ5KG1lcmdlUHJvcHMsIFwibWVyZ2VQcm9wc1wiKTtcbn1cblxuLy8gc3JjL2Nvbm5lY3Qvc2VsZWN0b3JGYWN0b3J5LnRzXG5mdW5jdGlvbiBwdXJlRmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeShtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcywgZGlzcGF0Y2gsIHtcbiAgYXJlU3RhdGVzRXF1YWwsXG4gIGFyZU93blByb3BzRXF1YWwsXG4gIGFyZVN0YXRlUHJvcHNFcXVhbFxufSkge1xuICBsZXQgaGFzUnVuQXRMZWFzdE9uY2UgPSBmYWxzZTtcbiAgbGV0IHN0YXRlO1xuICBsZXQgb3duUHJvcHM7XG4gIGxldCBzdGF0ZVByb3BzO1xuICBsZXQgZGlzcGF0Y2hQcm9wcztcbiAgbGV0IG1lcmdlZFByb3BzO1xuICBmdW5jdGlvbiBoYW5kbGVGaXJzdENhbGwoZmlyc3RTdGF0ZSwgZmlyc3RPd25Qcm9wcykge1xuICAgIHN0YXRlID0gZmlyc3RTdGF0ZTtcbiAgICBvd25Qcm9wcyA9IGZpcnN0T3duUHJvcHM7XG4gICAgc3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuICAgIGRpc3BhdGNoUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICBtZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuICAgIGhhc1J1bkF0TGVhc3RPbmNlID0gdHJ1ZTtcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlTmV3UHJvcHNBbmROZXdTdGF0ZSgpIHtcbiAgICBzdGF0ZVByb3BzID0gbWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBvd25Qcm9wcyk7XG4gICAgaWYgKG1hcERpc3BhdGNoVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcylcbiAgICAgIGRpc3BhdGNoUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICBtZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVOZXdQcm9wcygpIHtcbiAgICBpZiAobWFwU3RhdGVUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzKVxuICAgICAgc3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuICAgIGlmIChtYXBEaXNwYXRjaFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMpXG4gICAgICBkaXNwYXRjaFByb3BzID0gbWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoLCBvd25Qcm9wcyk7XG4gICAgbWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlTmV3U3RhdGUoKSB7XG4gICAgY29uc3QgbmV4dFN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKTtcbiAgICBjb25zdCBzdGF0ZVByb3BzQ2hhbmdlZCA9ICFhcmVTdGF0ZVByb3BzRXF1YWwobmV4dFN0YXRlUHJvcHMsIHN0YXRlUHJvcHMpO1xuICAgIHN0YXRlUHJvcHMgPSBuZXh0U3RhdGVQcm9wcztcbiAgICBpZiAoc3RhdGVQcm9wc0NoYW5nZWQpXG4gICAgICBtZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVTdWJzZXF1ZW50Q2FsbHMobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpIHtcbiAgICBjb25zdCBwcm9wc0NoYW5nZWQgPSAhYXJlT3duUHJvcHNFcXVhbChuZXh0T3duUHJvcHMsIG93blByb3BzKTtcbiAgICBjb25zdCBzdGF0ZUNoYW5nZWQgPSAhYXJlU3RhdGVzRXF1YWwoXG4gICAgICBuZXh0U3RhdGUsXG4gICAgICBzdGF0ZSxcbiAgICAgIG5leHRPd25Qcm9wcyxcbiAgICAgIG93blByb3BzXG4gICAgKTtcbiAgICBzdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICBvd25Qcm9wcyA9IG5leHRPd25Qcm9wcztcbiAgICBpZiAocHJvcHNDaGFuZ2VkICYmIHN0YXRlQ2hhbmdlZCkgcmV0dXJuIGhhbmRsZU5ld1Byb3BzQW5kTmV3U3RhdGUoKTtcbiAgICBpZiAocHJvcHNDaGFuZ2VkKSByZXR1cm4gaGFuZGxlTmV3UHJvcHMoKTtcbiAgICBpZiAoc3RhdGVDaGFuZ2VkKSByZXR1cm4gaGFuZGxlTmV3U3RhdGUoKTtcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIHB1cmVGaW5hbFByb3BzU2VsZWN0b3IobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpIHtcbiAgICByZXR1cm4gaGFzUnVuQXRMZWFzdE9uY2UgPyBoYW5kbGVTdWJzZXF1ZW50Q2FsbHMobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpIDogaGFuZGxlRmlyc3RDYWxsKG5leHRTdGF0ZSwgbmV4dE93blByb3BzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkoZGlzcGF0Y2gsIHtcbiAgaW5pdE1hcFN0YXRlVG9Qcm9wcyxcbiAgaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyxcbiAgaW5pdE1lcmdlUHJvcHMsXG4gIC4uLm9wdGlvbnNcbn0pIHtcbiAgY29uc3QgbWFwU3RhdGVUb1Byb3BzID0gaW5pdE1hcFN0YXRlVG9Qcm9wcyhkaXNwYXRjaCwgb3B0aW9ucyk7XG4gIGNvbnN0IG1hcERpc3BhdGNoVG9Qcm9wcyA9IGluaXRNYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG9wdGlvbnMpO1xuICBjb25zdCBtZXJnZVByb3BzID0gaW5pdE1lcmdlUHJvcHMoZGlzcGF0Y2gsIG9wdGlvbnMpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmVyaWZ5U3Vic2VsZWN0b3JzKG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzKTtcbiAgfVxuICByZXR1cm4gcHVyZUZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIGRpc3BhdGNoLCBvcHRpb25zKTtcbn1cblxuLy8gc3JjL3V0aWxzL2JpbmRBY3Rpb25DcmVhdG9ycy50c1xuZnVuY3Rpb24gYmluZEFjdGlvbkNyZWF0b3JzKGFjdGlvbkNyZWF0b3JzLCBkaXNwYXRjaCkge1xuICBjb25zdCBib3VuZEFjdGlvbkNyZWF0b3JzID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIGFjdGlvbkNyZWF0b3JzKSB7XG4gICAgY29uc3QgYWN0aW9uQ3JlYXRvciA9IGFjdGlvbkNyZWF0b3JzW2tleV07XG4gICAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGJvdW5kQWN0aW9uQ3JlYXRvcnNba2V5XSA9ICguLi5hcmdzKSA9PiBkaXNwYXRjaChhY3Rpb25DcmVhdG9yKC4uLmFyZ3MpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJvdW5kQWN0aW9uQ3JlYXRvcnM7XG59XG5cbi8vIHNyYy91dGlscy9pc1BsYWluT2JqZWN0LnRzXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xuICBpZiAodHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiB8fCBvYmogPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKTtcbiAgaWYgKHByb3RvID09PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgbGV0IGJhc2VQcm90byA9IHByb3RvO1xuICB3aGlsZSAoT2JqZWN0LmdldFByb3RvdHlwZU9mKGJhc2VQcm90bykgIT09IG51bGwpIHtcbiAgICBiYXNlUHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYmFzZVByb3RvKTtcbiAgfVxuICByZXR1cm4gcHJvdG8gPT09IGJhc2VQcm90bztcbn1cblxuLy8gc3JjL3V0aWxzL3ZlcmlmeVBsYWluT2JqZWN0LnRzXG5mdW5jdGlvbiB2ZXJpZnlQbGFpbk9iamVjdCh2YWx1ZSwgZGlzcGxheU5hbWUsIG1ldGhvZE5hbWUpIHtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIHdhcm5pbmcoXG4gICAgICBgJHttZXRob2ROYW1lfSgpIGluICR7ZGlzcGxheU5hbWV9IG11c3QgcmV0dXJuIGEgcGxhaW4gb2JqZWN0LiBJbnN0ZWFkIHJlY2VpdmVkICR7dmFsdWV9LmBcbiAgICApO1xuICB9XG59XG5cbi8vIHNyYy9jb25uZWN0L3dyYXBNYXBUb1Byb3BzLnRzXG5mdW5jdGlvbiB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50KGdldENvbnN0YW50KSB7XG4gIHJldHVybiBmdW5jdGlvbiBpbml0Q29uc3RhbnRTZWxlY3RvcihkaXNwYXRjaCkge1xuICAgIGNvbnN0IGNvbnN0YW50ID0gZ2V0Q29uc3RhbnQoZGlzcGF0Y2gpO1xuICAgIGZ1bmN0aW9uIGNvbnN0YW50U2VsZWN0b3IoKSB7XG4gICAgICByZXR1cm4gY29uc3RhbnQ7XG4gICAgfVxuICAgIGNvbnN0YW50U2VsZWN0b3IuZGVwZW5kc09uT3duUHJvcHMgPSBmYWxzZTtcbiAgICByZXR1cm4gY29uc3RhbnRTZWxlY3RvcjtcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldERlcGVuZHNPbk93blByb3BzKG1hcFRvUHJvcHMpIHtcbiAgcmV0dXJuIG1hcFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMgPyBCb29sZWFuKG1hcFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMpIDogbWFwVG9Qcm9wcy5sZW5ndGggIT09IDE7XG59XG5mdW5jdGlvbiB3cmFwTWFwVG9Qcm9wc0Z1bmMobWFwVG9Qcm9wcywgbWV0aG9kTmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24gaW5pdFByb3h5U2VsZWN0b3IoZGlzcGF0Y2gsIHsgZGlzcGxheU5hbWUgfSkge1xuICAgIGNvbnN0IHByb3h5ID0gZnVuY3Rpb24gbWFwVG9Qcm9wc1Byb3h5KHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpIHtcbiAgICAgIHJldHVybiBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA/IHByb3h5Lm1hcFRvUHJvcHMoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcykgOiBwcm94eS5tYXBUb1Byb3BzKHN0YXRlT3JEaXNwYXRjaCwgdm9pZCAwKTtcbiAgICB9O1xuICAgIHByb3h5LmRlcGVuZHNPbk93blByb3BzID0gdHJ1ZTtcbiAgICBwcm94eS5tYXBUb1Byb3BzID0gZnVuY3Rpb24gZGV0ZWN0RmFjdG9yeUFuZFZlcmlmeShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKSB7XG4gICAgICBwcm94eS5tYXBUb1Byb3BzID0gbWFwVG9Qcm9wcztcbiAgICAgIHByb3h5LmRlcGVuZHNPbk93blByb3BzID0gZ2V0RGVwZW5kc09uT3duUHJvcHMobWFwVG9Qcm9wcyk7XG4gICAgICBsZXQgcHJvcHMgPSBwcm94eShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICAgIGlmICh0eXBlb2YgcHJvcHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBwcm94eS5tYXBUb1Byb3BzID0gcHJvcHM7XG4gICAgICAgIHByb3h5LmRlcGVuZHNPbk93blByb3BzID0gZ2V0RGVwZW5kc09uT3duUHJvcHMocHJvcHMpO1xuICAgICAgICBwcm9wcyA9IHByb3h5KHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpO1xuICAgICAgfVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIilcbiAgICAgICAgdmVyaWZ5UGxhaW5PYmplY3QocHJvcHMsIGRpc3BsYXlOYW1lLCBtZXRob2ROYW1lKTtcbiAgICAgIHJldHVybiBwcm9wcztcbiAgICB9O1xuICAgIHJldHVybiBwcm94eTtcbiAgfTtcbn1cblxuLy8gc3JjL2Nvbm5lY3QvaW52YWxpZEFyZ0ZhY3RvcnkudHNcbmZ1bmN0aW9uIGNyZWF0ZUludmFsaWRBcmdGYWN0b3J5KGFyZywgbmFtZSkge1xuICByZXR1cm4gKGRpc3BhdGNoLCBvcHRpb25zKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFsaWQgdmFsdWUgb2YgdHlwZSAke3R5cGVvZiBhcmd9IGZvciAke25hbWV9IGFyZ3VtZW50IHdoZW4gY29ubmVjdGluZyBjb21wb25lbnQgJHtvcHRpb25zLndyYXBwZWRDb21wb25lbnROYW1lfS5gXG4gICAgKTtcbiAgfTtcbn1cblxuLy8gc3JjL2Nvbm5lY3QvbWFwRGlzcGF0Y2hUb1Byb3BzLnRzXG5mdW5jdGlvbiBtYXBEaXNwYXRjaFRvUHJvcHNGYWN0b3J5KG1hcERpc3BhdGNoVG9Qcm9wcykge1xuICByZXR1cm4gbWFwRGlzcGF0Y2hUb1Byb3BzICYmIHR5cGVvZiBtYXBEaXNwYXRjaFRvUHJvcHMgPT09IFwib2JqZWN0XCIgPyB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50KFxuICAgIChkaXNwYXRjaCkgPT4gKFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgYmluZEFjdGlvbkNyZWF0b3JzKG1hcERpc3BhdGNoVG9Qcm9wcywgZGlzcGF0Y2gpXG4gICAgKVxuICApIDogIW1hcERpc3BhdGNoVG9Qcm9wcyA/IHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQoKGRpc3BhdGNoKSA9PiAoe1xuICAgIGRpc3BhdGNoXG4gIH0pKSA6IHR5cGVvZiBtYXBEaXNwYXRjaFRvUHJvcHMgPT09IFwiZnVuY3Rpb25cIiA/IChcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgd3JhcE1hcFRvUHJvcHNGdW5jKG1hcERpc3BhdGNoVG9Qcm9wcywgXCJtYXBEaXNwYXRjaFRvUHJvcHNcIilcbiAgKSA6IGNyZWF0ZUludmFsaWRBcmdGYWN0b3J5KG1hcERpc3BhdGNoVG9Qcm9wcywgXCJtYXBEaXNwYXRjaFRvUHJvcHNcIik7XG59XG5cbi8vIHNyYy9jb25uZWN0L21hcFN0YXRlVG9Qcm9wcy50c1xuZnVuY3Rpb24gbWFwU3RhdGVUb1Byb3BzRmFjdG9yeShtYXBTdGF0ZVRvUHJvcHMpIHtcbiAgcmV0dXJuICFtYXBTdGF0ZVRvUHJvcHMgPyB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50KCgpID0+ICh7fSkpIDogdHlwZW9mIG1hcFN0YXRlVG9Qcm9wcyA9PT0gXCJmdW5jdGlvblwiID8gKFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB3cmFwTWFwVG9Qcm9wc0Z1bmMobWFwU3RhdGVUb1Byb3BzLCBcIm1hcFN0YXRlVG9Qcm9wc1wiKVxuICApIDogY3JlYXRlSW52YWxpZEFyZ0ZhY3RvcnkobWFwU3RhdGVUb1Byb3BzLCBcIm1hcFN0YXRlVG9Qcm9wc1wiKTtcbn1cblxuLy8gc3JjL2Nvbm5lY3QvbWVyZ2VQcm9wcy50c1xuZnVuY3Rpb24gZGVmYXVsdE1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpIHtcbiAgcmV0dXJuIHsgLi4ub3duUHJvcHMsIC4uLnN0YXRlUHJvcHMsIC4uLmRpc3BhdGNoUHJvcHMgfTtcbn1cbmZ1bmN0aW9uIHdyYXBNZXJnZVByb3BzRnVuYyhtZXJnZVByb3BzKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpbml0TWVyZ2VQcm9wc1Byb3h5KGRpc3BhdGNoLCB7IGRpc3BsYXlOYW1lLCBhcmVNZXJnZWRQcm9wc0VxdWFsIH0pIHtcbiAgICBsZXQgaGFzUnVuT25jZSA9IGZhbHNlO1xuICAgIGxldCBtZXJnZWRQcm9wcztcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VQcm9wc1Byb3h5KHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKSB7XG4gICAgICBjb25zdCBuZXh0TWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcbiAgICAgIGlmIChoYXNSdW5PbmNlKSB7XG4gICAgICAgIGlmICghYXJlTWVyZ2VkUHJvcHNFcXVhbChuZXh0TWVyZ2VkUHJvcHMsIG1lcmdlZFByb3BzKSlcbiAgICAgICAgICBtZXJnZWRQcm9wcyA9IG5leHRNZXJnZWRQcm9wcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhc1J1bk9uY2UgPSB0cnVlO1xuICAgICAgICBtZXJnZWRQcm9wcyA9IG5leHRNZXJnZWRQcm9wcztcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIilcbiAgICAgICAgICB2ZXJpZnlQbGFpbk9iamVjdChtZXJnZWRQcm9wcywgZGlzcGxheU5hbWUsIFwibWVyZ2VQcm9wc1wiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgICB9O1xuICB9O1xufVxuZnVuY3Rpb24gbWVyZ2VQcm9wc0ZhY3RvcnkobWVyZ2VQcm9wcykge1xuICByZXR1cm4gIW1lcmdlUHJvcHMgPyAoKSA9PiBkZWZhdWx0TWVyZ2VQcm9wcyA6IHR5cGVvZiBtZXJnZVByb3BzID09PSBcImZ1bmN0aW9uXCIgPyB3cmFwTWVyZ2VQcm9wc0Z1bmMobWVyZ2VQcm9wcykgOiBjcmVhdGVJbnZhbGlkQXJnRmFjdG9yeShtZXJnZVByb3BzLCBcIm1lcmdlUHJvcHNcIik7XG59XG5cbi8vIHNyYy91dGlscy9iYXRjaC50c1xuZnVuY3Rpb24gZGVmYXVsdE5vb3BCYXRjaChjYWxsYmFjaykge1xuICBjYWxsYmFjaygpO1xufVxuXG4vLyBzcmMvdXRpbHMvU3Vic2NyaXB0aW9uLnRzXG5mdW5jdGlvbiBjcmVhdGVMaXN0ZW5lckNvbGxlY3Rpb24oKSB7XG4gIGxldCBmaXJzdCA9IG51bGw7XG4gIGxldCBsYXN0ID0gbnVsbDtcbiAgcmV0dXJuIHtcbiAgICBjbGVhcigpIHtcbiAgICAgIGZpcnN0ID0gbnVsbDtcbiAgICAgIGxhc3QgPSBudWxsO1xuICAgIH0sXG4gICAgbm90aWZ5KCkge1xuICAgICAgZGVmYXVsdE5vb3BCYXRjaCgoKSA9PiB7XG4gICAgICAgIGxldCBsaXN0ZW5lciA9IGZpcnN0O1xuICAgICAgICB3aGlsZSAobGlzdGVuZXIpIHtcbiAgICAgICAgICBsaXN0ZW5lci5jYWxsYmFjaygpO1xuICAgICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXIubmV4dDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXQoKSB7XG4gICAgICBjb25zdCBsaXN0ZW5lcnMgPSBbXTtcbiAgICAgIGxldCBsaXN0ZW5lciA9IGZpcnN0O1xuICAgICAgd2hpbGUgKGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5uZXh0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxpc3RlbmVycztcbiAgICB9LFxuICAgIHN1YnNjcmliZShjYWxsYmFjaykge1xuICAgICAgbGV0IGlzU3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICBjb25zdCBsaXN0ZW5lciA9IGxhc3QgPSB7XG4gICAgICAgIGNhbGxiYWNrLFxuICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgICBwcmV2OiBsYXN0XG4gICAgICB9O1xuICAgICAgaWYgKGxpc3RlbmVyLnByZXYpIHtcbiAgICAgICAgbGlzdGVuZXIucHJldi5uZXh0ID0gbGlzdGVuZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaXJzdCA9IGxpc3RlbmVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICBpZiAoIWlzU3Vic2NyaWJlZCB8fCBmaXJzdCA9PT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICBpc1N1YnNjcmliZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGxpc3RlbmVyLm5leHQpIHtcbiAgICAgICAgICBsaXN0ZW5lci5uZXh0LnByZXYgPSBsaXN0ZW5lci5wcmV2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3QgPSBsaXN0ZW5lci5wcmV2O1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaXN0ZW5lci5wcmV2KSB7XG4gICAgICAgICAgbGlzdGVuZXIucHJldi5uZXh0ID0gbGlzdGVuZXIubmV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaXJzdCA9IGxpc3RlbmVyLm5leHQ7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxudmFyIG51bGxMaXN0ZW5lcnMgPSB7XG4gIG5vdGlmeSgpIHtcbiAgfSxcbiAgZ2V0OiAoKSA9PiBbXVxufTtcbmZ1bmN0aW9uIGNyZWF0ZVN1YnNjcmlwdGlvbihzdG9yZSwgcGFyZW50U3ViKSB7XG4gIGxldCB1bnN1YnNjcmliZTtcbiAgbGV0IGxpc3RlbmVycyA9IG51bGxMaXN0ZW5lcnM7XG4gIGxldCBzdWJzY3JpcHRpb25zQW1vdW50ID0gMDtcbiAgbGV0IHNlbGZTdWJzY3JpYmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGFkZE5lc3RlZFN1YihsaXN0ZW5lcikge1xuICAgIHRyeVN1YnNjcmliZSgpO1xuICAgIGNvbnN0IGNsZWFudXBMaXN0ZW5lciA9IGxpc3RlbmVycy5zdWJzY3JpYmUobGlzdGVuZXIpO1xuICAgIGxldCByZW1vdmVkID0gZmFsc2U7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmICghcmVtb3ZlZCkge1xuICAgICAgICByZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW51cExpc3RlbmVyKCk7XG4gICAgICAgIHRyeVVuc3Vic2NyaWJlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBub3RpZnlOZXN0ZWRTdWJzKCkge1xuICAgIGxpc3RlbmVycy5ub3RpZnkoKTtcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVDaGFuZ2VXcmFwcGVyKCkge1xuICAgIGlmIChzdWJzY3JpcHRpb24ub25TdGF0ZUNoYW5nZSkge1xuICAgICAgc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaXNTdWJzY3JpYmVkKCkge1xuICAgIHJldHVybiBzZWxmU3Vic2NyaWJlZDtcbiAgfVxuICBmdW5jdGlvbiB0cnlTdWJzY3JpYmUoKSB7XG4gICAgc3Vic2NyaXB0aW9uc0Ftb3VudCsrO1xuICAgIGlmICghdW5zdWJzY3JpYmUpIHtcbiAgICAgIHVuc3Vic2NyaWJlID0gcGFyZW50U3ViID8gcGFyZW50U3ViLmFkZE5lc3RlZFN1YihoYW5kbGVDaGFuZ2VXcmFwcGVyKSA6IHN0b3JlLnN1YnNjcmliZShoYW5kbGVDaGFuZ2VXcmFwcGVyKTtcbiAgICAgIGxpc3RlbmVycyA9IGNyZWF0ZUxpc3RlbmVyQ29sbGVjdGlvbigpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0cnlVbnN1YnNjcmliZSgpIHtcbiAgICBzdWJzY3JpcHRpb25zQW1vdW50LS07XG4gICAgaWYgKHVuc3Vic2NyaWJlICYmIHN1YnNjcmlwdGlvbnNBbW91bnQgPT09IDApIHtcbiAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICB1bnN1YnNjcmliZSA9IHZvaWQgMDtcbiAgICAgIGxpc3RlbmVycy5jbGVhcigpO1xuICAgICAgbGlzdGVuZXJzID0gbnVsbExpc3RlbmVycztcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdHJ5U3Vic2NyaWJlU2VsZigpIHtcbiAgICBpZiAoIXNlbGZTdWJzY3JpYmVkKSB7XG4gICAgICBzZWxmU3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICB0cnlTdWJzY3JpYmUoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdHJ5VW5zdWJzY3JpYmVTZWxmKCkge1xuICAgIGlmIChzZWxmU3Vic2NyaWJlZCkge1xuICAgICAgc2VsZlN1YnNjcmliZWQgPSBmYWxzZTtcbiAgICAgIHRyeVVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHtcbiAgICBhZGROZXN0ZWRTdWIsXG4gICAgbm90aWZ5TmVzdGVkU3VicyxcbiAgICBoYW5kbGVDaGFuZ2VXcmFwcGVyLFxuICAgIGlzU3Vic2NyaWJlZCxcbiAgICB0cnlTdWJzY3JpYmU6IHRyeVN1YnNjcmliZVNlbGYsXG4gICAgdHJ5VW5zdWJzY3JpYmU6IHRyeVVuc3Vic2NyaWJlU2VsZixcbiAgICBnZXRMaXN0ZW5lcnM6ICgpID0+IGxpc3RlbmVyc1xuICB9O1xuICByZXR1cm4gc3Vic2NyaXB0aW9uO1xufVxuXG4vLyBzcmMvdXRpbHMvdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdC50c1xudmFyIGNhblVzZURPTSA9ICgpID0+ICEhKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09IFwidW5kZWZpbmVkXCIpO1xudmFyIGlzRE9NID0gLyogQF9fUFVSRV9fICovIGNhblVzZURPTSgpO1xudmFyIGlzUnVubmluZ0luUmVhY3ROYXRpdmUgPSAoKSA9PiB0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIG5hdmlnYXRvci5wcm9kdWN0ID09PSBcIlJlYWN0TmF0aXZlXCI7XG52YXIgaXNSZWFjdE5hdGl2ZSA9IC8qIEBfX1BVUkVfXyAqLyBpc1J1bm5pbmdJblJlYWN0TmF0aXZlKCk7XG52YXIgZ2V0VXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9ICgpID0+IGlzRE9NIHx8IGlzUmVhY3ROYXRpdmUgPyBSZWFjdC51c2VMYXlvdXRFZmZlY3QgOiBSZWFjdC51c2VFZmZlY3Q7XG52YXIgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IC8qIEBfX1BVUkVfXyAqLyBnZXRVc2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCk7XG5cbi8vIHNyYy91dGlscy9zaGFsbG93RXF1YWwudHNcbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgaWYgKHggPT09IHkpIHtcbiAgICByZXR1cm4geCAhPT0gMCB8fCB5ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICB9XG59XG5mdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICBpZiAoaXMob2JqQSwgb2JqQikpIHJldHVybiB0cnVlO1xuICBpZiAodHlwZW9mIG9iakEgIT09IFwib2JqZWN0XCIgfHwgb2JqQSA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqQiAhPT0gXCJvYmplY3RcIiB8fCBvYmpCID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIGNvbnN0IGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqQiwga2V5c0FbaV0pIHx8ICFpcyhvYmpBW2tleXNBW2ldXSwgb2JqQltrZXlzQVtpXV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBzcmMvdXRpbHMvaG9pc3RTdGF0aWNzLnRzXG52YXIgUkVBQ1RfU1RBVElDUyA9IHtcbiAgY2hpbGRDb250ZXh0VHlwZXM6IHRydWUsXG4gIGNvbnRleHRUeXBlOiB0cnVlLFxuICBjb250ZXh0VHlwZXM6IHRydWUsXG4gIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgZGlzcGxheU5hbWU6IHRydWUsXG4gIGdldERlZmF1bHRQcm9wczogdHJ1ZSxcbiAgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yOiB0cnVlLFxuICBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM6IHRydWUsXG4gIG1peGluczogdHJ1ZSxcbiAgcHJvcFR5cGVzOiB0cnVlLFxuICB0eXBlOiB0cnVlXG59O1xudmFyIEtOT1dOX1NUQVRJQ1MgPSB7XG4gIG5hbWU6IHRydWUsXG4gIGxlbmd0aDogdHJ1ZSxcbiAgcHJvdG90eXBlOiB0cnVlLFxuICBjYWxsZXI6IHRydWUsXG4gIGNhbGxlZTogdHJ1ZSxcbiAgYXJndW1lbnRzOiB0cnVlLFxuICBhcml0eTogdHJ1ZVxufTtcbnZhciBGT1JXQVJEX1JFRl9TVEFUSUNTID0ge1xuICAkJHR5cGVvZjogdHJ1ZSxcbiAgcmVuZGVyOiB0cnVlLFxuICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gIGRpc3BsYXlOYW1lOiB0cnVlLFxuICBwcm9wVHlwZXM6IHRydWVcbn07XG52YXIgTUVNT19TVEFUSUNTID0ge1xuICAkJHR5cGVvZjogdHJ1ZSxcbiAgY29tcGFyZTogdHJ1ZSxcbiAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgcHJvcFR5cGVzOiB0cnVlLFxuICB0eXBlOiB0cnVlXG59O1xudmFyIFRZUEVfU1RBVElDUyA9IHtcbiAgW0ZvcndhcmRSZWZdOiBGT1JXQVJEX1JFRl9TVEFUSUNTLFxuICBbTWVtb106IE1FTU9fU1RBVElDU1xufTtcbmZ1bmN0aW9uIGdldFN0YXRpY3MoY29tcG9uZW50KSB7XG4gIGlmIChpc01lbW8oY29tcG9uZW50KSkge1xuICAgIHJldHVybiBNRU1PX1NUQVRJQ1M7XG4gIH1cbiAgcmV0dXJuIFRZUEVfU1RBVElDU1tjb21wb25lbnRbXCIkJHR5cGVvZlwiXV0gfHwgUkVBQ1RfU1RBVElDUztcbn1cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIG9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG5mdW5jdGlvbiBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIHNvdXJjZUNvbXBvbmVudCkge1xuICBpZiAodHlwZW9mIHNvdXJjZUNvbXBvbmVudCAhPT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChvYmplY3RQcm90b3R5cGUpIHtcbiAgICAgIGNvbnN0IGluaGVyaXRlZENvbXBvbmVudCA9IGdldFByb3RvdHlwZU9mKHNvdXJjZUNvbXBvbmVudCk7XG4gICAgICBpZiAoaW5oZXJpdGVkQ29tcG9uZW50ICYmIGluaGVyaXRlZENvbXBvbmVudCAhPT0gb2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICAgIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgaW5oZXJpdGVkQ29tcG9uZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZUNvbXBvbmVudCk7XG4gICAgaWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAga2V5cyA9IGtleXMuY29uY2F0KGdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2VDb21wb25lbnQpKTtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0U3RhdGljcyA9IGdldFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50KTtcbiAgICBjb25zdCBzb3VyY2VTdGF0aWNzID0gZ2V0U3RhdGljcyhzb3VyY2VDb21wb25lbnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmICghS05PV05fU1RBVElDU1trZXldICYmICEoc291cmNlU3RhdGljcyAmJiBzb3VyY2VTdGF0aWNzW2tleV0pICYmICEodGFyZ2V0U3RhdGljcyAmJiB0YXJnZXRTdGF0aWNzW2tleV0pKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlQ29tcG9uZW50LCBrZXkpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGRlZmluZVByb3BlcnR5KHRhcmdldENvbXBvbmVudCwga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXRDb21wb25lbnQ7XG59XG5cbi8vIHNyYy9jb21wb25lbnRzL0NvbnRleHQudHNcbnZhciBDb250ZXh0S2V5ID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoYHJlYWN0LXJlZHV4LWNvbnRleHRgKTtcbnZhciBnVCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsVGhpcyA6IChcbiAgLyogZmFsbCBiYWNrIHRvIGEgcGVyLW1vZHVsZSBzY29wZSAocHJlLTguMSBiZWhhdmlvdXIpIGlmIGBnbG9iYWxUaGlzYCBpcyBub3QgYXZhaWxhYmxlICovXG4gIHt9XG4pO1xuZnVuY3Rpb24gZ2V0Q29udGV4dCgpIHtcbiAgaWYgKCFSZWFjdC5jcmVhdGVDb250ZXh0KSByZXR1cm4ge307XG4gIGNvbnN0IGNvbnRleHRNYXAgPSBnVFtDb250ZXh0S2V5XSA/Pz0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgbGV0IHJlYWxDb250ZXh0ID0gY29udGV4dE1hcC5nZXQoUmVhY3QuY3JlYXRlQ29udGV4dCk7XG4gIGlmICghcmVhbENvbnRleHQpIHtcbiAgICByZWFsQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoXG4gICAgICBudWxsXG4gICAgKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICByZWFsQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiUmVhY3RSZWR1eFwiO1xuICAgIH1cbiAgICBjb250ZXh0TWFwLnNldChSZWFjdC5jcmVhdGVDb250ZXh0LCByZWFsQ29udGV4dCk7XG4gIH1cbiAgcmV0dXJuIHJlYWxDb250ZXh0O1xufVxudmFyIFJlYWN0UmVkdXhDb250ZXh0ID0gLyogQF9fUFVSRV9fICovIGdldENvbnRleHQoKTtcblxuLy8gc3JjL2NvbXBvbmVudHMvY29ubmVjdC50c3hcbnZhciBOT19TVUJTQ1JJUFRJT05fQVJSQVkgPSBbbnVsbCwgbnVsbF07XG52YXIgc3RyaW5naWZ5Q29tcG9uZW50ID0gKENvbXApID0+IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoQ29tcCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBTdHJpbmcoQ29tcCk7XG4gIH1cbn07XG5mdW5jdGlvbiB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0V2l0aEFyZ3MoZWZmZWN0RnVuYywgZWZmZWN0QXJncywgZGVwZW5kZW5jaWVzKSB7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4gZWZmZWN0RnVuYyguLi5lZmZlY3RBcmdzKSwgZGVwZW5kZW5jaWVzKTtcbn1cbmZ1bmN0aW9uIGNhcHR1cmVXcmFwcGVyUHJvcHMobGFzdFdyYXBwZXJQcm9wcywgbGFzdENoaWxkUHJvcHMsIHJlbmRlcklzU2NoZWR1bGVkLCB3cmFwcGVyUHJvcHMsIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUsIG5vdGlmeU5lc3RlZFN1YnMpIHtcbiAgbGFzdFdyYXBwZXJQcm9wcy5jdXJyZW50ID0gd3JhcHBlclByb3BzO1xuICByZW5kZXJJc1NjaGVkdWxlZC5jdXJyZW50ID0gZmFsc2U7XG4gIGlmIChjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLmN1cnJlbnQpIHtcbiAgICBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLmN1cnJlbnQgPSBudWxsO1xuICAgIG5vdGlmeU5lc3RlZFN1YnMoKTtcbiAgfVxufVxuZnVuY3Rpb24gc3Vic2NyaWJlVXBkYXRlcyhzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMsIHN0b3JlLCBzdWJzY3JpcHRpb24sIGNoaWxkUHJvcHNTZWxlY3RvciwgbGFzdFdyYXBwZXJQcm9wcywgbGFzdENoaWxkUHJvcHMsIHJlbmRlcklzU2NoZWR1bGVkLCBpc01vdW50ZWQsIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUsIG5vdGlmeU5lc3RlZFN1YnMsIGFkZGl0aW9uYWxTdWJzY3JpYmVMaXN0ZW5lcikge1xuICBpZiAoIXNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcykgcmV0dXJuICgpID0+IHtcbiAgfTtcbiAgbGV0IGRpZFVuc3Vic2NyaWJlID0gZmFsc2U7XG4gIGxldCBsYXN0VGhyb3duRXJyb3IgPSBudWxsO1xuICBjb25zdCBjaGVja0ZvclVwZGF0ZXMgPSAoKSA9PiB7XG4gICAgaWYgKGRpZFVuc3Vic2NyaWJlIHx8ICFpc01vdW50ZWQuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYXRlc3RTdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBsZXQgbmV3Q2hpbGRQcm9wcywgZXJyb3I7XG4gICAgdHJ5IHtcbiAgICAgIG5ld0NoaWxkUHJvcHMgPSBjaGlsZFByb3BzU2VsZWN0b3IoXG4gICAgICAgIGxhdGVzdFN0b3JlU3RhdGUsXG4gICAgICAgIGxhc3RXcmFwcGVyUHJvcHMuY3VycmVudFxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvciA9IGU7XG4gICAgICBsYXN0VGhyb3duRXJyb3IgPSBlO1xuICAgIH1cbiAgICBpZiAoIWVycm9yKSB7XG4gICAgICBsYXN0VGhyb3duRXJyb3IgPSBudWxsO1xuICAgIH1cbiAgICBpZiAobmV3Q2hpbGRQcm9wcyA9PT0gbGFzdENoaWxkUHJvcHMuY3VycmVudCkge1xuICAgICAgaWYgKCFyZW5kZXJJc1NjaGVkdWxlZC5jdXJyZW50KSB7XG4gICAgICAgIG5vdGlmeU5lc3RlZFN1YnMoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdENoaWxkUHJvcHMuY3VycmVudCA9IG5ld0NoaWxkUHJvcHM7XG4gICAgICBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLmN1cnJlbnQgPSBuZXdDaGlsZFByb3BzO1xuICAgICAgcmVuZGVySXNTY2hlZHVsZWQuY3VycmVudCA9IHRydWU7XG4gICAgICBhZGRpdGlvbmFsU3Vic2NyaWJlTGlzdGVuZXIoKTtcbiAgICB9XG4gIH07XG4gIHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlID0gY2hlY2tGb3JVcGRhdGVzO1xuICBzdWJzY3JpcHRpb24udHJ5U3Vic2NyaWJlKCk7XG4gIGNoZWNrRm9yVXBkYXRlcygpO1xuICBjb25zdCB1bnN1YnNjcmliZVdyYXBwZXIgPSAoKSA9PiB7XG4gICAgZGlkVW5zdWJzY3JpYmUgPSB0cnVlO1xuICAgIHN1YnNjcmlwdGlvbi50cnlVbnN1YnNjcmliZSgpO1xuICAgIHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlID0gbnVsbDtcbiAgICBpZiAobGFzdFRocm93bkVycm9yKSB7XG4gICAgICB0aHJvdyBsYXN0VGhyb3duRXJyb3I7XG4gICAgfVxuICB9O1xuICByZXR1cm4gdW5zdWJzY3JpYmVXcmFwcGVyO1xufVxuZnVuY3Rpb24gc3RyaWN0RXF1YWwoYSwgYikge1xuICByZXR1cm4gYSA9PT0gYjtcbn1cbnZhciBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRQdXJlT3B0aW9uID0gZmFsc2U7XG5mdW5jdGlvbiBjb25uZWN0KG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzLCB7XG4gIC8vIFRoZSBgcHVyZWAgb3B0aW9uIGhhcyBiZWVuIHJlbW92ZWQsIHNvIFRTIGRvZXNuJ3QgbGlrZSB1cyBkZXN0cnVjdHVyaW5nIHRoaXMgdG8gY2hlY2sgaXRzIGV4aXN0ZW5jZS5cbiAgLy8gQHRzLWlnbm9yZVxuICBwdXJlLFxuICBhcmVTdGF0ZXNFcXVhbCA9IHN0cmljdEVxdWFsLFxuICBhcmVPd25Qcm9wc0VxdWFsID0gc2hhbGxvd0VxdWFsLFxuICBhcmVTdGF0ZVByb3BzRXF1YWwgPSBzaGFsbG93RXF1YWwsXG4gIGFyZU1lcmdlZFByb3BzRXF1YWwgPSBzaGFsbG93RXF1YWwsXG4gIC8vIHVzZSBSZWFjdCdzIGZvcndhcmRSZWYgdG8gZXhwb3NlIGEgcmVmIG9mIHRoZSB3cmFwcGVkIGNvbXBvbmVudFxuICBmb3J3YXJkUmVmID0gZmFsc2UsXG4gIC8vIHRoZSBjb250ZXh0IGNvbnN1bWVyIHRvIHVzZVxuICBjb250ZXh0ID0gUmVhY3RSZWR1eENvbnRleHRcbn0gPSB7fSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKHB1cmUgIT09IHZvaWQgMCAmJiAhaGFzV2FybmVkQWJvdXREZXByZWNhdGVkUHVyZU9wdGlvbikge1xuICAgICAgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkUHVyZU9wdGlvbiA9IHRydWU7XG4gICAgICB3YXJuaW5nKFxuICAgICAgICAnVGhlIGBwdXJlYCBvcHRpb24gaGFzIGJlZW4gcmVtb3ZlZC4gYGNvbm5lY3RgIGlzIG5vdyBhbHdheXMgYSBcInB1cmUvbWVtb2l6ZWRcIiBjb21wb25lbnQnXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBjb25zdCBDb250ZXh0ID0gY29udGV4dDtcbiAgY29uc3QgaW5pdE1hcFN0YXRlVG9Qcm9wcyA9IG1hcFN0YXRlVG9Qcm9wc0ZhY3RvcnkobWFwU3RhdGVUb1Byb3BzKTtcbiAgY29uc3QgaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyA9IG1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcnkobWFwRGlzcGF0Y2hUb1Byb3BzKTtcbiAgY29uc3QgaW5pdE1lcmdlUHJvcHMgPSBtZXJnZVByb3BzRmFjdG9yeShtZXJnZVByb3BzKTtcbiAgY29uc3Qgc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzID0gQm9vbGVhbihtYXBTdGF0ZVRvUHJvcHMpO1xuICBjb25zdCB3cmFwV2l0aENvbm5lY3QgPSAoV3JhcHBlZENvbXBvbmVudCkgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGNvbnN0IGlzVmFsaWQgPSAvKiBAX19QVVJFX18gKi8gaXNWYWxpZEVsZW1lbnRUeXBlKFdyYXBwZWRDb21wb25lbnQpO1xuICAgICAgaWYgKCFpc1ZhbGlkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFlvdSBtdXN0IHBhc3MgYSBjb21wb25lbnQgdG8gdGhlIGZ1bmN0aW9uIHJldHVybmVkIGJ5IGNvbm5lY3QuIEluc3RlYWQgcmVjZWl2ZWQgJHtzdHJpbmdpZnlDb21wb25lbnQoXG4gICAgICAgICAgICBXcmFwcGVkQ29tcG9uZW50XG4gICAgICAgICAgKX1gXG4gICAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHdyYXBwZWRDb21wb25lbnROYW1lID0gV3JhcHBlZENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBXcmFwcGVkQ29tcG9uZW50Lm5hbWUgfHwgXCJDb21wb25lbnRcIjtcbiAgICBjb25zdCBkaXNwbGF5TmFtZSA9IGBDb25uZWN0KCR7d3JhcHBlZENvbXBvbmVudE5hbWV9KWA7XG4gICAgY29uc3Qgc2VsZWN0b3JGYWN0b3J5T3B0aW9ucyA9IHtcbiAgICAgIHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcyxcbiAgICAgIGRpc3BsYXlOYW1lLFxuICAgICAgd3JhcHBlZENvbXBvbmVudE5hbWUsXG4gICAgICBXcmFwcGVkQ29tcG9uZW50LFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgaW5pdE1hcFN0YXRlVG9Qcm9wcyxcbiAgICAgIGluaXRNYXBEaXNwYXRjaFRvUHJvcHMsXG4gICAgICBpbml0TWVyZ2VQcm9wcyxcbiAgICAgIGFyZVN0YXRlc0VxdWFsLFxuICAgICAgYXJlU3RhdGVQcm9wc0VxdWFsLFxuICAgICAgYXJlT3duUHJvcHNFcXVhbCxcbiAgICAgIGFyZU1lcmdlZFByb3BzRXF1YWxcbiAgICB9O1xuICAgIGZ1bmN0aW9uIENvbm5lY3RGdW5jdGlvbihwcm9wcykge1xuICAgICAgY29uc3QgW3Byb3BzQ29udGV4dCwgcmVhY3RSZWR1eEZvcndhcmRlZFJlZiwgd3JhcHBlclByb3BzXSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHJlYWN0UmVkdXhGb3J3YXJkZWRSZWY6IHJlYWN0UmVkdXhGb3J3YXJkZWRSZWYyLCAuLi53cmFwcGVyUHJvcHMyIH0gPSBwcm9wcztcbiAgICAgICAgcmV0dXJuIFtwcm9wcy5jb250ZXh0LCByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmMiwgd3JhcHBlclByb3BzMl07XG4gICAgICB9LCBbcHJvcHNdKTtcbiAgICAgIGNvbnN0IENvbnRleHRUb1VzZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBsZXQgUmVzdWx0Q29udGV4dCA9IENvbnRleHQ7XG4gICAgICAgIGlmIChwcm9wc0NvbnRleHQ/LkNvbnN1bWVyKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3QgaXNWYWxpZCA9IC8qIEBfX1BVUkVfXyAqLyBpc0NvbnRleHRDb25zdW1lcihcbiAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChwcm9wc0NvbnRleHQuQ29uc3VtZXIsIG51bGwpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIllvdSBtdXN0IHBhc3MgYSB2YWxpZCBSZWFjdCBjb250ZXh0IGNvbnN1bWVyIGFzIGBwcm9wcy5jb250ZXh0YFwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZXN1bHRDb250ZXh0ID0gcHJvcHNDb250ZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUmVzdWx0Q29udGV4dDtcbiAgICAgIH0sIFtwcm9wc0NvbnRleHQsIENvbnRleHRdKTtcbiAgICAgIGNvbnN0IGNvbnRleHRWYWx1ZSA9IFJlYWN0LnVzZUNvbnRleHQoQ29udGV4dFRvVXNlKTtcbiAgICAgIGNvbnN0IGRpZFN0b3JlQ29tZUZyb21Qcm9wcyA9IEJvb2xlYW4ocHJvcHMuc3RvcmUpICYmIEJvb2xlYW4ocHJvcHMuc3RvcmUuZ2V0U3RhdGUpICYmIEJvb2xlYW4ocHJvcHMuc3RvcmUuZGlzcGF0Y2gpO1xuICAgICAgY29uc3QgZGlkU3RvcmVDb21lRnJvbUNvbnRleHQgPSBCb29sZWFuKGNvbnRleHRWYWx1ZSkgJiYgQm9vbGVhbihjb250ZXh0VmFsdWUuc3RvcmUpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhZGlkU3RvcmVDb21lRnJvbVByb3BzICYmICFkaWRTdG9yZUNvbWVGcm9tQ29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYENvdWxkIG5vdCBmaW5kIFwic3RvcmVcIiBpbiB0aGUgY29udGV4dCBvZiBcIiR7ZGlzcGxheU5hbWV9XCIuIEVpdGhlciB3cmFwIHRoZSByb290IGNvbXBvbmVudCBpbiBhIDxQcm92aWRlcj4sIG9yIHBhc3MgYSBjdXN0b20gUmVhY3QgY29udGV4dCBwcm92aWRlciB0byA8UHJvdmlkZXI+IGFuZCB0aGUgY29ycmVzcG9uZGluZyBSZWFjdCBjb250ZXh0IGNvbnN1bWVyIHRvICR7ZGlzcGxheU5hbWV9IGluIGNvbm5lY3Qgb3B0aW9ucy5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCBzdG9yZSA9IGRpZFN0b3JlQ29tZUZyb21Qcm9wcyA/IHByb3BzLnN0b3JlIDogY29udGV4dFZhbHVlLnN0b3JlO1xuICAgICAgY29uc3QgZ2V0U2VydmVyU3RhdGUgPSBkaWRTdG9yZUNvbWVGcm9tQ29udGV4dCA/IGNvbnRleHRWYWx1ZS5nZXRTZXJ2ZXJTdGF0ZSA6IHN0b3JlLmdldFN0YXRlO1xuICAgICAgY29uc3QgY2hpbGRQcm9wc1NlbGVjdG9yID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiBmaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5KHN0b3JlLmRpc3BhdGNoLCBzZWxlY3RvckZhY3RvcnlPcHRpb25zKTtcbiAgICAgIH0sIFtzdG9yZV0pO1xuICAgICAgY29uc3QgW3N1YnNjcmlwdGlvbiwgbm90aWZ5TmVzdGVkU3Vic10gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKCFzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMpIHJldHVybiBOT19TVUJTQ1JJUFRJT05fQVJSQVk7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbjIgPSBjcmVhdGVTdWJzY3JpcHRpb24oXG4gICAgICAgICAgc3RvcmUsXG4gICAgICAgICAgZGlkU3RvcmVDb21lRnJvbVByb3BzID8gdm9pZCAwIDogY29udGV4dFZhbHVlLnN1YnNjcmlwdGlvblxuICAgICAgICApO1xuICAgICAgICBjb25zdCBub3RpZnlOZXN0ZWRTdWJzMiA9IHN1YnNjcmlwdGlvbjIubm90aWZ5TmVzdGVkU3Vicy5iaW5kKHN1YnNjcmlwdGlvbjIpO1xuICAgICAgICByZXR1cm4gW3N1YnNjcmlwdGlvbjIsIG5vdGlmeU5lc3RlZFN1YnMyXTtcbiAgICAgIH0sIFtzdG9yZSwgZGlkU3RvcmVDb21lRnJvbVByb3BzLCBjb250ZXh0VmFsdWVdKTtcbiAgICAgIGNvbnN0IG92ZXJyaWRkZW5Db250ZXh0VmFsdWUgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKGRpZFN0b3JlQ29tZUZyb21Qcm9wcykge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5jb250ZXh0VmFsdWUsXG4gICAgICAgICAgc3Vic2NyaXB0aW9uXG4gICAgICAgIH07XG4gICAgICB9LCBbZGlkU3RvcmVDb21lRnJvbVByb3BzLCBjb250ZXh0VmFsdWUsIHN1YnNjcmlwdGlvbl0pO1xuICAgICAgY29uc3QgbGFzdENoaWxkUHJvcHMgPSBSZWFjdC51c2VSZWYodm9pZCAwKTtcbiAgICAgIGNvbnN0IGxhc3RXcmFwcGVyUHJvcHMgPSBSZWFjdC51c2VSZWYod3JhcHBlclByb3BzKTtcbiAgICAgIGNvbnN0IGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUgPSBSZWFjdC51c2VSZWYodm9pZCAwKTtcbiAgICAgIGNvbnN0IHJlbmRlcklzU2NoZWR1bGVkID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgICAgIGNvbnN0IGlzTW91bnRlZCA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gICAgICBjb25zdCBsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yID0gUmVhY3QudXNlUmVmKFxuICAgICAgICB2b2lkIDBcbiAgICAgICk7XG4gICAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgaXNNb3VudGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIGlzTW91bnRlZC5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICB9LCBbXSk7XG4gICAgICBjb25zdCBhY3R1YWxDaGlsZFByb3BzU2VsZWN0b3IgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudCAmJiB3cmFwcGVyUHJvcHMgPT09IGxhc3RXcmFwcGVyUHJvcHMuY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNoaWxkUHJvcHNTZWxlY3RvcihzdG9yZS5nZXRTdGF0ZSgpLCB3cmFwcGVyUHJvcHMpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gc2VsZWN0b3I7XG4gICAgICB9LCBbc3RvcmUsIHdyYXBwZXJQcm9wc10pO1xuICAgICAgY29uc3Qgc3Vic2NyaWJlRm9yUmVhY3QgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaWJlID0gKHJlYWN0TGlzdGVuZXIpID0+IHtcbiAgICAgICAgICBpZiAoIXN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzdWJzY3JpYmVVcGRhdGVzKFxuICAgICAgICAgICAgc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzLFxuICAgICAgICAgICAgc3RvcmUsXG4gICAgICAgICAgICBzdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjaGlsZFByb3BzU2VsZWN0b3IsXG4gICAgICAgICAgICBsYXN0V3JhcHBlclByb3BzLFxuICAgICAgICAgICAgbGFzdENoaWxkUHJvcHMsXG4gICAgICAgICAgICByZW5kZXJJc1NjaGVkdWxlZCxcbiAgICAgICAgICAgIGlzTW91bnRlZCxcbiAgICAgICAgICAgIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUsXG4gICAgICAgICAgICBub3RpZnlOZXN0ZWRTdWJzLFxuICAgICAgICAgICAgcmVhY3RMaXN0ZW5lclxuICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmU7XG4gICAgICB9LCBbc3Vic2NyaXB0aW9uXSk7XG4gICAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0V2l0aEFyZ3MoY2FwdHVyZVdyYXBwZXJQcm9wcywgW1xuICAgICAgICBsYXN0V3JhcHBlclByb3BzLFxuICAgICAgICBsYXN0Q2hpbGRQcm9wcyxcbiAgICAgICAgcmVuZGVySXNTY2hlZHVsZWQsXG4gICAgICAgIHdyYXBwZXJQcm9wcyxcbiAgICAgICAgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZSxcbiAgICAgICAgbm90aWZ5TmVzdGVkU3Vic1xuICAgICAgXSk7XG4gICAgICBsZXQgYWN0dWFsQ2hpbGRQcm9wcztcbiAgICAgIHRyeSB7XG4gICAgICAgIGFjdHVhbENoaWxkUHJvcHMgPSBSZWFjdC51c2VTeW5jRXh0ZXJuYWxTdG9yZShcbiAgICAgICAgICAvLyBUT0RPIFdlJ3JlIHBhc3NpbmcgdGhyb3VnaCBhIGJpZyB3cmFwcGVyIHRoYXQgZG9lcyBhIGJ1bmNoIG9mIGV4dHJhIHNpZGUgZWZmZWN0cyBiZXNpZGVzIHN1YnNjcmliaW5nXG4gICAgICAgICAgc3Vic2NyaWJlRm9yUmVhY3QsXG4gICAgICAgICAgLy8gVE9ETyBUaGlzIGlzIGluY3JlZGlibHkgaGFja3kuIFdlJ3ZlIGFscmVhZHkgcHJvY2Vzc2VkIHRoZSBzdG9yZSB1cGRhdGUgYW5kIGNhbGN1bGF0ZWQgbmV3IGNoaWxkIHByb3BzLFxuICAgICAgICAgIC8vIFRPRE8gYW5kIHdlJ3JlIGp1c3QgcGFzc2luZyB0aGF0IHRocm91Z2ggc28gaXQgdHJpZ2dlcnMgYSByZS1yZW5kZXIgZm9yIHVzIHJhdGhlciB0aGFuIHJlbHlpbmcgb24gYHVTRVNgLlxuICAgICAgICAgIGFjdHVhbENoaWxkUHJvcHNTZWxlY3RvcixcbiAgICAgICAgICBnZXRTZXJ2ZXJTdGF0ZSA/ICgpID0+IGNoaWxkUHJvcHNTZWxlY3RvcihnZXRTZXJ2ZXJTdGF0ZSgpLCB3cmFwcGVyUHJvcHMpIDogYWN0dWFsQ2hpbGRQcm9wc1NlbGVjdG9yXG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IuY3VycmVudCkge1xuICAgICAgICAgIDtcbiAgICAgICAgICBlcnIubWVzc2FnZSArPSBgXG5UaGUgZXJyb3IgbWF5IGJlIGNvcnJlbGF0ZWQgd2l0aCB0aGlzIHByZXZpb3VzIGVycm9yOlxuJHtsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQuc3RhY2t9XG5cbmA7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IuY3VycmVudCA9IHZvaWQgMDtcbiAgICAgICAgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50ID0gdm9pZCAwO1xuICAgICAgICBsYXN0Q2hpbGRQcm9wcy5jdXJyZW50ID0gYWN0dWFsQ2hpbGRQcm9wcztcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcmVuZGVyZWRXcmFwcGVkQ29tcG9uZW50ID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgV3JhcHBlZENvbXBvbmVudCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLi4uYWN0dWFsQ2hpbGRQcm9wcyxcbiAgICAgICAgICAgICAgcmVmOiByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfSwgW3JlYWN0UmVkdXhGb3J3YXJkZWRSZWYsIFdyYXBwZWRDb21wb25lbnQsIGFjdHVhbENoaWxkUHJvcHNdKTtcbiAgICAgIGNvbnN0IHJlbmRlcmVkQ2hpbGQgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcykge1xuICAgICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0VG9Vc2UuUHJvdmlkZXIsIHsgdmFsdWU6IG92ZXJyaWRkZW5Db250ZXh0VmFsdWUgfSwgcmVuZGVyZWRXcmFwcGVkQ29tcG9uZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVuZGVyZWRXcmFwcGVkQ29tcG9uZW50O1xuICAgICAgfSwgW0NvbnRleHRUb1VzZSwgcmVuZGVyZWRXcmFwcGVkQ29tcG9uZW50LCBvdmVycmlkZGVuQ29udGV4dFZhbHVlXSk7XG4gICAgICByZXR1cm4gcmVuZGVyZWRDaGlsZDtcbiAgICB9XG4gICAgY29uc3QgX0Nvbm5lY3QgPSBSZWFjdC5tZW1vKENvbm5lY3RGdW5jdGlvbik7XG4gICAgY29uc3QgQ29ubmVjdCA9IF9Db25uZWN0O1xuICAgIENvbm5lY3QuV3JhcHBlZENvbXBvbmVudCA9IFdyYXBwZWRDb21wb25lbnQ7XG4gICAgQ29ubmVjdC5kaXNwbGF5TmFtZSA9IENvbm5lY3RGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICAgIGlmIChmb3J3YXJkUmVmKSB7XG4gICAgICBjb25zdCBfZm9yd2FyZGVkID0gUmVhY3QuZm9yd2FyZFJlZihcbiAgICAgICAgZnVuY3Rpb24gZm9yd2FyZENvbm5lY3RSZWYocHJvcHMsIHJlZikge1xuICAgICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChDb25uZWN0LCB7IC4uLnByb3BzLCByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmOiByZWYgfSk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBjb25zdCBmb3J3YXJkZWQgPSBfZm9yd2FyZGVkO1xuICAgICAgZm9yd2FyZGVkLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gICAgICBmb3J3YXJkZWQuV3JhcHBlZENvbXBvbmVudCA9IFdyYXBwZWRDb21wb25lbnQ7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKGZvcndhcmRlZCwgV3JhcHBlZENvbXBvbmVudCk7XG4gICAgfVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gaG9pc3ROb25SZWFjdFN0YXRpY3MoQ29ubmVjdCwgV3JhcHBlZENvbXBvbmVudCk7XG4gIH07XG4gIHJldHVybiB3cmFwV2l0aENvbm5lY3Q7XG59XG52YXIgY29ubmVjdF9kZWZhdWx0ID0gY29ubmVjdDtcblxuLy8gc3JjL2NvbXBvbmVudHMvUHJvdmlkZXIudHN4XG5mdW5jdGlvbiBQcm92aWRlcihwcm92aWRlclByb3BzKSB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIGNvbnRleHQsIHNlcnZlclN0YXRlLCBzdG9yZSB9ID0gcHJvdmlkZXJQcm9wcztcbiAgY29uc3QgY29udGV4dFZhbHVlID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gY3JlYXRlU3Vic2NyaXB0aW9uKHN0b3JlKTtcbiAgICBjb25zdCBiYXNlQ29udGV4dFZhbHVlID0ge1xuICAgICAgc3RvcmUsXG4gICAgICBzdWJzY3JpcHRpb24sXG4gICAgICBnZXRTZXJ2ZXJTdGF0ZTogc2VydmVyU3RhdGUgPyAoKSA9PiBzZXJ2ZXJTdGF0ZSA6IHZvaWQgMFxuICAgIH07XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgcmV0dXJuIGJhc2VDb250ZXh0VmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHsgaWRlbnRpdHlGdW5jdGlvbkNoZWNrID0gXCJvbmNlXCIsIHN0YWJpbGl0eUNoZWNrID0gXCJvbmNlXCIgfSA9IHByb3ZpZGVyUHJvcHM7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIE9iamVjdC5hc3NpZ24oYmFzZUNvbnRleHRWYWx1ZSwge1xuICAgICAgICBzdGFiaWxpdHlDaGVjayxcbiAgICAgICAgaWRlbnRpdHlGdW5jdGlvbkNoZWNrXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtzdG9yZSwgc2VydmVyU3RhdGVdKTtcbiAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gc3RvcmUuZ2V0U3RhdGUoKSwgW3N0b3JlXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHsgc3Vic2NyaXB0aW9uIH0gPSBjb250ZXh0VmFsdWU7XG4gICAgc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UgPSBzdWJzY3JpcHRpb24ubm90aWZ5TmVzdGVkU3VicztcbiAgICBzdWJzY3JpcHRpb24udHJ5U3Vic2NyaWJlKCk7XG4gICAgaWYgKHByZXZpb3VzU3RhdGUgIT09IHN0b3JlLmdldFN0YXRlKCkpIHtcbiAgICAgIHN1YnNjcmlwdGlvbi5ub3RpZnlOZXN0ZWRTdWJzKCk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzdWJzY3JpcHRpb24udHJ5VW5zdWJzY3JpYmUoKTtcbiAgICAgIHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlID0gdm9pZCAwO1xuICAgIH07XG4gIH0sIFtjb250ZXh0VmFsdWUsIHByZXZpb3VzU3RhdGVdKTtcbiAgY29uc3QgQ29udGV4dCA9IGNvbnRleHQgfHwgUmVhY3RSZWR1eENvbnRleHQ7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjb250ZXh0VmFsdWUgfSwgY2hpbGRyZW4pO1xufVxudmFyIFByb3ZpZGVyX2RlZmF1bHQgPSBQcm92aWRlcjtcblxuLy8gc3JjL2hvb2tzL3VzZVJlZHV4Q29udGV4dC50c1xuZnVuY3Rpb24gY3JlYXRlUmVkdXhDb250ZXh0SG9vayhjb250ZXh0ID0gUmVhY3RSZWR1eENvbnRleHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVzZVJlZHV4Q29udGV4dDIoKSB7XG4gICAgY29uc3QgY29udGV4dFZhbHVlID0gUmVhY3QudXNlQ29udGV4dChjb250ZXh0KTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFjb250ZXh0VmFsdWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJjb3VsZCBub3QgZmluZCByZWFjdC1yZWR1eCBjb250ZXh0IHZhbHVlOyBwbGVhc2UgZW5zdXJlIHRoZSBjb21wb25lbnQgaXMgd3JhcHBlZCBpbiBhIDxQcm92aWRlcj5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHRWYWx1ZTtcbiAgfTtcbn1cbnZhciB1c2VSZWR1eENvbnRleHQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlUmVkdXhDb250ZXh0SG9vaygpO1xuXG4vLyBzcmMvaG9va3MvdXNlU3RvcmUudHNcbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlSG9vayhjb250ZXh0ID0gUmVhY3RSZWR1eENvbnRleHQpIHtcbiAgY29uc3QgdXNlUmVkdXhDb250ZXh0MiA9IGNvbnRleHQgPT09IFJlYWN0UmVkdXhDb250ZXh0ID8gdXNlUmVkdXhDb250ZXh0IDogKFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjcmVhdGVSZWR1eENvbnRleHRIb29rKGNvbnRleHQpXG4gICk7XG4gIGNvbnN0IHVzZVN0b3JlMiA9ICgpID0+IHtcbiAgICBjb25zdCB7IHN0b3JlIH0gPSB1c2VSZWR1eENvbnRleHQyKCk7XG4gICAgcmV0dXJuIHN0b3JlO1xuICB9O1xuICBPYmplY3QuYXNzaWduKHVzZVN0b3JlMiwge1xuICAgIHdpdGhUeXBlczogKCkgPT4gdXNlU3RvcmUyXG4gIH0pO1xuICByZXR1cm4gdXNlU3RvcmUyO1xufVxudmFyIHVzZVN0b3JlID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZVN0b3JlSG9vaygpO1xuXG4vLyBzcmMvaG9va3MvdXNlRGlzcGF0Y2gudHNcbmZ1bmN0aW9uIGNyZWF0ZURpc3BhdGNoSG9vayhjb250ZXh0ID0gUmVhY3RSZWR1eENvbnRleHQpIHtcbiAgY29uc3QgdXNlU3RvcmUyID0gY29udGV4dCA9PT0gUmVhY3RSZWR1eENvbnRleHQgPyB1c2VTdG9yZSA6IGNyZWF0ZVN0b3JlSG9vayhjb250ZXh0KTtcbiAgY29uc3QgdXNlRGlzcGF0Y2gyID0gKCkgPT4ge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmUyKCk7XG4gICAgcmV0dXJuIHN0b3JlLmRpc3BhdGNoO1xuICB9O1xuICBPYmplY3QuYXNzaWduKHVzZURpc3BhdGNoMiwge1xuICAgIHdpdGhUeXBlczogKCkgPT4gdXNlRGlzcGF0Y2gyXG4gIH0pO1xuICByZXR1cm4gdXNlRGlzcGF0Y2gyO1xufVxudmFyIHVzZURpc3BhdGNoID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZURpc3BhdGNoSG9vaygpO1xuXG4vLyBzcmMvaG9va3MvdXNlU2VsZWN0b3IudHNcbmltcG9ydCB7IHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yIH0gZnJvbSBcInVzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3dpdGgtc2VsZWN0b3IuanNcIjtcbnZhciByZWZFcXVhbGl0eSA9IChhLCBiKSA9PiBhID09PSBiO1xuZnVuY3Rpb24gY3JlYXRlU2VsZWN0b3JIb29rKGNvbnRleHQgPSBSZWFjdFJlZHV4Q29udGV4dCkge1xuICBjb25zdCB1c2VSZWR1eENvbnRleHQyID0gY29udGV4dCA9PT0gUmVhY3RSZWR1eENvbnRleHQgPyB1c2VSZWR1eENvbnRleHQgOiBjcmVhdGVSZWR1eENvbnRleHRIb29rKGNvbnRleHQpO1xuICBjb25zdCB1c2VTZWxlY3RvcjIgPSAoc2VsZWN0b3IsIGVxdWFsaXR5Rm5Pck9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IHsgZXF1YWxpdHlGbiA9IHJlZkVxdWFsaXR5IH0gPSB0eXBlb2YgZXF1YWxpdHlGbk9yT3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiID8geyBlcXVhbGl0eUZuOiBlcXVhbGl0eUZuT3JPcHRpb25zIH0gOiBlcXVhbGl0eUZuT3JPcHRpb25zO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgbXVzdCBwYXNzIGEgc2VsZWN0b3IgdG8gdXNlU2VsZWN0b3JgKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBtdXN0IHBhc3MgYSBmdW5jdGlvbiBhcyBhIHNlbGVjdG9yIHRvIHVzZVNlbGVjdG9yYCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGVxdWFsaXR5Rm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFlvdSBtdXN0IHBhc3MgYSBmdW5jdGlvbiBhcyBhbiBlcXVhbGl0eSBmdW5jdGlvbiB0byB1c2VTZWxlY3RvcmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVkdXhDb250ZXh0ID0gdXNlUmVkdXhDb250ZXh0MigpO1xuICAgIGNvbnN0IHsgc3RvcmUsIHN1YnNjcmlwdGlvbiwgZ2V0U2VydmVyU3RhdGUgfSA9IHJlZHV4Q29udGV4dDtcbiAgICBjb25zdCBmaXJzdFJ1biA9IFJlYWN0LnVzZVJlZih0cnVlKTtcbiAgICBjb25zdCB3cmFwcGVkU2VsZWN0b3IgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAgIHtcbiAgICAgICAgW3NlbGVjdG9yLm5hbWVdKHN0YXRlKSB7XG4gICAgICAgICAgY29uc3Qgc2VsZWN0ZWQgPSBzZWxlY3RvcihzdGF0ZSk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3QgeyBkZXZNb2RlQ2hlY2tzID0ge30gfSA9IHR5cGVvZiBlcXVhbGl0eUZuT3JPcHRpb25zID09PSBcImZ1bmN0aW9uXCIgPyB7fSA6IGVxdWFsaXR5Rm5Pck9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCB7IGlkZW50aXR5RnVuY3Rpb25DaGVjaywgc3RhYmlsaXR5Q2hlY2sgfSA9IHJlZHV4Q29udGV4dDtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgaWRlbnRpdHlGdW5jdGlvbkNoZWNrOiBmaW5hbElkZW50aXR5RnVuY3Rpb25DaGVjayxcbiAgICAgICAgICAgICAgc3RhYmlsaXR5Q2hlY2s6IGZpbmFsU3RhYmlsaXR5Q2hlY2tcbiAgICAgICAgICAgIH0gPSB7XG4gICAgICAgICAgICAgIHN0YWJpbGl0eUNoZWNrLFxuICAgICAgICAgICAgICBpZGVudGl0eUZ1bmN0aW9uQ2hlY2ssXG4gICAgICAgICAgICAgIC4uLmRldk1vZGVDaGVja3NcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZmluYWxTdGFiaWxpdHlDaGVjayA9PT0gXCJhbHdheXNcIiB8fCBmaW5hbFN0YWJpbGl0eUNoZWNrID09PSBcIm9uY2VcIiAmJiBmaXJzdFJ1bi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRvQ29tcGFyZSA9IHNlbGVjdG9yKHN0YXRlKTtcbiAgICAgICAgICAgICAgaWYgKCFlcXVhbGl0eUZuKHNlbGVjdGVkLCB0b0NvbXBhcmUpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YWNrID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAoeyBzdGFjayB9ID0gZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgIFwiU2VsZWN0b3IgXCIgKyAoc2VsZWN0b3IubmFtZSB8fCBcInVua25vd25cIikgKyBcIiByZXR1cm5lZCBhIGRpZmZlcmVudCByZXN1bHQgd2hlbiBjYWxsZWQgd2l0aCB0aGUgc2FtZSBwYXJhbWV0ZXJzLiBUaGlzIGNhbiBsZWFkIHRvIHVubmVjZXNzYXJ5IHJlcmVuZGVycy5cXG5TZWxlY3RvcnMgdGhhdCByZXR1cm4gYSBuZXcgcmVmZXJlbmNlIChzdWNoIGFzIGFuIG9iamVjdCBvciBhbiBhcnJheSkgc2hvdWxkIGJlIG1lbW9pemVkOiBodHRwczovL3JlZHV4LmpzLm9yZy91c2FnZS9kZXJpdmluZy1kYXRhLXNlbGVjdG9ycyNvcHRpbWl6aW5nLXNlbGVjdG9ycy13aXRoLW1lbW9pemF0aW9uXCIsXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZCxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQyOiB0b0NvbXBhcmUsXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpbmFsSWRlbnRpdHlGdW5jdGlvbkNoZWNrID09PSBcImFsd2F5c1wiIHx8IGZpbmFsSWRlbnRpdHlGdW5jdGlvbkNoZWNrID09PSBcIm9uY2VcIiAmJiBmaXJzdFJ1bi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgIGlmIChzZWxlY3RlZCA9PT0gc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhY2sgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICh7IHN0YWNrIH0gPSBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgXCJTZWxlY3RvciBcIiArIChzZWxlY3Rvci5uYW1lIHx8IFwidW5rbm93blwiKSArIFwiIHJldHVybmVkIHRoZSByb290IHN0YXRlIHdoZW4gY2FsbGVkLiBUaGlzIGNhbiBsZWFkIHRvIHVubmVjZXNzYXJ5IHJlcmVuZGVycy5cXG5TZWxlY3RvcnMgdGhhdCByZXR1cm4gdGhlIGVudGlyZSBzdGF0ZSBhcmUgYWxtb3N0IGNlcnRhaW5seSBhIG1pc3Rha2UsIGFzIHRoZXkgd2lsbCBjYXVzZSBhIHJlcmVuZGVyIHdoZW5ldmVyICphbnl0aGluZyogaW4gc3RhdGUgY2hhbmdlcy5cIixcbiAgICAgICAgICAgICAgICAgIHsgc3RhY2sgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdFJ1bi5jdXJyZW50KSBmaXJzdFJ1bi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICAgICAgfVxuICAgICAgfVtzZWxlY3Rvci5uYW1lXSxcbiAgICAgIFtzZWxlY3Rvcl1cbiAgICApO1xuICAgIGNvbnN0IHNlbGVjdGVkU3RhdGUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcihcbiAgICAgIHN1YnNjcmlwdGlvbi5hZGROZXN0ZWRTdWIsXG4gICAgICBzdG9yZS5nZXRTdGF0ZSxcbiAgICAgIGdldFNlcnZlclN0YXRlIHx8IHN0b3JlLmdldFN0YXRlLFxuICAgICAgd3JhcHBlZFNlbGVjdG9yLFxuICAgICAgZXF1YWxpdHlGblxuICAgICk7XG4gICAgUmVhY3QudXNlRGVidWdWYWx1ZShzZWxlY3RlZFN0YXRlKTtcbiAgICByZXR1cm4gc2VsZWN0ZWRTdGF0ZTtcbiAgfTtcbiAgT2JqZWN0LmFzc2lnbih1c2VTZWxlY3RvcjIsIHtcbiAgICB3aXRoVHlwZXM6ICgpID0+IHVzZVNlbGVjdG9yMlxuICB9KTtcbiAgcmV0dXJuIHVzZVNlbGVjdG9yMjtcbn1cbnZhciB1c2VTZWxlY3RvciA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVTZWxlY3Rvckhvb2soKTtcblxuLy8gc3JjL2V4cG9ydHMudHNcbnZhciBiYXRjaCA9IGRlZmF1bHROb29wQmF0Y2g7XG5leHBvcnQge1xuICBQcm92aWRlcl9kZWZhdWx0IGFzIFByb3ZpZGVyLFxuICBSZWFjdFJlZHV4Q29udGV4dCxcbiAgYmF0Y2gsXG4gIGNvbm5lY3RfZGVmYXVsdCBhcyBjb25uZWN0LFxuICBjcmVhdGVEaXNwYXRjaEhvb2ssXG4gIGNyZWF0ZVNlbGVjdG9ySG9vayxcbiAgY3JlYXRlU3RvcmVIb29rLFxuICBzaGFsbG93RXF1YWwsXG4gIHVzZURpc3BhdGNoLFxuICB1c2VTZWxlY3RvcixcbiAgdXNlU3RvcmVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFjdC1yZWR1eC5tanMubWFwIl0sIm5hbWVzIjpbIlJlYWN0IiwiSVNfUkVBQ1RfMTkiLCJ2ZXJzaW9uIiwic3RhcnRzV2l0aCIsIlJFQUNUX0VMRU1FTlRfVFlQRSIsIlN5bWJvbCIsImZvciIsIlJFQUNUX1BPUlRBTF9UWVBFIiwiUkVBQ1RfRlJBR01FTlRfVFlQRSIsIlJFQUNUX1NUUklDVF9NT0RFX1RZUEUiLCJSRUFDVF9QUk9GSUxFUl9UWVBFIiwiUkVBQ1RfQ09OU1VNRVJfVFlQRSIsIlJFQUNUX0NPTlRFWFRfVFlQRSIsIlJFQUNUX0ZPUldBUkRfUkVGX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIiwiUkVBQ1RfTUVNT19UWVBFIiwiUkVBQ1RfTEFaWV9UWVBFIiwiUkVBQ1RfT0ZGU0NSRUVOX1RZUEUiLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFIiwiRm9yd2FyZFJlZiIsIk1lbW8iLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJ0eXBlIiwiJCR0eXBlb2YiLCJnZXRNb2R1bGVJZCIsInR5cGVPZiIsIm9iamVjdCIsImlzQ29udGV4dENvbnN1bWVyIiwiaXNNZW1vIiwid2FybmluZyIsIm1lc3NhZ2UiLCJjb25zb2xlIiwiZXJyb3IiLCJFcnJvciIsImUiLCJ2ZXJpZnkiLCJzZWxlY3RvciIsIm1ldGhvZE5hbWUiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJ2ZXJpZnlTdWJzZWxlY3RvcnMiLCJtYXBTdGF0ZVRvUHJvcHMiLCJtYXBEaXNwYXRjaFRvUHJvcHMiLCJtZXJnZVByb3BzIiwicHVyZUZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkiLCJkaXNwYXRjaCIsImFyZVN0YXRlc0VxdWFsIiwiYXJlT3duUHJvcHNFcXVhbCIsImFyZVN0YXRlUHJvcHNFcXVhbCIsImhhc1J1bkF0TGVhc3RPbmNlIiwic3RhdGUiLCJvd25Qcm9wcyIsInN0YXRlUHJvcHMiLCJkaXNwYXRjaFByb3BzIiwibWVyZ2VkUHJvcHMiLCJoYW5kbGVGaXJzdENhbGwiLCJmaXJzdFN0YXRlIiwiZmlyc3RPd25Qcm9wcyIsImhhbmRsZU5ld1Byb3BzQW5kTmV3U3RhdGUiLCJkZXBlbmRzT25Pd25Qcm9wcyIsImhhbmRsZU5ld1Byb3BzIiwiaGFuZGxlTmV3U3RhdGUiLCJuZXh0U3RhdGVQcm9wcyIsInN0YXRlUHJvcHNDaGFuZ2VkIiwiaGFuZGxlU3Vic2VxdWVudENhbGxzIiwibmV4dFN0YXRlIiwibmV4dE93blByb3BzIiwicHJvcHNDaGFuZ2VkIiwic3RhdGVDaGFuZ2VkIiwicHVyZUZpbmFsUHJvcHNTZWxlY3RvciIsImZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkiLCJpbml0TWFwU3RhdGVUb1Byb3BzIiwiaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyIsImluaXRNZXJnZVByb3BzIiwib3B0aW9ucyIsInByb2Nlc3MiLCJiaW5kQWN0aW9uQ3JlYXRvcnMiLCJhY3Rpb25DcmVhdG9ycyIsImJvdW5kQWN0aW9uQ3JlYXRvcnMiLCJrZXkiLCJhY3Rpb25DcmVhdG9yIiwiYXJncyIsImlzUGxhaW5PYmplY3QiLCJvYmoiLCJwcm90byIsImdldFByb3RvdHlwZU9mIiwiYmFzZVByb3RvIiwidmVyaWZ5UGxhaW5PYmplY3QiLCJ2YWx1ZSIsImRpc3BsYXlOYW1lIiwid3JhcE1hcFRvUHJvcHNDb25zdGFudCIsImdldENvbnN0YW50IiwiaW5pdENvbnN0YW50U2VsZWN0b3IiLCJjb25zdGFudCIsImNvbnN0YW50U2VsZWN0b3IiLCJnZXREZXBlbmRzT25Pd25Qcm9wcyIsIm1hcFRvUHJvcHMiLCJCb29sZWFuIiwibGVuZ3RoIiwid3JhcE1hcFRvUHJvcHNGdW5jIiwiaW5pdFByb3h5U2VsZWN0b3IiLCJwcm94eSIsIm1hcFRvUHJvcHNQcm94eSIsInN0YXRlT3JEaXNwYXRjaCIsImRldGVjdEZhY3RvcnlBbmRWZXJpZnkiLCJwcm9wcyIsImNyZWF0ZUludmFsaWRBcmdGYWN0b3J5IiwiYXJnIiwibmFtZSIsIndyYXBwZWRDb21wb25lbnROYW1lIiwibWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yeSIsIm1hcFN0YXRlVG9Qcm9wc0ZhY3RvcnkiLCJkZWZhdWx0TWVyZ2VQcm9wcyIsIndyYXBNZXJnZVByb3BzRnVuYyIsImluaXRNZXJnZVByb3BzUHJveHkiLCJhcmVNZXJnZWRQcm9wc0VxdWFsIiwiaGFzUnVuT25jZSIsIm1lcmdlUHJvcHNQcm94eSIsIm5leHRNZXJnZWRQcm9wcyIsIm1lcmdlUHJvcHNGYWN0b3J5IiwiZGVmYXVsdE5vb3BCYXRjaCIsImNhbGxiYWNrIiwiY3JlYXRlTGlzdGVuZXJDb2xsZWN0aW9uIiwiZmlyc3QiLCJsYXN0IiwiY2xlYXIiLCJub3RpZnkiLCJsaXN0ZW5lciIsIm5leHQiLCJnZXQiLCJsaXN0ZW5lcnMiLCJwdXNoIiwic3Vic2NyaWJlIiwiaXNTdWJzY3JpYmVkIiwicHJldiIsInVuc3Vic2NyaWJlIiwibnVsbExpc3RlbmVycyIsImNyZWF0ZVN1YnNjcmlwdGlvbiIsInN0b3JlIiwicGFyZW50U3ViIiwic3Vic2NyaXB0aW9uc0Ftb3VudCIsInNlbGZTdWJzY3JpYmVkIiwiYWRkTmVzdGVkU3ViIiwidHJ5U3Vic2NyaWJlIiwiY2xlYW51cExpc3RlbmVyIiwicmVtb3ZlZCIsInRyeVVuc3Vic2NyaWJlIiwibm90aWZ5TmVzdGVkU3VicyIsImhhbmRsZUNoYW5nZVdyYXBwZXIiLCJzdWJzY3JpcHRpb24iLCJvblN0YXRlQ2hhbmdlIiwidHJ5U3Vic2NyaWJlU2VsZiIsInRyeVVuc3Vic2NyaWJlU2VsZiIsImdldExpc3RlbmVycyIsImNhblVzZURPTSIsIndpbmRvdyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImlzRE9NIiwiaXNSdW5uaW5nSW5SZWFjdE5hdGl2ZSIsIm5hdmlnYXRvciIsInByb2R1Y3QiLCJpc1JlYWN0TmF0aXZlIiwiZ2V0VXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsInVzZUxheW91dEVmZmVjdCIsInVzZUVmZmVjdCIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJpcyIsIngiLCJ5Iiwic2hhbGxvd0VxdWFsIiwib2JqQSIsIm9iakIiLCJrZXlzQSIsImtleXMiLCJrZXlzQiIsImkiLCJSRUFDVF9TVEFUSUNTIiwiY2hpbGRDb250ZXh0VHlwZXMiLCJjb250ZXh0VHlwZSIsImNvbnRleHRUeXBlcyIsImRlZmF1bHRQcm9wcyIsImdldERlZmF1bHRQcm9wcyIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsIm1peGlucyIsInByb3BUeXBlcyIsIktOT1dOX1NUQVRJQ1MiLCJjYWxsZXIiLCJjYWxsZWUiLCJhcmd1bWVudHMiLCJhcml0eSIsIkZPUldBUkRfUkVGX1NUQVRJQ1MiLCJyZW5kZXIiLCJNRU1PX1NUQVRJQ1MiLCJjb21wYXJlIiwiVFlQRV9TVEFUSUNTIiwiZ2V0U3RhdGljcyIsImNvbXBvbmVudCIsImRlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIm9iamVjdFByb3RvdHlwZSIsImhvaXN0Tm9uUmVhY3RTdGF0aWNzIiwidGFyZ2V0Q29tcG9uZW50Iiwic291cmNlQ29tcG9uZW50IiwiaW5oZXJpdGVkQ29tcG9uZW50IiwiY29uY2F0IiwidGFyZ2V0U3RhdGljcyIsInNvdXJjZVN0YXRpY3MiLCJkZXNjcmlwdG9yIiwiQ29udGV4dEtleSIsImdUIiwiZ2xvYmFsVGhpcyIsImdldENvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwiY29udGV4dE1hcCIsIk1hcCIsInJlYWxDb250ZXh0Iiwic2V0IiwiUmVhY3RSZWR1eENvbnRleHQiLCJOT19TVUJTQ1JJUFRJT05fQVJSQVkiLCJzdHJpbmdpZnlDb21wb25lbnQiLCJDb21wIiwiSlNPTiIsInN0cmluZ2lmeSIsImVyciIsIlN0cmluZyIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3RXaXRoQXJncyIsImVmZmVjdEZ1bmMiLCJlZmZlY3RBcmdzIiwiZGVwZW5kZW5jaWVzIiwiY2FwdHVyZVdyYXBwZXJQcm9wcyIsImxhc3RXcmFwcGVyUHJvcHMiLCJsYXN0Q2hpbGRQcm9wcyIsInJlbmRlcklzU2NoZWR1bGVkIiwid3JhcHBlclByb3BzIiwiY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZSIsImN1cnJlbnQiLCJzdWJzY3JpYmVVcGRhdGVzIiwic2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzIiwiY2hpbGRQcm9wc1NlbGVjdG9yIiwiaXNNb3VudGVkIiwiYWRkaXRpb25hbFN1YnNjcmliZUxpc3RlbmVyIiwiZGlkVW5zdWJzY3JpYmUiLCJsYXN0VGhyb3duRXJyb3IiLCJjaGVja0ZvclVwZGF0ZXMiLCJsYXRlc3RTdG9yZVN0YXRlIiwiZ2V0U3RhdGUiLCJuZXdDaGlsZFByb3BzIiwidW5zdWJzY3JpYmVXcmFwcGVyIiwic3RyaWN0RXF1YWwiLCJhIiwiYiIsImhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZFB1cmVPcHRpb24iLCJjb25uZWN0IiwicHVyZSIsImZvcndhcmRSZWYiLCJjb250ZXh0IiwiQ29udGV4dCIsIndyYXBXaXRoQ29ubmVjdCIsIldyYXBwZWRDb21wb25lbnQiLCJpc1ZhbGlkIiwic2VsZWN0b3JGYWN0b3J5T3B0aW9ucyIsIkNvbm5lY3RGdW5jdGlvbiIsInByb3BzQ29udGV4dCIsInJlYWN0UmVkdXhGb3J3YXJkZWRSZWYiLCJ1c2VNZW1vIiwicmVhY3RSZWR1eEZvcndhcmRlZFJlZjIiLCJ3cmFwcGVyUHJvcHMyIiwiQ29udGV4dFRvVXNlIiwiUmVzdWx0Q29udGV4dCIsIkNvbnN1bWVyIiwiY29udGV4dFZhbHVlIiwidXNlQ29udGV4dCIsImRpZFN0b3JlQ29tZUZyb21Qcm9wcyIsImRpZFN0b3JlQ29tZUZyb21Db250ZXh0IiwiZ2V0U2VydmVyU3RhdGUiLCJzdWJzY3JpcHRpb24yIiwibm90aWZ5TmVzdGVkU3ViczIiLCJiaW5kIiwib3ZlcnJpZGRlbkNvbnRleHRWYWx1ZSIsInVzZVJlZiIsImxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IiLCJhY3R1YWxDaGlsZFByb3BzU2VsZWN0b3IiLCJzdWJzY3JpYmVGb3JSZWFjdCIsInJlYWN0TGlzdGVuZXIiLCJhY3R1YWxDaGlsZFByb3BzIiwidXNlU3luY0V4dGVybmFsU3RvcmUiLCJzdGFjayIsInJlbmRlcmVkV3JhcHBlZENvbXBvbmVudCIsInJlZiIsInJlbmRlcmVkQ2hpbGQiLCJQcm92aWRlciIsIl9Db25uZWN0IiwibWVtbyIsIkNvbm5lY3QiLCJfZm9yd2FyZGVkIiwiZm9yd2FyZENvbm5lY3RSZWYiLCJmb3J3YXJkZWQiLCJjb25uZWN0X2RlZmF1bHQiLCJwcm92aWRlclByb3BzIiwiY2hpbGRyZW4iLCJzZXJ2ZXJTdGF0ZSIsImJhc2VDb250ZXh0VmFsdWUiLCJpZGVudGl0eUZ1bmN0aW9uQ2hlY2siLCJzdGFiaWxpdHlDaGVjayIsImFzc2lnbiIsInByZXZpb3VzU3RhdGUiLCJQcm92aWRlcl9kZWZhdWx0IiwiY3JlYXRlUmVkdXhDb250ZXh0SG9vayIsInVzZVJlZHV4Q29udGV4dDIiLCJ1c2VSZWR1eENvbnRleHQiLCJjcmVhdGVTdG9yZUhvb2siLCJ1c2VTdG9yZTIiLCJ3aXRoVHlwZXMiLCJ1c2VTdG9yZSIsImNyZWF0ZURpc3BhdGNoSG9vayIsInVzZURpc3BhdGNoMiIsInVzZURpc3BhdGNoIiwidXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IiLCJyZWZFcXVhbGl0eSIsImNyZWF0ZVNlbGVjdG9ySG9vayIsInVzZVNlbGVjdG9yMiIsImVxdWFsaXR5Rm5Pck9wdGlvbnMiLCJlcXVhbGl0eUZuIiwicmVkdXhDb250ZXh0IiwiZmlyc3RSdW4iLCJ3cmFwcGVkU2VsZWN0b3IiLCJ1c2VDYWxsYmFjayIsInNlbGVjdGVkIiwiZGV2TW9kZUNoZWNrcyIsImZpbmFsSWRlbnRpdHlGdW5jdGlvbkNoZWNrIiwiZmluYWxTdGFiaWxpdHlDaGVjayIsInRvQ29tcGFyZSIsIndhcm4iLCJzZWxlY3RlZDIiLCJzZWxlY3RlZFN0YXRlIiwidXNlRGVidWdWYWx1ZSIsInVzZVNlbGVjdG9yIiwiYmF0Y2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-redux/dist/react-redux.mjs\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fsirishasadhu%2FDesktop%2Fprojects%2FFull-stack-projects%2Fflight-bookings%2FFrontend%2Fcomponents%2Fheader%2Fheader-10%2Findex.jsx&modules=%2FUsers%2Fsirishasadhu%2FDesktop%2Fprojects%2FFull-stack-projects%2Fflight-bookings%2FFrontend%2Fcomponents%2Fhero%2FFilterSelect.jsx&modules=%2FUsers%2Fsirishasadhu%2FDesktop%2Fprojects%2FFull-stack-projects%2Fflight-bookings%2FFrontend%2Fcomponents%2Fhero%2FMainFilterSearchBox.jsx&modules=%2FUsers%2Fsirishasadhu%2FDesktop%2Fprojects%2FFull-stack-projects%2Fflight-bookings%2FFrontend%2Fnode_modules%2Fnext%2Fdist%2Fshared%2Flib%2Flazy-dynamic%2Fdynamic-bailout-to-csr.js&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);